<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMake 学习记录</title>
    <url>/2021/05/03/CMake-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>GitHub repository: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R0cm95NTAvY21ha2UtZXhhbXBsZXM=">https://github.com/ttroy50/cmake-examples<i class="fa fa-external-link-alt"></i></span></p>
<p>CMake 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个库。<br/>
它用配置文件控制建构过程（build process）的方式和 Unix 的 make 相似，只是 CMake
的配置文件取名为 CMakeLists.txt。<br/>
CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或
Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。</p>
<span id="more"></span>
<blockquote>
<p>原文中将 CMake 命令称为“函数”。本文沿用了这种称法。</p>
</blockquote>
<h2 id="基础">基础 <a class="markdownIt-Anchor" href="#基础">#</a></h2>
<p>最基本的 Hello World CMakeLists.txt 文件：</p>
<figure class="highlight cmake"><figcaption><span>CMakeLists.txt</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># （可选）指定 所支持的 CMake 的最低版本</span></span><br><span class="line"><span class="comment"># 可以通过以下命令查看 CMake 版本</span></span><br><span class="line"><span class="comment"># $ cmake --version</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名，这样做会设置一些变量</span></span><br><span class="line"><span class="keyword">project</span>(hello_cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个要生成的可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_cmake main.cpp)</span><br></pre></td></tr></table></figure>
<details class="note info"><summary><p>Note</p>
</summary>
<p>有些时候会使用一种简便方法——将项目名和可执行文件名设成同一个名字。
然后就可以像下面这样写：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.6</span>)</span><br><span class="line"><span class="keyword">project</span>(hello_cmake)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<a href="https://cmake.org/cmake/help/latest/command/project.html"><code>project()</code></a> 函数将变量 <code>PROJECT_NAME</code> 设置为 <code>hello_cmake</code>，在 <a href="https://cmake.org/cmake/help/latest/command/add_executable.html"><code>add_executable()</code></a> 函数中则使用了这个变量指定可执行文件名。</p>

</details>
<h3 id="二进制目录">二进制目录 <a class="markdownIt-Anchor" href="#二进制目录">#</a></h3>
<p>我们运行 <code>cmake</code>（可带参数）命令时所在的目录（即当前工作目录、<code>pwd</code> 显示的目录）被称为
<code>CMAKE_BINARY_DIR</code>。这是你的生成的二进制文件所在的根目录（通常还会有一些其他文件）。</p>
<p>CMake 支持两种生成二进制文件的方式——就地构建（in-place
build）和源外构建（out-of-source build）。</p>
<h4 id="就地构建">就地构建 <a class="markdownIt-Anchor" href="#就地构建">#</a></h4>
<p>要以这种方式构建，只需在项目根目录（其实是 CMakeLists.txt 所在的目录）执行
<code>cmake</code>（不指定项目根目录，见下）命令。这样做会使 CMake
生成的临时文件和二进制文件和项目文件混在一起。</p>
<h4 id="源外构建">源外构建 <a class="markdownIt-Anchor" href="#源外构建">#</a></h4>
<p>要采用源外构建，在任一非项目根目录的目录中执行 <code>cmake &lt;project_root&gt;</code> 命令，其中
<code>&lt;project_root&gt;</code> 为项目根目录。这种方式生成的临时文件和二进制文件等会被放在执行
<code>cmake</code> 命令时所在的目录，而不会污染源目录（项目根目录），一般采用这种方式。</p>
<p>习惯上这样做（假设当前目录已经为源目录）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="其他目录路径变量">其他目录路径变量 <a class="markdownIt-Anchor" href="#其他目录路径变量">#</a></h3>
<p>完整变量列表见：<span class="exturl" data-url="aHR0cHM6Ly9jbWFrZS5vcmcvY21ha2UvaGVscC9sYXRlc3QvbWFudWFsL2NtYWtlLXZhcmlhYmxlcy43Lmh0bWw=">https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html<i class="fa fa-external-link-alt"></i></span></p>
<p>一些术语：</p>
<ul>
<li><strong>源（码）树（source tree）<strong>和</strong>构建树（build tree）</strong>：分别指项目 <em>源代码根目录</em>
和 <em>指定的生成二进制文件（等文件）的根目录</em> 和各自的子目录形成的树状目录结构。</li>
<li><strong>源（码）目录（source directory）</strong> 和 <strong>构建目录（build directory）</strong>：<em>源码树</em> 和
<em>构建树</em> 中的位置，一般指顶层位置，但是可以移动，表示当前位置的变量一般含有 <code>CURRENT</code>。</li>
<li>CMake 目录种类 TODO
<ul>
<li>顶层/根</li>
<li>当前所处</li>
<li>正在处理</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_SOURCE_DIR.html"><code>CMAKE_SOURCE_DIR</code></a></td>
<td>源码树（source tree）顶层的路径</td>
</tr>
<tr>
<td><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_SOURCE_DIR.html"><code>CMAKE_CURRENT_SOURCE_DIR</code></a></td>
<td>正在处理的源目录</td>
</tr>
<tr>
<td><a href="https://cmake.org/cmake/help/latest/variable/PROJECT_SOURCE_DIR.html"><code>PROJECT_SOURCE_DIR</code></a></td>
<td>当前项目的源目录</td>
</tr>
<tr>
<td><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_BINARY_DIR.html"><code>CMAKE_BINARY_DIR</code></a></td>
<td>构建树（build tree）顶层的路径</td>
</tr>
<tr>
<td><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_BINARY_DIR.html"><code>CMAKE_CURRENT_BINARY_DIR</code></a></td>
<td>当前所在的构建目录（build tree）</td>
</tr>
<tr>
<td><a href="https://cmake.org/cmake/help/latest/variable/PROJECT_BINARY_DIR.html"><code>PROJECT_BINARY_DIR</code></a></td>
<td>项目的构建目录</td>
</tr>
</tbody>
</table>
<h3 id="源文件变量">源文件变量 <a class="markdownIt-Anchor" href="#源文件变量">#</a></h3>
<p>可以声明一个变量保存要使用的源文件名，以便之后使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/Hello.cpp</span><br><span class="line">    src/main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>GOLB</code> 命令以用通配符寻找相符的文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SOURCES <span class="string">&quot;src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>这种方式已经不推荐，取而代之的是直接在 <code>add_xxx()</code> 函数中写明源文件。</p>
</div>
<h3 id="包含目录">包含目录 <a class="markdownIt-Anchor" href="#包含目录">#</a></h3>
<p>使用 <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html"><code>target_include_directories()</code></a> 函数为目标（target）添加包含目录（include path），这样添加的目录会在生成目标时以 <code>-I</code> 选项传递给编译器。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">target</span></span><br><span class="line">    PRIVATE</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>INTERFACE</code>、<code>PUBLIC</code>、<code>PRIVATE</code> 关键字用来指定其后的参数的作用域（scope，也就是这三个关键字）</p>
<ul>
<li><code>PUBLIC</code>、<code>PRIVATE</code>：参数会被用来填充目标的 <a href="https://cmake.org/cmake/help/latest/prop_tgt/INCLUDE_DIRECTORIES.html#prop_tgt:INCLUDE_DIRECTORIES"><code>INCLUDE_DIRECTORIES</code></a> 属性（property）</li>
<li><code>INTERFACE</code>、<code>PUBLIC</code>：参数会被用来填充目标的 <a href="https://cmake.org/cmake/help/latest/prop_tgt/INTERFACE_INCLUDE_DIRECTORIES.html#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES"><code>INTERFACE_INCLUDE_DIRECTORIES</code></a> 属性</li>
</ul>
<p>详细解释见下面的<a href="#%E5%BA%93">库</a>。</p>
<h3 id="库">库 <a class="markdownIt-Anchor" href="#库">#</a></h3>
<h4 id="创建库">创建库 <a class="markdownIt-Anchor" href="#创建库">#</a></h4>
<p><a href="">使用</a> <a href="https://cmake.org/cmake/help/latest/command/add_library.html"><code>add_library()</code></a> 函数以用指定源文件创建一个库文件。</p>
<p>如要创建静态库，可以像这样写：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello_library STATIC</span><br><span class="line">    src/Hello.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>指定库的类型：</p>
<ul>
<li><code>STATIC</code>：静态库，编译时链接</li>
<li><code>SHARED</code>：动态库，运行时链接</li>
<li><code>MODULE</code>：不会链接到其他目标，但是可以在运行时通过 <em>dlopen-like</em> 功能
（见 <span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMy9kbG9wZW4uMy5odG1s">man 3 dlopen<i class="fa fa-external-link-alt"></i></span>）手动加载</li>
</ul>
<blockquote>
<p>像之前推荐的那样，这里直接在 <code>add_xxx()</code> 函数中写明了要使用的源文件。</p>
</blockquote>
<p><a href="#%E5%8C%85%E5%90%AB%E7%9B%AE%E5%BD%95">上一节</a>中作用域的含义：</p>
<ul>
<li><code>PRIVATE</code>：参数会被添加为<strong>目标</strong>的包含目录之一</li>
<li><code>INTERFACE</code>：参数会被添加为<strong>与该库链接的所有的目标</strong>的包含目录之一</li>
<li><code>PUBLIC</code>：相当于前两个作用域相加的效果</li>
</ul>
<h4 id="链接库和目标">链接库和目标 <a class="markdownIt-Anchor" href="#链接库和目标">#</a></h4>
<p>要将指定目标与库链接，使用 <code>target_link_libraries()</code> 函数：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello_binary</span><br><span class="line">    src/main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_binary</span><br><span class="line">    PRIVATE</span><br><span class="line">        hello_library</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<details class="note info"><summary><p>目标别名</p>
</summary>
<p>可以在 <code>add_xxx()</code> 函数中使用 <code>ALIAS</code> 为目标创建一个别名，也可以理解为创建了一个“伪目标”。</p>
<p>如为库创建别名：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello::library ALIAS hello_library)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello_binary</span><br><span class="line">    src/main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_binary</span><br><span class="line">    PRIVATE</span><br><span class="line">        hello::library</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当然，也可以为可执行文件创建别名：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main ALIAS hello_binary)</span><br></pre></td></tr></table></figure>
</details>
<h3 id="安装">安装 <a class="markdownIt-Anchor" href="#安装">#</a></h3>
<p>CMake 提供了生成 <code>make install</code> 目标（是 Makefile 中的 target，而不是之前提到的
CMake 中的 target）的功能。<br/>
安装目录可以通过 <code>CMAKE_INSTALL_PREFIX</code> 指定，详见 <a href="#%E6%8C%87%E5%AE%9A%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95">指定安装目录</a>。</p>
<h4 id="install-函数">install 函数 <a class="markdownIt-Anchor" href="#install-函数">#</a></h4>
<p>安装由 <a href="https://cmake.org/cmake/help/latest/command/install.html"><code>install()</code></a> 函数控制。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span> (TARGETS cmake_examples_inst_bin</span><br><span class="line">    DESTINATION bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span> (TARGETS cmake_examples_inst</span><br><span class="line">    LIBRARY DESTINATION lib)</span><br></pre></td></tr></table></figure>
<p>上面的代码会将 <code>cmake_examples_inst_bin</code> 生成的二进制文件安装到 <code>$&#123;CMAKE_INSTALL_PREFIX&#125;/bin</code> 目录下，将 <code>cmake_examples_inst</code> 生成的二进制文件安装到 <code>$&#123;CMAKE_INSTALL_PREFIX&#125;/bin</code> 目录下。</p>
<div class="note warning"><p>在有 DLL 目标的平台（如 Windows）需要添加以下内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span> (TARGETS cmake_examples_inst</span><br><span class="line">    LIBRARY DESTINATION lib</span><br><span class="line">    RUNTIME DESTINATION bin)</span><br></pre></td></tr></table></figure></div>
<p>使用 <code>DIRECTORY</code> 以安装目录：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/</span><br><span class="line">    DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>使用 <code>FILES</code> 直接安装文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span> (FILES cmake-examples.conf</span><br><span class="line">    DESTINATION etc)</span><br></pre></td></tr></table></figure>
<h4 id="install_manifesttxt">install_manifest.txt <a class="markdownIt-Anchor" href="#install_manifesttxt">#</a></h4>
<p>运行完 <code>make install</code> 后，CMake 会生成一个名为 install_manifest.txt
的文件，其中包含了所有安装文件的详细信息。</p>
<p>如果以 root 运行 <code>make install</code>，install_manifest.txt 会为 root 所有。</p>
<h4 id="指定安装目录">指定安装目录 <a class="markdownIt-Anchor" href="#指定安装目录">#</a></h4>
<p><code>CMAKE_INSTALL_PREFIX</code> 的值默认为 <code>/usr/local/</code>，要改变其值，可以在添加
<em>可执行文件和库文件</em> 前在顶层（top level）CMakeLists.txt 中添加如下内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT )</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Setting default CMAKE_INSTALL_PREFIX path to $&#123;CMAKE_BINARY_DIR&#125;/install&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/install&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;The path to use for make install&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>也可以通过终端命令的参数（<code>-DCMAKE_INSTALL_PREFIX=/install/location</code>）设置该变量。</p>
<hr />
<p>还可以通过 make 的 <code>DESTDIR</code> 改变安装目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install DESTDIR=/tmp/stage</span><br></pre></td></tr></table></figure>
<p>这会创建 <code>$&#123;DESTDIR&#125;/$&#123;CMAKE_INSTALL_PREFIX&#125;</code> 作为安装目录。<br/>
在这个例子中，安装目录为 <code>/tmp/stage/usr/local</code>。</p>
<h4 id="卸载">卸载 <a class="markdownIt-Anchor" href="#卸载">#</a></h4>
<p>CMake 默认不提供 <code>make uninstall</code> 对象。<br/>
要添加 <code>make uninstall</code> 对象，可以参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRsYWIua2l0d2FyZS5jb20vY21ha2UvY29tbXVuaXR5Ly0vd2lraXMvRkFR">Can I do “make uninstall” with CMake?<i class="fa fa-external-link-alt"></i></span>。</p>
<p>一个简单的做法是利用 install_manifest.txt 文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo xargs rm &lt; install_manifest.txt</span><br></pre></td></tr></table></figure>
<h3 id="构建类型">构建类型 <a class="markdownIt-Anchor" href="#构建类型">#</a></h3>
<p>CMake 内置了几种构建类型，其原理就是向编译器传递一些标志（flags）：</p>
<table>
<thead>
<tr>
<th>Levels</th>
<th>Compiler Flags</th>
</tr>
</thead>
<tbody>
<tr>
<td>Release</td>
<td><code>-O3 -DNDEBUG</code></td>
</tr>
<tr>
<td>Debug</td>
<td><code>-g</code></td>
</tr>
<tr>
<td>MinSizeRel</td>
<td><code>-Os -DNDEBUG</code></td>
</tr>
<tr>
<td>RelWithDebInfo</td>
<td><code>-O2 -g -DNDEBUG</code></td>
</tr>
</tbody>
</table>
<ul>
<li>可以通过图形界面设置构建类型：</li>
</ul>
<img data-src="/2021/05/03/CMake-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Configuring-Using-Cmake-GUI.png" class="" title="Configuring Using Cmake GUI" alt="Configuring Using Cmake GUI">
<ul>
<li>也可以在终端命令中定义变量：  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Release</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>CMake 提供的默认的构建类型不包含任何相关的编译器标志，以优化程序。<br/>
但是有时可能会需要设置默认构建类型，可以在顶层 CMakeList.txt 中添加如下内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE <span class="keyword">AND</span> <span class="keyword">NOT</span> CMAKE_CONFIGURATION_TYPES)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;Setting build type to &#x27;RelWithDebInfo&#x27; as none was specified.&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_BUILD_TYPE RelWithDebInfo CACHE <span class="keyword">STRING</span> <span class="string">&quot;Choose the type of build.&quot;</span> FORCE)</span><br><span class="line">  <span class="comment"># Set the possible values of build type for cmake-gui</span></span><br><span class="line">  <span class="keyword">set_property</span>(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS <span class="string">&quot;Debug&quot;</span> <span class="string">&quot;Release&quot;</span></span><br><span class="line">    <span class="string">&quot;MinSizeRel&quot;</span> <span class="string">&quot;RelWithDebInfo&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<h3 id="编译器标志">编译器标志 <a class="markdownIt-Anchor" href="#编译器标志">#</a></h3>
<p>CMake 支持用若干种方式设置编译器标志：</p>
<ul>
<li>使用函数 <a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html"><code>target_compile_definitions()</code></a> 和 <a href="https://cmake.org/cmake/help/latest/command/target_compile_options.html"><code>target_compile_options()</code></a></li>
<li>使用变量 <code>CMAKE_C_FLAGS</code> 和 <code>CMAKE_CXX_FLAGS</code>，见 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html"><code>CMAKE_&lt;LANG&gt;_FLAGS</code></a></li>
</ul>
<h4 id="为指定目标设置">为指定目标设置 <a class="markdownIt-Anchor" href="#为指定目标设置">#</a></h4>
<p>在现代 CMake 中设置 C++ 标志的推荐方法是使用按对象标志（per-target flags），可以通过 <code>target_compile_definitions()</code> 函数将其填充到其他对象。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(cmake_examples_compile_flags</span><br><span class="line">     PRIVATE EX3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这会使编译器在变异目标（<code>cmake_examples_compile_flags</code>）时添加 <code>-DEX3</code> 标志。</p>
<p>使用该函数会填充 <strong>库</strong> 的 <a href="https://cmake.org/cmake/help/v3.0/prop_tgt/INTERFACE_COMPILE_DEFINITIONS.html#prop_tgt:INTERFACE_COMPILE_DEFINITIONS"><code>INTERFACE_COMPILE_DEFINITIONS</code></a>
变量，并会根据作用域（scope）将定义传递给链接的对象。<br/>
如果目标是一个库并且选择的作用域是 <code>PUBLIC</code> 或 <code>INTERFACE</code>，那么定义还会被包含在链接到该库的所有对象中。</p>
<h4 id="设置编译器标志">设置编译器标志 <a class="markdownIt-Anchor" href="#设置编译器标志">#</a></h4>
<p><code>CMAKE_CXX_FLAGS</code> 要么为空，要么包含所选构建类型的对应标志。<br/>
要设置 <strong>额外</strong> 的编译标志，可以在顶层 CMakeLists.txt 中添加如下内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -DEX2&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;Set C++ Compiler Flags&quot;</span> FORCE)</span><br></pre></td></tr></table></figure>
<div class="note info"><p><code>CACHE STRING &quot;Set C++ Compiler Flags&quot; FORCE</code> 用来强制变量在 CMakeLists.txt 中被设置，详见 <a href="https://cmake.org/cmake/help/latest/command/set.html#set-cache-entry"><code>set</code>#设置缓存项</a>。</p>
</div>
<p>类似地，<code>CMAKE_C_FLAGS</code> 等变量也可以以同样的方式设置。其他变量见 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html"><code>CMAKE_&lt;LANG&gt;_FLAGS</code></a>。<br/>
一旦设置了这些变量，CMake 会为此目录及其子目录下的所有目标设置编译器标志，因此更推荐使用 <code>target_compile_definitions</code> 函数。</p>
<h4 id="设置链接器标志">设置链接器标志 <a class="markdownIt-Anchor" href="#设置链接器标志">#</a></h4>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3ODM5MzIvaG93LWRvLWktYWRkLWEtbGlua2VyLW9yLWNvbXBpbGUtZmxhZy1pbi1hLWNtYWtlLWZpbGU=">How do I add a linker or compile flag in a CMake file?<i class="fa fa-external-link-alt"></i></span></p>
<p>先将标志储存为常量（现在不推荐这样做）：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(GCC_COVERAGE_COMPILE_FLAGS <span class="string">&quot;-fprofile-arcs -ftest-coverage&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(GCC_COVERAGE_LINK_FLAGS    <span class="string">&quot;-lgcov&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后可以通过几种方式添加它们：</p>
<ol>
<li>最简单的方式（not clean, but easy and convenient, and works only for compile flags, C &amp; C++ at once）： <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;GCC_COVERAGE_COMPILE_FLAGS&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>追加到现有的 CMake 变量： <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_FLAGS  <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;GCC_COVERAGE_COMPILE_FLAGS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_EXE_LINKER_FLAGS  <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; $&#123;GCC_COVERAGE_LINK_FLAGS&#125;&quot;</span>) </span><br></pre></td></tr></table></figure>
</li>
<li>使用目标属性（target properties）（需要指定目标名）<span class="exturl" data-url="aHR0cHM6Ly9jbWFrZS5vcmcvY21ha2UvaGVscC9sYXRlc3QvcHJvcF90Z3QvQ09NUElMRV9GTEFHUy5odG1s">COMPILE_FLAGS<i class="fa fa-external-link-alt"></i></span> <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(TEMP <span class="variable">$&#123;THE_TARGET&#125;</span> COMPILE_FLAGS)</span><br><span class="line"><span class="keyword">if</span>(TEMP <span class="keyword">STREQUAL</span> <span class="string">&quot;TEMP-NOTFOUND&quot;</span>)</span><br><span class="line">  <span class="keyword">SET</span>(TEMP <span class="string">&quot;&quot;</span>) <span class="comment"># Set to empty string</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">SET</span>(TEMP <span class="string">&quot;$&#123;TEMP&#125; &quot;</span>) <span class="comment"># A space to cleanly separate from existing content</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># Append our values</span></span><br><span class="line"><span class="keyword">SET</span>(TEMP <span class="string">&quot;$&#123;TEMP&#125;$&#123;GCC_COVERAGE_COMPILE_FLAGS&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;THE_TARGET&#125;</span> PROPERTIES COMPILE_FLAGS <span class="variable">$&#123;TEMP&#125;</span> )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第三方库">第三方库 <a class="markdownIt-Anchor" href="#第三方库">#</a></h3>
<p>CMake 提供了 <a href="https://cmake.org/cmake/help/latest/command/find_package.html"><code>find_package()</code></a> 函数来寻找第三方软件包文件所在路径。<br/>
该函数会在 <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html"><code>CMAKE_MODULE_PATH</code></a> 中的目录列表中的目录中寻找形似 “FindXXX.cmake” 的文件。Linux 中的默认搜索路径为 <code>/usr/share/cmake/Modules</code>（或者 <code>/usr/share/cmake-3.20/Modules</code>）。</p>
<p>如要寻找 Boost：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.46</span>.<span class="number">1</span> REQUIRED COMPONENTS filesystem system)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Boost</code>：包名，这会使 <code>find_package()</code> 函数寻找 FindBoost.cmake</li>
<li><code>1.46.1</code>：Boost 的最小版本</li>
<li><code>REQUIRED</code>：指定为必须，如果没找到符合要求的包则构建失败</li>
<li><code>COMPONENTS &lt;...&gt;</code>：库的组件列表</li>
</ul>
<h4 id="检查是否找到软件包">检查是否找到软件包 <a class="markdownIt-Anchor" href="#检查是否找到软件包">#</a></h4>
<p>大多数软件包（的 FindXXX.cmake 文件）会设置 <code>XXX_FOUND</code> 变量，可以通过检查该变量判断软件包是否被找到。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">message</span> (<span class="string">&quot;boost found&quot;</span>)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span> (FATAL_ERROR <span class="string">&quot;Cannot find Boost&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<h4 id="暴露变量">暴露变量 <a class="markdownIt-Anchor" href="#暴露变量">#</a></h4>
<p>找到指定的包（其实是加载了指定 FindXXX.cmake 文件）后，我们可以获得一些变量来帮助我们确定所需文件位置，如 <code>Boost_INCLUDE_DIRS</code> 就指明了 Boost 的包含文件所在目录。</p>
<p>有时可以通过 ccmake 或 cmake-gui 查看环境变量以确定所需变量。</p>
<h4 id="别名和导入目标">别名和导入目标 <a class="markdownIt-Anchor" href="#别名和导入目标">#</a></h4>
<p>大多数 CMake 库，在其模块文件中导出别名目标。</p>
<p>Boost 的所有导出目标以 <code>Boost::&lt;subsystem&gt;</code> 命名，如：</p>
<ul>
<li><code>Boost::boost</code>：仅头文件（header-only）的库</li>
<li><code>Boost::system</code>：Boost system library</li>
<li><code>Boost::filesystem</code>：文件系统相关的库</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(third_party_include</span><br><span class="line">    PRIVATE</span><br><span class="line">        Boost::filesystem</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这些目标会包含了它们的依赖，链接 <code>Boost::filesystem</code> 会自动添加 <code>Boost::boost</code> 和 <code>Boost::system</code> 依赖。</p>
<h4 id="非别名目标">非别名目标 <a class="markdownIt-Anchor" href="#非别名目标">#</a></h4>
<p>有些第三方库没有使用可导入的目标，这时就必须使用以下两个变量：</p>
<ul>
<li><code>xxx_INCLUDE_DIRS</code>：include directory</li>
<li><code>xxx_LIBRARY</code>：library path</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Include the boost headers</span></span><br><span class="line"><span class="keyword">target_include_directories</span>( third_party_include</span><br><span class="line">    PRIVATE <span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># link against the boost libraries</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( third_party_include</span><br><span class="line">    PRIVATE</span><br><span class="line">    <span class="variable">$&#123;Boost_SYSTEM_LIBRARY&#125;</span></span><br><span class="line">    <span class="variable">$&#123;Boost_FILESYSTEM_LIBRARY&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Create Snippets for UltiSnips</title>
    <url>/2021/03/28/Create-Snippets-for-Ultisnips/</url>
    <content><![CDATA[<p>Personal arrangement of <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NpclZlci91bHRpc25pcHM=">UltiSnips<i class="fa fa-external-link-alt"></i></span>’ official documentation.</p>
<p>My snippets: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fsb2hhaWEvbnZpbWNmZy90cmVlL2x1YS9VbHRpU25pcHM=">https://github.com/alohaia/nvimcfg/tree/lua/UltiSnips<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="include-other-snippet-files">Include Other Snippet Files <a class="markdownIt-Anchor" href="#include-other-snippet-files">#</a></h2>
<p>Add c snippets for cpp files for example.</p>
<ol>
<li><code>UltiSnipsAddFiletypes</code>: <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">au</span> FileType cpp UltiSnipsAddFiletypes cpp.<span class="keyword">c</span></span><br></pre></td></tr></table></figure>
</li>
<li><code>extends</code>: For example, in <code>cpp.snippets</code>, add: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extends c</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="keywords">Keywords <a class="markdownIt-Anchor" href="#keywords">#</a></h2>
<ol>
<li><code>extends</code>: See above.</li>
<li><code>priority</code>: Set priority for all snippet defined in the current file.</li>
<li><code>snippets</code> <code>endsnippet</code>: Define a snippet.</li>
<li><code>global</code> <code>endglobal</code>: Define a <a href="#global-snippets">global snippet</a>(only supports python currently).</li>
<li><code>pre_expand</code> <code>post_expand</code> <code>post_jump</code>: Declare snippet actions.</li>
</ol>
<h2 id="snippets-format">Snippets’ Format <a class="markdownIt-Anchor" href="#snippets-format">#</a></h2>
<pre><code>snippet trigger_word [ &quot;description&quot; [ options ] ]
...
endsnippet
</code></pre>
<ul>
<li><code>trigger_word</code>: The word to trigger the snippet. It can include spaces via wrap it in quotes or any other characters.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snippet &quot;tab trigger&quot; [ &quot;description&quot; [ options ] ]</span><br><span class="line">snippet ltab triggerl [ &quot;description&quot; [ options ] ]</span><br></pre></td></tr></table></figure>
Quotes can be included as part of the trigger by wrapping the trigger in
another character.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snippet !&quot;tab trigger&quot;! [ &quot;description&quot; [ options ] ]</span><br></pre></td></tr></table></figure>
</li>
<li><code>description</code>: A string describing the trigger.</li>
<li><code>options</code>: See below.</li>
</ul>
<h2 id="snippet-options">Snippet Options <a class="markdownIt-Anchor" href="#snippet-options">#</a></h2>
<ul>
<li><code>b</code>: Beginning of line - A snippet with this option is expanded only if the tab trigger is the first word on the line. In other words, if only whitespace precedes the tab trigger, expand. The default is to expand snippets at any position regardless of the preceding non-whitespace characters.</li>
<li><code>i</code>: In-word expansion - By default a snippet is expanded only if the tab trigger is the first word on the line or is preceded by one or more whitespace characters. A snippet with this option is expanded regardless of the preceding character. In other words, the snippet can be triggered in the middle of a word.</li>
<li><code>w</code>: Word boundary - With this option, the snippet is expanded if the tab trigger start matches a word boundary and the tab trigger end matches a word boundary. In other words the tab trigger must be preceded and followed by non-word characters. Word characters are defined by the <code>iskeyword</code> setting. Use this option, for example, to permit expansion where the tab trigger follows punctuation without expanding suffixes of larger words.</li>
<li><code>r</code>: Regular expression - With this option, the tab trigger is expected to be a python regular expression. The snippet is expanded if the recently typed characters match the regular expression. Note: The regular expression MUST be quoted (or surrounded with another character) like a multi-word tab trigger (see above) whether it has spaces or not. A resulting match is passed to any python code blocks in the snippet definition as the local variable “match”.</li>
<li><code>t</code>: Do not expand tabs - If a snippet definition includes leading tab characters, by default UltiSnips expands the tab characters honoring the Vim <code>shiftwidth</code>, <code>softtabstop</code>, <code>expandtab</code> and <code>tabstop</code> indentation settings. (For example, if <code>expandtab</code> is set, the tab is replaced with spaces.) If this option is set, UltiSnips will ignore the Vim settings and insert the tab characters as is. This option is useful for snippets involved with tab delimited formats.</li>
<li><code>s</code>: Remove whitespace immediately before the cursor at the end of a line before jumping to the next tabstop.  This is useful if there is a tabstop with optional text at the end of a line.</li>
<li><code>m</code>: Trim all whitespaces from right side of snippet lines. Useful when snippet contains empty lines which should remain empty after expanding. Without this option empty lines in snippets definition will have indentation too.</li>
<li><code>e</code>: Custom context snippet - With this option expansion of snippet can be controlled not only by previous characters in line, but by any given python expression. This option can be specified along with other options, like <code>b</code>. See UltiSnips-custom-context-snippets for more info.</li>
<li><code>A</code>: Snippet will be triggered automatically, when condition matches. See UltiSnips-autotrigger for more info.</li>
</ul>
<h2 id="character-escaping">Character Escaping <a class="markdownIt-Anchor" href="#character-escaping">#</a></h2>
<blockquote>
<p>In snippet definitions, the characters <code>`</code>, <code>&#123;</code>, <code>$</code> and <code>\</code> have special
meaning. If you want to insert one of these characters literally, escape them
with a backslash, <code>\</code>.</p>
</blockquote>
<h2 id="plaintext-snippets">Plaintext Snippets <a class="markdownIt-Anchor" href="#plaintext-snippets">#</a></h2>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snippet bye &quot;My mail signature&quot;</span><br><span class="line">Good bye, Sir. Hope to talk to you soon.</span><br><span class="line">- Arthur, King of Britain</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
<h2 id="tabstop-and-placeholders">Tabstop and Placeholders <a class="markdownIt-Anchor" href="#tabstop-and-placeholders">#</a></h2>
<p>A simplest tabstop looks like <code>$no</code>, <code>no</code> is a number starting from 1. <code>$0</code> is a special tabstop that is always the last tabstop no matter how many tabstops are defined.</p>
<pre><code>snippet letter
Dear $1,
$0
Yours sincerely,
$2
endsnippet
</code></pre>
<p>Default text:</p>
<pre><code>snippet case
case $&#123;1:word&#125; in
    $&#123;2:pattern&#125; ) $0;;
esac
endsnippet
</code></pre>
<p>Have a tabstop within another tabstop:</p>
<pre><code>snippet a
&lt;a href=&quot;$&#123;1:http://www.$&#123;2:example.com&#125;&#125;&quot;
    $0
&lt;/a&gt;
endsnippet
</code></pre>
<blockquote>
<p>Typing any text at the first tabstop replaces the default
value, including the second tabstop, with the typed text. So the second
tabstop is essentially deleted.</p>
</blockquote>
<h2 id="visual-placeholder">Visual Placeholder <a class="markdownIt-Anchor" href="#visual-placeholder">#</a></h2>
<p>Format:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;VISUAL:default/search/replace/option&#125;</span><br></pre></td></tr></table></figure>
<p>Usage:</p>
<ol>
<li>Select some text in visual mode and press the trigger key, the text well be deleted.</li>
<li>Enter the <code>trigger_word</code> and press the trigger key again, the text deleted will replace the <code>$&#123;VISUAL&#125;</code> placeholder.</li>
</ol>
<p>Details:</p>
<ol>
<li>Snippets containing Visual Placeholder can be used in insert mod. In the way, the <code>default</code> will be used as default text.</li>
<li>With <code>/search/replace/option</code>, you can process the text like using <code>:s</code> command. See <a href="#transformations">Transformations</a>.</li>
</ol>
<h2 id="mirrors">Mirrors <a class="markdownIt-Anchor" href="#mirrors">#</a></h2>
<p>Mirrors repeat the content of a <span class="exturl" data-url="aHR0cDovL3RhYnN0b3AuVG8=">tabstop.To<i class="fa fa-external-link-alt"></i></span> mirror a tabstop simply insert the tabstop again using the “dollar sign followed by a number” syntax, e.g., <code>\$1</code>.</p>
<pre><code>snippet ifndef
#ifndef $&#123;1:SOME_DEFINE&#125;
#define $1
$0
#endif /* $1 */
endsnippet
</code></pre>
<h2 id="interpolation">Interpolation <a class="markdownIt-Anchor" href="#interpolation">#</a></h2>
<h3 id="shellcode">Shellcode <a class="markdownIt-Anchor" href="#shellcode">#</a></h3>
<p>An example may be the most helpful.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snippet today</span><br><span class="line">Today is the `date +%d.%m.%y`.</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
<p>The output of command <code>date +%d.%m%y</code> will replace the text wrapped by backticks. You`ll get something like “Today is the 19.08.20.”</p>
<h3 id="vimscript">Vimscript <a class="markdownIt-Anchor" href="#vimscript">#</a></h3>
<p>Similar to shellcode, but begins with `v.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snippet indent</span><br><span class="line">Indent is: `!v indent(&quot;.&quot;)`.</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(note the 4 spaces in front): indent&lt;trigger_key&gt; -&gt;</span><br><span class="line">(note the 4 spaces in front): Indent is: 4.</span><br></pre></td></tr></table></figure>
<h3 id="python">Python <a class="markdownIt-Anchor" href="#python">#</a></h3>
<p>There are two choices:</p>
<ol>
<li><strong>`#!/usr/bin/python …`</strong>: Normal python code.</li>
<li><strong>`!p …`</strong>: Use python with some predefined objects and variables. The variables automatically defined in python code are:</li>
</ol>
<table>
<thead>
<tr>
<th>variable</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn</td>
<td>The current filename</td>
</tr>
<tr>
<td>path</td>
<td>The complete path to the current file</td>
</tr>
<tr>
<td>t</td>
<td>The values of the placeholders, t[1] is the text of <code>$&#123;1&#125;,</code> etc.</td>
</tr>
<tr>
<td>snip</td>
<td>UltiSnips.TextObjects.SnippetUtil object instance. Has methods that simplify indentation handling and owns the string that should be inserted for the snippet.</td>
</tr>
<tr>
<td>context</td>
<td>Result of context condition. See UltiSnips-custom-context-snippets.</td>
</tr>
<tr>
<td>match</td>
<td>Only in regular expression triggered snippets.<br> This is the return value of the match of the regular expression.<br> See <span class="exturl" data-url="aHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3JlLmh0bWwjbWF0Y2gtb2JqZWN0cw==">http://docs.python.org/library/re.html#match-objects<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody>
</table>
<p><strong><code>snip</code> object</strong></p>
<p>The <code>snip</code> object provides the following methods:</p>
<ul>
<li><code>snip.mkline(line=&quot;&quot;, indent=None)</code>:
Returns a line ready to be appended to the result. If indent
is None, then mkline prepends spaces and/or tabs appropriate to the
current <code>tabstop</code> and <code>expandtab</code> variables.</li>
<li><code>snip.shift(amount=1)</code>:
Shifts the default indentation level used by mkline right by the
number of spaces defined by <code>shiftwidth</code>, <code>amount</code> times.</li>
<li><code>snip.unshift(amount=1)</code>:
Shifts the default indentation level used by mkline left by the
number of spaces defined by <code>shiftwidth</code>, <code>amount</code> times.</li>
<li><code>snip.reset_indent()</code>:
Resets the indentation level to its initial value.</li>
<li><code>snip.opt(var, default)</code>:
Checks if the Vim variable <code>var</code> has been set. If so, it returns the
variable<code>s value; otherwise, it returns the value of</code>default`.</li>
</ul>
<p>The <code>snip</code> object provides some properties as well:</p>
<ul>
<li>
<p><code>snip.rv</code>:
<code>rv</code> is the return value, the text that will replace the python block
in the snippet definition. It is initialized to the empty string. This
deprecates the <code>res</code> variable.</p>
</li>
<li>
<p><code>snip.c</code>:
The text currently in the python block<code>s position within the snippet. It is set to empty string as soon as interpolation is completed. Thus you can check</code>if <code>snip.c</code> is != “”` to make sure that the interpolation
is only done once. This deprecates the “cur” variable.</p>
</li>
<li>
<p><code>snip.v</code>:
Data related to the <code>$&#123;VISUAL&#125;</code> placeholder. This has two attributes:
<code>snip.v.mode</code>   (<code>v</code>, <code>V</code>, <code>^V</code>, see |visual-mode| )
<code>snip.v.text</code>   The text that was selected.</p>
</li>
<li>
<p><code>snip.fn</code>:
The current filename.</p>
</li>
<li>
<p><code>snip.basename</code>:
The current filename with the extension removed.</p>
</li>
<li>
<p><code>snip.ft</code>:
The current filetype.</p>
</li>
<li>
<p><code>snip.p</code>:
Last selected placeholder. Will contain placeholder object with
following properties:</p>
<ul>
<li><code>current_text</code> - text in the placeholder on the moment of selection;</li>
<li><code>start</code> - placeholder start on the moment of selection;</li>
<li><code>end</code> - placeholder end on the moment of selection;</li>
</ul>
</li>
</ul>
<p>For your convenience, the <code>snip</code> object also provides the following
operators:</p>
<ul>
<li><code>snip &gt;&gt; amount</code>:
Equivalent to <code>snip.shift(amount)</code></li>
<li><code>snip &lt;&lt; amount</code>:
Equivalent to <code>snip.unshift(amount)</code></li>
<li><code>snip += line</code>:
Equivalent to “<code>snip.rv +=</code>\n<code>+ snip.mkline(line)</code>”</li>
</ul>
<blockquote>
<p>Any variables defined in a python block can be used in other python blocks
that follow within the same snippet. Also, the python modules <code>vim</code>, <code>re</code>,
<code>os</code>, <code>string</code> and <code>random</code> are pre-imported within the scope of snippet code.
Other modules can be imported using the python <code>import</code> command.</p>
</blockquote>
<blockquote>
<p>Python code allows for very flexible snippets. For example, the following
snippet mirrors the first tabstop value on the same line but right aligned and
in uppercase.</p>
</blockquote>
<h2 id="global-snippets">Global Snippets <a class="markdownIt-Anchor" href="#global-snippets">#</a></h2>
<p>Use <code>global</code> and <code>endglobal</code> to define Global snippets.</p>
<p>You can define functions or use import command inside.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global !p</span><br><span class="line">def upper_right(inp):</span><br><span class="line">    return (75 - 2 * len(inp))*` ` + inp.upper()</span><br><span class="line">endglobal</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global !p</span><br><span class="line">from my_snippet_helpers import *</span><br><span class="line">endglobal</span><br></pre></td></tr></table></figure>
<h2 id="transformations">Transformations <a class="markdownIt-Anchor" href="#transformations">#</a></h2>
<blockquote>
<p>Transformations are like mirrors but instead of just copying text from the
original tabstop verbatim, a regular expression is matched to the content of
the referenced tabstop and a transformation is then applied to the matched
pattern.</p>
</blockquote>
<pre><code>$&#123;&lt;tab_stop_no/regular_expression/replacement/options&#125;
</code></pre>
<p>The <strong>components</strong> are defined as follows:</p>
<ul>
<li><code>tab_stop_no</code>: The number of the tabstop to reference</li>
<li><code>regular_expression</code>: The regular expression the value of the referenced tabstop is matched on</li>
<li><code>replacement</code>: The replacement string, explained in detail below</li>
<li><code>options</code>: Options for the regular expression</li>
</ul>
<h3 id="regular-expression">Regular Expression <a class="markdownIt-Anchor" href="#regular-expression">#</a></h3>
<p>See <span class="exturl" data-url="aHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3JlLmh0bWw=">http://docs.python.org/library/re.html<i class="fa fa-external-link-alt"></i></span>.</p>
<h3 id="replacement-string">Replacement String <a class="markdownIt-Anchor" href="#replacement-string">#</a></h3>
<p>The <strong>replacement string</strong> can contain <code>$no</code> variables, e.g., <code>$1</code>, which reference matched groups in the regular expression. The <code>$0</code> variable is special and yields the whole match. The replacement string can also contain special escape sequences:</p>
<ul>
<li><code>\u</code>: Uppercase next letter</li>
<li><code>\l</code>: Lowercase next letter</li>
<li><code>\U</code>: Uppercase everything till the next \E</li>
<li><code>\L</code>: Lowercase everything till the next \E</li>
<li><code>\E</code>: End upper or lowercase started with \L or \U</li>
<li><code>\n</code>: A newline</li>
<li><code>\t</code>: A literal tab</li>
</ul>
<p>Finally, the <strong>replacement string</strong> can contain conditional replacements using the syntax (<strong>?no:text:other text</strong>). This reads as follows: if the group <code>$no</code> has
matched, insert “text”, otherwise insert “other text”. “other text” is
optional and if not provided defaults to the empty string, “”. This feature
is very powerful. It allows you to add optional text into snippets.</p>
<h3 id="options">Options <a class="markdownIt-Anchor" href="#options">#</a></h3>
<p>The <strong>options</strong> can be any combination of</p>
<ul>
<li>
<p><code>g</code>: <strong>global replace</strong></p>
<p>By default, only the first match of the regular expression is
replaced. With this option all matches are replaced.</p>
</li>
<li>
<p><code>i</code>: <strong>case insensitive</strong></p>
<p>By default, regular expression matching is case sensitive. With this
option, matching is done without regard to case.</p>
</li>
<li>
<p><code>m</code>: <strong>multiline</strong></p>
<p>By default, the <code>\^</code> and <code>\$</code> special characters only apply to the
start and end of the entire string; so if you select multiple lines,
transformations are made on them entirely as a whole single line
string. With this option, <code>^</code> and <code>\$</code> special characters match the
start or end of any line within a string ( separated by newline
character - <code>\n</code> ).</p>
</li>
<li>
<p><code>a</code>: <strong>ascii conversion</strong></p>
<p>By default, transformation are made on the raw utf-8 string. With
this option, matching is done on the corresponding ASCII string
instead, for example <code>à</code> will become <code>a</code>.
This option required the python package <code>unidecode</code>.</p>
</li>
</ul>
<h2 id="cleardisable-snippets">Clear(Disable) Snippets <a class="markdownIt-Anchor" href="#cleardisable-snippets">#</a></h2>
<p>Add <code>clearsnippets</code> to snippet files to disable some specified snippets.</p>
<ol>
<li>
<p>Disable by priority.</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority 6</span><br><span class="line">clearsnippets</span><br></pre></td></tr></table></figure>
<p>Disable all snippets have priority not bigger than 6.</p>
</li>
<li>
<p>Disable by trigger.</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clearsnippets printf title box</span><br></pre></td></tr></table></figure>
<p>Disable snippets whose trigger word is <code>printf</code>, <code>title</code> or <code>box</code>. To do this, the priority of <code>clearsnippets</code> must not be smaller than other snippets`.</p>
</li>
</ol>
<h2 id="context">Context <a class="markdownIt-Anchor" href="#context">#</a></h2>
<p>Custom context snippets can be enabled by using the <code>e</code> option in the snippet
definition.</p>
<p>In that case snippet should be defined using this syntax:</p>
<pre><code>snippet trigger_word &quot;description&quot; &quot;expression&quot; options
</code></pre>
<p>The context can be defined using a special header:</p>
<pre><code>context &quot;python_expression&quot;
snippet trigger_word &quot;description&quot; options
</code></pre>
<p>The <code>expression</code> can be any python expression. If <code>expression</code> evaluates to
<code>True</code>, then this snippet will be eligible for expansion. The <code>expression</code>
must be wrapped with <strong>double-quotes</strong>.</p>
<p>The following <strong>python modules</strong> are automatically imported into the scope before
<code>expression</code> is evaluated: <strong><code>re</code>, <code>os</code>, <code>vim</code>, <code>string</code>, <code>random</code></strong>.</p>
<p>Global variable <code>snip</code> will be available with following properties:</p>
<ul>
<li>
<p><code>snip.window</code>: alias for <code>vim.current.window</code></p>
</li>
<li>
<p><code>snip.buffer</code>: alias for <code>vim.current.window.buffer</code></p>
<blockquote>
<p>Note: special variable called <code>snip.buffer</code> should be used for all buffer
modifications. Not <code>vim.current.buffer</code> and not <code>vim.command(&quot;...&quot;)</code>, because
in that case UltiSnips will not be able to track changes to the buffer correctly.</p>
<p><code>snip.buffer</code> has the same interface as <code>vim.current.window.buffer</code>.</p>
</blockquote>
</li>
<li>
<p><code>snip.cursor</code>: cursor object, which behaves like <code>vim.current.window.cursor</code>, but zero-indexed and with following additional methods:</p>
<ul>
<li><code>preserve()</code>: special method for executing pre/post/jump actions;</li>
<li><code>set(line, column)</code>: sets cursor to specified line and column;</li>
<li><code>to_vim_cursor()</code>: returns 1-indexed cursor, suitable for assigning to <code>vim.current.window.cursor</code>;</li>
</ul>
</li>
<li>
<p><code>snip.contex</code>: evaluated value of the expression in <strong>context</strong>;</p>
</li>
<li>
<p><code>snip.line</code> and <code>snip.column</code>: aliases for cursor position (zero-indexed);</p>
</li>
<li>
<p><code>snip.visual_mode</code>: (<code>v</code>, <code>V</code>, <code>^V</code>, see visual-mode);</p>
</li>
<li>
<p><code>snip.visual_text</code>: last visually-selected text;</p>
</li>
<li>
<p><code>snip.last_placeholder</code>: last active placeholder from previous snippet with following properties:</p>
<ul>
<li><code>current_text</code>: text in the placeholder on the moment of selection;</li>
<li><code>start</code>: placeholder start on the moment of selection;</li>
<li><code>end</code>: placeholder end on the moment of selection;</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snippet i &quot;if err != nil&quot; &quot;re.match(`^\s+[^=]*err\s*:?=`, snip.buffer[snip.line-1])&quot; be</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    $1</span><br><span class="line">&#125;</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global !p</span><br><span class="line">import my_utils</span><br><span class="line">endglobal</span><br><span class="line"></span><br><span class="line">snippet , &quot;return ..., nil/err&quot; &quot;my_utils.is_return_argument(snip)&quot; ie</span><br><span class="line">, `!p if my_utils.is_in_err_condition():</span><br><span class="line">    snip.rv = &quot;err&quot;</span><br><span class="line">else:</span><br><span class="line">    snip.rv = &quot;nil&quot;`</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
<h2 id="snippet-actions">Snippet Actions <a class="markdownIt-Anchor" href="#snippet-actions">#</a></h2>
<ul>
<li>Pre-expand: invoked just after trigger condition was matched, but before snippet actually expanded;</li>
<li>Post-expand: invoked after snippet was expanded and interpolations were applied for the first time, but before jump on the first placeholder.</li>
<li>Jump: invoked just after a jump to the next/prev placeholder.</li>
</ul>
<blockquote>
<p>Specified code will be evaluated at stages defined above and same global
variables and modules will be available that are stated in
the UltiSnips-custom-context-snippets section.</p>
</blockquote>
<p><code>snip.visual_content</code> will be also declared and will contain text that was selected before snippet expansion (similar to <code>$VISUAL</code> placeholder).</p>
<pre><code>pre_expand &quot;snip.buffer[snip.line] = ``; snip.cursor.set(snip.line, len(snip.visual_content))&quot;
snippet &quot;nothing done here&quot;
$&#123;VISUAL&#125;
endsnippet
</code></pre>
<h3 id="pre-expand-and-post-expand-actions">Pre-expand and Post-expand Actions <a class="markdownIt-Anchor" href="#pre-expand-and-post-expand-actions">#</a></h3>
<p>Buffer can be modified in pre-expand action code through variable called
<code>snip.buffer</code>, snippet expansion position will be automatically adjusted.</p>
<pre><code>pre_expand &quot;snip.buffer[snip.line] = ` `*4; snip.cursor.set(snip.line, 4)&quot;
snippet d
def $1():
    $0
endsnippet

post_expand &quot;snip.buffer[snip.snippet_end[0]+1:snip.snippet_end[0]+1] = [``]&quot;
snippet d &quot;Description&quot; b
def $1():
    $2
endsnippet
</code></pre>
<h3 id="post-jump-actions">Post-jump Actions <a class="markdownIt-Anchor" href="#post-jump-actions">#</a></h3>
<p>Post-jump actions can be used to trigger some code based on user input into the placeholders.</p>
<p>Notable use <strong>cases</strong>:</p>
<ul>
<li>Expand another snippet after jump or anonymous snippet after last jump (e.g. perform move method refactoring and
then insert new method invokation);</li>
<li>Insert heading into TOC after last jump.</li>
</ul>
<p><strong>Variables</strong> and <strong>methods</strong> below will be also defined in the action code scope:</p>
<ul>
<li><code>snip.tabstop</code>: zero-indexed number of tabstop jumped onto;
<ul>
<li><code>start</code>: (line, column) of the starting position of the tabstop (also accessible as <code>tabstop.line</code> and <code>tabstop.col</code>).</li>
<li><code>end</code>: (line, column) of the ending position;</li>
<li><code>current_text</code>: text inside the tabstop.</li>
</ul>
</li>
<li><code>snip.jump_direction</code>: <code>1</code> if jumped forward and <code>-1</code> otherwise;</li>
<li><code>snip.tabstops</code>: list with tabstop objects, see above;</li>
<li><code>snip.snippet_start</code>: (line, column) of start of the expanded snippet;</li>
<li><code>snip.snippet_end</code>: (line, column) of end of the expanded snippet;</li>
<li><code>snip.expand_anon()</code>: alias for <code>UltiSnips_Manager.expand_anon()</code>;</li>
</ul>
<blockquote>
<p>Also note that you should use <code>snip.buffer</code>, rather than than any other way, to edit buffer content.</p>
</blockquote>
<p>Following snippet will insert section in the Table of Contents in the vim-help file:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_jump &quot;if snip.tabstop == 0: insert_toc_item(snip.tabstops[1], snip.buffer)&quot;</span><br><span class="line">snippet s &quot;section&quot; b</span><br><span class="line">`!p insert_delimiter_0(snip, t)`$1`!p insert_section_title(snip, t)`</span><br><span class="line">`!p insert_delimiter_1(snip, t)`</span><br><span class="line">$0</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The functions called in this snippet are not defined by Ultisnips.</p>
</blockquote>
<p>Following example will insert method call at the end of file after user jump out of method declaration snippet.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global !p</span><br><span class="line">def insert_method_call(name):</span><br><span class="line">	vim.command(`normal G`)</span><br><span class="line">	snip.expand_anon(name + `($1)\n`)</span><br><span class="line">endglobal</span><br><span class="line"></span><br><span class="line">post_jump &quot;if snip.tabstop == 0: insert_method_call(snip.tabstops[1].current_text)&quot;</span><br><span class="line">snippet d &quot;method declaration&quot; b</span><br><span class="line">def $1():</span><br><span class="line">	$2</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>Vim/NeoVim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim/NeoVim</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron+Vue 开发笔记软件</title>
    <url>/2021/04/28/Electron-VueJs-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li><a href="/2021/04/28/Vue-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">Vue 学习记录</a></li>
</ul>
<span id="more"></span>
<h2 id="搭建基本项目">搭建基本项目 <a class="markdownIt-Anchor" href="#搭建基本项目">#</a></h2>
<h3 id="相关依赖">相关依赖 <a class="markdownIt-Anchor" href="#相关依赖">#</a></h3>
<ul>
<li>node、npm（cnpm、yarn）</li>
<li>vue-cli：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cnpm i -g @vue/cli</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h3 id="vue-基本项目">vue 基本项目 <a class="markdownIt-Anchor" href="#vue-基本项目">#</a></h3>
<p>如在 electron-vue 目录下创建项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create electron-vue</span><br></pre></td></tr></table></figure>
<p>这时就可以用 <code>yarn serve</code> 命令运行项目了。</p>
<div class="note warning"><p>注意路由（router）不要启用 histroy 模式，否则最后打包时会出现问题。</p>
</div>
<h3 id="加入-electron">加入 electron <a class="markdownIt-Anchor" href="#加入-electron">#</a></h3>
<p>安装 <span class="exturl" data-url="aHR0cHM6Ly9ua2xheW1hbi5naXRodWIuaW8vdnVlLWNsaS1wbHVnaW4tZWxlY3Ryb24tYnVpbGRlci8=">vue-cli-plugin-electron-builder<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add electron-builder</span><br></pre></td></tr></table></figure>
<p>然后即可通过 yran（推荐）或 npm 启动测试 server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn election:serve</span><br><span class="line">npm run electron:serve</span><br></pre></td></tr></table></figure>
<p>要构建应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn electron:build</span><br><span class="line">npm run electron:build</span><br></pre></td></tr></table></figure>
<div class="note info"><p>首次进行这两个步骤需要访问境外资源，可能会由于网络原因而失败（解决方法不便明说）。</p>
</div>
<h3 id="配置-electron-builder">配置 Electron Builder <a class="markdownIt-Anchor" href="#配置-electron-builder">#</a></h3>
<p>文档：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ua2xheW1hbi5naXRodWIuaW8vdnVlLWNsaS1wbHVnaW4tZWxlY3Ryb24tYnVpbGRlci9ndWlkZS9jb25maWd1cmF0aW9uLmh0bWwjY29uZmlndXJpbmctZWxlY3Ryb24tYnVpbGRlcg==">https://nklayman.github.io/vue-cli-plugin-electron-builder/guide/configuration.html#configuring-electron-builder<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlY3Ryb24uYnVpbGQv">https://www.electron.build/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<figure class="highlight json"><figcaption><span>"vue.config.js"</span></figcaption><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    electronBuilder: &#123;</span><br><span class="line">      builderOptions: &#123;</span><br><span class="line">        <span class="comment">// options placed here will be merged with default configuration and passed to electron-builder</span></span><br><span class="line">        <span class="comment">// Windows 平台打包配置</span></span><br><span class="line">        <span class="comment">// https://www.electron.build/configuration/nsis</span></span><br><span class="line">        win: &#123;</span><br><span class="line">          target: &#x27;nsis&#x27;        <span class="comment">// 打包方式</span></span><br><span class="line">        &#125;,</span><br><span class="line">        nsis: &#123;</span><br><span class="line">          oneClick: <span class="literal">false</span>,      <span class="comment">// 禁用一键安装</span></span><br><span class="line">          allowToChangeInstallationDirectory: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Projects</category>
        <category>Softwares</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>Vue</tag>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 实战</title>
    <url>/2021/05/25/Git-%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>实用 Git 操作技巧。</p>
<span id="more"></span>
<h2 id="从远程仓库获取最新代码合并到本地分支">从远程仓库获取最新代码合并到本地分支 <a class="markdownIt-Anchor" href="#从远程仓库获取最新代码合并到本地分支">#</a></h2>
<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbmNoYW81MjcyL2FydGljbGUvZGV0YWlscy83OTE2MjEzMA==">https://blog.csdn.net/hanchao5272/article/details/79162130<i class="fa fa-external-link-alt"></i></span></p>
<p>查询当前远程的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>获取最新代码到本地（本地当前分支为 <branch>，获取的远端的分支为 <remote>/<branch>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取远端 origin 的 master 分支，保存为本地 origin/master 分支</span></span><br><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>
<p>查看版本差异：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 master 与 origin/master 的版本差异</span></span><br><span class="line">git log -p master..origin/master</span><br></pre></td></tr></table></figure>
<p>合并最新代码到本地分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Grammar Testing</title>
    <url>/2021/03/15/Grammar-Testing/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#reason">reason</a></li>
<li><a href="#hexo-renderer-markdown-it-plus">hexo-renderer-markdown-it-plus</a></li>
<li><a href="#tag-plugins">Tag-plugins</a>
<ul>
<li><a href="#link">Link</a></li>
<li><a href="#code-block">Code Block</a></li>
<li><a href="#include-code">Include Code</a></li>
<li><a href="#iframe">Iframe</a></li>
<li><a href="#image">Image</a></li>
<li><a href="#pull-quote">Pull Quote</a></li>
<li><a href="#reference">Reference</a></li>
<li><a href="#asset-resource">Asset Resource</a></li>
<li><a href="#next-tags">NexT tags</a>
<ul>
<li><a href="#call-out">Call Out</a></li>
<li><a href="#button">Button</a></li>
<li><a href="#caniuse">caniUse</a></li>
<li><a href="#center-quote">Center Quote</a></li>
<li><a href="#group-pictures">Group Pictures</a></li>
<li><a href="#label">Label</a></li>
<li><a href="#mermaid">Mermaid</a></li>
<li><a href="#pdf">Pdf</a></li>
<li><a href="#tabs">Tabs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<span id="more"></span>
<h2 id="reason">reason <a class="markdownIt-Anchor" href="#reason">#</a></h2>
<p>I use <strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0">hexo-theme-next<i class="fa fa-external-link-alt"></i></span></strong> for my blog, and I met a problem same with <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0L2lzc3Vlcy84MjY=">#826<i class="fa fa-external-link-alt"></i></span>.</p>
<p>I wrote a plugin <a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus"><strong>hexo-renderer-markdown-it-plus</strong></a> for fix it,and this article is a demo for <code>hexo-renderer-markdown-it-plus</code></p>
<p><img data-src="hello" alt="" /></p>
<p><img data-src="hello" alt="aloha" /></p>
<p>{
{
}<br />
}</p>
<ol>
<li>asdf</li>
<li>asdfas</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
<li>a</li>
</ol>
<ul>
<li>asdfas</li>
<li>asdfasdf</li>
</ul>
<ul>
<li>asdfasd</li>
<li>asdfasd</li>
</ul>
<ul class="task-list">
<li>
<p>asdf</p>
</li>
<li>
<p>asdfasdf</p>
</li>
<li class="task-list-item">
<p><div class="checkbox" /><input type="checkbox" id="cbx_0" disabled="true" /><label for="cbx_0"> unchecked</label></div></p>
</li>
<li class="task-list-item">
<p><div class="checkbox" /><input type="checkbox" id="cbx_1" checked="true" disabled="true" /><label for="cbx_1"> checked</label></div></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:right">Size</th>
<th style="text-align:right">Cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>bre</td>
<td style="text-align:right">123</td>
<td style="text-align:right">4.5</td>
</tr>
<tr>
<td>laun</td>
<td style="text-align:right">105</td>
<td style="text-align:right">21</td>
</tr>
<tr>
<td>laun</td>
<td style="text-align:right">593</td>
<td style="text-align:right">10</td>
</tr>
<tr>
<td>Total</td>
<td style="text-align:right">1396.0</td>
<td style="text-align:right">62.0</td>
</tr>
<tr>
<td>Average</td>
<td style="text-align:right">349.0</td>
<td style="text-align:right">15.5</td>
</tr>
</tbody>
</table>
<!-- tmf: $4,2=Sum(2:-1) ; $4,3=Sum(2:-1) -->
<!-- tmf: $5,2=Average(2:-2) ; $5,3=Average(2:-2) -->
<ol>
<li>one</li>
<li>two</li>
<li>three</li>
<li>four</li>
</ol>
<p>unavailable</p>
<p>i. asdf
ii. asdfas</p>
<p>a) asdf
b) asdfas
c) asdf</p>
<p>A) asdfa
B) asdf
C) asdfasd</p>
<dl>
<dt>Term 1</dt>
<dd>
<p>Definition 1</p>
</dd>
<dd>
<p>Definition 2
At The Begin</p>
</dd>
<dt>Term 2 with <em>inline markup</em></dt>
<dd>
<p>Characteristics</p>
<ul>
<li>Characteristic 1  <figure class="highlight cpp"><figcaption><span>test.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Characteristic 2</li>
</ul>
</dd>
<dt>Term 1</dt>
<dd>
<p>Definition 2</p>
</dd>
<dd>
<p>Definition 2</p>
</dd>
<dd>
<p>Definition 2</p>
</dd>
</dl>
<p>The hexo default <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXJlbmRlcmVyLW1hcmtlZA==">hexo-renderer-marked<i class="fa fa-external-link-alt"></i></span>
do not support LaTex parser, you must referer external link to parse Latex grammar to
html(That’s what <code>hexo-theme-next</code> did, <code>hexo-theme-next</code> use <code>mathjax</code>),
and the <code>mathjax</code> and <code>hexo-renderer-marked</code> will cause some problem:</p>
<ol>
<li><code>_</code> parse error, you must change <code>x_i</code> to <code>x\_i</code>(This problem had been fixed when i test.)</li>
<li>do not support lines grammar, example below:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">H=-\sum_&#123;i=1&#125;^N (\sigma_&#123;i&#125;^x \sigma_&#123;i+1&#125;^x+g \sigma_&#123;i&#125;^z)</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">f(n) = \begin&#123;cases&#125;</span><br><span class="line"> \frac&#123;n&#125;&#123;2&#125;,</span><br><span class="line"> &amp; \text&#123;if &#125; n\text&#123; is even&#125;</span><br><span class="line"> \\ 3n+1, &amp; \text&#123;if &#125; n\text&#123; is odd&#125;</span><br><span class="line"> \end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">\nabla \times \vec&#123;\mathbf&#123;B&#125;&#125; -\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;E&#125;&#125;&#125;&#123;\partial t&#125; &amp; = \frac&#123;4\pi&#125;&#123;c&#125;\vec&#123;\mathbf&#123;j&#125;&#125; \\   </span><br><span class="line">\nabla \cdot \vec&#123;\mathbf&#123;E&#125;&#125; &amp; = 4 \pi \rho \\</span><br><span class="line">\nabla \times \vec&#123;\mathbf&#123;E&#125;&#125;\, +\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;B&#125;&#125;&#125;&#123;\partial t&#125; &amp; = \vec&#123;\mathbf&#123;0&#125;&#125; \\</span><br><span class="line">\nabla \cdot \vec&#123;\mathbf&#123;B&#125;&#125; &amp; = 0 \end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h2 id="hexo-renderer-markdown-it-plus">hexo-renderer-markdown-it-plus <a class="markdownIt-Anchor" href="#hexo-renderer-markdown-it-plus">#</a></h2>
<p><a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus"><strong>hexo-renderer-markdown-it-plus</strong></a> support lines grammer for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>(Don’t worry, it’s grammer same with Latex).</p>
<p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NIRU5YQ0hFTi9oZXhvLXJlbmRlcmVyLW1hcmtkb3duLWl0LXBsdXM=">hexo-renderer-markdown-it-plus<i class="fa fa-external-link-alt"></i></span></strong></p>
<p>The latex code of above will be display below:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo stretchy="false">(</mo><msubsup><mi>σ</mi><mi>i</mi><mi>x</mi></msubsup><msubsup><mi>σ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>x</mi></msubsup><mo>+</mo><mi>g</mi><msubsup><mi>σ</mi><mi>i</mi><mi>z</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H=-\sum_{i=1}^N (\sigma_{i}^x \sigma_{i+1}^x+g \sigma_{i}^z)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p><sup>link</sup></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mtext> is even</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>3</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mtext> is odd</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(n) = \begin{cases}
 \frac{n}{2},
 &amp; \text{if } n\text{ is even}
 \\ 3n+1, &amp; \text{if } n\text{ is odd}
 \end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">3</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mord text"><span class="mord"> is even</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">n</span><span class="mord text"><span class="mord"> is odd</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">∇</mi><mo>×</mo><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover><mo>−</mo><mtext> </mtext><mfrac><mn>1</mn><mi>c</mi></mfrac><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi mathvariant="bold">E</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mn>4</mn><mi>π</mi></mrow><mi>c</mi></mfrac><mover accent="true"><mi mathvariant="bold">j</mi><mo>⃗</mo></mover></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">∇</mi><mo>⋅</mo><mover accent="true"><mi mathvariant="bold">E</mi><mo>⃗</mo></mover></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>4</mn><mi>π</mi><mi>ρ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">∇</mi><mo>×</mo><mover accent="true"><mi mathvariant="bold">E</mi><mo>⃗</mo></mover><mtext> </mtext><mo>+</mo><mtext> </mtext><mfrac><mn>1</mn><mi>c</mi></mfrac><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mn mathvariant="bold">0</mn><mo>⃗</mo></mover></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">∇</mi><mo>⋅</mo><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\nabla \times \vec{\mathbf{B}} -\, \frac1c\, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \\   
\nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \\
\nabla \times \vec{\mathbf{E}}\, +\, \frac1c\, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \\
\nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:8.52244em;vertical-align:-4.011220000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.51122em;"><span style="top:-6.511219999999999em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">B</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">c</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.64611em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">E</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-4.55611em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">E</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span><span style="top:-2.2499999999999996em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">E</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">c</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.64611em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">B</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.29488999999999965em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">B</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.011220000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.51122em;"><span style="top:-6.511219999999999em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">j</span></span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span style="top:-4.55611em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord mathdefault">ρ</span></span></span><span style="top:-2.2499999999999996em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">0</span></span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span><span style="top:-0.29488999999999965em;"><span class="pstrut" style="height:3.64611em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.011220000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>BTW, i bundle some plugins, example below:</p>
<ol>
<li>H<sub>2</sub>0</li>
<li>x<sup>2</sup></li>
<li><ins>inserted</ins>, <s>Delete</s></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>, example <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i + y_i = z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">y_i + z_i = 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li>
<li>​😄 😂 😛</li>
<li>toc&amp;anchor(do not explain this)</li>
<li>deflist</li>
<li><em>italic</em> <strong>bold</strong></li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI2RlZmluaXRpb24tbGlzdHM=">deflist syntax<i class="fa fa-external-link-alt"></i></span></p>
<dl>
<dt>Term 1</dt>
<dd>Definition 1</dd>
<dd>asdfasdf</dd>
<dt>Term 2 with <em>inline markup</em></dt>
<dd>Characteristics
<ul>
<li>
<p>Definition 2</p>
</li>
<li>
<p>Definition 3</p>
<p>{ some code, part of Definition 2 }
asdf</p>
</li>
</ul>
</dd>
<dt>Term 1</dt>
<dd>Definition 2</dd>
<dd>Definition 2</dd>
</dl>
<ol start="8">
<li><abbr title="hover this will show you something.">abbr</abbr></li>
</ol>
<ol start="9">
<li>Look at the bottom <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
</ol>
<ol start="10">
<li><mark>mark</mark>, <code>==mark==</code></li>
</ol>
<p><strong>The markdown code show as below:</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> H~2~0</span><br><span class="line"><span class="bullet">2.</span> x^2^</span><br><span class="line"><span class="bullet">3.</span> ++inserted++, ~~Delete~~</span><br><span class="line"><span class="bullet">4.</span> $\KaTex$, example $x<span class="emphasis">_i + y_</span>i = z<span class="emphasis">_i$ and $y_</span>i + z<span class="emphasis">_i = 10$</span></span><br><span class="line"><span class="emphasis">5. :smile: :joy: :stuck_</span>out<span class="emphasis">_tongue:</span></span><br><span class="line"><span class="emphasis">6. toc&amp;anchor(do not explain this)</span></span><br><span class="line"><span class="emphasis">7. deflist</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Term 1</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">:   Definition 1</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Term 2 with *inline markup*</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">:   Definition 2</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">        &#123; some code, part of Definition 2 &#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">    Third paragraph of definition 2.</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">8. abbr</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*[abbr]: hover this will show you something.</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">9. Look at the bottom[^hello]</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">   [^hello]: footnote</span></span><br><span class="line"><span class="emphasis">10. ==mark==, `==mark==`</span></span><br></pre></td></tr></table></figure>
<h2 id="tag-plugins">Tag-plugins <a class="markdownIt-Anchor" href="#tag-plugins">#</a></h2>
<p>Docs: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvdGFnLXBsdWdpbnMuaHRtbA==">https://hexo.io/zh-cn/docs/tag-plugins.html<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="link">Link <a class="markdownIt-Anchor" href="#link">#</a></h3>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==" title="https:&#x2F;&#x2F;www.google.com ExtBaidu">Baidu<i class="fa fa-external-link-alt"></i></span>
<h3 id="code-block">Code Block <a class="markdownIt-Anchor" href="#code-block">#</a></h3>
<figure class="highlight cpp"><figcaption><span>test.cpp</span><a href="https://www.aloha.org.cn">Aloha' Blog</a></figcaption><table><tr><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="built_in">glfwGetPrimaryMonitor</span>(), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line marked">    std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line marked">    :smile deep water:</span><br><span class="line marked">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line marked">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line marked">&#125;</span><br><span class="line marked"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line marked"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line marked"><span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br><span class="line"><span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tell GLFW to capture our mouse</span></span><br><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>test2.cpp</span><a href="https://www.aloha.org.cn">Aloha' Blog</a></figcaption><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="include-code">Include Code <a class="markdownIt-Anchor" href="#include-code">#</a></h3>
<figure class="highlight cpp"><figcaption><span>proj6-camera.cpp</span><a href="/code/proj6-camera.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// glfw: whenever the mouse moves, this callback is called</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (firstMouse)</span><br><span class="line">    {</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos; <span class="comment">// reversed since y-coordinates go from bottom to top</span></span><br><span class="line"></span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    camera.<span class="built_in">ProcessMouseMovement</span>(xoffset, yoffset);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="iframe">Iframe <a class="markdownIt-Anchor" href="#iframe">#</a></h3>
<iframe src="https://theme-next.iissnan.com/tag-plugins.html" width="800" height="600" frameborder="0" loading="lazy" allowfullscreen></iframe>
<h3 id="image">Image <a class="markdownIt-Anchor" href="#image">#</a></h3>
<img data-src="/images/aloha.gif" class="right" width="200" title="aloha" alt="aloha">
<ul>
<li><code>img.right</code>、<code>img.left</code> 会分别在右、左边浮动显示。</li>
<li><code>img</code> 的高度不超过 <code>35em</code>。</li>
</ul>
<h3 id="pull-quote">Pull Quote <a class="markdownIt-Anchor" href="#pull-quote">#</a></h3>
<blockquote class="pullquote"><p>content
What’s this?</p>
</blockquote>
<h3 id="reference">Reference <a class="markdownIt-Anchor" href="#reference">#</a></h3>
<a href="/2021/03/15/The-TTY-Demystified/" title="The &lt;b&gt;TTY&lt;&#x2F;b&gt; Demystified">The <b>TTY</b> Demystified</a>
<a href="/2021/03/15/The-TTY-Demystified/" title="The TTY Demystified">The TTY Demystified</a>
<a href="/2021/03/15/The-TTY-Demystified/" title="The TTY Demystified">The TTY Demystified</a>
<h3 id="asset-resource">Asset Resource <a class="markdownIt-Anchor" href="#asset-resource">#</a></h3>
<blockquote>
<p>需要将 <code>_config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>
<blockquote>
<p>asfasdf</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="next-tags">NexT tags <a class="markdownIt-Anchor" href="#next-tags">#</a></h3>
<h4 id="call-out">Call Out <a class="markdownIt-Anchor" href="#call-out">#</a></h4>
<div class="note default default"><p>default</p>
</div>
<div class="note primary primary"><p>primary</p>
</div>
<div class="note success success"><p>success</p>
</div>
<div class="note info info"><p>info</p>
</div>
<div class="note warning warning"><p>warning</p>
</div>
<div class="note danger danger"><p>danger</p>
</div>
<h4 id="button">Button <a class="markdownIt-Anchor" href="#button">#</a></h4>
<p><code>button</code> or <code>btn</code></p>
<p>sepqrate: ,</p>
<a class="btn" href="https://cmake.org/cmake/help/v3.20/command/target_include_directories.html" title="Bars"><i class="fa fa-bras"></i>target_include_directories</a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postButton</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  args = args.join(<span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> url   = args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> text  = args[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> icon  = args[<span class="number">2</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> title = args[<span class="number">3</span>] || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">    hexo.log.warn(<span class="string">&#x27;URL can NOT be empty.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  text = text.trim();</span><br><span class="line">  icon = icon.trim();</span><br><span class="line">  icon = icon.startsWith(<span class="string">&#x27;fa&#x27;</span>) ? icon : <span class="string">&#x27;fa fa-&#x27;</span> + icon;</span><br><span class="line">  title = title.trim();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;a class=&quot;btn&quot; href=&quot;<span class="subst">$&#123;url&#125;</span>&quot;<span class="subst">$&#123;title.length &gt; <span class="number">0</span> ? <span class="string">` title=&quot;<span class="subst">$&#123;title&#125;</span>&quot;`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>&gt;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;icon.length &gt; <span class="number">0</span> ? <span class="string">`&lt;i class=&quot;<span class="subst">$&#123;icon&#125;</span>&quot;&gt;&lt;/i&gt;`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span><span class="subst">$&#123;text&#125;</span></span></span><br><span class="line"><span class="string">          &lt;/a&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;button&#x27;</span>, postButton, &#123;<span class="attr">ends</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;btn&#x27;</span>, postButton, &#123;<span class="attr">ends</span>: <span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="caniuse">caniUse <a class="markdownIt-Anchor" href="#caniuse">#</a></h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caniUse</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  args = args.join(<span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> feature = args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> periods = args[<span class="number">1</span>] || <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!feature) &#123;</span><br><span class="line">    hexo.log.warn(<span class="string">&#x27;Caniuse feature can NOT be empty.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;iframe data-feature=&quot;<span class="subst">$&#123;feature&#125;</span>&quot; src=&quot;https://caniuse.bitsofco.de/embed/index.html?feat=<span class="subst">$&#123;feature&#125;</span>&amp;periods=<span class="subst">$&#123;periods&#125;</span>&amp;accessible-colours=false&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;400px&quot;&gt;&lt;/iframe&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;caniuse&#x27;</span>, caniUse);</span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;can&#x27;</span>, caniUse);</span><br></pre></td></tr></table></figure>
<h4 id="center-quote">Center Quote <a class="markdownIt-Anchor" href="#center-quote">#</a></h4>
<p><code>centerquote</code> or <code>cq</code></p>
<blockquote class="blockquote-center">
<p>So we beat on, boats against the current, borne back ceaselessly into the past.
我们奋力向前，宛如逆水行舟，与激流抗争勇进，直至淹没入岁月长河。</p>

</blockquote>
<h4 id="group-pictures">Group Pictures <a class="markdownIt-Anchor" href="#group-pictures">#</a></h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> LAYOUTS = &#123;</span><br><span class="line">  <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">2</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">3</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">3</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">4</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">5</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">6</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">7</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">8</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">6</span>: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">7</span>: [<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">9</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">6</span>: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">7</span>: [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">10</span>: &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">5</span>: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="number">6</span>: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="number">7</span>: [<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">groupBy</span>(<span class="params">group, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> count <span class="keyword">of</span> group) &#123;</span><br><span class="line">    r.push(data.slice(<span class="number">0</span>, count));</span><br><span class="line">    data = data.slice(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> templates = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span>(<span class="params">pictures, group, layout</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rule = LAYOUTS[group] ? LAYOUTS[group][layout] : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> rule ? <span class="built_in">this</span>.getHTML(groupBy(rule, pictures)) : templates.defaults(pictures);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Defaults Layout</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * □ □ □</span></span><br><span class="line"><span class="comment">   * □ □ □</span></span><br><span class="line"><span class="comment">   * ...</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="variable">pictures</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">defaults</span>: <span class="function"><span class="keyword">function</span>(<span class="params">pictures</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ROW_SIZE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> rows = pictures.length / ROW_SIZE;</span><br><span class="line">    <span class="keyword">var</span> pictureArr = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">      pictureArr.push(pictures.slice(i * ROW_SIZE, (i + <span class="number">1</span>) * ROW_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getHTML(pictureArr);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">getHTML</span>: <span class="function"><span class="keyword">function</span>(<span class="params">rows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rowHTML = rows.map(<span class="function"><span class="params">row</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`&lt;div class=&quot;group-picture-row&quot;&gt;<span class="subst">$&#123;<span class="built_in">this</span>.getColumnHTML(row)&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">    &#125;).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;div class=&quot;group-picture-container&quot;&gt;<span class="subst">$&#123;rowHTML&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">getColumnHTML</span>: <span class="function"><span class="keyword">function</span>(<span class="params">pictures</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> columnWidth = <span class="number">100</span> / pictures.length;</span><br><span class="line">    <span class="keyword">var</span> columnStyle = <span class="string">`style=&quot;width: <span class="subst">$&#123;columnWidth&#125;</span>%;&quot;`</span>;</span><br><span class="line">    <span class="keyword">return</span> pictures.map(<span class="function"><span class="params">picture</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`&lt;div class=&quot;group-picture-column&quot; <span class="subst">$&#123;columnStyle&#125;</span>&gt;<span class="subst">$&#123;picture&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">    &#125;).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">groupPicture</span>(<span class="params">args, content</span>) </span>&#123;</span><br><span class="line">  args = args[<span class="number">0</span>].split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> group = <span class="built_in">parseInt</span>(args[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> layout = <span class="built_in">parseInt</span>(args[<span class="number">1</span>], <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  content = hexo.render.renderSync(&#123;<span class="attr">text</span>: content, <span class="attr">engine</span>: <span class="string">&#x27;markdown&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> pictures = content.match(<span class="regexp">/&lt;img[\s\S]*?&gt;/g</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;div class=&quot;group-picture&quot;&gt;<span class="subst">$&#123;templates.dispatch(pictures, group, layout)&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;grouppicture&#x27;</span>, groupPicture, &#123;<span class="attr">ends</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;gp&#x27;</span>, groupPicture, &#123;<span class="attr">ends</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="label">Label <a class="markdownIt-Anchor" href="#label">#</a></h4>
<p>sepqrate: @</p>
<mark class="label default">《了不起的盖茨比》</mark>
<ul>
<li>default</li>
<li>primary</li>
<li>info</li>
<li>success</li>
<li>danger</li>
<li>warning</li>
</ul>
<h4 id="mermaid">Mermaid <a class="markdownIt-Anchor" href="#mermaid">#</a></h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mermaid</span>(<span class="params">args, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;pre class=&quot;mermaid&quot; style=&quot;text-align: center;&quot;&gt;</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">          &lt;/pre&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;mermaid&#x27;</span>, mermaid, &#123;<span class="attr">ends</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="pdf">Pdf <a class="markdownIt-Anchor" href="#pdf">#</a></h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pdf</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> theme = hexo.theme.config;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;div class=&quot;pdfobject-container&quot; data-target=&quot;<span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>&quot; data-height=&quot;<span class="subst">$&#123;args[<span class="number">1</span>] || theme.pdf.height&#125;</span>&quot;&gt;&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.tag.register(<span class="string">&#x27;pdf&#x27;</span>, pdf, &#123;<span class="attr">ends</span>: <span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="tabs">Tabs <a class="markdownIt-Anchor" href="#tabs">#</a></h4>
<p><code>tabs</code> or <code>subtabs</code> or <code>subsubtabs</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnpodWppYW4ubGlmZS9wb3N0cy81MjEzYzgwYi5odG1s">https://blog.zhujian.life/posts/5213c80b.html<i class="fa fa-external-link-alt"></i></span></p>
<div class="tabs" id="unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#unique-name-1"><i class="fa fa-bars"></i>Top</a></li><li class="tab"><a href="#unique-name-2"><i class="fa fa-bars"></i>Top</a></li><li class="tab"><a href="#unique-name-3"><i class="fa fa-bars"></i>Top</a></li></ul><div class="tab-content"><div class="tab-pane active" id="unique-name-1"><p>Top content 1</p></div><div class="tab-pane" id="unique-name-2"><p>Top content 2</p></div><div class="tab-pane" id="unique-name-3"><p>Top content 3</p>
<div class="tabs" id="unique-name-2"><ul class="nav-tabs"><li class="tab active"><a href="#unique-name-2-1"><i class="fa fa-bars"></i>Sub</a></li><li class="tab"><a href="#unique-name-2-2"><i class="fa fa-bars"></i>Sub</a></li></ul><div class="tab-content"><div class="tab-pane active" id="unique-name-2-1"><p>Sub content 1</p></div><div class="tab-pane" id="unique-name-2-2"><p>Sub content 2</p></div></div></div>
<div class="tabs" id="unique-name-3"><ul class="nav-tabs"><li class="tab"><a href="#unique-name-3-1"><i class="fa fa-bars"></i>Sub</a></li><li class="tab active"><a href="#unique-name-3-2"><i class="fa fa-bars"></i>Sub</a></li></ul><div class="tab-content"><div class="tab-pane" id="unique-name-3-1"><p>Sub content 1</p></div><div class="tab-pane active" id="unique-name-3-2"><p>Sub content 2</p></div></div></div></div></div></div>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>footnote <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
  </entry>
  <entry>
    <title>Linux 配置记录</title>
    <url>/2021/04/06/Linux-%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录 Linux 使用过程中遇到的坑、软件和开发环境的安装和配置等。</p>
<span id="more"></span>
<h2 id="踩坑记录">踩坑记录 <a class="markdownIt-Anchor" href="#踩坑记录">#</a></h2>
<h3 id="用-manjaro-安装镜像分区">用 Manjaro 安装镜像分区 <a class="markdownIt-Anchor" href="#用-manjaro-安装镜像分区">#</a></h3>
<p>Manjaro 安装程序分区有时候会有问题，建议先用 <code>fdisk</code> 分好区并格式化。</p>
<h3 id="把-home-目录下的目录名改为英文">把 HOME 目录下的目录名改为英文 <a class="markdownIt-Anchor" href="#把-home-目录下的目录名改为英文">#</a></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xdg-user-dirs-gtk &amp;&amp; <span class="built_in">export</span> LANG=en_US &amp;&amp; xdg-user-dirs-gtk-update</span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<h3 id="arch-系安装-deb-包">Arch 系安装 deb 包 <a class="markdownIt-Anchor" href="#arch-系安装-deb-包">#</a></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 debtap</span></span><br><span class="line">yay -S debtap</span><br><span class="line">sudo debtap -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 arch 包</span></span><br><span class="line">debtap &lt;deb 包&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装生成的包</span></span><br><span class="line">sudo pacman -U &lt;arch 包&gt;</span><br></pre></td></tr></table></figure>
<h2 id="linux-安装及基本配置">Linux 安装及基本配置 <a class="markdownIt-Anchor" href="#linux-安装及基本配置">#</a></h2>
<h3 id="linux-安装">Linux 安装 <a class="markdownIt-Anchor" href="#linux-安装">#</a></h3>
<p><strong>镜像及启动盘制作</strong>（<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuLw==">清华镜像站<i class="fa fa-external-link-alt"></i></span>）</p>
<ul>
<li>Arch Linux：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2FyY2hsaW51eC9pc28vbGF0ZXN0Lw==">https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/<i class="fa fa-external-link-alt"></i></span></li>
<li>Manjaro Linux
<ul>
<li>官方版：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL29zZG4vc3RvcmFnZS9nL20vbWEvbWFuamFyby8=">https://mirrors.tuna.tsinghua.edu.cn/osdn/storage/g/m/ma/manjaro/<i class="fa fa-external-link-alt"></i></span></li>
<li>社区版：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL29zZG4vc3RvcmFnZS9nL20vbWEvbWFuamFyby1jb21tdW5pdHkv">https://mirrors.tuna.tsinghua.edu.cn/osdn/storage/g/m/ma/manjaro-community/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>刻录软件：
<ul>
<li>Windows：rufus</li>
<li>Linux：<code>dd</code> 命令，示例：<code>dd if=~/Downloads/archlinux-2021.04.01-x86_64.iso of=/dev/sdc1</code>
if 指定镜像文件，of 指定要用的启动盘，一般为 U 盘，可使用 <code>lsblk -f</code> 和 <code>sudo fdisk -l</code> 帮助确定。</li>
</ul>
</li>
</ul>
<p>启动盘制作完成后即可重启电脑，通过 BIOS 从启动盘启动计算机。</p>
<p><strong>后续步骤</strong></p>
<p>Arch</p>
<ol>
<li>参考 ArchWiki 的 <span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0luc3RhbGxhdGlvbl9ndWlkZV8oJUU3JUFFJTgwJUU0JUJEJTkzJUU0JUI4JUFEJUU2JTk2JTg3KQ==">Installation Guide<i class="fa fa-external-link-alt"></i></span></li>
<li>4-1-2021，官方发布<span class="exturl" data-url="aHR0cHM6Ly9hcmNobGludXgub3JnL25ld3MvaW5zdGFsbGF0aW9uLW1lZGl1bS13aXRoLWluc3RhbGxlci8=">消息<i class="fa fa-external-link-alt"></i></span>，可通过“a guided installer”安装 Arch Linux。镜像自带该安装器，只需在镜像系统中使用 <code>archinstall</code> 即可启动菜单式安装。<s>爷的青春结束了</s></li>
</ol>
<p>Manjaro：自带图形安装界面</p>
<p><strong>分区参考</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME        FSTYPE FSVER LABEL  UUID                                 FSAVAIL FSUSE% MOUNTPOINT</span><br><span class="line">nvme0n1</span><br><span class="line">├─nvme0n1p1 vfat   FAT32        3833-B9DC                             510.5M     0% /boot/efi</span><br><span class="line">├─nvme0n1p2 swap   1            8759088c-fdb3-4719-952d-a00cd91fa61b                [SWAP]</span><br><span class="line">├─nvme0n1p3 xfs                 b78adcf1-81a8-4cb0-83dc-3813e68067b8   62.3G    38% /</span><br><span class="line">├─nvme0n1p4 xfs                 7fd8a9e3-8e5e-4d7f-99c3-a6a1498bd192  146.7G    27% /home</span><br><span class="line">└─nvme0n1p5 ntfs         Shared CC00E4A900E49C28                       17.8G    89% /home/aloha/Shared</span><br></pre></td></tr></table></figure>
<p>我的是 Win10 + Linux 双系统，<code>nvme0n1p5</code> 为共享分区。</p>
<p><strong>文件系统格式推荐</strong></p>
<ul>
<li>btrfs：Fedora 的默认 文件系统，支持 copy-on-write（COW），被认为是 Linux 的下一代文件系统，参考
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQwNzM4NjY1My9hbnN3ZXIvMTM1NDk2NDYwNg==">知乎-如何看待 Fedora 33 将默认使用 btrfs 文件系统？-@醉卧沙场的回答<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mZWRvcmFwcm9qZWN0Lm9yZy93aWtpL0NoYW5nZXMvQnRyZnNCeURlZmF1bHQ=">Fedora Wiki-Btrfs by Default<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>xfs：RHEL（Red Hat Enterprise Linux）7 和 8 等著名的商用发行版默认采用的文件系统，我在使用的就是 xfs，主要以因为可以使用 <code>xfsdump</code> 方便备份</li>
</ul>
<p><strong>使用 <code>xfsdump</code> 自动备份的脚本</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">day=$(date +%w)</span><br><span class="line"><span class="comment"># day=0</span></span><br><span class="line"></span><br><span class="line">RET=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#@1 str</span></span><br><span class="line"><span class="comment">#@2 color</span></span><br><span class="line"><span class="function"><span class="title">Hi</span></span>()&#123;</span><br><span class="line">    RET=<span class="string">&quot;\033[1;<span class="variable">$2</span>;40m<span class="variable">$1</span>\033[0m&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">back_mnt_rel=<span class="string">&#x27;_tmp/.sys-backup-mnt&#x27;</span></span><br><span class="line"><span class="comment"># mount point of backup device</span></span><br><span class="line">back_mnt=`<span class="built_in">pwd</span> -P`/<span class="variable">$&#123;back_mnt_rel&#125;</span></span><br><span class="line"><span class="comment"># dir to store backup files</span></span><br><span class="line">back_dir=<span class="variable">$&#123;back_mnt&#125;</span></span><br><span class="line"><span class="comment"># dir to store old backup files</span></span><br><span class="line">back_old_dir=<span class="variable">$&#123;back_mnt&#125;</span>/.old</span><br><span class="line"><span class="comment"># device where to store dump files</span></span><br><span class="line">back_dev=<span class="string">&quot;6b1bd96b-5abc-4625-aa44-7de685a79752&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Backup Information:&quot;</span></span><br><span class="line">Hi <span class="variable">$&#123;back_dev&#125;</span> 33 &amp;&amp; <span class="built_in">echo</span> -e <span class="string">&quot;\tUsing Device:\t\t<span class="variable">$&#123;RET&#125;</span>&quot;</span></span><br><span class="line">Hi <span class="variable">$&#123;back_mnt&#125;</span> 33 &amp;&amp; <span class="built_in">echo</span> -e <span class="string">&quot;\tMount Point:\t\t<span class="variable">$&#123;RET&#125;</span>&quot;</span></span><br><span class="line">Hi <span class="variable">$&#123;back_dir&#125;</span> 33 &amp;&amp; <span class="built_in">echo</span> -e <span class="string">&quot;\tBackup Directory:\t<span class="variable">$&#123;RET&#125;</span>&quot;</span></span><br><span class="line">Hi <span class="variable">$&#123;day&#125;</span>      33 &amp;&amp; <span class="built_in">echo</span> -e <span class="string">&quot;\tBackup Level:\t\t<span class="variable">$&#123;RET&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Continue? y(es)/[n(o)]: &quot;</span> confirm</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;confirm&#125;</span> <span class="keyword">in</span></span><br><span class="line">    [yY][eE][sS]|[yY])</span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;34;40mBackup Starting...\033[0m&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    [nN][oO]|[nN])</span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;31;40mAborted.\033[0m&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;31;40mInvalid input.\033[0m&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 2</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$&#123;back_mnt&#125;</span></span><br><span class="line">mount --uuid <span class="variable">$&#123;back_dev&#125;</span> <span class="variable">$&#123;back_mnt&#125;</span></span><br><span class="line">mkdir -p <span class="variable">$&#123;back_dir&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$day</span> -eq 1 || <span class="variable">$day</span> -eq 2 || <span class="variable">$day</span> -eq 3 || <span class="variable">$day</span> -eq 4 || <span class="variable">$day</span> -eq 5 || <span class="variable">$day</span> -eq 6 ]];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;34;40m[Level <span class="variable">$&#123;day&#125;</span>]Dumping...\033[0m&quot;</span></span><br><span class="line">    <span class="comment"># /boot/efi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mtar -upf <span class="variable">$&#123;back_dir&#125;</span>/efi-full-`date +%F`.tgz /boot/efi\033[0m&quot;</span></span><br><span class="line">    tar -upf <span class="variable">$&#123;back_dir&#125;</span>/efi-full-`date +%F`.tgz /boot/efi</span><br><span class="line">    <span class="comment"># /</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mxfsdump -e -l <span class="variable">$&#123;day&#125;</span> -f <span class="variable">$&#123;back_dir&#125;</span>/root-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -L root-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -M nvme0n1p3 /\033[0m&quot;</span></span><br><span class="line">    xfsdump -e -l <span class="variable">$&#123;day&#125;</span> -f <span class="variable">$&#123;back_dir&#125;</span>/root-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -L root-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -M nvme0n1p3 /</span><br><span class="line">    <span class="comment"># /home</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mxfsdump -e -l <span class="variable">$&#123;day&#125;</span> -f <span class="variable">$&#123;back_dir&#125;</span>/root-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -L home-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -M nvme0n1p4 /home\033[0m&quot;</span></span><br><span class="line">    xfsdump -e -l <span class="variable">$&#123;day&#125;</span> -f <span class="variable">$&#123;back_dir&#125;</span>/home-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -L home-inc<span class="variable">$&#123;day&#125;</span>-`date +%F` -M nvme0n1p4 /home</span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$day</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;34;40m[Level 0(full)]Dumping...\033[0m&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;34;40mCleaning up old Dumps..\033[0m&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mrm <span class="variable">$&#123;back_old_dir&#125;</span>/*\033[0m&quot;</span></span><br><span class="line">    rm <span class="variable">$&#123;back_old_dir&#125;</span>/*</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mmv <span class="variable">$&#123;back_dir&#125;</span>/*inc* <span class="variable">$&#123;back_dir&#125;</span>/*full* <span class="variable">$&#123;back_old_dir&#125;</span>/\033[0m&quot;</span></span><br><span class="line">    mv <span class="variable">$&#123;back_dir&#125;</span>/*inc* <span class="variable">$&#123;back_dir&#125;</span>/*full* <span class="variable">$&#123;back_old_dir&#125;</span>/</span><br><span class="line">    <span class="comment"># /boot/efi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mtar -cpf <span class="variable">$&#123;back_dir&#125;</span>/efi-full-`date +%F`.tgz /boot/efi\033[0m&quot;</span></span><br><span class="line">    tar -cpf <span class="variable">$&#123;back_dir&#125;</span>/efi-full-`date +%F`.tgz /boot/efi</span><br><span class="line">    <span class="comment"># /</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mxfsdump -e -f <span class="variable">$&#123;back_dir&#125;</span>/root-full-`date +%F` -L root-full-`date +%F` -M nvme0n1p3 /\033[0m&quot;</span></span><br><span class="line">    xfsdump -e -f <span class="variable">$&#123;back_dir&#125;</span>/root-full-`date +%F` -L root-full-`date +%F` -M nvme0n1p3 /</span><br><span class="line">    <span class="comment"># /home</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32;40mxfsdump -e -f <span class="variable">$&#123;back_dir&#125;</span>/home-full-`date +%F` -L home-full-`date +%F` -M nvme0n1p4 /home\033[0m&quot;</span></span><br><span class="line">    xfsdump -e -f <span class="variable">$&#123;back_dir&#125;</span>/home-full-`date +%F` -L home-full-`date +%F` -M nvme0n1p4 /home</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;Actually, this is IMPOSSIBLE.&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">umount <span class="variable">$&#123;back_mnt&#125;</span></span><br><span class="line">rmdir -p <span class="variable">$&#123;back_mnt_rel&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="pacman-换源">pacman 换源 <a class="markdownIt-Anchor" href="#pacman-换源">#</a></h2>
<ol>
<li>方法 1：sudo pacman-mirrors -i -c China -m rank</li>
<li>方法 2：在 /etc/pacman.d/mirrorlist 开头加上：</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>/etc/pacman.d/mirrorlist</span></figcaption><table><tr><td class="code"><pre><span class="line">## Country : China</span><br><span class="line">Server = https://mirrors.sjtug.sjtu.edu.cn/manjarostable/$repo/$arch</span><br></pre></td></tr></table></figure>
<p>然后同步本地数据库：<code>sudo pacman -Syy</code></p>
<p>启用 <code>archlinuxcn</code> 源（optional，<mark>不建议 manjaro 用户启用</mark>）：</p>
<p>在 <code>/etc/pacman.conf</code> 末尾加上：</p>
<figure class="highlight plaintext"><figcaption><span>/etc/pacman.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">#SigLevel = Optional TrustedOnly</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>
<p>然后执行命令：<code>sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code></p>
<h2 id="软件和开发环境">软件和开发环境 <a class="markdownIt-Anchor" href="#软件和开发环境">#</a></h2>
<h3 id="wps">WPS <a class="markdownIt-Anchor" href="#wps">#</a></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru -S wps-office-cn ttf-wps-fonts wps-office-mui-zh-cn</span><br></pre></td></tr></table></figure>
<p>安装后出现提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ATTENTION: When you shut down wps, the wpsoffice process may still exist.</span><br><span class="line"># You can do &#x27;sudo chmod -x /usr/lib/office6/wpsoffice&#x27; to fix it. But</span><br><span class="line"># this might bring you problem with signing in.</span><br></pre></td></tr></table></figure>
<h3 id="字体">字体 <a class="markdownIt-Anchor" href="#字体">#</a></h3>
<p>Nerd 字体：<code>nerd-fonts-jetbrains-mono</code> 或 <code>nerd-fonts-fira-code</code></p>
<p>中文字体：<code>ttf-sarasa-gothic</code> 或 <code>adobe-source-han-serif-otc-fonts</code> 和 <code>adobe-source-han-sans-otc-fonts</code></p>
<h3 id="fcitx-输入法">fcitx 输入法 <a class="markdownIt-Anchor" href="#fcitx-输入法">#</a></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im fcitx5-material-color fcitx5-rime librime</span><br></pre></td></tr></table></figure>
<p>设置环境变量：</p>
<figure class="highlight bash"><figcaption><span>~/.pam_environment</span></figcaption><table><tr><td class="code"><pre><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx</span><br><span class="line">XMODIFIERS    DEFAULT=\@im=fcitx</span><br><span class="line">SDL_IM_MODULE DEFAULT=fcitx</span><br></pre></td></tr></table></figure>
<p>Rime 配置目录：<code>~/.local/share/fcitx5/rime/</code></p>
<p>参见</p>
<ul>
<li>ArchWiki：
<ul>
<li>fcitx5：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0ZjaXR4NV8oJUU3JUFFJTgwJUU0JUJEJTkzJUU0JUI4JUFEJUU2JTk2JTg3KQ==">https://wiki.archlinux.org/index.php/Fcitx5_(简体中文)<i class="fa fa-external-link-alt"></i></span></li>
<li>rime：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1JpbWVfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">https://wiki.archlinux.org/index.php/Rime_(简体中文)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>Rime Github 主页：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JpbWUvaG9tZQ==">https://github.com/rime/home<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="mariadb-和-lua-mysql">MariaDB 和 lua-mysql <a class="markdownIt-Anchor" href="#mariadb-和-lua-mysql">#</a></h3>
<ul>
<li>lua-mysql</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo proxychains -q luarocks install luasql-mysql MYSQL_INCDIR=/usr/include/mysql</span><br></pre></td></tr></table></figure>
<ul>
<li>MariaDB</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S mariadb mariadb-clients mariadb-libs</span><br><span class="line">sudo mv /var/lib/mysql /tmp</span><br><span class="line">sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line">sudo systemctl restart mariadb</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 和 C</title>
    <url>/2021/04/15/Lua-%E5%92%8C-C/</url>
    <content><![CDATA[<p>Lua 是一种</p>
<ul>
<li><strong>嵌入式语言</strong>——C 语言拥有控制权，Lua 被当作库，C 代码称为<strong>应用代码</strong></li>
<li><strong>可扩展的语言</strong>——Lua 拥有控制权，C 语言被用作库，C 代码称为<strong>库代码</strong></li>
</ul>
<p>应用代码和库代码都使用相同的 API 和 Lua 通信，这些 API 被称为 <mark>C API</mark>。</p>
<div class="note info"><p>完整函数列表见：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9tYW51YWwvbHVhNTNkb2MvY29udGVudHMuaHRtbCNpbmRleA==">Lua 参考手册（Lua5.3 - 菜鸟教程）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5sdWEub3JnL21hbnVhbC81LjQvI2luZGV4">Lua 参考手册（Lua5.4 - 官网）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</div>
<span id="more"></span>
<h2 id="头文件">头文件 <a class="markdownIt-Anchor" href="#头文件">#</a></h2>
<ul>
<li><code>lua.h</code>：Lua 提供的基础函数，如创建新 Lua 环境、调用 Lua 函数、读写环境中全局变量以及注册供 Lua 调用的新函数的函数。这些函数都以 <code>lua_</code> 开头。</li>
<li><code>lauxlib.h</code>：<strong>辅助库</strong>（auxlibary library, auxlib）所提供的函数，使用 <code>lua.h</code> 中的基础 API 实现更高层次的抽象。这些函数以 <code>luaL_</code> 开头。</li>
<li><code>lualib.h</code>：用于操作 Lua 标准库。其中的函数也以 <code>luaL_</code> 开头。</li>
</ul>
<h2 id="栈">栈 <a class="markdownIt-Anchor" href="#栈">#</a></h2>
<p>Lua 通过维护一个虚拟栈来完成 Lua 代码和 C 代码之间的交流。C API 中的函数若需要传入栈索引，这个索引必须是<strong>有效索引</strong>或<strong>可接受索引</strong>。</p>
<dl>
<dt>有效索引（valid indices）</dt>
<dd>对应一个可以修改的 Lua 值所在位置的索引，包括 1 到栈顶（1 ≤ abs(index) ≤ <code>lua_gettop(L)</code>）之间的栈索引和<strong>伪索引</strong>。</dd>
<dt>可接受索引（acceptable indices）</dt>
<dd>栈顶之后的索引（abs(index) &gt; <code>lua_gettop(L)</code>）以及大于<strong>上值</strong>数目的伪索引。前者可以以只读方式访问内存。</dd>
<dd>除非特别说明，API 中的函数能正确处理可接受索引。</dd>
<dt>伪索引（pseudo-indices）</dt>
<dd>可以用来访问<strong>注册表</strong>（registry）（使用 <code>LUAREGISTRYINDEX</code> 访问）和 C 函数的<strong>上值</strong>（upvalue）。</dd>
<dd>注册表和上值都是不在栈中但是可以被 C 代码访问的位置。</dd>
</dl>
<p>Lua 代码严格按照后进先出的规则操纵栈，而 C 代码则可以对栈进行随机访问，甚至可以在任何位置插入和删除元素。</p>
<p>C 代码通过 <code>lua_push*</code> 函数将元素压入栈，通过 <code>lua_to*</code> 函数取得指定位置的元素值。</p>
<p>对于数字（Number 和 Integer），返回值 0 有意义，不能视为错误。
Lua5.2 中引入了新函数进行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">lua_Number <span class="title">lua_tonumberx</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="keyword">int</span> *isnum)</span></span>;</span><br><span class="line"><span class="function">lua_Integer <span class="title">lua_tointegerx</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="keyword">int</span> *isnum)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当获得的值为 0 或指定的值类型不对时，两个函数都会返回 0。
<code>isnum</code> 返回一个布尔值表示指定的值的类型是否为所需类型，以区分上述两种情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lua_pushstring(L, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> msg;</span><br><span class="line"><span class="keyword">if</span>(!lua_tonumberx(L, <span class="number">-1</span>, &amp;msg)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not a number, %d\n&quot;</span>, msg);</span><br><span class="line">    <span class="comment">// -&gt; Not a number, 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lua_pushinteger(L, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> msg;</span><br><span class="line"><span class="keyword">if</span>(!lua_tonumberx(L, <span class="number">-1</span>, &amp;msg)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not a number, %d\n&quot;</span>, msg);</span><br><span class="line">    <span class="comment">// -&gt; Not a number, 1</span></span><br><span class="line">    <span class="comment">// &quot;Not a number&quot; 判断错误，msg 表明指定位置的值的类型为 number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="note warning"><summary><p>确保栈中有足够的空间</p>
</summary>
<p>Lua 保证在使用栈时栈中至少有 20 个空闲的位置（slot）（<code>lua.h</code> 中定义的单位大小为 <code>LUA_MINSTACK</code>），但有些时候会需要更多的空间，这时便需要 <code>lua_checkstack</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lua_checkstack</span><span class="params">(lua_State *L, <span class="keyword">int</span> sz)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>lua_checkstack</code> 确保堆栈上至少有 <code>n</code> 个额外空位。
如果不能把堆栈扩展到相应的尺寸，函数返回假（0）。</p>
<p>辅助库 <code>lauxlib.h</code> 中定义了一个高层函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaL_checkstack</span><span class="params">(lua_Stack *L, <span class="keyword">int</span> sz, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数类似于 <code>lua_ckeckstack</code>，但是当无法扩展空间时，会抛出一个错误。
<code>msg</code> 是描述错误的额外文本信息，<code>NULL</code> 表示不需要额外文本。</p>

</details>
<p>其他栈操作（详细说明见<a href="#">手册</a>）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">lua_gettop</span>    <span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_settop</span>    <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushvalue</span> <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_rotate</span>    <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_remove</span>    <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_insert</span>    <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_replace</span>   <span class="params">(lua_State *L, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_copy</span>      <span class="params">(lua_State *L, <span class="keyword">int</span> fromidx, <span class="keyword">int</span> toidx)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="c-api-中的错误处理">C API 中的错误处理 <a class="markdownIt-Anchor" href="#c-api-中的错误处理">#</a></h2>
<blockquote>
<p>用异常来提示错误，而没有在 API 的每个操作中使用错误码。与 C++ 或 Java 不同，C 语言没有提供异常处理机制。为了解决这个问题，Lua 使用了 C 语言中的 <code>setjmp</code> 机制，<code>setjmp</code> 营造了一个<em>类似异常处理的机制</em>。
因此，大多数 API 都可以抛出异常（即调用 <code>longjmp</code>）而不是直接返回。</p>
</blockquote>
<h3 id="处理应用代码中的错误">处理应用代码中的错误 <a class="markdownIt-Anchor" href="#处理应用代码中的错误">#</a></h3>
<p>在应用代码中，如果没有为 <code>longjmp</code> 准备对应的 <code>setjmp</code>，API 中的任何错误都会导致 Lua 调用紧急函数（panic function），这个函数返回时，应用就会退出。
我们可以通过 <code>lua_atpanic</code> 设置自己的紧急函数，但是作用不大。</p>
<p>要正确处理应用代码中的错误，必须通过 Lua 提供的 API 调用我们自己的代码，即在 <code>setjmp</code> 的上下文中运行代码。
我们可以将 C 代码封装到一个 C 函数中，再通过 <code>lua_pcall</code> 调用，这样我们的 C 代码会在<strong>保护模式</strong>（见 <a href="https://www.runoob.com/manual/lua53doc/manual.html#lua_pcall"><code>lua_pcall</code></a>）下运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// code to run in protected mode</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">secure_foo</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    lua_pushfunction(L, foo);</span><br><span class="line">    <span class="keyword">return</span>(lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理库代码中的错误">处理库代码中的错误 <a class="markdownIt-Anchor" href="#处理库代码中的错误">#</a></h3>
<p>在编写<strong>库代码</strong>时，通常无需进行额外的操作。库函数抛出的错误要么被 Lua 中的 <code>pcall</code> 捕获，要么被应用代码中的 <code>lua_pcall</code> 捕获（这就要求应用代码需要按照上文中的方式编写）。
因此，当库代码中的函数检测到错误时，只需简单地调用 <code>lua_error</code>（或 <code>luaL_error</code>）即可。<code>lua_error</code> 会以栈顶的值作为<strong>错误对象</strong>(error object)（“a single value”，<code>lua_pcall</code> 会在检测到错误时会将其置于栈顶），抛出一个 Lua 错误。</p>
<h2 id="内存分配">内存分配 <a class="markdownIt-Anchor" href="#内存分配">#</a></h2>
<p>Lua 的 C API 并不一定要通过调用 <code>malloc</code> 等函数来分配内存，而是可以通过用户自己实现的一个<strong>分配函数</strong>（allocation function）来分配和释放内存。</p>
<p><code>luaL_newstate</code> 通过默认分配函数来创建 Lua 状态机，该分配函数使用了 C 的 <code>malloc</code>、<code>realloc</code>、<code>free</code> 函数。
<code>lua_newstate</code> 则将其参数作为分配函数创建 Lua 状态机。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">lua_State* <span class="title">lua_newstate</span><span class="params">(lua_Alloc f, <span class="keyword">void</span>* ud)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lua_Alloc f</code>：分配函数</li>
<li><code>void* ud</code>：用户数据</li>
</ul>
<p>分配函数需满足以下格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (*lua_Alloc)(<span class="keyword">void</span>* ud,</span><br><span class="line">                           <span class="keyword">void</span>* ptr,</span><br><span class="line">                           <span class="keyword">size_t</span> osize,</span><br><span class="line">                           <span class="keyword">size_t</span> nsize);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void* ud</code>：始终为 <code>lua_newstate</code> 提供的用户数据</li>
<li><code>void* ptr</code>：正要被分配、重分配、释放的块的地址</li>
<li><code>size_t osize</code>：原始块的大小</li>
<li><code>size_t nsize</code>：请求的块的大小</li>
</ul>
<p>分配函数的行为像</p>
<ul>
<li><code>malloc</code>：<code>ptr</code> 为 <code>NULL</code>，<code>nsize</code> 为 0，返回新分配的块的地址</li>
<li><code>realloc</code>：<code>ptr</code> 不为 <code>NULL</code> 且 <code>nsize</code> 不为 0，释放 <code>ptr</code> 指向的块并返回新地址</li>
<li><code>free</code>：<code>ptr</code> 不为 <code>NULL</code>，<code>nsize</code> 为 0，分配函数必须释放 <code>ptr</code> 指向的块并返回 <code>NULL</code></li>
</ul>
<p>注意：</p>
<ul>
<li>如果 <code>ptr</code> 是 <code>NULL</code>，那么 <code>osize</code> 则用来存放其他信息。若同时 <code>nsize</code> 为 0，则分配函数什么也不做，并返回 <code>NULL</code></li>
<li>如果无法分配指定的块，则必须返回 <code>NULL</code></li>
<li>Lua 假定 <code>nsize</code> 等于 <code>osize</code> 时不会失败</li>
</ul>
<p><code>luaL_newstate</code> 使用的默认分配函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">l_alloc</span><span class="params">(<span class="keyword">void</span>* ud, <span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> osize, <span class="keyword">size_t</span> nsize)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) ud; (<span class="keyword">void</span>)osize; <span class="comment">/* 未使用 */</span></span><br><span class="line">    <span class="keyword">if</span>(nsize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">realloc</span>(ptr, nsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在-lua-中调用-c-语言">在 Lua 中调用 C 语言 <a class="markdownIt-Anchor" href="#在-lua-中调用-c-语言">#</a></h2>
<p>Lua 调用 C 函数时，每个 C 函数痘有其独立的<strong>局部栈</strong>，其第一个参数总是位于局部栈中索引为 1 的位置。</p>
<p>创建一个 C 库一般包含三步：</p>
<ol>
<li>创建 C 函数</li>
<li>填充函数注册表：定义 C 函数到 Lua 函数的映射</li>
<li>定义入口函数：将 C 函数注册为 Lua 函数</li>
</ol>
<p>首先，库函数都必须使用同一个原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*lua_CFunction)</span><span class="params">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C 函数通过返回值（<code>return</code>）决定要返回（通过虚拟栈）给 Lua 的参数个数。</p>
<p>第二步中，函数注册表为一个 <code>luaL_Reg</code> 数组，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> _<span class="title">lib_reg</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;dir&quot;</span>, l_dir&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125; <span class="comment">// 哨兵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>l_dir</code> 函数被注册为 Lua 函数 <code>dir</code>。</p>
<p>最后就是使用第二步中的函数注册表将 C 函数注册为 Lua 函数。这一步需要我们定义一个<strong>入口函数</strong>。
Lua 会根据库文件名在库文件中寻找入口函数，一般为 <code>luaopen_&lt;file_name_without_extention_name&gt;</code>，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_libdir</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    luaL_newlib(L, _lib_reg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入口函数通常直接使用 <code>luaL_newlib</code> 方法创建新的 Lua 表，其中包含注册好的 Lua 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaL_newlib</span><span class="params">(lua_State *L, <span class="keyword">const</span> luaL_Reg l[])</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>luaL_newlib</code> 其实是一个宏，详见<a href="#%E5%85%B1%E4%BA%AB%E4%B8%8A%E5%80%BC">共享上值</a>。</p>
<p>完整示例见<a href="#%E5%AE%9E%E7%8E%B0-lua-%E7%9A%84-dir-%E5%87%BD%E6%95%B0">实现 Lua 的 dir 函数</a>。</p>
<details class="note info"><summary><p>require 函数参数中的连字符</p>
</summary>
<p>Lua 的 <code>require</code> 函数在寻找入口函数时，入口函数名为库文件第一个连字符（-）之前的部分或文件名去处末尾的 <code>.so</code>（Windows 为 <code>.dll</code>）。</p>
<p>另外，<code>require</code> 函数中的句点 <code>.</code> 表示<strong>子模块</strong>，如：<code>require'libdir-v0.1'</code> 中的 <code>libdir-v0.1</code> 表示 <code>libdir-v0/1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; dir = require&#x27;libdir-v0.1&#x27;</span><br><span class="line">stdin:1: module &#x27;libdir-v0.1&#x27; not found:</span><br><span class="line">        no field package.preload[&#x27;libdir-v0.1&#x27;]</span><br><span class="line">        no file &#x27;/usr/share/lua/5.4/libdir-v0/1.lua&#x27;</span><br><span class="line">        no file &#x27;/usr/share/lua/5.4/libdir-v0/1/init.lua&#x27;</span><br><span class="line">        no file &#x27;/usr/lib/lua/5.4/libdir-v0/1.lua&#x27;</span><br><span class="line">        no file &#x27;/usr/lib/lua/5.4/libdir-v0/1/init.lua&#x27;</span><br><span class="line">        no file &#x27;./libdir-v0/1.lua&#x27;</span><br><span class="line">        no file &#x27;./libdir-v0/1/init.lua&#x27;</span><br><span class="line">        no file &#x27;/usr/lib/lua/5.4/libdir-v0/1.so&#x27;</span><br><span class="line">        no file &#x27;/usr/lib/lua/5.4/loadall.so&#x27;</span><br><span class="line">        no file &#x27;./libdir-v0/1.so&#x27;</span><br><span class="line">        no file &#x27;/usr/lib/lua/5.4/libdir-v0.so&#x27;</span><br><span class="line">        no file &#x27;/usr/lib/lua/5.4/loadall.so&#x27;</span><br><span class="line">        no file &#x27;./libdir-v0.so&#x27;</span><br><span class="line">stack traceback:</span><br><span class="line">        [C]: in function &#x27;require&#x27;</span><br><span class="line">        stdin:1: in main chunk</span><br><span class="line">        [C]: in ?</span><br></pre></td></tr></table></figure>
</details>
<h3 id="注册表">注册表 <a class="markdownIt-Anchor" href="#注册表">#</a></h3>
<p>Lua API 中通过使用注册表来实现“全局变量”。使用这一功能需要一对函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaL_ref</span> <span class="params">(lua_State *L, <span class="keyword">int</span> t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaL_unref</span> <span class="params">(lua_State *L, <span class="keyword">int</span> t, <span class="keyword">int</span> ref)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注册表总是位于<strong>伪索引</strong> <code>LUA_REGISTRYINDEX</code> 中，可以像使用一个普通的索引一样使用它。
需要注意的是，所有在 Lua 中加载的库代码都共用一个注册表，在给表的键取名时要注意命名冲突。</p>
<div class="note warning"><p>在注册表中不能使用数值类型的键，因为 Lua 将其作为<strong>引用系统</strong>的保留字。</p>
</div>
<details class="note info"><summary><p>轻量用户数据</p>
</summary>
<p>Lua 中提供轻量用户数据（light userdata）来获取唯一值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具有唯一地址的变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Key = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存字符串</span></span><br><span class="line">lua_pushlightuserdata(L, (<span class="keyword">void</span>*)&amp;Key);</span><br><span class="line">lua_pushstring(L, myStr);</span><br><span class="line">lua_settable(L, LUA_REGISTRYINDEX);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串</span></span><br><span class="line">lua_pushlightuserdata(L, (<span class="keyword">void</span>*)&amp;Key);</span><br><span class="line">lua_gettable(L, LUA_REGISTRYINDEX);</span><br><span class="line">*myStr = lua_tostring(L, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>为了简化将变量地址作为唯一值的用法，Lua5.2 引入了两个函数：<code>lua_rawgetp</code> 和 <code>lua_rawsetp</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具有唯一地址的变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Key = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存字符串</span></span><br><span class="line">lua_pushstring(L, myStr);</span><br><span class="line">lua_rawsetp(L, LUA_REGISTRYINDEX, (<span class="keyword">void</span>*)&amp;Key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串</span></span><br><span class="line">lua_rawgetp(L, LUA_REGISTRYINDEX, (<span class="keyword">void</span>*)&amp;Key);</span><br><span class="line">myStr = lua_tostring(L, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
</details>
<h3 id="上值和共享上值">上值和共享上值 <a class="markdownIt-Anchor" href="#上值和共享上值">#</a></h3>
<p>Lua 中可以为一个函数绑定若干个<strong>上值</strong>，这些上值仅在绑定的函数中可见。
一个函数和其上值的关联称为<strong>闭包</strong>（closure）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并返回闭包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushcclosure</span><span class="params">(lua_State *L, lua_CFunction fn, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 在闭包函数中获取上值的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lua_upvalueindex</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上值的索引可以被当作普通索引使用，Lua 会处理好一切。</p>
<p>使用 <code>lua_pushcclosure</code> 在工厂函数中返回一个闭包是上值的一种使用方法，实例见：<a href="#%E4%B8%8A%E5%80%BC%E5%92%8C%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0">上值和工厂函数</a>。</p>
<p>如果要在多个函数中共用上值（共享上值），可以使用以下代码替代 <code>luaL_newlib</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建库函数表</span></span><br><span class="line">luaL_newlibtable(L, _lib_reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备要共享的值（这里是一个表）</span></span><br><span class="line">lua_newtable(L);</span><br><span class="line"><span class="comment">/* ...（这里假设这些代码保证上面的表最终在栈顶） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 _lib_reg 中的函数添加到新库中，指定栈顶一定数量（这里是 1）的共享上值</span></span><br><span class="line"><span class="comment">// lua_setfuncs 会将栈中的值删除</span></span><br><span class="line">lua_setfuncs(L, lib, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="实例">实例 <a class="markdownIt-Anchor" href="#实例">#</a></h2>
<h3 id="输出整个栈中的内容">输出整个栈中的内容 <a class="markdownIt-Anchor" href="#输出整个栈中的内容">#</a></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stackDump</span> <span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> top = lua_gettop(L);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = lua_type(L, i);</span><br><span class="line">        <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">            <span class="keyword">case</span> LUA_TSTRING: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27;&quot;</span>, lua_tostring(L, i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> LUA_TBOOLEAN: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(lua_toboolean(L, i) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> LUA_TNUMBER: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%g&quot;</span>, lua_tonumber(L, i));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, lua_typename(L, t));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现-lua-的-dir-函数">实现 Lua 的 dir 函数 <a class="markdownIt-Anchor" href="#实现-lua-的-dir-函数">#</a></h3>
<p>Lua 标准库中没有 <code>dir</code> 函数（读取目录下的所有文件），但是我们可以自己实现：</p>
<figure class="highlight c"><figcaption><span>libdir-v0-1.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lua.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lauxlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">l_dir</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path = luaL_checkstring(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lua_pushnil(L);</span><br><span class="line">        lua_pushstring(L, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lua_newtable(L);</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lua_pushinteger(L, i++);</span><br><span class="line">        lua_pushstring(L, entry-&gt;d_name);</span><br><span class="line">        lua_settable(L, <span class="number">-3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> _<span class="title">lib_reg</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;dir&quot;</span>, l_dir&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125; <span class="comment">// 哨兵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数，不加 static，lua_open&lt;libname&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_libdir</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    luaL_newlib(L, _lib_reg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>gcc -fPIC -shared -o libdir-v0-1.so libdir-v0-1.c</code> 编译得到动态库。
再通过以下 Lua 脚本测试：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">dir = <span class="built_in">require</span><span class="string">&quot;libdir&quot;</span>   <span class="comment">--&gt; </span></span><br><span class="line">dir.dir(<span class="string">&#x27;.&#x27;</span>)  <span class="comment">--&gt; table: 0x5580923c1af0</span></span><br></pre></td></tr></table></figure>
<h3 id="上值和工厂函数">上值和工厂函数 <a class="markdownIt-Anchor" href="#上值和工厂函数">#</a></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数，返回（通过虚拟栈）一个 closure</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newCounter</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">    lua_pushinteger(L, <span class="number">10</span>);</span><br><span class="line">    lua_pushcclosure(L, &amp;counter, <span class="number">1</span>);   <span class="comment">// 状态机，指定闭包中的函数，要绑定的上值数量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = lua_tointeger(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">    lua_pushinteger(L, ++val);</span><br><span class="line">    lua_copy(L, <span class="number">-1</span>, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>C/C++</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 迭代器和泛型 for</title>
    <url>/2021/04/08/Lua-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8B-for/</url>
    <content><![CDATA[<blockquote>
<p>《Lua 程序设计》的“迭代器”和“工厂”（返回迭代器及其他值的函数）经常混用。
本文也未刻意区分。</p>
</blockquote>
<span id="more"></span>
<h2 id="迭代器">迭代器 <a class="markdownIt-Anchor" href="#迭代器">#</a></h2>
<dl>
<dt>迭代器（iterator）</dt>
<dd>一种可以用来遍历一个集合中所有元素的代码结构（函数）。</dd>
<dt>闭包（closure）</dt>
<dd>一个可以访问其自身环境中一个或多个局部变量的函数。</dd>
<dd>通常这一概念还包含其可访问的外部局部变量。但也可将其简单理解为有状态（保存在外部局部变量中）的迭代器，与下文中的“无状态迭代器”相对。</dd>
<dt>工厂（factory）</dt>
<dd>用于创建闭包及其封装变量的函数。</dd>
</dl>
<p>这里所说的闭包内可以访问局部变量称为”状态“。除了局部变量，宿主语言（如 C）中实现的迭代器还可以将状态保存在其自身的变量中（如 <code>io.read()</code> 将状态保存在 C 结构体中）。</p>
<h2 id="泛型-for">泛型 for <a class="markdownIt-Anchor" href="#泛型-for">#</a></h2>
<p>泛型 for 的语法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;var-list&gt; <span class="keyword">in</span> &lt;<span class="built_in">exp</span>-list&gt; <span class="keyword">do</span></span><br><span class="line">    &lt;body&gt;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>for</code> 做的第一件事就是对 <code>&lt;exp-list&gt;</code> 求值。</p>
<p>表达式列表 <code>&lt;exp-list&gt;</code> 应返回三个值<strong>供 <code>for</code> 保存</strong>：</p>
<ol>
<li>迭代函数</li>
<li>不可变状态（invariant state）（<code>ipairs</code> 和 <code>pairs</code> 简单地将其参数作为不可变状态返回）</li>
<li>控制变量的初始值</li>
</ol>
<dl>
<dt>控制变量（control variable）</dt>
<dd>其值为 <code>nil</code> 时循环结束。</dd>
</dl>
<p>表达式列表的结果最多有三个，多余的会被舍弃；而不足的则以 <code>nil</code> 补齐。
其中只有最后一项能产生多个值。</p>
<p><code>for</code> 做的第二件事是以不可变状态和控制变量为参数来调用选代函数，并将返回值赋给 <code>&lt;var-list&gt;</code>，如果第一个返回值为 <code>nil</code> 则结束循环，否则执行循环体并再次调用迭代函数，并不断重复此过程。</p>
<p>确切地说，形如</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var_1, ..., var_n <span class="keyword">in</span> <span class="built_in">exp</span>-list <span class="keyword">do</span></span><br><span class="line">    block</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>与以下代码等价：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> _f, _s, _var = <span class="built_in">exp</span>-list</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> var_1, ..., var_n = _f(_s, _var)</span><br><span class="line">        _var = var_1</span><br><span class="line">        <span class="keyword">if</span> var == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        block</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>因此，假设迭代函数为 f，不可变状态为 s，控制变量初始值为 a<sub>0</sub>，那么在循环中控制变量的值依次为 a<sub>1</sub>=f(s,a<sub>0</sub>), a<sub>2</sub>=f(s,a<sub>1</sub>), …，直到 a<sub>i</sub> 为 <code>nil</code>。如果 <code>&lt;var-list&gt;</code> 还有其他变量（var_1、var_2……），那么这些变量只是简单地在每次调用 f 后得到额外的返回值（可以在 <code>block</code> 中使用这些变量）。</p>
<h2 id="无状态迭代器">无状态迭代器 <a class="markdownIt-Anchor" href="#无状态迭代器">#</a></h2>
<dl>
<dt>无状态迭代器（stateless iterator）</dt>
<dd>一种自身不保存任何状态（即闭包所访问的“局部变量”）的选代器。</dd>
</dl>
<p>无状态迭代器只根据不可变状态和控制变量（即其参数）的值来生成下一个元素。
生成无状态迭代器的工厂函数不用为其提供局部变量，一般只需简单地返回迭代器和不可变状态即可。所以可以将无状态迭代器放在工厂外而不是工厂函数的 <code>return</code> 语句中。</p>
<p><code>ipairs</code> 是一个典型的无状态迭代器，可以在 Lua 中这样实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter</span><span class="params">(t, i)</span></span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">local</span> v = t[i]</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> i, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, t, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以下两个等效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> iter,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,<span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>pairs</code> 和 <code>ipairs</code> 类似，不过 <code>pairs</code> 返回的迭代函数是 Lua 中的一个基本函数 <code>next</code>：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairs</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span>, t, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim Syntax</title>
    <url>/2021/03/16/Vim-Syntax/</url>
    <content><![CDATA[<blockquote>
<p>写 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fsb2hhaWEvdmltLWhleG93aWtp">NeoVim 插件<i class="fa fa-external-link-alt"></i></span>过程中，对 Vim 语法高亮的一些总结。</p>
</blockquote>
<span id="more"></span>
<h2 id="优先级">优先级 <a class="markdownIt-Anchor" href="#优先级">#</a></h2>
<ol>
<li>多个 Match 或 Region 的匹配项在相同位置起始时，最后定义的优先。</li>
<li>Keyword 优先级高于 Match 和 Region。</li>
<li>在更靠前的位置起始的匹配项优先。</li>
</ol>
<h2 id="其他">其他 <a class="markdownIt-Anchor" href="#其他">#</a></h2>
<ul>
<li>大小写：<code>:h syn-case</code></li>
<li>折叠深度：<code>:h syn-foldlevel</code></li>
<li>语法检查：<code>:h syn-spell</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syn keyword vimCommand tag</span><br><span class="line">syn keyword vimSetting contained tag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>Vim/NeoVim</category>
      </categories>
      <tags>
        <tag>Vim/NeoVim</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL</title>
    <url>/2021/04/17/OpenGL/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>Computer Graphics</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 学习记录</title>
    <url>/2021/04/28/Vue-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BB%8E%E7%A9%BA%E7%9B%AE%E5%BD%95%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA-electron-%E9%A1%B9%E7%9B%AE">从空目录开始搭建 Electron 项目</a>
<ul>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85">准备工具的安装</a></li>
<li><a href="#%E6%90%AD%E5%BB%BA-electron-%E7%8E%AF%E5%A2%83">搭建 Electron 环境</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85">全局安装</a></li>
<li><a href="#%E4%B8%BA%E6%8C%87%E5%AE%9A%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85">为指定项目安装</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%A7%8B%E9%A1%B9%E7%9B%AE">开始项目</a></li>
</ul>
</li>
</ul>
</p>
<span id="more"></span>
<h2 id="从空目录开始搭建-electron-项目">从空目录开始搭建 Electron 项目 <a class="markdownIt-Anchor" href="#从空目录开始搭建-electron-项目">#</a></h2>
<h3 id="准备工具的安装">准备工具的安装 <a class="markdownIt-Anchor" href="#准备工具的安装">#</a></h3>
<p>安装 npm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy npm</span><br></pre></td></tr></table></figure>
<p>安装 cnpm（可选）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install cnpm -g --registry=https://registry.nlark.com</span><br></pre></td></tr></table></figure>
<p>安装 yarn（可选）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy yarn</span><br></pre></td></tr></table></figure>
<h3 id="搭建-electron-环境">搭建 Electron 环境 <a class="markdownIt-Anchor" href="#搭建-electron-环境">#</a></h3>
<h4 id="全局安装">全局安装 <a class="markdownIt-Anchor" href="#全局安装">#</a></h4>
<p>使用 npm（可用 cnpm 或者 yarn 代替）安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 稳定版</span></span><br><span class="line">npm i -D electron@latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试版</span></span><br><span class="line">npm i -D electron@beta</span><br><span class="line"></span><br><span class="line"><span class="comment"># github 上的最新版</span></span><br><span class="line">npm i -D electron-nightly</span><br></pre></td></tr></table></figure>
<p>使用 Linux 软件包管理器安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru -Sy electron</span><br></pre></td></tr></table></figure>
<h4 id="为指定项目安装">为指定项目安装 <a class="markdownIt-Anchor" href="#为指定项目安装">#</a></h4>
<blockquote>
<p>非必需，但是可以使 LSP server 能提供相应的语法补全。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="开始项目">开始项目 <a class="markdownIt-Anchor" href="#开始项目">#</a></h3>
<p>准备两个基本文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch main.js index.html</span><br></pre></td></tr></table></figure>
<p>初始化 <code>packages.json</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm init --yes</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Computer</category>
        <category>Front end</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>主要组织相容性复合体</title>
    <url>/2021/05/21/%E4%B8%BB%E8%A6%81%E7%BB%84%E7%BB%87%E7%9B%B8%E5%AE%B9%E6%80%A7%E5%A4%8D%E5%90%88%E4%BD%93/</url>
    <content><![CDATA[<dl>
<dt>主要组织相容性复合体（MHC）</dt>
<dd>一组与免疫应答密切相关、决定移植组织是否相容、紧密连锁的基因群。</dd>
</dl>
<p>人类的 MHC 称为 <strong>人类白细胞抗原</strong>。</p>
<span id="more"></span>
<p>HLA 基因复合体分为三个基因区</p>
<p>MHC 基因分两种类型</p>
<ul>
<li>经典 HLA Ⅰ 类基因和 Ⅱ 类基因</li>
<li>免疫功能相关基因
<ul>
<li>血清补体成分的编码基因</li>
<li>抗原加工相关基因</li>
<li>非经典 Ⅰ 类基因</li>
<li>炎症相关基因</li>
</ul>
</li>
</ul>
<p>MHC 遗传特点</p>
<ol>
<li>MHC 多态性</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>医学免疫学</category>
      </categories>
      <tags>
        <tag>医学免疫学</tag>
      </tags>
  </entry>
  <entry>
    <title>人类发育与遗传学</title>
    <url>/2021/04/10/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E4%B8%8E%E9%81%97%E4%BC%A0%E5%AD%A6/</url>
    <content><![CDATA[<blockquote>
<p>人的发育是在一定的环境中依赖其特有的基因型而完成的，涉及<strong>细胞分化</strong>（cell
differentiation）、<strong>形态发生</strong>（morphogenesis）、<strong>生长</strong>（growth）和 <strong>繁殖</strong>（reproduction）。</p>
</blockquote>
<dl>
<dt>遗传学（genetics）</dt>
<dd>研究生物遗传物质及其变化规律的学科。</dd>
<dt>医学遗传学（medical genetics）</dt>
<dd>遗传学与医学结合产生的一门边缘学科。</dd>
<dd>研究疾病发生和发展的遗传机制、遗传方式及其诊治和预防的策略和措施。</dd>
</dl>
<span id="more"></span>
<ol>
<li><a href="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/">人类发育的细胞学和遗传学基础</a></li>
<li><a href="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/">配子的发生与受精</a></li>
<li><a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/">早期胚胎发育</a></li>
<li><a href="/2021/04/10/%E5%99%A8%E5%AE%98%E3%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%85%88%E5%A4%A9%E6%80%A7%E7%95%B8%E5%BD%A2/">器官、系统的发生与先天性畸形</a></li>
<li><a href="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/">生殖内分泌</a></li>
<li><a href="/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/">染色体病</a></li>
<li><a href="/2021/04/28/%E5%8D%95%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/">单基因遗传病</a></li>
<li><a href="/2021/05/07/%E5%88%86%E5%AD%90%E7%97%85%E5%92%8C%E5%85%88%E5%A4%A9%E4%BB%A3%E8%B0%A2%E7%97%85/">分子病和先天代谢病</a></li>
<li><a href="/2021/05/12/%E7%BE%A4%E4%BD%93%E9%81%97%E4%BC%A0%E5%AD%A6/">群体遗传学</a></li>
<li><a href="/2021/05/14/%E5%A4%9A%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/">多基因遗传病</a></li>
</ol>
<p>另见：<a href="/2021/05/26/%E8%83%9A%E8%83%8E%E5%AD%A6/">胚胎学</a>。</p>
<h2 id="遗传病的基本特征和分类">遗传病的基本特征和分类 <a class="markdownIt-Anchor" href="#遗传病的基本特征和分类">#</a></h2>
<dl>
<dt>遗传病（genetic disease）</dt>
<dd>以 <strong>遗传物质</strong> 变化为基本特征的疾病，其发病也不同程度的受 <strong>环境因素</strong> 的影响。</dd>
</dl>
<p>遗传因素作用的大小称为 <strong>遗传度</strong>（见
<a href="/2021/05/14/%E5%A4%9A%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/#遗传度">多基因遗传病</a>）。</p>
<p>理解遗传病应注意下述两种情况：</p>
<ol>
<li><strong>家族性疾病</strong> 不都是遗传病，只是存在家族聚集现象；</li>
<li><strong>先天性疾病</strong>（先天就表型出来的疾病）不都是遗传病，某些遗传病的致病基因是在生命过程中逐渐表达出来的。</li>
</ol>
<p>遗传病的分类</p>
<ol>
<li><a href="/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/">染色体病</a></li>
<li><a href="/2021/04/28/%E5%8D%95%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/">单基因遗传病</a></li>
<li><a href="/2021/04/28/%E5%8D%95%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/#线粒体遗传病">线粒体遗传病</a></li>
<li><a href="/2021/05/14/%E5%A4%9A%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/">多基因遗传病</a></li>
<li>体细胞遗传病</li>
</ol>
<dl>
<dt>体细胞遗传病</dt>
<dd>体细胞中遗传物质改变引发的疾病，如肿瘤。</dd>
<dd>只在特定的体细胞中发生，一般不会遗传给后代。</dd>
</dl>
<h2 id="遗传学重要事件">遗传学重要事件 <a class="markdownIt-Anchor" href="#遗传学重要事件">#</a></h2>
<ol>
<li>孟德尔于 1865 年通过豌豆杂交实验发现了遗传分离律和自由组合律，萸定了近代遗传学基础。</li>
<li>1902 年，Garrod 通过对尿黑酯尿症的研究，提出先天性代谢缺陷的概念。</li>
<li>蒋有兴等于 1956 年证明人类染色体数目为 46 条，这是人类细胞遗传学的开端。</li>
<li>1944 年，Avery 等通过肺炎双球菌转化实验证明了 DNA 是遗传物质。</li>
<li>Watson 和 Crick 于 1953 年确立了 DNA 双螺旋结构，标志着分子遗传学的开端。</li>
<li>1949 年 Pauling 发现镰状细胞病的异常血红蛋白分子，并提出了分子病的概念。</li>
<li>1977 年，Sanger 建立了双脱氧链终止法进行 DNA 测序。</li>
<li>1985 年，Mullis 创立了聚合酶链反应（PCR）进行体外 DNA 扩增。</li>
<li><strong>人类基因组计划</strong>（human genome project，<abbr title="人类基因组计划">HGP</abbr>）于 2003 年公布了人类基因组“完成版”。</li>
</ol>
<p><abbr title="人类基因组计划">HGP</abbr> 的重要事件</p>
<ul>
<li><strong>1990 年</strong> 10 月 1 日，<abbr title="人类基因组计划">HGP</abbr> 正式开始</li>
<li>2000 年 6 月 26 日，六个参与国——美国、法国、德国、日本、中国的科学家共同宣布，人类基因组 <strong>草图</strong> 完成</li>
<li><strong>2003 年</strong> 4 月 14 日，六国政府首脑共同宣告人类基因组序列图完成</li>
</ul>
<p><abbr title="人类基因组计划">HGP</abbr> 的目标：解读人类基因组中的全部基因，将人类基因组中的全部基因和 DNA 序列制成
<strong>遗传图</strong>（genetic map）和 <strong>物理图</strong>（physical map），并完成全部
30 亿碱基的测序任务，制作核苷酸 <strong>序列图</strong>（sequence map）。</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>The TTY Demystified</title>
    <url>/2021/03/15/The-TTY-Demystified/</url>
    <content><![CDATA[<p>原文：<span class="exturl" data-url="aHR0cDovL3d3dy5saW51c2FrZXNzb24ubmV0L3Byb2dyYW1taW5nL3R0eS8=">http://www.linusakesson.net/programming/tty/<i class="fa fa-external-link-alt"></i></span></p>
<p>参考：</p>
<ul>
<li>维基百科</li>
<li>百度百科</li>
<li>《UNIX 环境高级编程 第 3 版·英文版》</li>
</ul>
<p>一些概念：</p>
<dl>
<dt>TTY</dt>
<dd>Teletype 或 Teletypewriter，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，和古老的电报机区别并不是很大。</dd>
</dl>
<span id="more"></span>
<p>一个 getty 的处理过程是：一个程序监视物理的 TTY/终端接口。</p>
<dl>
<dt>PTY/伪终端/终端模拟器</dt>
<dd>成对的逻辑终端设备（即 master 和 slave 设备，对 master 的操作会反映到 slave上）。</dd>
</dl>
<p>它们与实际物理设备并不直接相关。如果一个程序把 ptyp3 ( master 设备）看作是一个串行端口设
备，则它对该端口的读/ 写操作会反映在该逻辑终端设备对应的另一个 ttyp3 ( slave 设备）上面。
而 ttyp3 则是另一个程序用于读写操作的逻辑设备。telnet 主机 A 就是通过“伪终端”与主机 A 的
登录程序进行通信。</p>
<dl>
<dt>控制终端</dt>
<dd>可以使用命令 <code>ps –ax</code> 来查看进程与哪个控制终端相连。</dd>
<dt>UART:</dt>
<dd>Universal Asynchronous Receiver and Transmitter, 通用异步收发器</dd>
<dd>一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。</dd>
<dt>Serial device</dt>
<dd>串行设备</dd>
</dl>
<p>嵌入式设计中，UART用来与PC进行通信，包括与监控调试器和其它器件，如 EEPROM 通信。</p>
<h2 id="the-use-case">The Use Case <a class="markdownIt-Anchor" href="#the-use-case">#</a></h2>
<h3 id="line-editing">Line Editing <a class="markdownIt-Anchor" href="#line-editing">#</a></h3>
<img data-src="/2021/03/15/The-TTY-Demystified/case1.png" class="" title="case1" alt="case1">
<dl>
<dt>Line discipline</dt>
<dd>一个编辑缓冲区和一些基本的编辑命令（退格，擦除单词，清除行，重新打印）</dd>
</dl>
<p>Line discipline 还包含用于字符回显（character echoing）以及回车（carriage return）和换行（linefeed）之间自动转换的选项。如果愿意，可以将其视为原始的内核级 <code>sed(1)</code>（Stream EDitor)</p>
<p>另外，内核提供了数种不同的 line discipline，一次只能将其中之一连接到指定串行设备。默认的 line discipline 提供了 line editing，被称为 <strong>N_TTY</strong>（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvcnZhbGRzL2xpbnV4L2Jsb2IvbWFzdGVyL2RyaXZlcnMvdHR5L25fdHR5LmM=">driver/tty/n_tty.c<i class="fa fa-external-link-alt"></i></span>）。其他则被用于别的目的，如管理分组交换数据（packet switched data）（ppp，IrDA，serial mice）。</p>
<p>高级应用程序（如 Vim）可以通过将线路规则置于 raw mode 而不是默认的 cooked (or canonical) mode 来禁用这些功能。</p>
<p>大多数交互式应用程序（编辑器，邮件用户代理，shell，所有依赖于 curses 或 readline 的程序）以 raw mode 运行，并自行处理所有行编辑命令(line discipline 中提到的退格等)。</p>
<dl>
<dt>curses</dt>
<dd>CRT (Cathode Ray Tube, 阴极射线管) screen handling and optimization package.</dd>
<dd>See <code>man curses</code></dd>
</dl>
<h3 id="session-management">Session Management <a class="markdownIt-Anchor" href="#session-management">#</a></h3>
<p>用户可能希望同时运行多个程序，并一次与一个程序交互。如果程序陷入无尽的循环，则用户可能想杀死（kill）或挂起（suspend）。在后台启动的程序应能够执行，直到它们尝试写入终端为止，此时应将其挂起。同样，用户输入应仅定向到前台程序。操作系统在 <strong>TTY driver</strong> （进程可能会截获某些信号，并尝试适应这种情况，但大多数情况并非如此。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvcnZhbGRzL2xpbnV4L2Jsb2IvbWFzdGVyL2RyaXZlcnMvdHR5L3R0eV9pby5j">driver/tty/tty_io.c<i class="fa fa-external-link-alt"></i></span>）中实现这些功能。</p>
<p>一个操作系统进程是“alive”的（有执行上下文（execution context）），意味着它能进行某些动作。在面对对象的术语中，TTY driver 是一个 <strong>被动对象</strong>（passive object） 。它有一些数据字段和一些方法，但是能做些什么的唯一方式只有通过进程的上下文（context）或内核中断处理程序（kernel interrupt handler）调用。Line discipline 同样也是一个被动对象（entity）。</p>
<p>UART driver、line discipline 实例和 TTY driver 这三者有时会一起被称为一个 <strong>TTY device</strong> ，或者简单地称为 <strong>TTY</strong> 。用户可以通过操作 <code>/dev</code> 目录下对应的设备文件来影响任何 TTY device的行为。由于需要对此设备文件的写入权限，用户在某个特定的 TTY 上登录时，必须成为设备文件的所有者（owner）。这个操作习惯上由以 root 权限运行的 <code>login(1)</code> 程序完成。</p>
<p>之前图片中的 physical line 当然也可以是一根很长的电话线：</p>
<img data-src="/2021/03/15/The-TTY-Demystified/case2.png" class="" title="case2" alt="case2">
<dl>
<dt>Modem</dt>
<dd>Modulator-demodulator，调制解调器，用于计算机的数字信号和可沿电话线传播的脉冲信号之间的相互转换。</dd>
</dl>
<p>这没有多少变化，除了现在系统必须处理调制解调器延迟的情况。</p>
<blockquote>
<p>If the device is a modem, the <code>open</code> may delay inside the device driver until the modem is dialed and the call is answered.</p>
</blockquote>
<p>让我们来研究典型的桌面环境。Linux 控制台（console）是这样运行的：</p>
<img data-src="/2021/03/15/The-TTY-Demystified/case3.png" class="" title="case3" alt="case3">
<p>TTY driver 和 line discipline 和之前例子中表现得一样，但是现在这里没有了 UART 和 physical terminal。取而代之的是一个用软件模拟并渲染成 VGA 显示的 video terminal （a complex state machine including a frame buffer of characters and graphical character attributes（对 OpenGL 有了解的话应该能比较好地理解这句话））。</p>
<dl>
<dt>VGA</dt>
<dd>Video Graphics Array，视频图形阵列，是IBM于1987年提出的一个使用模拟信号的电脑显示标准。</dd>
<dd>这个标准已对于现今的个人电脑市场已经十分过时。现在的个人电脑大多使用 HDMI。</dd>
</dl>
<p>控制台子系统（console subsystem）有些死板。如果我们将终端模拟（terminal emulation）转到用户环境，事情会变得更加复杂。这是 <code>xterm(1)</code> 和其克隆（clone）的工作方式：</p>
<img data-src="/2021/03/15/The-TTY-Demystified/case4.png" class="" title="case4" alt="case4">
<h2 id="processes">Processes <a class="markdownIt-Anchor" href="#processes">#</a></h2>
<p>一个 Linux 进程可能处于以下状态之一：</p>
<img data-src="/2021/03/15/The-TTY-Demystified/linuxprocess.png" class="" title="linuxprocess" alt="linuxprocess">
<ul>
<li>R: 正在运行或可运行（在运行队列中）</li>
<li>D: Uninterruptible sleep (wait for some event)，见下文</li>
<li>S: Interruptible sleep (waiting for some event or signal)，见下文</li>
<li>T: 暂停/挂起，接收到作业控制信号（job control signal）<code>SIGTSTP</code>（比如在终端正在执行命令时按下 Ctrl-z，会将此信号发送给前台进程）时或正在被 debugger 追踪时。</li>
<li>Z: 僵尸进程，已中止但还未被父进程清除（比如父进程调用 <code>popen</code> 函数后没有调用 <code>pclose</code> 函数）。</li>
</ul>
<p>运行 <code>ps l</code> 命令，可以查看哪些进程正在运行，哪些进程在休眠（sleeping）。如果进程正在休眠，<code>WCHAN</code> （”wait channel“，the name of the <em>wait queue</em> ；<code>man ps</code>: address of the kernel function where the process is sleeping）这一列说明了进程正在等待的内核事件（kernel event）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps l</span><br><span class="line">F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND</span><br><span class="line">0   500  5942  5928  15   0  12916  1460 <span class="built_in">wait</span>   Ss   pts/14     0:00 -/bin/bash</span><br><span class="line">0   500 12235  5942  15   0  21004  3572 <span class="built_in">wait</span>   S+   pts/14     0:01 vim index.php</span><br><span class="line">0   500 12580 12235  15   0   8080  1440 <span class="built_in">wait</span>   S+   pts/14     0:00 /bin/bash -c (ps l) &gt;/tmp/v727757/1 2&gt;&amp;1</span><br><span class="line">0   500 12581 12580  15   0   4412   824 -      R+   pts/14     0:00 ps l</span><br></pre></td></tr></table></figure>
<p>其中的“wait” wait queue 对应 system call <code>wait(2)</code>，一旦这些进程的一个子进程的状态改变了，它们就会被移到运行状态。有两种休眠状态：Interruptible sleep 和 uninterruptible sleep。前者（最常见的情况）意味着，即使进程是 wait queue 的一部分，当有信号被发送给它时，它也可能会被移到运行状态。如果你去查看内核源码，你会发现，任何等待事件的代码都必须在<code>schedule()</code> 返回后检查信号是否处于 <em>pending</em> 状态，如果是，则中止 system call 。</p>
<blockquote>
<p><code>man 2 wait</code>: All of these system calls are used to wait for state changes in a child of the calling process, and obtain information about the child whose state has changed. A state  change  is considered to be: the child terminated; the child was stopped by a signal; or the child was resumed by a signal. In the case of a terminated child, performing a wait allows the system to release the resources associated with the child; if a wait is not performed, then the terminated child remains in a “zombie” state.</p>
</blockquote>
<p>在上面的 <code>ps</code> 的显示结果中， <code>STAT</code> 列显示了每个进程现在的状态。一列中可能包含一个或多个属性或标志。</p>
<ul>
<li><code>S</code>: 进程是一个 <a href="#session-leader">session leader</a></li>
<li><code>+</code>: 进程属于一个前台进程组（foreground process group)</li>
</ul>
<h2 id="jobs-and-sessions">Jobs and Sessions <a class="markdownIt-Anchor" href="#jobs-and-sessions">#</a></h2>
<p>作业控制（Job control）发生在你按下 <code>^Z</code> (Ctrl-Z) 来挂起一个程序，或用 <code>&amp;</code> 来启动一个程序时。一个作业（job）和一个进程组（process group）是一样的。Internal shell commands（built-in commands in the shell）如 <code>jobs</code>，<code>fg</code> 和 <code>bg</code>，能用来操作一个 <strong>会话</strong>（session） 中存在的作业。</p>
<p>每个会话都由一个 <strong>session leader</strong> 管理。session leader，一般是 shell，通过信号和 system call 的复杂协议与内核紧密合作。</p>
<p>下面的 Shell 交互……</p>
<img data-src="/2021/03/15/The-TTY-Demystified/jobs_show.png" class="" title="jobs_show" alt="jobs_show">
<p>……对应以下这些进程……</p>
<img data-src="/2021/03/15/The-TTY-Demystified/examplediagram.png" class="" title="examplediagram" alt="examplediagram">
<p>……和这些内核结构体。</p>
<ul>
<li>TTY Driver (<code>/dev/pts/0</code>)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Size: 45x13</span><br><span class="line">Controlling process group: (101)</span><br><span class="line">Foreground process group: (103)</span><br><span class="line">UART configuration (ignored, since this is an xterm):</span><br><span class="line">  Baud rate, parity, word length and much more.</span><br><span class="line">Line discipline configuration:</span><br><span class="line">  cooked/raw mode, linefeed correction,</span><br><span class="line">  meaning of interrupt characters etc.</span><br><span class="line">Line discipline state:</span><br><span class="line">  edit buffer (currently empty),</span><br><span class="line">  cursor position within buffer etc.</span><br></pre></td></tr></table></figure>
<ul>
<li>pipe0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Readable end (connected to PID 104 as file descriptor 0)</span><br><span class="line">Writable end (connected to PID 103 as file descriptor 1)</span><br><span class="line">Buffer</span><br></pre></td></tr></table></figure>
<p>基本思想是每个管道都是一项工作，因为管道中的每个进程都应同时进行操作（停止，恢复，终止）。这就是为什么 <code>kill(2)</code> 允许您将信号发送到整个进程组。默认情况下， <code>fork(2)</code> 将新创建的子进程与其父进程放置在同一进程组中，因此，例如，键盘产生的 <code>^C</code>（Ctrl-c） 会同时影响父子进程。作为其会话负责人职责的一部分，shell 程序每次启动管道（pipeline）时都会创建一个新的进程组。</p>
<p>TTY driver 仅以被动方式跟踪前台进程组 ID。Session leader 必须在必要时显式更新此信息（TTY driver 跟踪的前台进程组 ID）。类似地，TTY driver 跟踪所连接终端的大小（行列数），但是此信息必须由终端模拟器甚至是用户显式更新。</p>
<p>如上图所示，几个进程将它们的标准输入连接到了 <code>/dev/pts/0</code>。但是只有前台作业（<code>ls | sort</code> 管道）将被允许接收来自 TTY 的输入。同样，仅前台作业将被允许写入 TTY 设备（在默认配置情况下）。如果 <code>cat</code> 进程试图写入 TTY，则内核将使用信号将其挂起。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cat &amp;</span><br><span class="line">[1] 170055</span><br><span class="line">[1]  + 170055 suspended (tty input)  cat</span><br></pre></td></tr></table></figure>
<h2 id="signal-madness">Signal Madness <a class="markdownIt-Anchor" href="#signal-madness">#</a></h2>
<p>现在，让我们仔细看看内核中的 TTY driver，line discipline 和 UART driver 如何与用户态进程（userland processes）通信。</p>
<p>UNIX 文件，包括 TTY driver 文件，当然可以通过魔法一般的 <code>ioctl(2)</code> （UNIX 的瑞士军刀）调用来进行读写，并对其进行进一步操作，对此它已经进行了许多与TTY相关的操作定义。不过，<code>ioctl</code> 请求必须从进程启动，因此当内核需要与应用程序异步通信时，不能使用它们。</p>
<p>道格拉斯·亚当斯（Douglas Adams）在《银河系漫游指南》中提到了一个极其沉闷的星球，里面栖息着一群沮丧的人类和某种具有锋利牙齿的的物种，它们通过在大腿上用力地咬人与人类交流。这和内核通过发送“麻痹”或“死亡”信号与进程交流的 UNIX 惊人地相似。进程可能会截获某些信号，并尝试做出回应，但大多数进程不会这样做。</p>
<p>因此，信号是一种粗糙的机制，它允许内核与进程异步通信。UNIX 中的信号不是干净的或通用的。相反，每个信号都是唯一的，必须单独研究。</p>
<p>你可以使用命令 <code>kill -l</code> 查看系统实现的信号。可能是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1）SIGHUP 2）SIGINT 3）SIGQUIT 4）SIGILL</span><br><span class="line"> 5）SIGTRAP 6）SIGABRT 7）SIGBUS 8）SIGFPE</span><br><span class="line"> 9）SIGKILL 10）SIGUSR1 11）SIGSEGV 12）SIGUSR2</span><br><span class="line">13）SIGPIPE 14）SIGALRM 15）SIGTERM 16）SIGSTKFLT</span><br><span class="line">17）SIGCHLD 18）SIGCONT 19）SIGSTOP 20）SIGTSTP</span><br><span class="line">21）SIGTTIN 22）SIGTTOU 23）SIGURG 24）SIGXCPU</span><br><span class="line">25）SIGXFSZ 26）SIGVTALRM 27）SIGPROF 28）SIGWINCH</span><br><span class="line">29）SIGIO 30）SIGPWR 31）SIGSYS 34）SIGRTMIN</span><br><span class="line">35）SIGRTMIN + 1 36）SIGRTMIN + 2 37）SIGRTMIN + 3 38）SIGRTMIN + 4</span><br><span class="line">39）SIGRTMIN + 5 40）SIGRTMIN + 6 41）SIGRTMIN + 7 42）SIGRTMIN + 8</span><br><span class="line">43）SIGRTMIN + 9 44）SIGRTMIN + 10 45）SIGRTMIN + 11 46）SIGRTMIN + 12</span><br><span class="line">47）SIGRTMIN + 13 48）SIGRTMIN + 14 49）SIGRTMIN + 15 50）SIGRTMAX-14</span><br><span class="line">51）SIGRTMAX-13 52）SIGRTMAX-12 53）SIGRTMAX-11 54）SIGRTMAX-10</span><br><span class="line">55）SIGRTMAX-9 56）SIGRTMAX-8 57）SIGRTMAX-7 58）SIGRTMAX-6</span><br><span class="line">59）SIGRTMAX-5 60）SIGRTMAX-4 61）SIGRTMAX-3 62）SIGRTMAX-2</span><br><span class="line">63）SIGRTMAX-1 64）SIGRTMAX</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">kill</span> -l</span><br><span class="line">HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS</span><br></pre></td></tr></table></figure>
<p>如你所见，信号从 1 开始编号。但是，当将它们用于位掩码（例如 <code>ps s</code> 的输出）时，最低有效位对应于信号 1。</p>
<blockquote>
<p>UNIX 中，没有任何一个有效信号的值为 0。</p>
</blockquote>
<p>本文将重点介绍以下信号：<code>SIGHUP</code>，<code>SIGINT</code>，<code>SIGQUIT</code>，<code>SIGPIPE</code>，<code>SIGCHLD</code>，<code>SIGSTOP</code>，<code>SIGCONT</code>，<code>SIGTSTP</code>，<code>SIGTTIN</code>，<code>SIGTTOU</code> 和 <code>SIGWINCH</code>。</p>
<dl>
<dt>SIGHUP</dt>
<dd>默认行为： <strong>Terminate</strong></dd>
<dd>可能行为：Terminate，Ignore，Function call</dd>
<dd>检测到挂起（hangup）的情况时，UART driver 会将 <code>SIGHUP</code> 信号发送到整个会话。这一般会杀掉会话中的所用进程。有些进程。如 <code>nohub(1)</code> 和 <code>screen(1)</code> 会从它们的进程（和 TTY）中分离，所以它们的子进程不会注意到挂起。</dd>
<dt>SIGINT</dt>
<dd>默认行为： <strong>Terminate</strong></dd>
<dd>可能行为：Terminate，Ignore，Function call</dd>
<dd>当交互式注意字符（interactive attention character，通常是 <code>^C</code>，ASCII 码为 3）出现在输入流中时，TTY driver 会将 <code>SIGINT</code> 发送给当前的前台作业，除非此行为被关闭。只要有 TTY device 的访问（access）权限，就能改变交互式注意字符和开关这一特性。另外，session leader (manager) 会跟踪每个作业的 TTY 配置，并在每次切换作业时更新 TTY （配置）。</dd>
<dt>SIGQUIT</dt>
<dd>默认行为： <strong>Core dump</strong></dd>
<dd>可能行为：Core dump，Ignore，Function call</dd>
<dd><code>SIGQUIT</code> 和 <code>SIGINT</code> 的工作方式相似，但是对应字符为 <code>^\</code> 并且默认行为不同。</dd>
<dt>SIGPIPE</dt>
<dd>默认行为： <strong>Terminate</strong></dd>
<dd>可能行为：Terminate，Ignore，Function call</dd>
<dd>内核会将 <code>SIGPIPE</code> 发送给任何〔尝试写入〔没有读取器的管道〕的〕进程。这是很有用的，因为如果没有这个，<code>yes | head</code> 这样的进程将永远不会中止。</dd>
</dl>
<blockquote>
<p><code>yes</code> 不断输出一个字符串，直到被杀死为止。</p>
</blockquote>
<dl>
<dt>SIGCHLD</dt>
<dd>默认行为： <strong>Ignore</strong></dd>
<dd>可能行为：Ignore，Function call</dd>
<dd>当一个进程死亡或改变状态（停止或继续），内核会将一个 <code>SIGCHLD</code> 信号发送给其父进程。<code>SIGCHLD</code> 携带了额外信息，如该进程的 ID，用户 ID，exit status （或 termination signal）和其他 执行时间数据（execution time statistics）。Session leader 借助此信号追踪其作业。</dd>
<dt>SIGSTOP</dt>
<dd>默认行为： <strong>Suspend</strong></dd>
<dd>可能行为：Suspend</dd>
<dd>此信号会无条件地将接受者挂起，也就是说，其行为无法被重新设置。然而，请注意内核不会在作业控制过程中发送 <code>SIGSTOP</code> 信号。作为替代，<code>^Z</code> 通常会触发 <code>SIGTSTP</code>。<code>SIGTSTP</code> 可以被应用程序拦截。应用程序可以将光标移动到屏幕底部，或者将终端置于已知状态（known state），然后使用 <code>SIGSTOP</code> 让自己进入睡眠状态。</dd>
<dt>SIGCONT</dt>
<dd>默认行为： <strong>Wake up</strong></dd>
<dd>可能行为：Wake up，Wake up + Function call</dd>
<dd><code>SIGCONT</code> 会将一个被停止的进程取消挂起（un-suspend）。用户调用 <code>fg</code> 命令时，它会被显式发送给指定进程。</dd>
<dt>SIGTSTP</dt>
<dd>默认行为： <strong>Suspend</strong></dd>
<dd>可能行为：Suspend，Ignore，Function call</dd>
<dd><code>SIGTSTP</code> 的工作方式和 <code>SIGINT</code> 与 <code>SIGQUIT</code> 类似，但是 “magic” 字符一般是 <code>^Z</code> 并且默认行为是挂起进程。</dd>
<dt>SIGTTIN</dt>
<dd>默认行为： <strong>Suspend</strong></dd>
<dd>可能行为：Suspend，Ignore，Function call</dd>
<dd>如果一个后台作业中的进程尝试从 TTY device 读取，TTY 会向整个作业发送 <code>SIGTTIN</code>。这通常会挂起该作业。</dd>
<dt>SIGTTOU</dt>
<dd>默认行为： <strong>Suspend</strong></dd>
<dd>可能行为：Suspend，Ignore，Function call</dd>
<dd>如果一个后台作业中的进程尝试写入到 TTY device，TTY 会向整个作业发送 <code>SIGTOUT</code>。这通常会挂起该作业。可以为单独的 TTY 关闭此功能。</dd>
<dt>SIGWINCH</dt>
<dd>默认行为： <strong>Ignore</strong></dd>
<dd>可能行为：Ignore，Function call</dd>
<dd>如前所述，TTY device 会追踪终端的大小（行列数），但是此信息需要手动更新。每当终端窗口大小改变时，TTY 会发送一个 <code>SIGWINCH</code> 信号给前台作业。行为良好的（well-behaving）交互式应用程序，如编辑器，会对此做出回应——获取新的终端大小并重新绘制自己。</dd>
</dl>
<h2 id="a-example">A Example <a class="markdownIt-Anchor" href="#a-example">#</a></h2>
<p>假设您正在（基于终端的）编辑器（如 Vim）中编辑文件。光标位于屏幕中间的某处，编辑器正忙于执行一些处理器密集型任务（processor intensive task），例如对大文件的搜索和替换操作。现在你按 <code>^Z</code>。由于已将 line discipline 配置为拦截该字符（<code>^Z</code> 是一个字节，ASCII 码为 26），因此你不必等待编辑器完成其任务再开始从 TTY device 读取。取而代之的是，line discipline 子系统立即将 <code>SIGTSTP</code> 发送到前台进程组。该进程组包含编辑器以及由它创建的任何子进程。</p>
<p>编辑器已为 <code>SIGTSTP</code> 安装了信号处理程序（即源代码中对 <code>SIGTSTP</code> 进行拦截并进行处理），因此内核将进程转到执行信号处理程序（signal handler，源码中的一个函数）的代码。该代码通过将相应的控制序列写入 TTY device，将光标移动到屏幕的最后一行。由于编辑器仍在前台，因此将按要求发送控制序列。但是随后，编辑器将 <code>SIGSTOP</code> 发送到其自己的进程组。</p>
<p>编辑器进程现在被挂起了。这件事，包括被挂起的进程的 ID，由内核通过 <code>SIGCHLD</code> 报告给 session leader （一般为 shell）。当前台作业的所有进程都被挂起时，session leader 会从 TTY device 读取当前配置，并将其保存以供以后（恢复被挂起的前台作业时）检索。Session leader 接下来使用 <code>ioctl</code> 调用将自己安装为 TTY 的前台进程组。然后，它会打印 <code>[1]+ Stopped</code> 之类的信息来提示用户有一个作业刚刚被挂起了。</p>
<p>此时，<code>ps(1)</code>（<code>ps l</code>）将告诉你编辑器处于停止状态（T）。如果我们尝试通过使用 shell 内置命令 <code>bg</code> 或使用 <code>kill(1)</code> 将 <code>SIGCONT</code> 发送到进程来唤醒它，则编辑器将开始执行其 <code>SIGCONT</code> 信号处理程序（signal handler）。该信号处理程序可能会通过写入 TTY 设备来尝试重绘编辑器 GUI（其实是 TUI）。但是由于编辑器现在是后台作业，因此 TTY device 将不允许这样（唤醒后台作业）。相反，TTY 会将 <code>SIGTTOU</code> 发送给编辑器，然后再次停止它。这件事将会通过 <code>SIGCHLD</code> 信号传达给 session leader，并且 shell 程序将再次向终端写入 <code>[1]+ Stopped</code> 之类的信息。</p>
<p>然而当我们使用 <code>fg</code> 命令（如 <code>fg %vim</code>）时，shell 首先会恢复原先保存的 line discipline 配置。这告诉 TTY driver 编辑器作业从现在起应该被视为前台作业。最后，shell 会向编辑器进程组发送 <code>SIGCONT</code> 信号。编辑器进程将会尝试重绘其 GUI （其实是 TUI）。因为它现在是前台进程组的一部分，所以这次它不会被 <code>SIGTTOU</code> 信号中断。</p>
<h2 id="flow-control-and-blocking-io">Flow control and blocking I/O <a class="markdownIt-Anchor" href="#flow-control-and-blocking-io">#</a></h2>
<p>（流控制和阻断式 I/O）</p>
<p>在 <code>xterm</code> 中运行 <code>yes</code>，你会看见许多只有一个 “y” 的行从你眼前掠过。自然，<code>yes</code> 生成这些行的速度会比 <code>xterm</code> 应用程序解析它们、更新其帧缓存、与 X server 沟通以滚动屏幕等工作的速度更快。这些程序是怎样协同合作的？</p>
<p>答案就在阻塞式 I/O。伪终端只能在其内核缓冲区中保留一定数量的数据，并且当该缓冲区已满并且 <code>yes</code> 尝试调用 <code>write(2)</code> 时，<code>write(2)</code> 将阻塞（block），将 <code>yes</code> 进程移至 interruptible sleep 状态，其中它会一直保持此状态直到 <code>xterm</code> 进程有机会读取一些缓冲的字节为止。</p>
<p>如果将 TTY 连接到串行端口，会发生相同的情况。<code>yes</code> 将能够以比 9600 波特高得多的速率传输数据，但是如果串行端口被限制为该速度，则内核缓冲区很快就会填满，并且随后所有的 <code>write(2)</code> 调用都会阻塞该进程（如果进程已请求非阻塞式 I/O，则以错误码 <code>EAGAIN</code> 失败）。</p>
<p>如果我告诉您，即使内核缓冲区中有剩余空间，也可以将 TTY 显式置于阻塞状态，会怎么样？除非另行通知（further notice），否则所有尝试将对 TTY <code>write(2)</code> 的进程都会自动阻塞。这种功能的用途是什么？</p>
<p>假设我们正在操作 9600 波特的旧 VT-100 硬件。我们刚刚发送了一个复杂的控制序列，要求终端滚动显示。此时，终端由于某些问题无法进行滚动操作，以致无法以 9600 波特的满速率接收新数据。嗯，实际上，终端 UART 仍以 9600 波特运行，但是终端中没有足够的缓冲区空间来保留所接收字符的积压。这是将 TTY 置于阻塞状态的好时机。但是我们如何从终端上做到这一点呢？</p>
<p>我们已经看到，可以将 TTY 设备配置为对某些数据字节进行特殊处理。例如，在默认配置中，接收到的 <code>^C</code> 字节不会通过 <code>read(2)</code> 传递给应用程序，而是将 <code>SIGINT</code> 传递给前台作业。以类似的方式，可以将 TTY 配置为对 停止流字节（stop flow byte，通常是 <code>^S</code>，ASCII 码为 19） 和 开始流字节（start flow byte，通常是 <code>^Q</code>，ASCII 码为 17）作出反应。旧的终端硬件会自动发送这些字节，并期望操作系统相应地调节其数据流。这称为流控制。</p>
<p>这里有一个重要的区别：对 TTY 的写入操作可能会由于流控制，也可能会由于内核缓冲区空间不足而停止，这会阻塞你的进程，但是因为后台作业尝试写入 TTY 而引发的 <code>SIGTTOU</code> 会挂起整个进程组。我不知道为什么 UNIX 的设计者会发明 <code>SIGTTOU</code> 和 <code>SIGTTIN</code> 而不是依靠阻塞式 I/O，但是我的猜测是负责作业控制的 TTY driver 旨在监控和操控整个作业，而不是其中的单个进程。</p>
<h2 id="configuring-the-tty-device">Configuring the TTY Device <a class="markdownIt-Anchor" href="#configuring-the-tty-device">#</a></h2>
<p>要找出当前 shell 的控制 TTY（controlling terminal）是什么，可以参考前面所述的 <code>ps l</code> 输出中的 TTY 列，或者可以简单地运行 <code>tty(1)</code> 命令。</p>
<p>进程可以使用 <code>ioctl(2)</code> 读取或修改打开的 TTY device 的配置。该 API 在 <code>tty_ioctl(4)</code>（ioctls for terminals and serial lines）中进行了描述。由于它是 Linux 应用程序和内核之间的二进制接口的一部分，因此它将在各 Linux 版本之间保持稳定。但是，该接口是不可移植的，应用程序应该使用 <code>termios(3)</code> 手册页中描述的 POSIX 封装（wrapper）。</p>
<p>我不会详细介绍 <code>termios(3)</code> 接口，但是如果您正在编写 C 程序，并且想在 <code>^C</code> 被转换为 <code>SIGINT</code> 之前对其进行拦截，请禁用行编辑（line editing）和字符回显（character echoing），更改串行端口的波特率，关闭流控制等。然后您将在上述手册页中找到所需的内容。</p>
<p>还有一个命令行工具，称为 <code>stty(1)</code>，用于操纵 TTY 设备。它使用了 <code>termios(3)</code> API。</p>
<p>Let’s try it!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ stty -a</span><br><span class="line">speed 38400 baud; rows 73; columns 238; line = 0;</span><br><span class="line">intr = ^C; quit = ^\; erase = ^?; <span class="built_in">kill</span> = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;</span><br><span class="line">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts</span><br><span class="line">-ignbrk brkint ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany imaxbel -iutf8</span><br><span class="line">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class="line">isig icanon iexten <span class="built_in">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; stty -a</span><br><span class="line">speed 38400 baud; rows 15; columns 92; line = 0;</span><br><span class="line">intr = ^C; quit = ^\; erase = ^?; <span class="built_in">kill</span> = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;</span><br><span class="line">swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;</span><br><span class="line">discard = ^O; min = 1; time = 0;</span><br><span class="line">-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts</span><br><span class="line">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany</span><br><span class="line">-imaxbel iutf8</span><br><span class="line">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class="line">isig icanon iexten <span class="built_in">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br><span class="line">-flusho -extproc</span><br></pre></td></tr></table></figure>
<p>该 <code>-a</code> 标志告诉 <code>stty</code> 显示的 <em>所有</em> 设置。默认情况下，它将查看连接到你的 Shell 的 TTY device，但是你可以使用 <code>-F</code> 指定另一个设备。</p>
<p>其中一些设置取决于 UART 参数，有些会影响 line discipline，有些则与作业控制有关。全部放在一起供君取用。让我们先看一下第一行：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>相关</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>speed</td>
<td>UART</td>
<td>波特率（baud rate）。伪终端无视。</td>
</tr>
<tr>
<td>rows, columns</td>
<td>TTY driver</td>
<td>连接到此 TTY device 的终端的大小（以字符为单位）。基本上，这只是内核空间中的一对变量，你可以自由设置和获取。设置它们将导致 TTY driver 将 <code>SIGWINCH</code> 发送给前台作业。</td>
</tr>
<tr>
<td>line</td>
<td>Line discipline</td>
<td>连接到 TTY 的 line discipline。0 表示 <code>N_TTY</code>，所有的有效数字都在 <code>/proc/tty/ldisc</code> 中被列出。为列出的数字好像是 <code>N_TTY</code> 的别名，但是不要依赖这点。</td>
</tr>
</tbody>
</table>
<p>请尝试以下操作：启动 xterm。记下其 TTY device（由 <code>tty</code> 显示）和
其大小（由 <code>stty -a</code> 显示）。在 xterm 中启动 vim （或其他全屏终端应用程序） 。编辑器向
TTY device 查询当前的终端大小，以填满整个窗口。现在，从另一个 shell 窗口中键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stty -F X rows Y</span><br></pre></td></tr></table></figure>
<p>其中 <em>X</em> 是前面记录的 TTY device， <em>Y</em> 是前面记录的终端高度的一半。这会更新内核内存中的 TTY 数据结构体（TTY data structure），并向编辑器发送 <code>SIGWINCH</code> 信号，该编辑器将仅使用可用窗口区域的上半部分立即重绘自身。</p>
<p><code>stty -a</code> 输出的第二列列出了所有特殊字符。启动一个新的 xterm 并尝试以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stty intr o</span><br></pre></td></tr></table></figure>
<p>现在，<code>o</code> 而不是 <code>^C</code>，会向前台进程发送 <code>SIGINT</code>。尝试启动什么程序，如 <code>cat</code>，并且验证你现在无法用 <code>^C</code> 杀掉它。然后，试着向其中输入 “hello”。</p>
<p>有时，您可能会遇到在 UNIX 系统中退格键不起作用的情况。当终端模拟器发送的退格键（ASCII 码为 8 或 127）与 TTY device 中设置的 <code>erase</code> 不匹配时，就会发生这种情况。要解决此问题，通常可以键入 <code>stty erase ^H</code>（设置为 ASCII 8）或 <code>stty erase ^?</code>（设置为 ASCII 127）。但是请记住，许多终端应用程序都使用 <code>readline</code>，这会将线路规则置于原始模式。这些应用程序不受前面 <code>stty</code> 命令的影响。</p>
<p>最后，<code>stty -a</code> 列出了一堆开关。不出所料，它们没有按特定顺序列出。其中一些与 UART 相关，一些影响 line discipline 的行为，一些用于流控制，一些用于作业控制。破折号（-）表示开关已关闭；否则打开。所有开关都在 <code>stty(1)</code> 手册页中进行了说明，因此，我仅简要介绍其中的一些：</p>
<p><code>icanon</code> 开启或关闭 canonical (line-based) 模式。在新的 xterm 中尝试以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stty -icanon; cat</span><br></pre></td></tr></table></figure>
<p>注意所有的行编辑字符，如退格和 <code>^U</code>，都无法正常使用。另外注意 <code>cat</code> 一次性接收和输出一个字符，而不是（一次性接收和输出）一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; stty -icanon; cat</span><br><span class="line">aassddff^?^?^?^?^?^?^?aassddffaassdd^?^?^?^C</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p><code>echo</code> 启用字符回显，默认开启。重新回到 canonical 模式（<code>stty icanon</code>），然后尝试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stty -<span class="built_in">echo</span>; cat</span><br></pre></td></tr></table></figure>
<p>你输入的同时，终端模拟器将信息发送给内核。通常，内核会显示相同的信息到终端模拟器，使你能够看到你输入了什么。没有字符回显，你看不到你输入了什么，但是我们在 cooked 模式，所以行编辑功能任然能发挥作用。一旦你按下回车键，line discipline 就会将编辑缓冲发送给 <code>cat</code>，这将显示你写入的内容。</p>
<p><code>tostop</code> 控制后台作业是否被允许写入终端。先来试试这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stty tostop; (sleep 5; <span class="built_in">echo</span> hello, world) &amp;</span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 使括号中的命令在后台运行。五秒后，作业中的 <code>cat</code> 尝试写入 TTY。TTY device 会使用 <code>SIGTOUT</code>将其挂起，你的 shell 可能会对此做出报告，可能会是立即，也可能会是在将要发送新的提示符时（这种情况可以按下回车以获得新的提示符）。现在杀死后台进程，尝试以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stty -tostop; (sleep 5; <span class="built_in">echo</span> hello, world) &amp;</span><br></pre></td></tr></table></figure>
<p>你会先得到提示符，但是在五秒后，后台作业在你输入的途中会发送 <code>hello world</code> 到终端。</p>
<p>最后，<code>stty sane</code> 会重置你的 TTY device 到合理的设置（一般为默认设置）。</p>
<h2 id="conclusion">Conclusion <a class="markdownIt-Anchor" href="#conclusion">#</a></h2>
<p>我希望本文为您提供了足够的信息，以使您能够熟悉 TTY drivers 和 line disciplines，以及它们与终端、line editing 和作业控制的关系。可以在我提到的各种手册页以及 glibc 手册（<code>info libc</code> 中的 “Job Control”）中找到更多详细信息。</p>
<p>最后，尽管我没有足够的时间回答所有问题，但我欢迎您对此网站以及本网站其他页面的反馈。
谢谢阅读！</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Projects</category>
        <category>Computer</category>
        <category>uncategorized</category>
        <category>Programming</category>
        <category>自制伪终端</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>TTY</tag>
      </tags>
  </entry>
  <entry>
    <title>人类疱疹病毒</title>
    <url>/2021/05/17/%E4%BA%BA%E7%B1%BB%E7%96%B1%E7%96%B9%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<dl>
<dt>人类疱疹病毒</dt>
<dd>一类中等大小，结构相似的 <strong>DNA 有包膜病毒</strong></dd>
</dl>
<span id="more"></span>
<details class="note info"><summary><p>举例说明 HHV 的感染类型</p>
</summary>
<ol>
<li>显性感染：病毒增殖，破坏细胞，出现症状</li>
<li><strong>潜伏感染</strong>：病毒不增殖，但可被激活</li>
<li>整合感染：病毒转换</li>
<li>先天性感染：可导致先天畸形</li>
</ol>

</details>
<details class="note info"><summary><p>潜伏感染</p>
</summary>

</details>
<h2 id="单纯疱疹病毒">单纯疱疹病毒 <a class="markdownIt-Anchor" href="#单纯疱疹病毒">#</a></h2>
<h3 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h3>
<p>传播途径</p>
<ul>
<li>直接接触、性接触</li>
<li>垂直传播</li>
</ul>
<p>感染类型</p>
<ul>
<li>原发感染</li>
<li>潜伏和再发感染</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
      </tags>
  </entry>
  <entry>
    <title>人胚发生和早期发育</title>
    <url>/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/</url>
    <content><![CDATA[<p>月经周期第 14 天（增生期 → 分泌期）排卵。</p>
<p>人胚发育共经历 38 周（约 266 天）：</p>
<ul>
<li><strong>胚期</strong>：受精卵形成至 8W 末，<strong>人胚早期发生</strong> 即指胚期；</li>
<li><strong>胎期</strong>：9W 至出生。</li>
</ul>
<dl>
<dt>围生期</dt>
<dd>受精龄第 26 周至出生后 4 周。</dd>
</dl>
<p>临床上，围生期的母体、胎儿及新生儿的保健医学称为 <strong>围生医学</strong>。</p>
<span id="more"></span>
<h2 id="生殖细胞和受精">生殖细胞和受精 <a class="markdownIt-Anchor" href="#生殖细胞和受精">#</a></h2>
<p>见 <a href="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/">配子的发生与受精</a>。</p>
<h2 id="卵泡形成与植入">卵泡形成与植入 <a class="markdownIt-Anchor" href="#卵泡形成与植入">#</a></h2>
<h3 id="卵裂和胚泡形成">卵裂和胚泡形成 <a class="markdownIt-Anchor" href="#卵裂和胚泡形成">#</a></h3>
<dl>
<dt>卵裂（cleavage)</dt>
<dd>受精卵形成后，在向子宫方向移动时，同时进行的细胞分裂。</dd>
<dd>此时产生的子细胞称为 <strong>卵裂球</strong>。</dd>
</dl>
<img data-src="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/%E5%8D%B5%E8%A3%82.png" class="" title="卵裂" alt="卵裂">
<dl>
<dt>桑椹胚（morula）</dt>
<dd>受精后约 72h 后，合子分裂形成的一个由 <strong>16</strong> 个卵裂球所组成的圆形实体。</dd>
<dt>胚泡（blastocyst) | 囊胚（blastula）</dt>
<dd>桑椹胚进入子宫腔继续分裂，卵裂球数量达 100 左右时，细胞按一定规律排布，形成 <strong>胚泡</strong>。</dd>
<dd>胚泡由 <strong>滋养层</strong>、<strong>胚泡腔</strong>、<strong>内细胞群</strong> 三部份组成。</dd>
</dl>
<img data-src="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/%E8%83%9A%E6%B3%A1.png" class="" title="胚泡" alt="胚泡">
<h3 id="植入">植入 <a class="markdownIt-Anchor" href="#植入">#</a></h3>
<dl>
<dt>植入（implantation）| 着床（imbed）</dt>
<dd>胚泡逐渐埋入子宫内膜的过程。
<ul>
<li><mark>时间：受精后 5~6 天开始，11~12 天完成</mark>；</li>
<li>部位：子宫体前后壁或子宫底的内膜。</li>
</ul>
</dd>
</dl>
<blockquote>
<p>在《人类发育与遗传学》中，着床仅为植入的第一阶段——<em>胚泡定位、识别、接触、黏附、融合的过程</em>。</p>
</blockquote>
<p>植入条件：</p>
<ol>
<li>受精卵在输卵管中运行正常；</li>
<li>透明带准时消失；</li>
<li>母体性激素分泌正常；</li>
<li>子宫内膜处于分泌期。</li>
</ol>
<h4 id="植入后的滋养层的变化">植入后的滋养层的变化 <a class="markdownIt-Anchor" href="#植入后的滋养层的变化">#</a></h4>
<p>胚泡植入后，滋养层细胞迅速分裂增殖，由单层变为复层，表层和内层细胞分别形成
<strong>合体滋养层</strong> 和 <strong>细胞滋养层</strong>。</p>
<dl>
<dt>合体滋养层（syncytiotrophoblast）</dt>
<dd>表层滋养层，细胞互相融合，界限消失。</dd>
<dt>细胞滋养层（cytotrophoblast）</dt>
<dd>内层滋养层，细胞界限明显。</dd>
</dl>
<img data-src="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/%E6%A4%8D%E5%85%A5%E5%90%8E%E7%9A%84%E6%BB%8B%E5%85%BB%E5%B1%82.png" class="" title="植入后的滋养层" alt="植入后的滋养层">
<p>滋养层细胞增殖迅速。合体滋养层内形成一些小的腔隙，称为
<strong>滋养层陷窝</strong>，内含来自子宫内膜的母体血，可进行物质交换。</p>
<h4 id="植入后的子宫内膜的变化">植入后的子宫内膜的变化 <a class="markdownIt-Anchor" href="#植入后的子宫内膜的变化">#</a></h4>
<dl>
<dt>蜕膜（decidua）</dt>
<dd>是受精卵着床之后，在孕激素作用下，经历增厚和血供增加过程的子宫内膜（的功能层）。</dd>
<dd>蜕膜会在分娩时脱落，故得名。</dd>
</dl>
<p>蜕膜可分为 <strong>底蜕膜</strong>、<strong>包蜕膜</strong>、<strong>壁蜕膜</strong> 三部分。</p>
<img data-src="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/%E8%9C%95%E8%86%9C.png" class="" title="蜕膜" alt="蜕膜">
<dl>
<dt>底蜕膜（decidua basalis）</dt>
<dd>位于胚泡与子宫内膜之间，参与胚盘的形成。</dd>
<dt>包蜕膜（decidua capsularis）</dt>
<dd>覆盖于胚宫腔侧的蜕膜。</dd>
<dt>壁蜕膜（decidua parietalis）</dt>
<dd>子宫其余部分的蜕膜，与包蜕膜围成 <strong>子宫腔</strong>。</dd>
</dl>
<h2 id="胚层的形成">胚层的形成 <a class="markdownIt-Anchor" href="#胚层的形成">#</a></h2>
<h3 id="二胚层胚盘及相关结构的发生">二胚层胚盘及相关结构的发生 <a class="markdownIt-Anchor" href="#二胚层胚盘及相关结构的发生">#</a></h3>
<h4 id="二胚层胚盘的形成">二胚层胚盘的形成 <a class="markdownIt-Anchor" href="#二胚层胚盘的形成">#</a></h4>
<dl>
<dt>二胚层胚盘</dt>
<dd><mark>第 2 周</mark> 胚泡植入过程中，内细胞群增殖分化形成的圆盘状结构。</dd>
<dd>二胚层胚盘由 <strong>下胚层</strong> 和 <strong>上胚层</strong> 组成。</dd>
<dt>下胚层（hypoblast）| 初级内胚层（primitive endoderm）</dt>
<dd>二胚层胚盘中靠近 <strong>胚泡腔</strong> 的一层立方形细胞。</dd>
<dt>上胚层（epiblast）| 初级外胚层（primitive entoderm）</dt>
<dd>二胚层胚盘中靠近 <strong>滋养层</strong> 的一层柱状细胞。</dd>
</dl>
<h4 id="羊膜囊和卵黄囊的形成">羊膜囊和卵黄囊的形成 <a class="markdownIt-Anchor" href="#羊膜囊和卵黄囊的形成">#</a></h4>
<p>在细胞滋养层内面形成一层扁平细胞构成的膜，称
<strong>胚外体腔膜</strong>（exocoelomic membrane），该膜与下胚层相连接，形成
<strong>初级卵黄囊</strong>（primary yolk sac）。</p>
<p>上、下胚层形成的同时，上胚层细胞之间出现了一个小腔，随着小腔不断扩大，一层细胞被推向滋养层，形成滋养层内面的膜，称为 <strong>羊膜</strong>（amniotic membrane）。<br/>
上胚层与 羊膜之间的间隙称为 <strong>羊膜腔</strong>（amniotic cavity），腔内的液体称为 <strong>羊水</strong>。<br/>
羊膜与上胚层共同包绕羊膜腔形成 <strong><mark>羊膜囊</mark></strong>（amniotic cyst）。</p>
<p>另见：<a href="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/?highlight=羊膜#胎盘">胎盘</a>。</p>
<p>第二周末，下胚层周缘细胞向下生长，形成一个由立方上皮细胞围成的囊，称为
<strong><mark>次级卵黄囊</mark></strong>（secondary yolk sac）。<br/>
由胚外体腔膜构成的初级卵黄囊逐渐退化。</p>
<h4 id="胚外中胚层和胚外体腔的形成">胚外中胚层和胚外体腔的形成 <a class="markdownIt-Anchor" href="#胚外中胚层和胚外体腔的形成">#</a></h4>
<p>在羊膜囊和卵黄囊形成的同时，胚泡腔中出现了一些疏松排列的星状细胞和细胞外基质，分布于细胞滋养层和羊膜、卵黄囊之间，称为 <strong><mark>胚外中胚层</mark></strong>（extra-embryonic mesoderm）。</p>
<p>胚外中胚层内会出现一些小的腔隙，并逐渐融合成一个大腔，称为 <strong><mark>胚外体腔</mark></strong>。</p>
<img data-src="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/%E8%83%9A%E5%A4%96%E4%B8%AD%E8%83%9A%E5%B1%82%E5%92%8C%E8%83%9A%E5%A4%96%E4%BD%93%E8%85%94%E7%9A%84%E5%BD%A2%E6%88%90.png" class="" title="胚外中胚层和胚外体腔的形成" alt="胚外中胚层和胚外体腔的形成">
<dl>
<dt>体蒂（body stalk）</dt>
<dd>胚外中胚层持续扩大，仅有的少部分连接 <em>胚盘尾端</em> 和滋养层的胚外中胚层，将来演变为 <a href="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/?highlight=脐带#脐带"><strong>脐带</strong></a>。</dd>
</dl>
<h3 id="三胚层胚盘及相关结构的发生">三胚层胚盘及相关结构的发生 <a class="markdownIt-Anchor" href="#三胚层胚盘及相关结构的发生">#</a></h3>
<dl>
<dt>原条（primitive streak）</dt>
<dd>在 <mark>第 3 周</mark> 初，胚盘部分 <mark>上胚层</mark> 细胞增殖迅速，并由两侧向中间迁移，形成的一条细胞增厚区。</dd>
</dl>
<details class="note info"><summary><p>原条和畸形瘤</p>
</summary>
<p>第 4 周原条退化消失，若残留则可形成畸形瘤。</p>

</details>
<p>原条位置和朝向：原条所在的一端为胚体的尾端（泄殖腔膜，<a href="#%E8%83%9A%E5%A4%96%E4%B8%AD%E8%83%9A%E5%B1%82%E5%92%8C%E8%83%9A%E5%A4%96%E4%BD%93%E8%85%94%E7%9A%84%E5%BD%A2%E6%88%90">体蒂</a>），前为胚体的头端（口咽膜）。</p>
<dl>
<dt>原结（primitive node）</dt>
<dd>原条头部的细胞增殖较快，形成的结节状肥后区。</dd>
<dt>原沟（primitive groove）</dt>
<dd>原条细胞增殖并向深处迁移形成的沟状凹陷。</dd>
</dl>
<hr />
<p>原条细胞增殖、分化、扩散形成了 <strong>三胚层胚盘</strong>。</p>
<div class="note warning"><p>三胚层胚盘的三个胚层均起源于 <strong>上胚层</strong>。</p>
</div>
<dl>
<dt>内胚层（endoderm）</dt>
<dd>原沟底部部分细胞进入下胚层，并逐渐置换了下胚层细胞，形成内胚层。</dd>
<dt>中胚层（mesoderm）| 胚内中胚层（intraembryonic mesoderm）</dt>
<dd>上胚层迁出的另一部分细胞在上下胚层之间形成的一夹层。</dd>
<dt>外胚层（ectoderm）</dt>
<dd>原来的上胚层的改称。</dd>
</dl>
<hr />
<dl>
<dt>原凹（primitive pit）</dt>
<dd><strong>原结</strong> 中心的凹陷。</dd>
<dt>脊索（notochord）</dt>
<dd><strong>原凹</strong> 处细胞向下增殖，并向头端增生迁移，在内、外胚层之间形成的一细胞索。</dd>
</dl>
<p>脊索在胚胎早期起 <strong>支持作用</strong>，以后逐渐退化，最终形成椎间盘中央的 <strong>髓核</strong>。</p>
<hr />
<h2 id="三胚层分化和胚体形成">三胚层分化和胚体形成 <a class="markdownIt-Anchor" href="#三胚层分化和胚体形成">#</a></h2>
<h3 id="三胚层分化">三胚层分化 <a class="markdownIt-Anchor" href="#三胚层分化">#</a></h3>
<h4 id="外胚层的分化">外胚层的分化 <a class="markdownIt-Anchor" href="#外胚层的分化">#</a></h4>
<h5 id="神经管的形成和分化">神经管的形成和分化 <a class="markdownIt-Anchor" href="#神经管的形成和分化">#</a></h5>
<dl>
<dt>神经板（neural plate）</dt>
<dd>在脊索的诱导下，沿着脊索背部的外胚层（此时也称 <strong>神经外胚层</strong>）细胞增厚形成的细胞板。</dd>
</dl>
<p>神经板中央凹陷，称 <strong>神经沟</strong>（neural groove）；<br/>
沟两侧部分隆起，称 <strong>神经褶</strong>（neural fold）。</p>
<dl>
<dt>神经管（neural tube）</dt>
<dd>第 3 周末，<strong>神经沟</strong> 加深，<strong>神经褶</strong> 愈合（神经板边缘融合）形成神经管。</dd>
</dl>
<p><strong>神经管分化</strong>：神经管是 <strong>中枢神经系统</strong>（脑、脊髓）的原基，神经管还可以分化为松果体、神经垂体和视网膜等。</p>
<dl>
<dt>前神经孔（anterior neuropore）、后神经管（posterior neuropore）</dt>
<dd>神经管头端和尾端的孔。</dd>
</dl>
<p>前、后神经孔分别在约第 25、27 天闭合。未闭合会分别导致 <strong>无脑儿</strong> 和 <strong>脊髓脊柱裂</strong>。</p>
<h5 id="神经嵴的形成和分化">神经嵴的形成和分化 <a class="markdownIt-Anchor" href="#神经嵴的形成和分化">#</a></h5>
<dl>
<dt>神经嵴（neural crest）</dt>
<dd><strong>神经板缘</strong>（neural plate border）的一些细胞在神经管过程中迁移到其背侧，最终分裂成两条，位于神经管背外侧，称为神经嵴。</dd>
</dl>
<p><strong>神经嵴分化</strong>：<strong>周围神经系统</strong>（脑神经节、脊神经节及周围神经节）的原基，还可以分化为肾上腺髓质和某些 APUD 细胞。</p>
<h5 id="表面外胚层的分化">表面外胚层的分化 <a class="markdownIt-Anchor" href="#表面外胚层的分化">#</a></h5>
<ul>
<li><strong>表皮及其附属器</strong></li>
<li>牙釉质</li>
<li>角膜上皮、晶状体</li>
<li>内耳迷路</li>
<li>……</li>
</ul>
<h4 id="中胚层的分化">中胚层的分化 <a class="markdownIt-Anchor" href="#中胚层的分化">#</a></h4>
<p>脊索两侧中胚层细胞增殖快，由内向外分为：</p>
<dl>
<dt>轴旁中胚层（paraxial mesoderm）</dt>
<dd>邻近脊索两侧的中胚层迅速增殖形成的一对纵行细胞索。</dd>
<dt>间介中胚层（intermediate mesoderm）</dt>
<dd>轴旁中胚层和侧中胚层之间的狭长区域，是泌尿生殖系统的原基。</dd>
<dt>侧中胚层（lateral mesoderm）| 侧板中胚层（lateral plate mesoderm）</dt>
<dd>初为单一薄层结构，后出现间隙，称为 <strong>胚内体腔</strong>（intraembryonic coelom），由此被分为与外胚层相贴的 <strong>体壁中胚层</strong>（somatic mesoderm）和与内胚层相贴的 <strong>脏壁中胚层</strong>（splanchnic mesoderm）。</dd>
</dl>
<img data-src="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/%E4%B8%AD%E8%83%9A%E5%B1%82.png" class="" title="中胚层" alt="中胚层">
<dl>
<dt>间充质（mesenchyme）</dt>
<dd>散在的中胚层细胞，称<strong>间充质</strong>，分化为结缔组织、血管、肌组织。</dd>
</dl>
<p><strong>中胚层三部分的分化</strong>：</p>
<ul>
<li><strong>轴旁中胚层</strong> → <strong>体节</strong> → 脊柱、背部皮肤真皮和骨骼肌</li>
<li><strong>间介中胚层</strong>：<strong>泌尿生殖系统的原基</strong></li>
<li><strong>侧中胚层</strong> →
<ul>
<li><strong>胚内体腔</strong> → 心包腔、胸膜腔、腹膜腔</li>
<li><strong>体壁中胚层</strong> → 浆膜壁层、体壁肌肉、骨骼</li>
<li><strong>脏壁中胚层</strong> → 浆膜脏层、内脏平滑肌与结缔组织</li>
</ul>
</li>
</ul>
<h4 id="内胚层的分化">内胚层的分化 <a class="markdownIt-Anchor" href="#内胚层的分化">#</a></h4>
<p>卵黄囊顶壁的内胚层被卷入胚体内形成 <strong>原始消化管</strong>（primitive gut）。<br/>
原始消化管分为 <strong>前肠</strong>（foregut）、<strong>中肠</strong>（midgut） 和 <strong>后肠</strong>（hindgut）。前肠头端和后肠末端分别由口咽膜和泄殖腔膜封闭（见 <a href="#%E4%B8%89%E8%83%9A%E5%B1%82%E8%83%9A%E7%9B%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%91%E7%94%9F">三胚层胚盘及相关结构的发生</a>）。</p>
<p><strong>内胚层的分化</strong>：</p>
<ul>
<li><strong>消化管消化腺</strong></li>
<li>呼吸道和肺的上皮</li>
<li>中耳、甲状腺、胸腺等的上皮</li>
</ul>
<h3 id="胚体形成">胚体形成 <a class="markdownIt-Anchor" href="#胚体形成">#</a></h3>
<p>早期胚盘呈扁平盘状，第四周初，由于体节、神经管生长迅速，胚盘中部生长生长速度较周缘快，导致胚盘向羊膜腔中隆起。</p>
<dl>
<dt>头褶（head fold）、尾褶（tail fold）、侧褶（lateral fold）</dt>
<dd>胚盘周缘头端、尾端、两侧缘的卷褶。</dd>
</dl>
<p>随着胚的生长，头褶、尾褶和侧褶逐渐加深，胚盘由圆盘状变为圆柱状的 <strong>胚体</strong>。第四周末，胚体呈”C“字形。</p>
<p>第 5~8 周称为 <strong>器官发生期</strong>（organogenetic period）此时期胚体外形发生明显变化，至第 8
周时初具人形，主要器官、系统在此时期形成。</p>
<h2 id="胚胎龄的推算">胚胎龄的推算 <a class="markdownIt-Anchor" href="#胚胎龄的推算">#</a></h2>
<dl>
<dt>受精龄</dt>
<dd>从受精到胎儿出生，约 38 周，包括 <strong>胚期</strong> 和 <strong>胎期</strong>。</dd>
<dt>月经龄</dt>
<dd>从末次月经到婴儿出生，约 40 周。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
        <category>组织学与胚胎学</category>
        <category>胚胎学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
        <tag>组织学与胚胎学</tag>
        <tag>胚胎学</tag>
      </tags>
  </entry>
  <entry>
    <title>人类发育的细胞学和遗传学基础</title>
    <url>/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>细胞增殖，遗传物质和遗传信息的传递以及一些基因分析技术。</p>
<span id="more"></span>
<p>另见 <a href="/2021/05/19/%E7%BB%86%E8%83%9E%E7%94%9F%E7%89%A9%E5%AD%A6/">细胞生物学</a>。</p>
<h2 id="真核细胞和基因组">真核细胞和基因组 <a class="markdownIt-Anchor" href="#真核细胞和基因组">#</a></h2>
<dl>
<dt>核仁（nucleolus）</dt>
<dd>核糖体 RNA（rRNA）合成和加工的部位，由细丝、颗粒和相随染色体组成。</dd>
<dt>核仁组织区（Nucleolus organizer region, NOR）</dt>
<dd>真核生物 DNA 上能参与核仁形成的区域。</dd>
</dl>
<blockquote>
<p>研究表明，核仁组织区上的 DNA 序列主要由反复出现的 rDNA 基因簇组成。
在核仁存在时，核仁组织区的 DNA 因为转录活动频繁，DNA 压缩比低，会形成一串串如同“圣诞树”的结构。
人的 13、14、15、21 和 22 号染色体上存在核仁组织区。<br/>
核仁组织区多数位于相关染色体的 <strong>次缢痕</strong> 区，一部分核仁组织区的 DNA 会形成染色体上的随体。<br/></p>
</blockquote>
<blockquote>
<p>大肠杆菌的 rDNA 操纵子也会聚集在一起，形成类似于核仁的结构。</p>
</blockquote>
<h2 id="人类染色体">人类染色体 <a class="markdownIt-Anchor" href="#人类染色体">#</a></h2>
<blockquote>
<p>染色体和染色质是同一遗传物质在细胞间期和分裂期的两种不同形态。</p>
</blockquote>
<p>在 <strong>间期</strong> 细胞中，染色质可分为 <strong>常染色质</strong> 和 <strong>异染色质</strong>。</p>
<dl>
<dt>常染色质（euchromatin）</dt>
<dd>染色质的主要成分，染色较浅，是细胞间期处于解螺旋状态的、具有转录活性的染色质。</dd>
</dl>
<p>处于表达状态的基因一定处于常染色质中。</p>
<dl>
<dt>异染色质（heterochromatin）</dt>
<dd>染色很深、折叠致密，是呈凝缩状态的、很少进行转录或无转录活性的染色质。</dd>
</dl>
<p>在间期细胞中，异染色质呈簇分布在细胞核周围，分为 <strong>组成型异染色质</strong> 和 <strong>功能型异染色质</strong>。</p>
<dl>
<dt>组成型异染色质（constitutive heterochromatin）</dt>
<dd>在各种细胞中总是处于凝缩状态，没有转录活性，常见于染色体的固定位置，如着丝粒、端粒和 <strong>核仁组织区</strong>。</dd>
<dt>功能型异染色质（functional heterochromatin）| 兼性染色质（facultative heterochromatin）</dt>
<dd>在特定的细胞或个体发育到一定阶段，由常染色质凝缩转变而形成，当它处于疏松状态时，又转变为常染色质，如 <strong>X 染色质</strong>。</dd>
<dt>X 染色质（X-chromatin）| Barr 小体</dt>
<dd>正常女性间期细胞核膜内院的一个染色较深、呈椭圆形、直径约 1μm 大小的小体。</dd>
</dl>
<p>女性细胞内的 X 染色体只有一条处于活性状态（异染色质）其余的均处于凝缩状态（兼性染色质），所以：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mrow><mi>B</mi><mi>a</mi><mi>r</mi><mi>r</mi></mrow></msub><mo>=</mo><msub><mi>N</mi><mi>X</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N_{Barr}=N_{X}-1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<dl>
<dt>Y 染色质</dt>
<dd>正常男性细胞的间期细胞用荧光染料染色后，在细胞核内显示的一个圆形或椭圆形、直径约
0.3 μm 的强荧光小体。</dd>
</dl>
<h2 id="基因组和基因">基因组和基因 <a class="markdownIt-Anchor" href="#基因组和基因">#</a></h2>
<dl>
<dt>基因组（genome）</dt>
<dd>细胞全部基因 DNA 序列和非基因 DNA 序列的总和，即人体所有遗传信息的总和。</dd>
<dd>人类（动物细胞的基因组包括 <strong>核基因组</strong> 和 <strong>线粒体基因组</strong>。</dd>
<dt>线粒体基因组（mitochondrial genome）</dt>
<dd>环状封闭的双链 DNA 分子，外环是重链，内环是轻链，总共有 <strong>37 个基因</strong>，其中有
<strong>13 个编码多肽基因</strong>。</dd>
<dt>核基因组（nuclear genome）</dt>
<dd>由分布于 24 条不同染色体（22 对常染色体和 X、Y 染色体）上的线性 DNA 分子组成，包含 <strong>30 亿个碱基对</strong>，包含 <strong>20,000~25,000 个基因</strong>。</dd>
</dl>
<h3 id="dna-结构和-dna-序列">DNA 结构和 DNA 序列 <a class="markdownIt-Anchor" href="#dna-结构和-dna-序列">#</a></h3>
<p>TODO: 细胞生物学 - 大沟</p>
<p><strong>DNA 基本结构的生理学意义</strong></p>
<ol>
<li>DNA 分子的碱基排列顺序储存大量 <strong>遗传信息</strong>；</li>
<li>DNA 分子的双螺旋碱基互补结构是 <strong>DNA 复制和修复</strong> 的基础；</li>
<li>双螺旋结构形成的 <strong>大沟</strong> 是 <strong>DNA 与蛋白质相互作用</strong> 的结构条件；</li>
<li>DNA 双螺旋的碱基互补性是 <strong>DNA 分析技术</strong> 的基础。</li>
</ol>
<h4 id="基因组-dna-的基本类型">基因组 DNA 的基本类型 <a class="markdownIt-Anchor" href="#基因组-dna-的基本类型">#</a></h4>
<h5 id="基因序列和非基因序列">基因序列和非基因序列 <a class="markdownIt-Anchor" href="#基因序列和非基因序列">#</a></h5>
<dl>
<dt>基因序列</dt>
<dd>基因组中决定蛋白质的 DNA 序列，起始于起始密码子 ATG，终止于终止密码子。</dd>
</dl>
<p>基因序列的定义与 <strong>可读框</strong>（open reading frame，ORF）相同，即一个 ORF 相当于一个基因。</p>
<h5 id="编码序列和非编码序列">编码序列和非编码序列 <a class="markdownIt-Anchor" href="#编码序列和非编码序列">#</a></h5>
<dl>
<dt>编码序列</dt>
<dd>编码 RNA 和蛋白质的 DNA 序列，即基因序列中的外显子。</dd>
</dl>
<h5 id="单一序列和重复序列">单一序列和重复序列 <a class="markdownIt-Anchor" href="#单一序列和重复序列">#</a></h5>
<dl>
<dt>单一序列（unique sequence）</dt>
<dd>只在基因组中重复一次或少数几次的 DNA 序列，约占基因组的 45%。</dd>
</dl>
<hr />
<dl>
<dt>重复序列（repetitive sequence）</dt>
<dd>在基因组中重复出现的 DNA 序列，约占基因组的 55%，主要为非编码序列，但
<a href="#%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F%E5%92%8C%E5%81%87%E5%9F%BA%E5%9B%A0"><strong>基因家族</strong></a> 也包含在其中。</dd>
</dl>
<p>根据 DNA 在基因组中的重复频率不同，重复序列可分为 <strong>轻度、中度和重度重复序列</strong>；<br/>
根据 DNA 序列在基因组中的分布形式的不同，重复序列又可以分为 <strong>串联重复序列</strong> 和 <strong>散在重复序列</strong>。</p>
<dl>
<dt>串联重复序列（tandem repetitive sequence）</dt>
<dd>不同数目大氨基酸重复拷贝串联在一起，一般为高度重复序列。</dd>
<dd>主要包括 <strong>卫星 DNA</strong> 和 <strong>倒位重复序列</strong>。</dd>
<dt>卫星 DNA（satellite DNA）</dt>
<dd>DNA 在氯化铯密度梯度离心中，DNA 主峰旁形成小的卫星 DNA 峰，其 GC 含量较少。</dd>
<dd>2~6 个核苷酸单元重复组成的，称为 <strong>微卫星 DNA</strong>，6~25
个核苷酸单元重复组成的，则称为 <strong>小卫星 DNA</strong>。</dd>
</dl>
<p>卫星 DNA 序列在人类基因组中表现为 <strong>多态性</strong>，可作为遗传学研究的
<strong>遗传标记</strong>，卫星 DNA 还与某些疾病有关。</p>
<dl>
<dt>倒位重复序列/反向重复序列（inverted repetitive sequence）</dt>
<dd>两个序列相同的互补拷贝在同一条 DNA 链上反向排列而成。</dd>
</dl>
<p>倒位重复序列的两个互补拷贝共价连接，形成”发夹“结构（见下图<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>），可以构成终止子。<br/>
如果两个互补序列中间没有间隔序列，则称为 <strong>回文结构</strong>（palindrome）。</p>
<img data-src="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/DNA%20palindrome.svg" class="" title="DNA palindrome" alt="DNA palindrome">
<dl>
<dt>散在重复序列（interspersed repetitive sequence）</dt>
<dd>分布于基因组内散在的重复序列，一般为中度重复序列。</dd>
</dl>
<h3 id="基因家族和假基因">基因家族和假基因 <a class="markdownIt-Anchor" href="#基因家族和假基因">#</a></h3>
<dl>
<dt>基因家族（gene family）</dt>
<dd>某些来源相同、结构相似和功能相关的一组基因。</dd>
</dl>
<p>基因家族通常是由一个祖先基因经过多次重复和变异后形成的，既可以呈簇地分布于一条或几条染色体，形成 <strong>基因簇</strong>（gene cluster），也可以散在地分布于不同的染色体上。</p>
<dl>
<dt>假基因（pseudogene）</dt>
<dd>基因家族中的某些成员具有部分基因结构，但不能表达活性产生蛋白。</dd>
</dl>
<h3 id="断裂基因的基本结构">断裂基因的基本结构 <a class="markdownIt-Anchor" href="#断裂基因的基本结构">#</a></h3>
<dl>
<dt><strong>基因</strong>（gene）</dt>
<dd>具有功能的 DNA 片段。</dd>
<dt>断裂基因（split gene）</dt>
<dd>人类 DNA 片段由 <strong>编码序列</strong> 和 <strong>非编码序列</strong> 组成，非编码序列将编码序列隔开，因此称为断裂基因。</dd>
</dl>
<p>人类的结构基因主要由 <strong>外显子</strong>、<strong>内含子</strong> 和 <strong>侧翼序列</strong> 组成。</p>
<h4 id="外显子">外显子 <a class="markdownIt-Anchor" href="#外显子">#</a></h4>
<dl>
<dt>外显子（exon）</dt>
<dd>基因内的编码序列。</dd>
</dl>
<h4 id="内含子">内含子 <a class="markdownIt-Anchor" href="#内含子">#</a></h4>
<dl>
<dt>内含子（intron）</dt>
<dd>基因内的非编码序列。</dd>
</dl>
<h4 id="侧翼序列">侧翼序列 <a class="markdownIt-Anchor" href="#侧翼序列">#</a></h4>
<dl>
<dt>侧翼序列（flanking sequence）</dt>
<dd>每个基因的 5’ 端和 3’ 端都有的一段不转录的非编码区。</dd>
<dd>包括 5‘ 端的启动子、增强子及 3’ 端的终止子等。</dd>
</dl>
<details class="note info"><summary><p>GT-AG 法则</p>
</summary>
<p>每个内含子的 5’ 端开始的两个核苷酸都是 GT，3’ 端末尾的两个核苷酸都是 AG，是 RNA <strong>剪接</strong> 的信号。</p>

</details>
<h5 id="启动子">启动子 <a class="markdownIt-Anchor" href="#启动子">#</a></h5>
<dl>
<dt>启动子（promoter）</dt>
<dd>位于转录起始点上游 100~200bp 内，为 <strong>RNA 聚合酶</strong> 结合部位，启动基因转录。</dd>
<dt>TATA 框（TATA box）</dt>
<dd>位于转录起始点上游 25~30bp，由 TAT(A/T)A(A/T)A 七个碱基组成，与转录因子 TFII 结合，精确定位转录起始。</dd>
<dt>GAAT 框（GAAT box）</dt>
<dd>位于转录起始点上游 75~80bp，由 GG(C/T)CAATCT 九个碱基组成，与转录因子 CTF 结合，高效转录所必须。</dd>
<dt>GC 框（GC box）</dt>
<dd>位于 CAAT 框的两侧，序列为 GGGCGG，与转录因子 SP1 结合激活转录。</dd>
</dl>
<h5 id="增强子">增强子 <a class="markdownIt-Anchor" href="#增强子">#</a></h5>
<dl>
<dt>增强子（enhancer）</dt>
<dd>一般包括 <strong>启动子</strong> 上、下游的一段 DNA 序列，能显著提高基因的转录效率。</dd>
</dl>
<p>增强子作用不受距离变化的影响，作用方向可以是 5’→3’，也可以是 3’→5’，具有
<strong>组织特异性</strong>，与基因的选择性表达有关。</p>
<h5 id="增强子-2">增强子 <a class="markdownIt-Anchor" href="#增强子-2">#</a></h5>
<dl>
<dt>终止子（terminator）</dt>
<dd>由一段 <strong>回文序列</strong>（转录中止信号）和 5’-AATAAA-3’（加尾信号）序列组成。</dd>
</dl>
<h3 id="基因的表达与调控">基因的表达与调控 <a class="markdownIt-Anchor" href="#基因的表达与调控">#</a></h3>
<h4 id="基因表达">基因表达 <a class="markdownIt-Anchor" href="#基因表达">#</a></h4>
<p><strong>基因表达</strong> 即基因的 <strong>转录</strong> 和 <strong>翻译</strong>。</p>
<h4 id="基因表达调控">基因表达调控 <a class="markdownIt-Anchor" href="#基因表达调控">#</a></h4>
<h5 id="转录前调控">转录前调控 <a class="markdownIt-Anchor" href="#转录前调控">#</a></h5>
<h5 id="转录调控">转录调控 <a class="markdownIt-Anchor" href="#转录调控">#</a></h5>
<p><strong>转录调控</strong> 主要通过 <strong>顺式作用元件</strong> 和 <strong>转录因子</strong> 之间的相互作用来实现。</p>
<dl>
<dt>转录因子（transcription factor）| 反式作用元件（<em>trans</em>-acting element）</dt>
<dd>能与目的基因调控序列中 <strong>顺式作用元件</strong> 相结合调节基因表达的 <strong>蛋白质</strong>。</dd>
<dd>有 <strong>激活因子</strong>（activator）、<strong>抑制因子</strong>（repressor）。</dd>
<dt>顺式作用元件（<em>cis</em>-acting element）</dt>
<dd>基因中能与转录因子特异性结合，调节基因转录的保守序列。</dd>
<dd>包括 <a href="#%E5%90%AF%E5%8A%A8%E5%AD%90"><strong>启动子</strong></a>、<a href="#%E5%A2%9E%E5%BC%BA%E5%AD%90"><strong>增强子</strong></a>、<strong>沉默子</strong> 和
<strong>绝缘子</strong>（insulator）（见下图<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>）。</dd>
</dl>
<img data-src="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/insulator.svg" class="" title="绝缘子" alt="绝缘子">
<dl>
<dt>沉默子（silencer）</dt>
<dd>一段能够结合阻遏蛋白（一种抑制因子）的 DNA 序列。</dd>
<dd>一般位于上游 20~2000bp 不等，还可以位于启动子的下游、基因本身的内含子或外显子上。</dd>
</dl>
<h5 id="转录后调控">转录后调控 <a class="markdownIt-Anchor" href="#转录后调控">#</a></h5>
<p><mark>mRNA 的成熟加工</mark> 即 mRNA 前体（核内异质 RNA，<abbr title="mRNA 前体 / 核内异质 RNA">hnRNA</abbr>）加工成有功能的成熟 mRNA
的过程，包括 <strong>加帽</strong>、<strong>剪接</strong>、<strong>加尾</strong>/<strong>多聚腺苷酸化</strong>（polyadenylation）三步。<br/>
剪接是最关键的一步，指根据 GT-AG 法则（见 <a href="#%E4%BE%A7%E7%BF%BC%E5%BA%8F%E5%88%97">侧翼序列</a>）将 <abbr title="mRNA 前体 / 核内异质 RNA">hnRNA</abbr>
中的内含子剪切掉，把外显子拼接起来。</p>
<dl>
<dt>RNA 编辑（RNA editing）</dt>
<dd>mRNA 转录后在编码酶的作用下，因插入、缺失或核苷酸的替换，改变了来自 DNA 的遗传信息。</dd>
<dd>如人载脂蛋白基因 APOB 在肝脏中编码 apoB100，在长中编码 apoB48，少见于哺乳动物。</dd>
</dl>
<h5 id="翻译调控">翻译调控 <a class="markdownIt-Anchor" href="#翻译调控">#</a></h5>
<h5 id="翻译后调控">翻译后调控 <a class="markdownIt-Anchor" href="#翻译后调控">#</a></h5>
<h5 id="表观遗传调控">表观遗传调控 <a class="markdownIt-Anchor" href="#表观遗传调控">#</a></h5>
<dl>
<dt>表观遗传调控</dt>
<dd>有丝分裂和/或减数分裂中 <em>可遗传</em> 的基因功能改变，<em>不涉及 DNA 序列的改变</em>。
<ol>
<li>DNA 甲基化</li>
<li>组蛋白修饰</li>
<li>染色质重塑</li>
<li>非编码 RNA 调控</li>
</ol>
</dd>
<dt>DNA 甲基化（DNA methylation）</dt>
<dd>CpG 二核苷酸的胞嘧啶（C）共价结合一个甲基基团，一般会抑制转录。</dd>
<dt>组蛋白修饰（histone modification）</dt>
<dd><strong>乙酰化</strong>（激活转录）、<em>甲基化</em>、磷酸化、泛素化。</dd>
<dt>染色质重塑（chromatin remodeling）</dt>
<dd>所有能使染色质发生功能性变化的染色质修饰和重构。</dd>
<dd>广义上重塑的途径包括：
<ul>
<li>组蛋白共价修饰：<strong>乙酰化</strong>（激活转录）、甲基化、磷酸化、泛素化</li>
<li>DNA 分子甲基化</li>
<li>RNA 干扰</li>
<li>ATP 依赖的染色质重塑</li>
</ul>
</dd>
<dd>狭义上指依赖 ATP 的一种物理修饰，即由 <strong>ATP 依赖的染色质重塑复合物</strong> 改变组蛋白和
DNA 的结合状态，使转录因子易于接近 DNA</dd>
</dl>
<p><strong>非编码 RNA</strong>（noncoding RNA，ncRNA）</p>
<ul>
<li>小干扰 RNA（small interfering RNA，siRNA）：<em>外源或内源性双链 RNA</em>，长度 21~23nt</li>
<li>微小 RNA（microRNA，miRNA）：<em>内源性非编码单链 RNA</em>，长度 18~25nt</li>
<li>长链非编码 RNA（long noncoding RNA，lncRNA）：无编码蛋白潜能，长度大于 200nt</li>
</ul>
<h2 id="基因突变与-dna-多态性">基因突变与 DNA 多态性 <a class="markdownIt-Anchor" href="#基因突变与-dna-多态性">#</a></h2>
<h3 id="基因突变">基因突变 <a class="markdownIt-Anchor" href="#基因突变">#</a></h3>
<dl>
<dt>突变（mutation）</dt>
<dd>遗传物质的可遗传变异。</dd>
</dl>
<ul>
<li><strong>染色体畸形</strong>：染色体数目或结构异常（见 <a href="/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/#染色体畸变">染色体畸变</a>）</li>
<li><strong>基因突变</strong>：<a href="?highlight=%E7%82%B9%E7%AA%81%E5%8F%98#%E7%82%B9%E7%AA%81%E5%8F%98">点突变</a>、<a href="?highlight=%E7%A7%BB%E7%A0%81%E7%AA%81%E5%8F%98#%E7%A7%BB%E7%A0%81%E7%AA%81%E5%8F%98">移码突变</a>、<a href="?highlight=%E5%8A%A8%E6%80%81%E7%AA%81%E5%8F%98#%E5%8A%A8%E6%80%81%E7%AA%81%E5%8F%98"><strong>动态突变</strong></a></li>
</ul>
<h4 id="点突变">点突变 <a class="markdownIt-Anchor" href="#点突变">#</a></h4>
<dl>
<dt>点突变（point mutation）</dt>
<dd>即单个碱基置换，指一个碱基被另一个碱基所替换。</dd>
<dd>主要有两种方式：
<ol>
<li><strong>转换</strong>（transition）：不同嘌呤或嘧啶间相互置换；</li>
<li><strong>颠换</strong>（transversion）：嘌呤与嘧啶间的相互置换。</li>
</ol>
</dd>
</dl>
<p>点突变的类型：</p>
<ul>
<li><strong>错义突变</strong>：密码子改变，编码另一种氨基酸；</li>
<li><strong>同义突变</strong>/中性突变/静止突变：密码子改变，但编码的氨基酸不变；</li>
<li><strong>无义突变</strong>：编码氨基酸的密码子突变为终止密码子；</li>
<li><strong>终止密码子突变</strong>：终止密码子突变为编码氨基酸的密码子。</li>
</ul>
<h4 id="移码突变">移码突变 <a class="markdownIt-Anchor" href="#移码突变">#</a></h4>
<dl>
<dt>移码突变（frameshift mutation）</dt>
<dd>DNA 编码序列插入或缺失 3 的非整数倍个碱基。</dd>
<dd>导致阅读框架改变，结果突变点以后的氨基酸种类和顺序改变。</dd>
</dl>
<h4 id="动态突变">动态突变 <a class="markdownIt-Anchor" href="#动态突变">#</a></h4>
<dl>
<dt><mark>动态突变</mark>（dynamic mutation）</dt>
<dd><strong>三核苷酸重复</strong>（triplet repeat）次数在世代传递过程中明显增加。</dd>
<dd>形成原因是三核苷酸重复序列在复制时发生位移。</dd>
</dl>
<h3 id="dna-多态性">DNA 多态性 <a class="markdownIt-Anchor" href="#dna-多态性">#</a></h3>
<dl>
<dt>DNA 多态性（DNA polymorphism）</dt>
<dd>某一 <strong>基因座</strong> 在人群中存在 <strong>两种或两种以上</strong>
的序列突变，其中频率最低的形式也远远高于依赖突变所能维持的频率。</dd>
<dd>对于同一基因座上的两个或两个以上的等位基因，等位基因频率至少 <strong>0.01</strong>
携带该等位基因的杂合子频率大于 <strong>2%</strong>，则认为该基因座具有多态性。</dd>
</dl>
<p>常见的 DNA 多态性类型：</p>
<ul>
<li>RFLP（限制性片段长度多态性）</li>
<li>VNTR（可变数目串联重复）</li>
<li>SNP（单核苷酸多态性）</li>
</ul>
<h2 id="基因分析技术">基因分析技术 <a class="markdownIt-Anchor" href="#基因分析技术">#</a></h2>
<p>鉴定单基因突变的流程</p>
<ol>
<li>临床：诊断→系谱绘制→查阅文献→采血</li>
<li>实验室：提取 DNA→设计 PCR 引物→合成引物→PCR 扩增→测序→结果分析</li>
</ol>
<h3 id="分子杂交">分子杂交 <a class="markdownIt-Anchor" href="#分子杂交">#</a></h3>
<dl>
<dt>分子杂交（molecular hybridization）</dt>
<dd>利用碱基互补碱基配对的原理，在复杂的靶 DNA 或 RNA 序列中，用特异的探针来鉴定其同源的
DNA 或 RNA 片段。</dd>
</dl>
<h4 id="探针">探针 <a class="markdownIt-Anchor" href="#探针">#</a></h4>
<dl>
<dt>探针（probe）</dt>
<dd>一段与目的基因或 DNA/RNA 片段特异杂交的核苷酸序列。</dd>
</dl>
<div class="tabs" id="探针"><ul class="nav-tabs"><li class="tab active"><a href="#探针-1">探针种类</a></li><li class="tab"><a href="#探针-2">探针的标记</a></li><li class="tab"><a href="#探针-3">探针检测</a></li></ul><div class="tab-content"><div class="tab-pane active" id="探针-1"><ul>
<li>DNA 探针</li>
<li>RNA 探针</li>
<li>寡核苷酸探针</li>
</ul></div><div class="tab-pane" id="探针-2"><ul>
<li>切口平移法</li>
<li>随机引物延伸法</li>
<li>DNA 末段标记法</li>
<li>RNA 探针标记</li>
</ul></div><div class="tab-pane" id="探针-3"><ul>
<li>放射性同位素</li>
<li>荧光基因</li>
<li>间接检测</li>
</ul></div></div></div>
<h4 id="杂交技术">杂交技术 <a class="markdownIt-Anchor" href="#杂交技术">#</a></h4>
<dl>
<dt>Southern 印记杂交</dt>
<dd>通过标记探针的 DNA 单链与互补的待测靶 DNA 单链结合形成异源双链，检测待测靶
DNA 序列中是否存在与探针同源的 <strong>DNA 序列</strong>。</dd>
<dd>广泛应用于遗传学研究和基因诊断。</dd>
<dt>Northern 印记杂交</dt>
<dd>通过标记探针的 DNA 单链与互补的待测靶 mRNA 单链结合形成异源双链，检测待测靶
mRNA 序列中是否存在与探针同源的 <strong>mRNA 序列</strong>。</dd>
<dd>主要应用于检测某一基因的 mRNA 表达水平和相关转录物的情况。</dd>
<dt><em>Western 印记杂交 | 免疫印记</em></dt>
<dd>通过运用免疫动物或遗传工程方法生产的抗体来检测待测样品是否有能够与抗体特异性结合的抗原（<strong>蛋白质</strong>）。</dd>
<dd>主要应用于基因表达和功能研究。</dd>
<dt>斑点杂交</dt>
<dd>一般使用 <strong>等位基因特异性寡核苷酸</strong>（allele-specific
oligonucleotide，ASO）探针，快速筛查 <strong>等位基因间单核苷酸的差异</strong>。</dd>
</dl>
<h3 id="重组-dna-技术">重组 DNA 技术 <a class="markdownIt-Anchor" href="#重组-dna-技术">#</a></h3>
<dl>
<dt>重组 DNA 技术（recombination DNA）</dt>
<dd>按人类需要选择 <strong>目的基因</strong>（DNA 片段），在体外与 <strong>载体</strong>
重组，再用一定的基因转移方法将重组 DNA
输入另一细胞或生物体内，以改良或创新生物品种以及治疗人类疾病。</dd>
<dd>遗传工程的 <mark>核心技术</mark>，也是 DNA 操作的基本工具。</dd>
</dl>
<p>所需工具、技术</p>
<ol>
<li>限制酶</li>
<li>载体</li>
<li>细胞 DNA 克隆</li>
<li>基因文库</li>
</ol>
<h4 id="限制酶">限制酶 <a class="markdownIt-Anchor" href="#限制酶">#</a></h4>
<dl>
<dt>限制酶（restriction enzyme）| 限制性内切核酸酶</dt>
<dd>一种能特异性切断 DNA 链内的磷酸二酯键的酶。</dd>
</dl>
<p><strong>II 型限制酶</strong> 的酶切位点在其识别序列的内部，可以应用于重组 DNA 技术</p>
<p>限制酶的命名</p>
<ul>
<li>细菌属名第一个字母（大写斜体）</li>
<li>细菌种名的前两个字母（小写斜体）</li>
<li><em>菌株名称（大写或小写正体）</em></li>
<li>酶的序号（罗马数字）</li>
</ul>
<blockquote>
<p>如 <em>Alu</em> I 是分离自属和种名为 Arthrobacter luteus 细菌的第一种酶</p>
</blockquote>
<h4 id="载体">载体 <a class="markdownIt-Anchor" href="#载体">#</a></h4>
<dl>
<dt>载体（vector）</dt>
<dd>将外源 DNA 片段运送到受体细胞并能进行自我复制增殖和表达的工具。</dd>
</dl>
<ul>
<li>克隆载体：外源 DNA 片段，增殖扩大数量</li>
<li>表达载体：外源基因，产生蛋白质</li>
</ul>
<p><strong>载体的特征</strong></p>
<ol>
<li><strong>分子质量小</strong>，便于与较大的 DNA 片段结合，能进入受体细胞并在其中增殖；</li>
<li><strong>有多个限制酶切位点</strong>，但对每一种限制酶只能有一个酶切位点；</li>
<li>插入外源 DNA 后，不影响自身的 <strong>复制和表达能力</strong>；</li>
<li>有可选择的 <strong>标记基因</strong>（如抗药基因）或报道基因；</li>
<li>克隆载体上要有 <strong>复制起点</strong>，表达载体上还要有 <strong>启动子</strong>；</li>
</ol>
<p>常用载体</p>
<ul>
<li><a href="/2021/03/21/%E7%BB%86%E8%8F%8C/#细胞质">质粒</a>：能克隆较小 DNA 片段（小于 10kb）</li>
<li><a href="/2021/03/21/%E7%97%85%E6%AF%92/#噬菌体">λ 噬菌体</a>：能克隆中等长度的 DNA 片段，具有
<strong><a href="/2021/04/22/%E5%99%AC%E8%8F%8C%E4%BD%93/">cos 序列</a></strong></li>
<li>黏粒</li>
<li>细菌人工染色体：可克隆长达 300kb 的 DNA 大片段</li>
<li>酵母菌人工染色体：常用来克隆很大的 DNA 片段</li>
</ul>
<dl>
<dt>黏粒（cosmid）</dt>
<dd>将质粒和噬菌体改建的一种载体 , 即将 λ 噬萧体的 cos 序列插入质粒。</dd>
<dt>细菌人工染色体（BAC）</dt>
<dd>一种重组的质粒，能在细菌细胞内繁殖。</dd>
<dt>酵母菌人工染色体（YAC）</dt>
<dd>一种在酵母中繁殖的克隆载体系统。</dd>
</dl>
<h4 id="细胞-dna-克隆">细胞 DNA 克隆 <a class="markdownIt-Anchor" href="#细胞-dna-克隆">#</a></h4>
<dl>
<dt>细胞 DNA 克隆 | DNA 克隆 | 分子克隆</dt>
<dd>为获得特异基因和特异序列，将目的基因 DNA 片段与载体 DNA 重组，使重组 DNA 分子在
<strong>宿主细胞</strong> 中表达扩增而获得大量相同的 DNA 片段。</dd>
</dl>
<img data-src="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E7%BB%86%E8%83%9E%E5%85%8B%E9%9A%86%E7%9A%84%E9%80%89%E6%8B%A9%E5%A2%9E%E6%AE%96.png" class="" title="细胞克隆的选择增殖" alt="细胞克隆的选择增殖">
<p><mark>细胞 DNA 克隆的主要步骤</mark>：</p>
<ol>
<li><strong>构建重组 DNA 分子</strong>：将靶（目的）DNA 片段与载体连接；</li>
<li><strong>转化</strong>：将重组 DNA 分子转移到宿主细胞（细菌或酵母细胞）；</li>
<li><strong>细胞克隆的选择增殖</strong>：将转化的细胞值置于<em>琼脂皿的表面</em>以刺激其克隆生长，再将单个 <strong>细胞克隆</strong> 移到液体培养基中进行扩增；</li>
<li><strong>分离重组 DNA 克隆</strong>：收获扩增的培养细胞并选择分离重组 DNA。</li>
</ol>
<dl>
<dt>细胞克隆</dt>
<dd>单个细胞在遗传上形成的在遗传上相通的细胞群体。</dd>
</dl>
<h4 id="基因文库">基因文库 <a class="markdownIt-Anchor" href="#基因文库">#</a></h4>
<dl>
<dt>基因文库（gene library）| DNA 文库</dt>
<dd>用重组 DNA 技术和 DNA 克隆方法人工构建的，含有 <strong>基因组全部 DNA 片段</strong>
的 DNA 克隆所组成的库。
<ul>
<li>基因组 DNA 文库</li>
<li>cDNA 文库</li>
<li>染色体特异的基因文库</li>
</ul>
</dd>
</dl>
<h3 id="pcr">PCR <a class="markdownIt-Anchor" href="#pcr">#</a></h3>
<dl>
<dt>PCR | 聚合酶链反应 | 多聚酶链式反应</dt>
<dd>一种体外 DNA 扩增技术，模拟体内 DNA 复制条件，可以在体外迅速地选择、扩增特定的靶
DNA 序列，得到大量相同的 DNA 片段，即 <strong>PCR-DNA 克隆</strong>。</dd>
</dl>
<p>设计原理及步骤</p>
<ol>
<li>设计及合成引物（primer）</li>
<li>必须有 DNA 前身物（四种 dNTP）</li>
<li>必须有 <em>Taq</em> 酶</li>
<li>PCR 反应体系：基因组 DNA、一对引物、四种 dNTP、<em>Taq</em> DNA 聚合酶、酶反应缓冲体系、必需的离子（如 Mg<sup>2+</sup>）</li>
<li>PCR 是链式反应：变性→复性→延伸→变性→……</li>
</ol>
<h3 id="dna-测序">DNA 测序 <a class="markdownIt-Anchor" href="#dna-测序">#</a></h3>
<ul>
<li>第一代测序：双脱氧链末端终止法</li>
<li>第二代测序</li>
<li>第三代单分子实时合成测序技术</li>
</ul>
<img data-src="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E5%8F%8C%E8%84%B1%E6%B0%A7%E6%A0%B8%E8%8B%B7%E9%85%B8%E5%92%8C%E5%8F%8C%E8%84%B1%E6%B0%A7%E9%93%BE%E6%9C%AB%E7%AB%AF%E7%BB%88%E6%AD%A2%E6%B3%95.png" class="" title="双脱氧核苷酸和双脱氧链末端终止法" alt="双脱氧核苷酸和双脱氧链末端终止法">
<h3 id="其他">其他 <a class="markdownIt-Anchor" href="#其他">#</a></h3>
<dl>
<dt>基因组编辑（genome editing）</dt>
<dd>依赖一些识别特定序列的核酸酶在 DNA 上切割，产生双链 DNA
断点，再通过非同源端连接机制（NHEJ）或同源重组机制修复断点的同时 DNA 进行编辑。</dd>
</dl>
<ul>
<li>锌指核酸内切酶 | ZFN</li>
<li>转录激活子样效应因子核酸酶 | TALEN</li>
<li>CRISPR/Cas9 系统</li>
</ul>
<p><strong>DNA 微阵列 | DNA 芯片</strong></p>
<img data-src="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/DNA-%E5%BE%AE%E9%98%B5%E5%88%97.png" class="" title="DNA 微阵列" alt="DNA 微阵列">
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>By User:Acdx - Own work, based on File:Palindrome of DNA structure.PNG, CC BY-SA 3.0, <span class="exturl" data-url="aHR0cHM6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvdy9pbmRleC5waHA/Y3VyaWQ9MTE5NDcwMDc=">https://commons.wikimedia.org/w/index.php?curid=11947007<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>由Squidonius (talk) - 自己的作品 (Original text: self-made)，公有领域，<span class="exturl" data-url="aHR0cHM6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvdy9pbmRleC5waHA/Y3VyaWQ9MTA1NDczMDM=">https://commons.wikimedia.org/w/index.php?curid=10547303<i class="fa fa-external-link-alt"></i></span> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>其他病毒</title>
    <url>/2021/05/20/%E5%85%B6%E4%BB%96%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<p class="center">Empty...</p>
<span id="more"></span>
<h2 id="狂犬病病毒">狂犬病病毒 <a class="markdownIt-Anchor" href="#狂犬病病毒">#</a></h2>
<p>中枢神经系统，死亡率 100%，</p>
<p>病毒呈“子弹头状”</p>
<dl>
<dt><mark>内基小体</mark></dt>
<dd>狂犬病病毒在神经细胞（主要是 <strong>大脑海马回的锥体细胞</strong>）中增殖形成的嗜酸性包涵体。</dd>
<dd>是决定狂犬病病毒感染的辅助诊断指标。</dd>
</dl>
<h3 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h3>
<ul>
<li>传染源：狂犬、猫蝙蝠</li>
<li>传播途径：咬伤、眼结膜</li>
</ul>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
<p>病毒潜伏期长，可进行疫苗接种获得被动免疫，预防疾病发生。</p>
<h2 id="人乳头瘤病毒">人乳头瘤病毒 <a class="markdownIt-Anchor" href="#人乳头瘤病毒">#</a></h2>
<p>DNA 无包膜病毒</p>
<h3 id=""> <a class="markdownIt-Anchor" href="#">#</a></h3>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
      </tags>
  </entry>
  <entry>
    <title>免疫器官和组织</title>
    <url>/2021/04/26/%E5%85%8D%E7%96%AB%E5%99%A8%E5%AE%98%E5%92%8C%E7%BB%84%E7%BB%87/</url>
    <content><![CDATA[<p><strong>免疫组织（immune tissue）| 淋巴组织（lymphoid tissue）</strong>：弥散淋巴组织、淋巴小结</p>
<p><strong>免疫器官（immune organ）| 淋巴器官（lymphoid organ）</strong></p>
<ul>
<li><a href="#%E4%B8%AD%E6%9E%A2%E5%85%8D%E7%96%AB%E5%99%A8%E5%AE%98">中枢免疫器官</a></li>
<li><a href="#%E5%A4%96%E5%91%A8%E5%85%8D%E7%96%AB%E5%99%A8%E5%AE%98">外周免疫器官</a></li>
</ul>
<span id="more"></span>
<h2 id="中枢免疫器官">中枢免疫器官 <a class="markdownIt-Anchor" href="#中枢免疫器官">#</a></h2>
<dl>
<dt>中枢免疫器官（central immune organ）| 初级淋巴器官（primary lymphoid organ）</dt>
<dd>免疫细胞发生、分化、发育和成熟的场所。</dd>
</dl>
<h3 id="骨髓">骨髓 <a class="markdownIt-Anchor" href="#骨髓">#</a></h3>
<dl>
<dt>骨髓（bone marrow）</dt>
<dd>各类血细胞（包括免疫细胞）的发源地</dd>
<dd>人类和其他哺乳动物 B 细胞发育成熟的场所</dd>
</dl>
<h4 id="骨髓的结构和细胞组成">骨髓的结构和细胞组成 <a class="markdownIt-Anchor" href="#骨髓的结构和细胞组成">#</a></h4>
<dl>
<dt>红骨髓</dt>
<dd>造血功能活跃，由 <strong>造血组织</strong> 和血窦组成。</dd>
</dl>
<p>造血组织</p>
<ul>
<li>造血细胞</li>
<li>基质细胞：网状细胞、成纤维细胞、血窦内皮细胞、巨噬细胞……</li>
</ul>
<dl>
<dt>黄骨髓</dt>
<dd>含有大量脂肪组织，特定条件下可转换为红骨髓。</dd>
</dl>
<p><strong>造血诱导微环境（HIM）</strong></p>
<ul>
<li>细胞外基质</li>
<li>骨髓基质细胞</li>
<li>多种细胞因子</li>
</ul>
<h4 id="骨髓的功能">骨髓的功能 <a class="markdownIt-Anchor" href="#骨髓的功能">#</a></h4>
<ol>
<li>各类血细胞、免疫细胞发生的场所</li>
<li>B 细胞 NK 细胞分化成熟的场所</li>
<li>发生再次体液免疫应答后，抗体产生的主要部位（成熟浆细胞分化及再次应答抗体产生的场所）</li>
</ol>
<details class="note info"><summary><p>mIgM</p>
</summary>
<p>即膜型 IgM（mIgM），成熟和未成熟的 B 细胞都可产生。</p>
<blockquote>
<p>成熟后 B 细胞还会产生 <strong>mIgD</strong>，可作为鉴定标志。</p>
</blockquote>

</details>
<h3 id="胸腺">胸腺 <a class="markdownIt-Anchor" href="#胸腺">#</a></h3>
<dl>
<dt>胸腺（thymus）</dt>
<dd>由胸腺细胞和胸腺基质细胞组成，是 T 细胞发育、分化、成熟的场所。</dd>
</dl>
<h4 id="胸腺的结构">胸腺的结构 <a class="markdownIt-Anchor" href="#胸腺的结构">#</a></h4>
<ul>
<li>皮质：深皮质、浅皮质</li>
<li>髓质：散在分布的成熟胸腺细胞、巨噬细胞、树突状细胞</li>
</ul>
<p>细胞组成</p>
<ul>
<li>胸腺细胞：处于不同分化阶段的 T 细胞</li>
<li>胸腺基质细胞（thymus stromal cell, TSC）
<ul>
<li>胸腺上皮细胞</li>
<li>巨噬细胞</li>
<li>树突状细胞</li>
</ul>
</li>
</ul>
<h4 id="胸腺微环境">胸腺微环境 <a class="markdownIt-Anchor" href="#胸腺微环境">#</a></h4>
<dl>
<dt>胸腺微环境（thymic microenvironment）</dt>
<dd>决定 T 细胞分化、增殖和选择性发育的重要条件。
<ul>
<li>胸腺基质细胞</li>
<li>细胞外基质</li>
<li>局部活性因子</li>
</ul>
</dd>
<dd><strong>细胞外基质</strong> 也是胸腺微环境的重要组成部分。</dd>
</dl>
<p>胸腺上皮细胞影响胸腺细胞分化的两种方式</p>
<ul>
<li>细胞-细胞间相互接触</li>
<li>分泌细胞因子和胸腺肽类因子</li>
</ul>
<h4 id="胸腺的功能">胸腺的功能 <a class="markdownIt-Anchor" href="#胸腺的功能">#</a></h4>
<ol>
<li>T 细胞分化、成熟的场所：T 细胞迁移、阳性选择、阴性选择</li>
<li>免疫调节作用：细胞因子、胸腺肽类因子</li>
<li>自身免疫耐受的建立与维持：通过阴性选择形成中枢免疫耐受</li>
</ol>
<h2 id="外周免疫器官和组织">外周免疫器官和组织 <a class="markdownIt-Anchor" href="#外周免疫器官和组织">#</a></h2>
<ul>
<li>成熟淋巴细胞定居的场所</li>
<li>淋巴细胞对外来抗原产生免疫应答的主要部位</li>
</ul>
<h3 id="淋巴结">淋巴结 <a class="markdownIt-Anchor" href="#淋巴结">#</a></h3>
<h4 id="淋巴结的结构">淋巴结的结构 <a class="markdownIt-Anchor" href="#淋巴结的结构">#</a></h4>
<ul>
<li>皮质：浅皮质区、深皮质区</li>
<li>髓质：髓索、髓窦</li>
</ul>
<hr />
<dl>
<dt>浅皮质区 | 非胸腺依赖区（thymus-indepentent area）</dt>
<dd>靠近被膜下的皮质区，为 <strong>B 细胞区</strong>，是 B 细胞定居的场所。</dd>
<dt>初级淋巴滤泡（primary lymphoid follicle）| 淋巴小结（lymphoid nodule）</dt>
<dd>浅皮质区中，大量 B 细胞聚集而成。</dd>
<dt>次级淋巴滤泡（secondary lymphoid follicle）</dt>
<dd><strong>初级淋巴滤泡</strong> 受抗原刺激后，出现 <strong>生发中心</strong>（germinal center, <strong>GC</strong>），称为 <strong>次级淋巴滤泡</strong>。</dd>
<dd>内含大量增殖分化的 <strong>B 淋巴母细胞</strong>，可转移至髓质分化为浆细胞并产生抗体。</dd>
</dl>
<div class="note default"><p>B 细胞缺陷时，皮质缺乏初级淋巴滤泡和生发中心。</p>
</div>
<hr />
<dl>
<dt>深皮质区 | 副皮质区 | 胸腺依赖区（thymus-depentent area）</dt>
<dd>浅皮质区与髓质之间的皮质区，为 <strong>T 细胞区</strong>，是 T 细胞定居的场所。</dd>
<dt>高内皮微静脉（high endothelial venule, HEV）</dt>
<dd>副皮质区中的由内皮细胞组成的、呈非连续状的 <strong>毛细血管后微静脉</strong>。</dd>
</dl>
<hr />
<dl>
<dt>髓索</dt>
<dd>由密集的淋巴细胞组成，主要为 B 细胞和浆细胞，也有部分 T 细胞和 Mϕ。</dd>
<dt>髓窦</dt>
<dd>富含 Mϕ，有较强的捕捉、清除抗原体的功能。</dd>
</dl>
<h4 id="淋巴结的功能">淋巴结的功能 <a class="markdownIt-Anchor" href="#淋巴结的功能">#</a></h4>
<ol>
<li>成熟 T 细胞（75%）、B 细胞（25%）定居的场所</li>
<li>适应性免疫应答的主要场所</li>
<li>过滤作用：过滤组织来源的抗原</li>
<li>参与淋巴细胞再循环</li>
</ol>
<h3 id="脾">脾 <a class="markdownIt-Anchor" href="#脾">#</a></h3>
<h4 id="脾的结构">脾的结构 <a class="markdownIt-Anchor" href="#脾的结构">#</a></h4>
<ul>
<li>白髄：动脉周围淋巴鞘（PALS）、脾小结、边缘区</li>
<li>红髓：脾索、脾血窦</li>
</ul>
<h4 id="脾的功能">脾的功能 <a class="markdownIt-Anchor" href="#脾的功能">#</a></h4>
<ol>
<li>T 细胞（40%）和 B 细胞（60%）定居的场所</li>
<li>免疫应答发生的场所</li>
<li>生成生物活性物质，如补体、细胞因子</li>
<li>过滤作用：清除血液来源的抗原</li>
</ol>
<h3 id="黏膜相关淋巴组织">黏膜相关淋巴组织 <a class="markdownIt-Anchor" href="#黏膜相关淋巴组织">#</a></h3>
<dl>
<dt>黏膜相关淋巴组织（MALT）</dt>
<dd>胃肠道、呼吸道、泌尿生殖道黏膜固有层和上皮细胞下散在的淋巴组织，以及带有生发中心的淋巴组织。</dd>
</dl>
<h4 id="黏膜相关淋巴组织的组成">黏膜相关淋巴组织的组成 <a class="markdownIt-Anchor" href="#黏膜相关淋巴组织的组成">#</a></h4>
<ul>
<li>肠相关淋巴结（GALT）
<ul>
<li>派氏集合淋巴结（PP）</li>
<li>上皮内淋巴结（IEL）</li>
</ul>
</li>
<li>鼻相关淋巴结（NALT）</li>
<li>支气管相关淋巴组织（BALT）</li>
</ul>
<h4 id="黏膜相关淋巴组织的功能">黏膜相关淋巴组织的功能 <a class="markdownIt-Anchor" href="#黏膜相关淋巴组织的功能">#</a></h4>
<ul>
<li>黏膜局部免疫反应的主要部位、黏膜局部抗感染免疫防御、肠道问胎的维持</li>
<li>产生分泌型 IgA（SIgA）</li>
</ul>
<h2 id="淋巴细胞归巢与再循环">淋巴细胞归巢与再循环 <a class="markdownIt-Anchor" href="#淋巴细胞归巢与再循环">#</a></h2>
<dl>
<dt>淋巴细胞归巢（lymphocyte homing）</dt>
<dd>血液中淋巴细胞选择性取向迁移并定居与外周免疫器官的特定区域或特定组织的过程。</dd>
<dt>淋巴细胞再循环（lymphocyte recirculation）</dt>
<dd>定居在外周免疫器官的淋巴细胞重新分布到全身淋巴器官和组织的反复循环过程。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>医学免疫学</category>
      </categories>
      <tags>
        <tag>医学免疫学</tag>
      </tags>
  </entry>
  <entry>
    <title>分子病和先天代谢病</title>
    <url>/2021/05/07/%E5%88%86%E5%AD%90%E7%97%85%E5%92%8C%E5%85%88%E5%A4%A9%E4%BB%A3%E8%B0%A2%E7%97%85/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%88%86%E5%AD%90%E7%97%85">分子病</a>
<ul>
<li><a href="#%E8%A1%80%E7%BA%A2%E8%9B%8B%E7%99%BD%E7%97%85">血红蛋白病</a>
<ul>
<li><a href="#%E8%A1%80%E7%BA%A2%E8%9B%8B%E7%99%BD%E7%97%85%E7%9A%84%E7%A7%8D%E7%B1%BB">血红蛋白病的种类</a></li>
<li><a href="#%E8%A1%80%E7%BA%A2%E8%9B%8B%E7%99%BD%E7%97%85%E7%9A%84%E5%88%86%E5%AD%90%E5%9F%BA%E7%A1%80">血红蛋白病的分子基础</a></li>
<li><a href="#%E8%A1%80%E7%BA%A2%E8%9B%8B%E7%99%BD%E7%97%85%E4%B8%BE%E4%BE%8B">血红蛋白病举例</a>
<ul>
<li><a href="#%E5%9C%B0%E4%B8%AD%E6%B5%B7%E8%B4%AB%E8%A1%80">地中海贫血</a></li>
<li><a href="#%E5%AE%B6%E6%97%8F%E6%80%A7%E9%AB%98%E8%83%86%E5%9B%BA%E9%86%87%E8%A1%80%E7%97%87">家族性高胆固醇血症</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%88%E5%A4%A9%E4%BB%A3%E8%B0%A2%E7%97%85">先天代谢病</a>
<ul>
<li><a href="#%E5%85%88%E5%A4%A9%E4%BB%A3%E8%B0%A2%E7%BC%BA%E9%99%B7%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E5%88%B6">先天代谢缺陷的产生机制</a></li>
<li><a href="#%E5%85%88%E5%A4%A9%E6%80%A7%E4%BB%A3%E8%B0%A2%E7%97%85%E7%9A%84%E7%B1%BB%E5%9E%8B">先天性代谢病的类型</a>
<ul>
<li><a href="#%E6%B0%A8%E5%9F%BA%E9%85%B8%E4%BB%A3%E8%B0%A2%E7%97%85">氨基酸代谢病</a></li>
<li><a href="#%E7%B3%96%E4%BB%A3%E8%B0%A2%E7%97%85">糖代谢病</a></li>
<li><a href="#%E8%84%82%E7%B1%BB%E4%BB%A3%E8%B0%A2%E7%97%85">脂类代谢病</a></li>
<li><a href="#%E5%98%8C%E5%91%A4%E4%BB%A3%E8%B0%A2%E7%97%85">嘌呤代谢病</a></li>
<li><a href="#%E8%91%A1%E8%90%84%E7%B3%96-6-%E7%A3%B7%E9%85%B8%E8%84%B1%E6%B0%A2%E9%85%B6%E7%BC%BA%E4%B9%8F%E7%97%87">葡萄糖 6-磷酸脱氢酶缺乏症</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<span id="more"></span>
<h2 id="分子病">分子病 <a class="markdownIt-Anchor" href="#分子病">#</a></h2>
<dl>
<dt>分子病（molecular disease）</dt>
<dd><strong>基因突变</strong>导致蛋白质分子质和量的异常，从而引起机体功能障碍的一类疾病。</dd>
</dl>
<h3 id="血红蛋白病">血红蛋白病 <a class="markdownIt-Anchor" href="#血红蛋白病">#</a></h3>
<dl>
<dt>血红蛋白病（hemoglobinpathy）</dt>
<dd>由于珠蛋白分子结构或合成量异常所引起的疾病。
<ul>
<li>镰状细胞病</li>
<li>不稳定血红蛋白病</li>
<li>血红蛋白 M 病</li>
<li>氧亲和力改变的血红蛋白病</li>
</ul>
</dd>
</dl>
<p>血红蛋白（<abbr title="血红蛋白">Hb</abbr>）
:</p>
<p>珠蛋白基因结构</p>
<ul>
<li>α 珠蛋白基因簇</li>
<li>β 珠蛋白基因簇</li>
</ul>
<p>珠蛋白基因表达调控：LCR</p>
<dl>
<dt>镰状细胞病（Sickle Cell Disease）</dt>
<dd>不完全显性遗传，缺氧时血红蛋白凝聚</dd>
</dl>
<p>GAG → GTG</p>
<ul>
<li>纯合子</li>
<li>杂合子</li>
</ul>
<p>斑点杂交</p>
<hr />
<h4 id="血红蛋白病的种类">血红蛋白病的种类 <a class="markdownIt-Anchor" href="#血红蛋白病的种类">#</a></h4>
<dl>
<dt>不稳定血红蛋白病（）</dt>
<dd>AD（不完全显性）</dd>
</dl>
<hr />
<dl>
<dt>血红蛋白 M 病 | 遗传性高铁血红蛋白血症</dt>
<dd>紫绀、继发性红细胞增多症</dd>
</dl>
<hr />
<dl>
<dt>氧亲和力改变的血红蛋白病</dt>
<dd><abbr title="血红蛋白">Hb</abbr> 分子与氧的亲和力增高或降低导致其运输氧的能力改变。</dd>
</dl>
<h4 id="血红蛋白病的分子基础">血红蛋白病的分子基础 <a class="markdownIt-Anchor" href="#血红蛋白病的分子基础">#</a></h4>
<ul>
<li>单个碱基置换
<ul>
<li>错义突变：<abbr title="血红蛋白">Hb</abbr> S</li>
<li>无义突变：</li>
<li>终止密码突变：<abbr title="血红蛋白">Hb</abbr> content spring</li>
</ul>
</li>
<li>移码突变</li>
<li>密码子的插入和缺失：<abbr title="血红蛋白">Hb</abbr> Gun Hill</li>
<li>融合基因：<abbr title="血红蛋白">Hb</abbr> Lepore</li>
</ul>
<h4 id="血红蛋白病举例">血红蛋白病举例 <a class="markdownIt-Anchor" href="#血红蛋白病举例">#</a></h4>
<h5 id="地中海贫血">地中海贫血 <a class="markdownIt-Anchor" href="#地中海贫血">#</a></h5>
<dl>
<dt>地中海贫血（Thalassemia）</dt>
<dd>由于珠蛋白基因缺失或突变导致某种珠蛋白的链合成障碍，造成 α 或 β 链<strong>合成失去平衡</strong>而导致的溶血性贫血。
<ul>
<li>α 地中海贫血</li>
<li>β 地中海贫血</li>
</ul>
</dd>
</dl>
<hr />
<dl>
<dt>α 地中海贫血</dt>
<dd>α 链合成受到抑制，主要是由于 <strong>α 基因缺失</strong>
<ul>
<li>α<sup>0</sup> 地贫（α 地贫 1）</li>
<li>α<sup>+</sup> 地贫（α 地贫 2）</li>
</ul>
</dd>
<dt>α<sup>0</sup> 地贫（α 地贫 1）</dt>
<dd>缺失两个基因，-- / αα</dd>
<dt>α<sup>+</sup> 地贫（α 地贫 2）</dt>
<dd>缺失一个基因，α- / αα</dd>
</dl>
<p>临床分类</p>
<ol>
<li>HB Bart’s 胎儿水肿综合征（γ<sub>4</sub>）</li>
<li>血红蛋白 H 病</li>
<li>轻型（标准型）</li>
<li>静止型</li>
</ol>
<hr />
<dl>
<dt>β 地中海贫血</dt>
<dd>β 链合成受到抑制，主要由于<strong>基因突变</strong>
<ul>
<li>完全不能合成 β 链：</li>
<li>能部分合成 β 链：</li>
</ul>
</dd>
</dl>
<p>临床类型</p>
<ol>
<li>重型 β 地中海贫血：<strong>地中海贫血面容</strong></li>
<li>轻型 β 地中海贫血</li>
<li>中间型 β 地中海贫血</li>
</ol>
<dl>
<dt>遗传性胎儿血红蛋白增多症</dt>
<dd>δ 和 β 受抑、γ 链合成增多，导致成人 HbF 增多。</dd>
</dl>
<h5 id="家族性高胆固醇血症">家族性高胆固醇血症 <a class="markdownIt-Anchor" href="#家族性高胆固醇血症">#</a></h5>
<dl>
<dt>家族性高胆固醇血症</dt>
<dd>LDL 受体突变</dd>
</dl>
<h2 id="先天代谢病">先天代谢病 <a class="markdownIt-Anchor" href="#先天代谢病">#</a></h2>
<h3 id="先天代谢缺陷的产生机制">先天代谢缺陷的产生机制 <a class="markdownIt-Anchor" href="#先天代谢缺陷的产生机制">#</a></h3>
<ol>
<li>结构基因突变使酶结构代谢</li>
<li>调节基因突变</li>
<li>翻译后修饰、加工</li>
</ol>
<h3 id="先天性代谢病的类型">先天性代谢病的类型 <a class="markdownIt-Anchor" href="#先天性代谢病的类型">#</a></h3>
<h4 id="氨基酸代谢病">氨基酸代谢病 <a class="markdownIt-Anchor" href="#氨基酸代谢病">#</a></h4>
<dl>
<dt>苯丙酮尿症</dt>
<dd>由肝脏 <strong>苯丙氨酸羟化酶</strong> 缺乏所致的一种常染色体隐性遗传病，少数由于 <strong>四氢生物蝶呤</strong> 缺乏所致。</dd>
<dd>旁路代谢开放、鼠尿味；黑色素和成减少、；影响大脑发育</dd>
</dl>
<p>苯丙氨酸羟化酶发挥作用需要辅因子 <strong>四氢生物蝶呤</strong>（BH<sub>4</sub>）</p>
<dl>
<dt>白化病</dt>
<dd>缺乏 <strong>酪氨酸酶</strong> 所致的一种常染色体隐性遗传病。</dd>
<dt>尿黑酸尿症</dt>
<dd>缺乏 <strong>尿黑酸氧化酶</strong> 所致</dd>
<dd>致病：褐黄病</dd>
</dl>
<h4 id="糖代谢病">糖代谢病 <a class="markdownIt-Anchor" href="#糖代谢病">#</a></h4>
<ol>
<li><strong>半乳糖血症</strong>：<strong>1-磷酸半乳糖尿苷转移酶</strong></li>
<li><strong>糖原贮积症</strong> ：糖原降解或生成过程中某些酶活性的缺乏，如 Ⅰ 型是由于 <strong>葡糖糖-6-磷酸酶</strong> 缺乏</li>
</ol>
<h4 id="脂类代谢病">脂类代谢病 <a class="markdownIt-Anchor" href="#脂类代谢病">#</a></h4>
<ol>
<li><strong>戈谢氏（Gaucher）病</strong>：<strong>β-葡萄糖苷脂酶</strong></li>
<li><strong>Tay-Sachs 病</strong>（GM<sub>2</sub> 神经节苷脂病Ⅰ型）：氨基己糖苷酶 A</li>
</ol>
<h4 id="嘌呤代谢病">嘌呤代谢病 <a class="markdownIt-Anchor" href="#嘌呤代谢病">#</a></h4>
<p><strong>Lesch-Nyhan 综合征</strong>（LNS）/自毁容貌综合征：X 连锁隐性遗传病，**次黄嘌呤鸟嘌呤磷酸核糖转移酶（HGPRT）**缺乏</p>
<h4 id="葡萄糖-6-磷酸脱氢酶缺乏症">葡萄糖 6-磷酸脱氢酶缺乏症 <a class="markdownIt-Anchor" href="#葡萄糖-6-磷酸脱氢酶缺乏症">#</a></h4>
<dl>
<dt>葡萄糖 6-磷酸脱氢（G6PD）</dt>
<dd>磷酸己糖旁路、产生 NADPH、保持 <strong>谷胱甘肽</strong> 和 <strong>巯基</strong> 水平</dd>
<dd>服用 <strong>伯胺喹呤</strong>、<strong>蚕豆</strong> 可致发病</dd>
</dl>
]]></content>
  </entry>
  <entry>
    <title>动物源性细菌</title>
    <url>/2021/04/19/%E5%8A%A8%E7%89%A9%E6%BA%90%E6%80%A7%E7%BB%86%E8%8F%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>医学免疫学</title>
    <url>/2021/04/25/%E5%8C%BB%E5%AD%A6%E5%85%8D%E7%96%AB%E5%AD%A6/</url>
    <content><![CDATA[<dl>
<dt>免疫</dt>
<dd>机体识别和清除外来环境入侵抗原和体内的突变或衰老细胞，维持机体内环境稳定的功能。</dd>
</dl>
<span id="more"></span>
<ul>
<li><a href="/2021/04/26/%E5%85%8D%E7%96%AB%E5%99%A8%E5%AE%98%E5%92%8C%E7%BB%84%E7%BB%87/">免疫器官和组织</a></li>
<li><a href="/2021/04/30/%E6%8A%97%E5%8E%9F/">抗原</a>、<a href="/2021/05/10/%E6%8A%97%E4%BD%93/">抗体</a></li>
<li><a href="/2021/05/17/%E8%A1%A5%E4%BD%93%E7%B3%BB%E7%BB%9F/">补体系统</a></li>
<li><a href="/2021/05/21/%E7%BB%86%E8%83%9E%E5%9B%A0%E5%AD%90/">细胞因子</a></li>
<li>主要组织相容性复合体</li>
</ul>
<h2 id="免疫系统的组成">免疫系统的组成 <a class="markdownIt-Anchor" href="#免疫系统的组成">#</a></h2>
<ul>
<li>免疫器官
<ul>
<li>中枢：胸腺、骨髓</li>
<li>外周：脾脏、淋巴结</li>
</ul>
</li>
<li>免疫细胞：T 细胞、B 细胞、NK 细胞……</li>
<li>免疫分子
<ul>
<li>膜型分子</li>
<li>分泌型分子</li>
</ul>
</li>
</ul>
<h2 id="免疫系统的基本功能">免疫系统的基本功能 <a class="markdownIt-Anchor" href="#免疫系统的基本功能">#</a></h2>
<dl>
<dt><mark>免疫防御</mark>（immune defense）</dt>
<dd>防止病原体入侵及清除已入侵病原体及其他有害物质。</dd>
<dt><mark>免疫监视</mark>（immune surveillance）</dt>
<dd>随时发现和清除体内出现的“非己”成分。</dd>
<dt><mark>免疫自稳</mark>（immune homeostasis）</dt>
<dd>通过 <strong>免疫耐受</strong> 和 <strong>免疫调节</strong> 两种重要机制来达到机体内环境的稳定。</dd>
</dl>
<h2 id="免疫应答的种类">免疫应答的种类 <a class="markdownIt-Anchor" href="#免疫应答的种类">#</a></h2>
<dl>
<dt>免疫应答（immune response）</dt>
<dd>免疫系统识别和清除“非己”物质的整个过程，可分为 <strong>固有免疫</strong> 和 <strong>适应性免疫</strong>。</dd>
<dt>固有免疫（innate immune）| 先天性免疫（natural immune or native immune）| 非特异性免疫（non-specific immune）</dt>
<dd>生物在长期进化过程中形成的，是机体抵御病原体入侵的第一道防线。</dd>
<dt>适应性免疫（adaptive immune）| 特异性免疫（specific immune）</dt>
<dd>T、B 细胞接受“非己”物质刺激后，自身活化、增殖、分化为 <strong>效应细胞</strong>，产生一系列生物学效应的全过程。</dd>
<dd>相比固有免疫，有三个主要特点：
<ul>
<li><strong>特异性</strong></li>
<li><strong>耐受性</strong></li>
<li><strong>记忆性</strong></li>
</ul>
</dd>
<dd>适应性免疫应答可分为两类：
<ul>
<li><strong>体液免疫</strong></li>
<li><strong>细胞免疫</strong></li>
</ul>
</dd>
<dt>体液免疫（humoral immunity）</dt>
<dd>由 B 细胞产生的抗体介导，主要针对细胞外病原体和毒素。</dd>
<dt>细胞免疫（cellular immunity）| 细胞介导的免疫（cell-mediated immunity）</dt>
<dd>由 T 细胞介导，主要针对胞内病原体，如病毒。</dd>
</dl>
<p>固有免疫和适应性免疫关系密切：固有免疫是适应性免疫的 <strong>先决条件</strong> 和
<strong>启动因素</strong>；适应性免疫的效应分子也可大幅度 <strong>促进</strong> 固有免疫应答。</p>
<h2 id="免疫性疾病">免疫性疾病 <a class="markdownIt-Anchor" href="#免疫性疾病">#</a></h2>
<!-- UPDATING -->
<dl>
<dt>免疫性疾病</dt>
<dd>免疫系统的组成和功能发生异常导致的疾病。</dd>
<dd>包括免疫缺陷病、超敏反应、自身免疫病、肿瘤、移植排斥反应等。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>医学免疫学</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>医学免疫学</tag>
      </tags>
  </entry>
  <entry>
    <title>化脓性细菌</title>
    <url>/2021/03/25/%E5%8C%96%E8%84%93%E6%80%A7%E7%BB%86%E8%8F%8C/</url>
    <content><![CDATA[<p><a href="/2021/03/21/%E7%BB%86%E8%8F%8C/#细胞壁">革兰氏阳性菌</a></p>
<ul>
<li><a href="#%E8%91%A1%E8%90%84%E7%90%83%E8%8F%8C">葡萄球菌</a></li>
<li><a href="#%E9%93%BE%E7%90%83%E8%8F%8C">链球菌</a></li>
<li><a href="#%E8%82%BA%E7%82%8E%E9%93%BE%E7%90%83%E8%8F%8C">肺炎链球菌</a></li>
</ul>
<p><a href="/2021/03/21/%E7%BB%86%E8%8F%8C/">革兰氏阴性菌</a></p>
<ul>
<li>奈瑟菌属
<ul>
<li><a href="#%E8%84%91%E8%86%9C%E7%82%8E%E5%A5%88%E7%91%9F%E8%8F%8C">脑膜炎奈瑟菌</a></li>
<li><a href="#%E6%B7%8B%E7%97%85%E5%A5%88%E7%91%9F%E8%8F%8C">淋病奈瑟菌</a></li>
</ul>
</li>
<li><a href="#%E9%93%9C%E7%BB%BF%E5%81%87%E5%8D%95%E8%83%9E%E8%8F%8C">铜绿假单胞菌</a></li>
</ul>
<span id="more"></span>
<h2 id="葡萄球菌">葡萄球菌 <a class="markdownIt-Anchor" href="#葡萄球菌">#</a></h2>
<h3 id="生物学性状">生物学性状 <a class="markdownIt-Anchor" href="#生物学性状">#</a></h3>
<p>形态与染色：球型，葡萄串状，革兰氏染色阳姓（G<sup>+</sup>）</p>
<h4 id="培养特性和生化反应">培养特性和生化反应 <a class="markdownIt-Anchor" href="#培养特性和生化反应">#</a></h4>
<ul>
<li>易培养：普通平板、血平板</li>
<li>脂溶性色素，根据色素颜色分为三类：
<ul>
<li>金黄色：<strong>金黄色葡萄球菌</strong>，可在血平板上产生 <strong>β 溶血环</strong></li>
<li>白色：<em>表皮葡萄球菌</em>或<em>腐生葡萄球菌</em></li>
<li>柠檬色：<em>腐生葡萄球菌</em></li>
</ul>
</li>
</ul>
<p>生化反应</p>
<ul>
<li>触媒（过氧化氢酶）试验阳性：<strong>鉴别</strong></li>
<li>耐盐性强，在 10%~15% 的培养基上仍能生长：选择培养基</li>
<li>金黄色葡萄球菌：
<ul>
<li><strong>血浆凝固酶阳性</strong></li>
<li>分解甘露醇（甘露醇发酵）</li>
</ul>
</li>
</ul>
<dl>
<dt>血浆凝固酶试验</dt>
<dd>鉴别是否为致病性葡萄球菌</dd>
<dt><mark>葡萄球菌 A 蛋白（staphylococcal protein A，SPA）</mark></dt>
<dd>存在于致病性的金黄色葡萄球菌的细胞壁上，具有属特异性，化学本质为单链多肽</dd>
<dd>介导了葡萄球菌的多种细胞行为</dd>
</dl>
<img data-src="/2021/03/25/%E5%8C%96%E8%84%93%E6%80%A7%E7%BB%86%E8%8F%8C/SPA.png" class="" title="SPA" alt="SPA">
<ul>
<li>与人和动物的免疫球蛋白 G（IgG）的 <em>Fc 段</em>非特异性结合，从而抑制吞噬细胞的调理吞噬作用</li>
<li>临床上可以用具有 SPA 的葡萄球菌作为载体进行<strong>协同凝聚试验</strong></li>
</ul>
<h4 id="抵抗力">抵抗力 <a class="markdownIt-Anchor" href="#抵抗力">#</a></h4>
<div class="note info"><p>葡萄球菌是无芽孢细菌中抵抗力最强的细菌。</p>
</div>
<ul>
<li>对碱性染料（龙胆紫）敏感</li>
<li>易产生耐药性，特别对青霉素（能产生青霉素酶）</li>
</ul>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="致病物质">致病物质 <a class="markdownIt-Anchor" href="#致病物质">#</a></h4>
<ol>
<li>菌体成分
<ol>
<li>荚膜</li>
<li>SPA</li>
<li>磷壁酸</li>
<li>肽聚糖</li>
</ol>
</li>
<li><s>侵袭性</s>酶
<ol>
<li><strong>凝固酶</strong>：鉴别有无致病性的重要指标
<ul>
<li>抵抗吞噬细胞的吞噬</li>
<li>保护病菩不受血清中杀菌物质的破坏</li>
<li>使感染局限化和形成血栓</li>
</ul>
</li>
<li>触媒：将 H<sub>2</sub>O<sub>2</sub> 分解为 H<sub>2</sub>O 和 O<sub>2</sub>，保护细菌免遭吞噬细胞杀伤</li>
<li><strong>青霉素酶</strong>：引起 β-酰胺类抗生素耐药</li>
</ol>
</li>
<li>毒素
<ol>
<li>细胞毒素</li>
<li><strong>毒性休克综合征毒素-1（TSST-1）</strong></li>
<li><strong>表皮脱落毒素</strong></li>
<li><strong>肠毒素</strong></li>
</ol>
</li>
</ol>
<h4 id="所致疾病">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病">#</a></h4>
<p>侵袭性：病灶一般比较局限</p>
<ul>
<li>皮肤化脓性感染</li>
<li>内脏器官感染</li>
<li>全身感染</li>
</ul>
<p>毒素性</p>
<ul>
<li>食物中毒（急性胃肠炎）：呕吐症状突出</li>
<li>毒性休克综合征（TSS）</li>
<li>葡萄球菌烫伤样皮肤综合征（SSSS）/脱落性皮炎</li>
<li>假膜性肠炎</li>
</ul>
<h3 id="预防和治疗">预防和治疗 <a class="markdownIt-Anchor" href="#预防和治疗">#</a></h3>
<p>首选<strong>万古霉素</strong></p>
<div class="note warning"><p>已发现万古霉素耐药的葡萄球菌。</p>
</div>
<h2 id="链球菌">链球菌 <a class="markdownIt-Anchor" href="#链球菌">#</a></h2>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>形态与染色：球形，链状排列，革兰染色阳性（G<sup>+</sup>）</li>
<li>抗原结构与分类
<ul>
<li>细胞壁多糖抗原：A～H、K～T、U、V 共 20 群</li>
<li>根据表面抗原，A 群可分为 100 型</li>
</ul>
</li>
<li>培养特性和生化反应
<ul>
<li>营养要求高：<strong>血（琼脂）平板</strong>或血清培养基</li>
<li>液体培养为沉淀生长</li>
<li>在血平板表面为灰白色表面光滑小菌落，不同菌株溶血不一</li>
<li>生化反应
<ul>
<li>分解葡萄糖</li>
<li>不分解菊糖，不被胆汁溶解（鉴别<mark>甲型溶血性链球菌</mark>与肺炎链球菌（都是 α 溶血））</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>根据溶血现象可分为三类</p>
<table>
<thead>
<tr>
<th>溶血现象</th>
<th>名称</th>
<th>类别</th>
<th>致病性</th>
</tr>
</thead>
<tbody>
<tr>
<td>草绿色溶血</td>
<td>α 溶血</td>
<td>甲型溶血性链球菌</td>
<td>多为条件致病菌</td>
</tr>
<tr>
<td>完全溶血</td>
<td>β 溶血</td>
<td>乙型溶血性链球菌</td>
<td>致病性强</td>
</tr>
<tr>
<td>不溶血</td>
<td>γ 溶血</td>
<td>丙型链球菌</td>
<td>无致病性</td>
</tr>
</tbody>
</table>
<h3 id="致病性与免疫性-2">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-2">#</a></h3>
<p><strong>A 群菌</strong>对人类致病，多数呈<em>乙型溶血</em></p>
<h4 id="致病物质-2">致病物质 <a class="markdownIt-Anchor" href="#致病物质-2">#</a></h4>
<p>A 群链球菌的致病物质</p>
<ol>
<li>菌体致病成分
<ol>
<li>M 蛋白：有抗吞噬和抗吞噬细胞内杀菌作用，与某些<strong>超敏反应性疾病</strong>有关</li>
<li>F 蛋白：粘附素，有利于细菌在宿主体内定植和繁殖</li>
<li>脂磷壁酸 | LTA：黏附作用</li>
<li>透明质酸荚膜：免疫逃逸</li>
</ol>
</li>
<li>外毒素
<ol>
<li>链球菌溶素</li>
<li>链球菌致热外毒素</li>
</ol>
</li>
<li>侵袭性酶类：有利于细胞<strong>播散</strong>
<ol>
<li>透明质酸酶：扩散因子</li>
<li>链激酶</li>
<li>链道酶</li>
</ol>
</li>
</ol>
<dl>
<dt>链球菌溶素</dt>
<dd>溶解破坏白细胞、血小板和红细胞，形成 <mark>β 溶血环</mark></dd>
</dl>
<ol>
<li>链球菌溶素 O（SLO）：对 O<sub>2</sub> 敏感，抗原性强</li>
<li>链球菌溶素 S（SLS）：对 O<sub>2</sub> 稳定，抗原性骏</li>
</ol>
<dl>
<dt>链球菌致热外毒素 | SPE | 红疹毒素 | 猩红热毒素</dt>
<dd>引起<strong>猩红热</strong>的主要物质；可导致毒性休克综合征</dd>
</dl>
<h4 id="所致疾病-2">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-2">#</a></h4>
<ol>
<li>化脓性感染</li>
<li>中毒性疾病：猩红热、毒性休克综合征</li>
<li><strong>超敏反应性疾病</strong> | 感染后遗症：风湿热、急性肾小球肾炎</li>
</ol>
<h3 id="预防和治疗-2">预防和治疗 <a class="markdownIt-Anchor" href="#预防和治疗-2">#</a></h3>
<p>首选<strong>青霉素</strong></p>
<h2 id="肺炎链球菌">肺炎链球菌 <a class="markdownIt-Anchor" href="#肺炎链球菌">#</a></h2>
<dl>
<dt>肺炎链球菌 | 肺炎球菌</dt>
<dd>常寄居于健康人体的鼻咽腔内，多数不致病或致病性弱，少数致病。</dd>
<dd>是<em>细菌性肺炎</em>的主要病原体</dd>
</dl>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<ul>
<li>形态与染色：双球菌，矛头状（平面相对，尖面相背），革兰氏染色阳性（G<sup>+</sup>），<mark>有厚荚膜</mark>，无鞭毛</li>
<li>抗原结构和分类
<ul>
<li>荚膜多糖抗原
<ul>
<li>可分为 90 多型</li>
<li>致病的血清型有 20 多型（<strong>8～10</strong> 个较常见）：造成 2/3 的成年人肺炎链球菌感染</li>
</ul>
</li>
<li>菌体抗原：C 多糖、M 蛋白</li>
</ul>
</li>
<li>抵抗力
<ul>
<li>较弱：对一般的化学消毒剂、多种抗生素（青霉素、红霉素）敏感</li>
<li>抗干燥——厚荚膜</li>
</ul>
</li>
<li>培养特性和生化反应
<ul>
<li><strong>血平板</strong>培养，呈 α 溶血，菌落与甲型链球菌相似，能自溶（<mark>自溶酶</mark>）</li>
<li>生化反应（鉴别<mark>甲型溶血性链球菌</mark>与肺炎链球菌（都是 α 溶血））
<ul>
<li>（<em>胆汁溶菌试验</em>阳性）胆汁、胆盐激活自溶酶，使菌体溶解</li>
<li>（<em>菊糖发酵试验</em>阳性）能分解菊糖</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="致病性与免疫性-3">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-3">#</a></h3>
<p>内源性感染，大多数感染都是由自身口咽部肺炎球菌向远处波及而引起</p>
<h4 id="致病物质-3">致病物质 <a class="markdownIt-Anchor" href="#致病物质-3">#</a></h4>
<ol>
<li>荚膜（主要）：抵抗吞噬细胞的吞噬作用</li>
<li>肺炎链球菌溶素 O：溶解红细胞，抑制中性粒细胞，引起发热、炎症、组织损伤</li>
</ol>
<h4 id="所致疾病-3">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-3">#</a></h4>
<p>单纯的炎症，细菌不会产生毒力因子，易治疗，无后遗症</p>
<ul>
<li>非侵袭性
<ul>
<li><strong>大叶性肺炎</strong></li>
<li>中耳炎、鼻窦炎……</li>
</ul>
</li>
<li>侵袭性
<ul>
<li>菌血症：脑膜炎、心内膜炎、阑尾炎……</li>
</ul>
</li>
</ul>
<h4 id="免疫性">免疫性 <a class="markdownIt-Anchor" href="#免疫性">#</a></h4>
<p>机体产生<em>荚膜多糖型特异抗体</em>，建立<em>同型免疫</em></p>
<h3 id="预防和治疗-3">预防和治疗 <a class="markdownIt-Anchor" href="#预防和治疗-3">#</a></h3>
<ul>
<li>预防——疫苗：23 个型别的<em>多价肺炎链球菌荚膜多糖疫苗</em>
<ul>
<li>小于两岁：推荐 7 价疫苗</li>
<li>高风险成年人：推荐 23 价疫苗</li>
</ul>
</li>
<li>治疗——抗生素：首选<em>青霉素 G</em></li>
</ul>
<h2 id="脑膜炎奈瑟菌">脑膜炎奈瑟菌 <a class="markdownIt-Anchor" href="#脑膜炎奈瑟菌">#</a></h2>
<dl>
<dt>脑膜炎奈瑟菌 | 脑膜炎球菌</dt>
<dd><strong>流行性脑脊髓膜炎</strong>的第二常见病原菌（第一为<mark>肺炎球菌</mark>），属于奈瑟菌属</dd>
</dl>
<h3 id="奈瑟菌属">奈瑟菌属 <a class="markdownIt-Anchor" href="#奈瑟菌属">#</a></h3>
<p>仅有<a href="#%E8%84%91%E8%86%9C%E7%82%8E%E5%A5%88%E7%91%9F%E8%8F%8C">脑膜炎奈瑟菌</a>和<a href="#%E6%B7%8B%E7%97%85%E5%A5%88%E7%91%9F%E8%8F%8C">淋病奈瑟菌</a>对人致病</p>
<img data-src="/2021/03/25/%E5%8C%96%E8%84%93%E6%80%A7%E7%BB%86%E8%8F%8C/%E5%A5%88%E7%91%9F%E8%8F%8C%E5%B1%9E.png" class="" title="奈瑟菌属" alt="奈瑟菌属">
<ul>
<li>形态与染色：革兰氏阴性，双球菌，无鞭毛，无芽孢，有菌毛</li>
<li>培养特性和生化反应
<ul>
<li>5%~10% CO<sub>2</sub></li>
<li>巧克力色培养基</li>
<li>Thayer-Martin medium</li>
</ul>
</li>
</ul>
<img data-src="/2021/03/25/%E5%8C%96%E8%84%93%E6%80%A7%E7%BB%86%E8%8F%8C/Neisseria_gonorrhoeae.png" class="" title="Neisseria_gonorrhoeae" alt="Neisseria_gonorrhoeae">
<dl>
<dt>巧克力（色）血琼脂培养基</dt>
<dd>经 80℃ 以上加温的血琼脂培养基</dd>
<dt>Thayer-Martin 培养基 | Thayer-Martin 琼脂 | VPN 琼脂</dt>
<dd>含有 5% 巧克力羊血和抗生素（如万古霉素可抑制 G<sup>+</sup> 菌的生长）的 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTXVlbGxlci1IaW50b25fYWdhcg==">Mueller-Hinton琼脂<i class="fa fa-external-link-alt"></i></span></dd>
</dl>
<h3 id="生物学特性-3">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-3">#</a></h3>
<ul>
<li>形态与染色：革兰氏染色阴性，双球菌，肾形或咖啡豆形</li>
<li>抗原结构和分类
<ul>
<li>荚膜多糖抗原：分 13 个<strong>群</strong>，跟人类疾病密切相关的是 A，B，C，Y，W135 五个群；A，C 在我国多见</li>
<li>外膜蛋白抗原：分<strong>型</strong>和<strong>亚型</strong>，A 群外膜蛋白抗原相同</li>
<li><strong>脂寡糖</strong>抗原</li>
</ul>
</li>
<li>抵抗力：极弱，接种时要注意保护</li>
<li>培养特性和生化反应
<ul>
<li>专性需氧菌，5%~10% CO<sub>2</sub></li>
<li>巧克力（色）血琼脂培养基上形成露珠状菌落</li>
<li>能产生自溶酶，人工培养超过 48h，不及时转种易裂解自溶</li>
</ul>
</li>
</ul>
<dl>
<dt>脂寡糖 | LOS</dt>
<dd>缺乏长的多糖侧链而只有寡聚糖单位的<strong>脂多糖</strong></dd>
</dl>
<h3 id="致病性与免疫性-4">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-4">#</a></h3>
<h4 id="致病物质-4">致病物质 <a class="markdownIt-Anchor" href="#致病物质-4">#</a></h4>
<ol>
<li>荚膜</li>
<li>外膜蛋白</li>
<li>IgA1 蛋白酶</li>
<li>菌毛</li>
<li>内毒素：脂寡糖</li>
</ol>
<h4 id="所致疾病-4">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-4">#</a></h4>
<blockquote>
<p>人类是脑膜炎球菌的<strong>唯一宿主</strong></p>
</blockquote>
<dl>
<dt>流行性脑脊髓膜炎 | 流脑 | 化脓性脑脊髓膜炎</dt>
<dd>流行性的脑膜炎球菌性脑膜炎或脑脊髓膜炎，属于脑膜炎球菌病的一种</dd>
<dd>致病过程
<ol>
<li>黏附于鼻咽部，局部感染，上呼吸道症状</li>
<li>侵入血液，引起菌血症或败血症</li>
<li>到达脑脊髓膜，致病</li>
</ol>
</dd>
<dd>三种临床类型
<ol>
<li>普通型</li>
<li>爆发型</li>
<li>慢性败血症型（脑膜炎球菌血症）</li>
</ol>
</dd>
</dl>
<h3 id="免疫性-2">免疫性 <a class="markdownIt-Anchor" href="#免疫性-2">#</a></h3>
<p>体液免疫为主</p>
<h3 id="预防和治疗-4">预防和治疗 <a class="markdownIt-Anchor" href="#预防和治疗-4">#</a></h3>
<p>防治原则</p>
<ul>
<li>关键是要尽快消除传染源、切断传播途径及提高人群免疫力</li>
<li>儿童注射流脑荚膜多糖疫苗进行特异性预防（A 群多糖菌苗）</li>
</ul>
<p>治疗使用<strong>抗生素</strong></p>
<h2 id="淋病奈瑟菌">淋病奈瑟菌 <a class="markdownIt-Anchor" href="#淋病奈瑟菌">#</a></h2>
<dl>
<dt>淋病奈瑟菌 | 淋球菌</dt>
<dd>人类<strong>淋病</strong>的病原菌，属于<strong>奈瑟菌属</strong></dd>
</dl>
<h3 id="生物学特性-4">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-4">#</a></h3>
<ul>
<li>形态与染色：革兰氏染色阴性，双球菌，肾形或咖啡豆形，有菌毛和荚膜</li>
<li>抗原结构和分类</li>
<li>抵抗力：同<a href="#%E8%84%91%E8%86%9C%E7%82%8E%E5%A5%88%E7%91%9F%E8%8F%8C">脑膜炎奈瑟菌</a></li>
<li>培养特性和生化反应
<ul>
<li>专性需氧菌，5%~10% CO<sub>2</sub></li>
<li>巧克力（色）血琼脂培养基</li>
<li><em>氧化酶阳性</em></li>
</ul>
</li>
</ul>
<h3 id="致病性与免疫性-5">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-5">#</a></h3>
<h4 id="致病物质-5">致病物质 <a class="markdownIt-Anchor" href="#致病物质-5">#</a></h4>
<ol>
<li><strong>菌毛</strong>：无菌毛的菌株是无毒的</li>
<li>外膜蛋白</li>
<li>IgA 蛋白酶</li>
<li>脂寡糖</li>
</ol>
<h4 id="所致疾病-5">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-5">#</a></h4>
<dl>
<dt>淋病</dt>
<dd>一种感染淋病双球菌所导致的性传染病。
<ul>
<li>男性常见症状包括排尿灼热、阴茎开口流脓、睾丸疼痛等，有可能并发<strong>副睾炎</strong>。</li>
<li>女性的常见症状一样是排尿灼热、伴随阴道异常分泌物、不正常出血，甚至是骨盆疼痛，有时甚至会导致骨盆发炎的并发症。</li>
<li>如果淋病并未正确治疗，导致反复感染，少数情况可能会造成败血性关节炎或是心内膜炎。</li>
</ul>
</dd>
</dl>
<ul>
<li>人类是淋病奈瑟菌的唯一宿主</li>
<li>淋病主要通过<mark>性接触</mark>传播</li>
<li>无症状的携带者是主要的传染源（10% 的男性感染者和 80% 的女性感染者无明显症状）</li>
</ul>
<dl>
<dt>新生儿淋菌性结膜炎 | 新生儿脓漏眼</dt>
<dd>由患有淋菌性阴道炎或宫颈炎的孕妇在分娩时经产道（<em>垂直传播</em>）传染给胎儿</dd>
</dl>
<h4 id="免疫性-3">免疫性 <a class="markdownIt-Anchor" href="#免疫性-3">#</a></h4>
<ul>
<li>人类无天然抵抗力，免疫产生后不持久</li>
<li>感染后多数可<em>自愈</em></li>
</ul>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<ul>
<li>标本
<ul>
<li>无菌绵拭沾取<em>泌尿生殖道脓性分泌物</em>或<em>子宫颈口表面分泌物</em></li>
<li>标本采集后应注意保暖保湿，立即送检接种</li>
</ul>
</li>
<li>直接涂片镜检：<strong>男性患者</strong>（女性生殖道存在正常菌群）的标本在中性粒细胞内（多形核白细胞）发现有革兰阴性双球菌时，有诊断价值</li>
<li>分离培养与鉴定
<ul>
<li>Thayer-Martin 培养基</li>
<li>5%~10% CO<sub>2</sub></li>
<li>革兰阴性，氧化酶阳性的菌落→淋病奈瑟菌</li>
</ul>
</li>
</ul>
<h3 id="预防和治疗-5">预防和治疗 <a class="markdownIt-Anchor" href="#预防和治疗-5">#</a></h3>
<p>治疗</p>
<ul>
<li>抗生素</li>
<li>新生儿 1% 硝酸银滴眼</li>
</ul>
<h2 id="铜绿假单胞菌">铜绿假单胞菌 <a class="markdownIt-Anchor" href="#铜绿假单胞菌">#</a></h2>
<dl>
<dt>铜绿假单胞菌 | 绿脓杆菌</dt>
<dd>是一种革兰氏阴性菌，属于<strong>假单胞菌属</strong>，好氧、呈长棒形的细菌，只有单向的运动性，是<strong>机会性致病菌</strong>
<ul>
<li>10% 的正常人携带于结肠内</li>
<li>广泛分布于环境中，尤其是水里，是<mark>医源性感染</mark>的主要（10～20%）病原体</li>
</ul>
</dd>
</dl>
<h3 id="生物学特性-5">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-5">#</a></h3>
<ul>
<li>形态与染色
<ul>
<li>革兰氏阴性，直或微弯杆菌，有荚膜，单极鞭毛，运动活泼</li>
</ul>
</li>
<li>抵抗力：强于其他革兰氏阴性菌，在恶劣的环境下也可存活</li>
<li>培养特性和生化反应
<ul>
<li>专性需氧，4℃ 不生长，37～42℃ 生长</li>
<li>可散发出水果味，玉米味</li>
<li>带荧光的绿色<em>水溶性</em>色素</li>
<li>能产生溶血环</li>
</ul>
</li>
</ul>
<h3 id="致病性与免疫性-6">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-6">#</a></h3>
<h4 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h4>
<ul>
<li>几乎可感染人体的任何组织和部位</li>
<li>表现为局部和全身化脓性炎症</li>
<li>婴儿：流行性腹泻</li>
</ul>
<p>易感人群</p>
<ul>
<li>皮肤粘膜损伤</li>
<li>机体免疫力下降病人</li>
<li>下置导管者</li>
</ul>
<h3 id="预防和治疗-6">预防和治疗 <a class="markdownIt-Anchor" href="#预防和治疗-6">#</a></h3>
<ul>
<li>预防：伤口、手术器械等严格消毒</li>
<li>治疗
<ul>
<li>多种耐药，必须进行药敏试验</li>
<li>庆大霉素、多粘菌素等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>单基因遗传病</title>
    <url>/2021/04/28/%E5%8D%95%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/</url>
    <content><![CDATA[<dl>
<dt>单基因病（single gene disease, monogenic disease）| 孟德尔（式）遗传病</dt>
<dd>受一对等位基因控制的遗传病，其遗传遵循孟德尔遗传定律。</dd>
<dt>基因座（locus）</dt>
<dd>一条染色体上的特定位置，每个基因座上存在有特定的基因。</dd>
<dt>等位基因（allele）</dt>
<dd>同源染色体生同一基因座上的基因。</dd>
</dl>
<p>同源染色体上成对的等位基因相同的个体称为 <strong>纯合子</strong>（homozygote），该基因座是 <em>纯合性</em>（homozygous）的；否则该个体为 <strong>杂合子</strong>（heterozygote），该基因座是 <em>杂合性</em>（heterozygous）的。<br/>
在杂合子情况下表现出来的性状为 <strong>显性</strong>（dominant），为表现出来的为 <strong>隐性</strong>（recessive）。</p>
<dl>
<dt>基因型（genotype）</dt>
<dd>一个个体的基因结构或组成，也可指一个基因做伤的等位基因。</dd>
<dt>表（现）型（phenotype）</dt>
<dd>生物某一特定的物理外观或成分，为基因型与环境相互作用的结果。</dd>
</dl>
<span id="more"></span>
<dl>
<dt>复合杂合子</dt>
<dd>一个特定位点伤有 <em>两个不同突变</em> 等位基因的个体。</dd>
</dl>
<div class="note warning"><p>隐性遗传病的杂合子（复合杂合子）也可能表现出症状。</p>
</div>
<dl>
<dt>双重杂合子</dt>
<dd>在 <em>两个不同位点上</em> 每个位点各带有一种突变基因的个体。</dd>
</dl>
<details class="note info"><summary><p>系谱绘制</p>
</summary>
<dl>
<dt>系谱（pedigree）</dt>
<dd>从 <strong>先证者</strong> 入手，追溯调查其家系所有成员的 <strong>亲属关系</strong> 以及某种遗传病的 <strong>发病情况</strong>（或某种性状的分布），用特定的符号按一定方式绘制而成的图解。</dd>
<dt>先证者（proband）</dt>
<dd>某个家庭中首先被医生或遗传研究者发现的罹患某种遗传病的患者或者具有某种遗传性状的成员。</dd>
</dl>

</details>
<h2 id="常染色体显性遗传病">常染色体显性遗传病 <a class="markdownIt-Anchor" href="#常染色体显性遗传病">#</a></h2>
<p><strong>常染色体显性遗传</strong>（Autosomal Dominant，<abbr title="Autosomal Dominant，常染色体显性">AD</abbr>）病遗传特点：</p>
<ul>
<li>连续遗传；</li>
<li>男女发病概率相等；</li>
<li>患者双亲必有一方患病；</li>
<li>患者同胞中将有 1/2 概率患病，患者的正常同胞后代都正常；</li>
<li>患者后代中将有 1/2 概率患病。</li>
</ul>
<h3 id="常染色体显性遗传的不同类型">常染色体显性遗传的不同类型 <a class="markdownIt-Anchor" href="#常染色体显性遗传的不同类型">#</a></h3>
<h4 id="完全显性">完全显性 <a class="markdownIt-Anchor" href="#完全显性">#</a></h4>
<dl>
<dt>完全显性（complete dominance）</dt>
<dd>纯合子患者（AA）和杂合子患者（Aa）表型上无差别，如 <em>并指 Ⅰ 型</em>（syndactyly type Ⅰ）（MIM185900）。</dd>
</dl>
<h4 id="不完全显性">不完全显性 <a class="markdownIt-Anchor" href="#不完全显性">#</a></h4>
<dl>
<dt>不完全显性（incomplete dominance）| 半显性（semidominance）</dt>
<dd>杂合子患者（Aa）表型介于纯合子患者（AA）和纯合隐性正常人（aa）之间。</dd>
</dl>
<p><strong><mark>家族性高胆固醇血症</mark></strong>（familial hypercholesterolemia）（MIM143890）/ 高脂蛋白血症 Ⅱ 型是一种常染色体不完全显性遗传病，患者多为杂合子。<br/>
该病由细胞膜上 <strong>低密度脂蛋白受体</strong>（low density lipoprotein receptor，LDLR）遗传性缺陷所致，患者血清内 <strong>胆固醇</strong> 增高，约 50% 患者出现 <strong>黄瘤</strong>（xanthomas），较早出现 <strong>角膜弓</strong>（corneal arcus）（老人环），40~60 岁可患 <strong>冠心病</strong>。<br/>
纯合子患者血清胆固醇显著升高，可在儿童期发生冠心病，20~30 岁死于心肌梗死或猝死。</p>
<h4 id="共显性">共显性 <a class="markdownIt-Anchor" href="#共显性">#</a></h4>
<dl>
<dt>共显性（co-dominance）</dt>
<dd>一对等位基因之间没有显性和隐性的区别，杂合状态下分别表达产物。</dd>
<dt>复等位基因（multiple allele）</dt>
<dd>某基因座上，在群体中有两个以上的等位基因。</dd>
</dl>
<p><strong>ABO 血型</strong>（ABO blood group）（MIM616093）由一组复等位基因 <em>I<sup>A</sup></em>、<em>I<sup>B</sup></em> 和 <em>i</em> 所控制。</p>
<p class="align-text-center table-caption ">
      ABO 血型
    </p>
<table>
<thead>
<tr>
<th style="text-align:center">表型</th>
<th style="text-align:center">红细胞抗原</th>
<th style="text-align:center">血清中的抗体</th>
<th style="text-align:center">基因型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">A</td>
<td style="text-align:center">抗 B 抗体</td>
<td style="text-align:center"><em>I<sup>A</sup>I<sup>A</sup></em>，<em>I<sup>A</sup>i</em></td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">B</td>
<td style="text-align:center">抗 A 抗体</td>
<td style="text-align:center"><em>I<sup>B</sup>I<sup>B</sup></em>，<em>I<sup>B</sup>i</em></td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">—</td>
<td style="text-align:center">抗 A 抗体、抗 B 抗体</td>
<td style="text-align:center"><em>ii</em></td>
</tr>
<tr>
<td style="text-align:center">AB</td>
<td style="text-align:center">A、B</td>
<td style="text-align:center">—</td>
<td style="text-align:center"><em>I<sup>A</sup>I<sup>B</sup></em></td>
</tr>
</tbody>
</table>
<h4 id="不规则显性">不规则显性 <a class="markdownIt-Anchor" href="#不规则显性">#</a></h4>
<dl>
<dt>不规则显性（irregular dominance）</dt>
<dd>可以表现或不表现出相应的表型，且表现程度不同。</dd>
<dd>是由于决定表型的主基因之外，基因组中的其他基因（<strong>遗传背景</strong>）不同造成的，<strong>修饰基因</strong> 对主基因及表型有显著效应。</dd>
</dl>
<p>不规则显性常见原因：</p>
<ul>
<li><em><strong>外显率</strong> 降低</em>（decreased penetrance），如 <strong>遗传性红斑性肢痛病</strong>（MIM133020）</li>
<li><em><strong>表现度</strong> 不一致</em>（variable expressivity），如 <strong>Marfan 综合征</strong>、<strong>神经纤维瘤 1 型</strong></li>
</ul>
<dl>
<dt>外显率（penetrance）</dt>
<dd>一个群体中带有某一致病基因的个体，表型出相应疾病表型的比率。</dd>
<dt>表现度（expressivity）</dt>
<dd>致病基因在不同个体的表达程度，即患病的严重程度。</dd>
</dl>
<hr />
<p><strong>Marfan 综合征</strong>（Marfan syndrome）（MIM154700）由 <strong>肌原纤维蛋白基因</strong>（<em>FBN1</em>）突变引起，同时还受到环境因素和 <strong>遗传背景</strong> 的影响。<br/></p>
<p>患者主要受累器官为 <em>骨骼系统</em>、<em>眼</em> 和 <em>心血管系统</em>：</p>
<ul>
<li>骨骼系统：身材高、体瘦、四肢细长、<strong>鸡胸或漏斗胸</strong>、脊柱侧凸、手指细长（<strong>蜘蛛样指</strong>）</li>
<li>眼：晶状体脱位、高度近视、白内障</li>
<li>心血管系统：二尖瓣功能障碍、主动脉瘤（可引起猝死）</li>
</ul>
<p>决定表型的主基因外的其他基因对该主基因而言即是 <strong>遗传背景</strong>。遗传背景中的 <strong>修饰基因</strong>（modified gene）对主基因、对表型的形成有显著效应（增强或减弱）。</p>
<hr />
<p><strong>神经纤维瘤 1 型</strong>（neurofibromatosis 1，NF1）（MIM162200）的致病基因 <em>NF1</em> 定位于 17q11.2 但其表现度不一致的原因尚且不明。<br/>
患者的症状逐渐加重：</p>
<ul>
<li>轻度：皮肤黑褐色斑点（<strong>牛奶咖啡斑</strong>）；眼部虹膜上，有良性 <strong>错构瘤结节</strong>（Lisch nodule）；</li>
<li>中度：表皮和皮下 <strong>神经纤维瘤</strong>（常沿着神经生长）；</li>
<li>重度：高度脉管丛状的神经纤维瘤侵润周围组织，引起 <strong>严重畸形</strong> 并伴有功能障碍；</li>
</ul>
<h4 id="延迟显性">延迟显性 <a class="markdownIt-Anchor" href="#延迟显性">#</a></h4>
<dl>
<dt>延迟显性（delayed dominance）</dt>
<dd>在生命早期致病基因不表达，达到 <strong>一定年龄后</strong> 才表现出疾病。</dd>
</dl>
<div class="tabs" id="延迟显性遗传病"><ul class="nav-tabs"><li class="tab active"><a href="#延迟显性遗传病-1">多囊肾病</a></li><li class="tab"><a href="#延迟显性遗传病-2">亨亭顿舞蹈症</a></li></ul><div class="tab-content"><div class="tab-pane active" id="延迟显性遗传病-1"><p><strong>多囊肾病</strong>（Polycystic kidney disease 1，<abbr title="Polycystic kidney disease 1，多囊肾病">PKD1</abbr>）特征是双侧肾肿大，并有许多囊肿、血尿、高血压、腹痛和进行性肾衰竭，许多患者直到 40 岁甚至更晚才出现临床症状。</p></div><div class="tab-pane" id="延迟显性遗传病-2"><p><strong><mark>Huntington 病</mark></strong>（Huntington disease，<abbr title="Huntington disease，Huntington 病，亨亭顿舞蹈症">HD</abbr>）（<strong>亨亭顿舞蹈症</strong>）是一种进行性神经病变，临床表现为 <strong>进行性不自主舞蹈样动作</strong>。该病通常 30~40 岁发病，最终演变为 <strong>痴呆</strong>。<br/>
<abbr title="Huntington disease，Huntington 病，亨亭顿舞蹈症">HD</abbr> 是由于 <a href="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/?highlight=动态突变#动态突变"><strong><mark>动态突变</mark></strong></a> 引起的。<abbr title="Huntington disease，Huntington 病，亨亭顿舞蹈症">HD</abbr> 的致病基因为 4p16.3 上的 <em>HTT</em>，其 5’ 端有 (CAG)<sub>n</sub> 三核苷酸重复，正常人重复拷贝数范围为 9~34 次，患者的重复拷贝数扩展到 37~100 次。<br/></p>
<p>如果 <em>HTT</em> 是由父亲传来的，患者可在 20 岁之前发病且病情严重；若是从母亲传来的，则多在 40 岁以后发病且病情轻，这种现象称为 <strong>遗传印记</strong>。</p>
<details class="note info"><summary><p>遗传印记</p>
</summary>
<dl>
<dt>遗传印记（genetic imprinting）</dt>
<dd>由于基因来自来自父方或母方而产生不同表型的现象。</dd>
<dd>是一种依赖于配子起源的某些等位基因的修饰现象，一些基因在精子/卵子的形成过程中被印记（如甲基化），表达受到影响。</dd>
</dl>
<p>如 <strong>染色体 15q11-q13 缺失</strong>：其中数个基因在男、女性体内表现状态（有无活性）不同</p>
<ul>
<li>父源：<strong>Prader-Willi 综合征</strong>（PWS）</li>
<li>母源：<strong>Angelman 综合征</strong>（AS）</li>
</ul>
</details></div></div></div>
<h4 id="遗传早现">遗传早现 <a class="markdownIt-Anchor" href="#遗传早现">#</a></h4>
<dl>
<dt>遗传早现（genetic anticipation）</dt>
<dd>某些遗传病（通常为显性遗传病）在连续世代传递中，患者发病年龄逐代 <strong>提前</strong>，病情逐渐 <strong>加重</strong> 的现象，分子基础是 <a href="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/?highlight=动态突变#动态突变"><strong><mark>动态突变</mark></strong></a>。</dd>
</dl>
<p><strong>强直性肌营养不良</strong>（dystrophy myotonic，DM）主要特征为 <strong>肌无力</strong>，从面部开始，逐渐遍及全身，从肌无力或肌强直直到肌肉收缩松弛，可累及心肌和平滑肌，与早期白内障、免疫球蛋白异常有关，并伴有轻度智力低下。<br/>
该病致病基因为定位于 19q13 的 <strong>肌强直蛋白激酶</strong>（dystrophia myotonia protein kinase，<em>DMPK</em>），其 3’ 非翻译区存在 (GCT)<sub>n</sub> 或 (CTG)<sub>n</sub> 三核苷酸重复，患者拷贝重复次数超过 50 次，甚至可达 1000 次以上。<br/>
在 <strong>女性减数分裂</strong> 中，重复拷贝数扩增明显。</p>
<h4 id="从性遗传">从性遗传 <a class="markdownIt-Anchor" href="#从性遗传">#</a></h4>
<dl>
<dt>从性遗传（sex-influenced inheritance）</dt>
<dd>表达受性别的影响，在某一性别表达出相应表型，在另一性别则不表达相应表型，或者在某一性别的发病率远高于另一性别。</dd>
</dl>
<p><strong>秃顶</strong>（baldness）男性杂合子表现秃顶症状，而女性杂合子仅表现为头发稀疏而不表现秃顶症状。<br/>
秃顶从性遗传是因为基因表达受性别的影响，可能与 <strong>雄性激素</strong> 的作用有关。</p>
<h2 id="常染色体隐性遗传病">常染色体隐性遗传病 <a class="markdownIt-Anchor" href="#常染色体隐性遗传病">#</a></h2>
<dl>
<dt>常染色体隐性遗传（autosomal recessive, <abbr title="autosomal recessive，常染色体隐性遗传">AR</abbr>）病</dt>
<dd>致病基因位于 1~22 号染色体上，只有致病基因的纯合子个体才发病。</dd>
</dl>
<details class="note info"><summary><p>遗传异质性</p>
</summary>
<dl>
<dt>遗传异质性（genetic heterogeneity）</dt>
<dd>相同或相似的表型可以有不同的遗传基础所决定。</dd>
<dt>等位基因异质性（allele heterogeneity）</dt>
<dd>同一基因的 <strong>不同突变</strong> 引起的相同或相似的表型。</dd>
<dt>基因座异质性（locus heterogeneity）</dt>
<dd><strong>不同基因座上</strong> 的不同基因突变引起的相同或相似的表型。</dd>
</dl>

</details>
<dl>
<dt>携带者（carrier）</dt>
<dd>「狭义」表型正常，但是携带致病基因，并可将致病基因遗传给下一代。</dd>
</dl>
<h3 id="ar-系谱特征"><abbr title="autosomal recessive，常染色体隐性遗传">AR</abbr> 系谱特征 <a class="markdownIt-Anchor" href="#ar-系谱特征">#</a></h3>
<ul>
<li>患者同胞发病风险的统计往往比理论的 1/4 高：<strong>不完全确认</strong>；</li>
<li>近亲婚配明显提告 <abbr title="autosomal recessive，常染色体隐性遗传">AR</abbr> 遗传病的发病风险。</li>
</ul>
<img data-src="/2021/04/28/%E5%8D%95%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%A1%AE%E8%AE%A4.png" class="" title="不完全确认" alt="不完全确认">
<details class="note warning"><summary><p>近亲婚配和亲缘系数</p>
</summary>
<p><strong>近亲婚配</strong> 会明显提高 AR 遗传病的患病风险。</p>
<dl>
<dt>近亲婚配（Consanguineous Mating）</dt>
<dd>在 3~4 代之内有共同祖先的个体之间的婚配。</dd>
<dt><mark>亲缘系数</mark>（coefficient of relationship）</dt>
<dd>有共同祖先的两个人，在某一基因座上带有相同基因（由共同祖先传递来）的概率。</dd>
</dl>
<table>
<thead>
<tr>
<th>亲属类型</th>
<th style="text-align:center">亲属级别</th>
<th style="text-align:center">亲缘系数</th>
</tr>
</thead>
<tbody>
<tr>
<td>单卵双生子</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>父母-子女</td>
<td style="text-align:center">一级</td>
<td style="text-align:center">1/2</td>
</tr>
<tr>
<td>兄弟姐妹（同胞）</td>
<td style="text-align:center">一级</td>
<td style="text-align:center">1/2</td>
</tr>
<tr>
<td>半同胞（同父异母/同母异父）</td>
<td style="text-align:center">二级</td>
<td style="text-align:center">1/4</td>
</tr>
<tr>
<td>叔侄女、姨外甥</td>
<td style="text-align:center">二级</td>
<td style="text-align:center">1/4</td>
</tr>
<tr>
<td>一级表亲</td>
<td style="text-align:center">三级</td>
<td style="text-align:center">1/8</td>
</tr>
</tbody>
</table>

</details>
<h3 id="ar-遗传病举例"><abbr title="autosomal recessive，常染色体隐性遗传">AR</abbr> 遗传病举例 <a class="markdownIt-Anchor" href="#ar-遗传病举例">#</a></h3>
<ul>
<li><strong>苯丙酮尿症</strong>（Phenylketonuria，<abbr title="Phenylketonuria，苯丙酮尿症">PKU</abbr>）：<strong>苯丙氨酸羟化酶</strong>（phenylalanine hydroxylase，<abbr title="phenylalanine hydroxylase，苯丙氨酸羟化酶">PAH</abbr>）遗传性缺陷</li>
<li><strong>白化病 ⅠA 型</strong>（albinism type ⅠA）：<strong>酪氨酸酶</strong>（tyrosinase）遗传性缺陷</li>
<li><strong>先天性聋哑 Ⅰ 型（Congenital Deafness type Ⅰ）</strong></li>
</ul>
<p>部分先天性聋哑并非由遗传因素造成的，而是由于环境因素的影响所致，与 <abbr title="autosomal recessive，常染色体隐性遗传">AR</abbr> 引起的先天性聋哑表型相同，这是一种 <strong>表型模拟</strong> 现象。</p>
<dl>
<dt>表型模拟（phenocopy）| 拟表型</dt>
<dd>由于 <em>环境因素</em> 的作用使个体的表型与某一特定基因所产生的表型相同或相似，不遗传给后代。</dd>
</dl>
<h2 id="x-连锁隐性遗传病">X 连锁隐性遗传病 <a class="markdownIt-Anchor" href="#x-连锁隐性遗传病">#</a></h2>
<dl>
<dt>X 连锁隐性遗传（X-linked recessive inheritance，<abbr title="X-linked recessive inheritance，X 连锁隐性遗传">XR</abbr>）病</dt>
<dd>致病基因位于 X 染色体上，只有致病基因的纯合子个体才发病。</dd>
</dl>
<dl>
<dt>半合子（hemizygote）</dt>
<dd>男性只有一条 X 染色体，因此，X 染色体上的基因只有成对等位基因中的一个，因此称为 <em>半合子</em>。</dd>
<dt>交叉遗传（cross inheritance）</dt>
<dd>男性的 X 染色体由母亲传递，Y 染色体由父亲传递，因此，<em>男性 X 连锁基因只能从母亲传来，将来只能传给他的女儿</em>，不存在由男性向男性的传递。</dd>
</dl>
<h3 id="xr-系谱特征"><abbr title="X-linked recessive inheritance，X 连锁隐性遗传">XR</abbr> 系谱特征 <a class="markdownIt-Anchor" href="#xr-系谱特征">#</a></h3>
<ol>
<li>群体中男性患者远多于女性患者；</li>
<li>男性患者的致病基因由携带者母亲传来（新生突变除外），其母亲再生育，儿子 1/2 概率患病，女儿表型都正常，但 1/2 的概率是携带者；</li>
<li>由于交叉遗传，患者之间往往是兄弟、姨表兄弟、舅父与外甥、外祖父与外孙等关系；</li>
<li>在一些极少的情况下，<abbr title="X-linked recessive inheritance，X 连锁隐性遗传">XR</abbr> 遗传病可以观察到女性患者。</li>
</ol>
<p>出现 <em>女患者</em> 的原因：</p>
<ol>
<li>群体中致病基因频率高；</li>
<li>罕见性染色体病，如 <a href="/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/#turner-综合征">Turner 综合征</a>；</li>
<li>X 染色体和常染色体间易位；</li>
<li><a href="/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/#lyon-假说">莱昂（Lyon）化</a>程度的不同可导致杂合子女性表现出 <abbr title="X-linked recessive inheritance，X 连锁隐性遗传">XR</abbr> 遗传病的临床特征；</li>
<li><a href="?highlight=%E9%81%97%E4%BC%A0%E5%BC%82%E8%B4%A8%E6%80%A7#%E5%B8%B8%E6%9F%93%E8%89%B2%E4%BD%93%E9%9A%90%E6%80%A7%E9%81%97%E4%BC%A0%E7%97%85">遗传异质性</a>：临床特征与 <abbr title="X-linked recessive inheritance，X 连锁隐性遗传">XR</abbr> 遗传病不能区别，被误认为 <abbr title="X-linked recessive inheritance，X 连锁隐性遗传">XR</abbr> 遗传病。</li>
</ol>
<h3 id="xr-遗传病举例"><abbr title="X-linked recessive inheritance，X 连锁隐性遗传">XR</abbr> 遗传病举例 <a class="markdownIt-Anchor" href="#xr-遗传病举例">#</a></h3>
<ul>
<li><strong>甲型血友病</strong>（Hemophilia A）</li>
<li><strong>Duchenne 型肌营养不良症</strong>：较 <abbr title="Becker muscular dystrophy，Backer 型肌营养不良症">BMD</abbr> 型病情较重，患者 <strong>腓肠肌假性肥大</strong>、从卧位到站立表现有 <strong><mark>Gower 征</mark></strong></li>
</ul>
<details class="note info"><summary><p>假肥大型肌营养不良症</p>
</summary>
<p>假肥大型肌营养不良症包括 Duchenne 和 Becker 两种类型，都是由相同的 <strong>抗肌萎缩蛋白</strong>（<em>Dystrophin</em>）基因突变所致（<a href="?highlight=%E7%AD%89%E4%BD%8D%E5%9F%BA%E5%9B%A0%E5%BC%82%E8%B4%A8%E6%80%A7%20%E9%81%97%E4%BC%A0%E5%BC%82%E8%B4%A8%E6%80%A7#%E5%B8%B8%E6%9F%93%E8%89%B2%E4%BD%93%E9%9A%90%E6%80%A7%E9%81%97%E4%BC%A0%E7%97%85">等位基因异质性</a>）。</p>
<ul>
<li><strong>Duchenne 型肌营养不良症</strong>（Duchenne muscular dystrophy，DMD）：发病早，病情重，抗肌萎缩蛋白不表达或表达无功能的蛋白</li>
<li><strong>Backer 型肌营养不良症</strong>（Becker muscular dystrophy，BMD）：发病晚、病情轻，抗肌萎缩蛋白质量减少或蛋白质长度变化</li>
</ul>

</details>
<p><abbr title="Duchenne muscular dystrophy，Duchenne 型肌营养不良症">DMD</abbr> 的致病基因 <em><abbr title="Duchenne muscular dystrophy，Duchenne 型肌营养不良症">DMD</abbr></em> 基因克隆是 <strong>定位克隆</strong>（positional cloning）的典型例子。</p>
<details class="note default"><summary><p>定位克隆</p>
</summary>
<p>在其他信息未知的情况下，将与某一表型相关的基因定位于染色体的某一位点并进一步缩小候选区域，根据这一位置信息再从相关区域的“邻接克隆群”（contig）中筛选可表达的结构基因，然后比较正常人和患者结构基因的区别，即在患者的结构基因中筛查出突变，最终确定疾病相关基因。</p>

</details>
<h2 id="x-连锁显性遗传病">X 连锁显性遗传病 <a class="markdownIt-Anchor" href="#x-连锁显性遗传病">#</a></h2>
<dl>
<dt>X 连锁显性遗传（X-linked dominant inheritance，<abbr title="X-linked dominant inheritance，X 连锁显性遗传">XD</abbr>）病</dt>
<dd>致病基因位于 X 染色体上，致病基因的杂合子女性即可表现为疾病。</dd>
</dl>
<h3 id="xd-系谱特征"><abbr title="X-linked dominant inheritance，X 连锁显性遗传">XD</abbr> 系谱特征 <a class="markdownIt-Anchor" href="#xd-系谱特征">#</a></h3>
<ol>
<li>群体中女性患者多于男性患者，通常约为男性患者的 2 倍，但女性患者的病情通常比男性轻；</li>
<li>患者双亲中必有一方患病；</li>
<li>由于 [交叉遗传](?highlight=交叉遗传#X 连锁隐性遗传病)，<strong>男性患者的女儿全部患病，儿子则全部正常</strong>；女性患者（杂合子）的子女各有 1/2 的概率患病；</li>
<li>家系中可见到连续遗传现象。</li>
</ol>
<h3 id="xd-遗传病举例"><abbr title="X-linked dominant inheritance，X 连锁显性遗传">XD</abbr> 遗传病举例 <a class="markdownIt-Anchor" href="#xd-遗传病举例">#</a></h3>
<p><strong>抗维生素 D 佝偻病</strong>（vitamin D-resistant rickets）/ <strong>低磷酸盐血症</strong>（hypophosp-hatemic rickets）：尿磷增多，血磷下降，肠道对钙、磷吸收不良，引起 <strong>佝偻病</strong>。</p>
<h2 id="y-连锁遗传病">Y 连锁遗传病 <a class="markdownIt-Anchor" href="#y-连锁遗传病">#</a></h2>
<dl>
<dt>Y 连锁遗传（Y-linked inheritance）病</dt>
<dd>致病基因位于 Y 染色体，随染色体在上下代之间传递。</dd>
</dl>
<p>Y 连锁遗传病表现为 <strong>全男性遗传</strong>（holandric inheritance），男性的 Y 染色体只能由父亲传来，将来只能传给他的儿子，再由儿子传递给孙子。</p>
<ul>
<li><strong>无精子因子</strong>（azoospermia factor，AZF）</li>
<li><strong>多毛耳</strong></li>
</ul>
<h2 id="线粒体遗传病">线粒体遗传病 <a class="markdownIt-Anchor" href="#线粒体遗传病">#</a></h2>
<h3 id="线粒体-dna-的遗传特征">线粒体 DNA 的遗传特征 <a class="markdownIt-Anchor" href="#线粒体-dna-的遗传特征">#</a></h3>
<p><strong>线粒体 DNA</strong>（mitochondrial DNA，<strong>mtDNA</strong>）的遗传特征：</p>
<ol>
<li><strong>半自主性</strong></li>
<li>线粒体基因组所用 <em>遗传密码</em> 和通用密码不同，</li>
<li><em>母系遗传</em></li>
<li>复制分离、<strong>遗传瓶颈</strong></li>
<li><strong>杂质性</strong> 与 <strong>阈值效应</strong></li>
<li>突变率极高</li>
</ol>
<dl>
<dt>遗传瓶颈（genetic bottleneck）</dt>
<dd>卵母细胞经减数分裂成熟过程中，线粒体数目从 100,000 锐减至 100 个以下的过程。</dd>
</dl>
<p>纯质性和杂质性：</p>
<ul>
<li><strong>纯质性</strong>（homoplasmy）：一个细胞或组织中所有的染色体具有相同的基因型；</li>
<li><strong>杂质性</strong>（heteroplasmy）：一个细胞或组织中既含有突变型又含有野生型线粒体基因组。</li>
</ul>
<p>mtDNA 存在 <strong>阈值效应</strong>，在 <em>异质性</em> 细胞中，突变的 mtDNA 达到一定比例时，细胞便不足以产生足够的能量以致出现异常表型，即 <em>线粒体病</em>。</p>
<h3 id="常见线粒体遗传病">常见线粒体遗传病 <a class="markdownIt-Anchor" href="#常见线粒体遗传病">#</a></h3>
<div class="tabs" id="常见染色体病"><ul class="nav-tabs"><li class="tab active"><a href="#常见染色体病-1">Leber 遗传性视神经病</a></li><li class="tab"><a href="#常见染色体病-2">MERRF 综合征</a></li><li class="tab"><a href="#常见染色体病-3">MELAS 综合征</a></li><li class="tab"><a href="#常见染色体病-4">KSS 病</a></li></ul><div class="tab-content"><div class="tab-pane active" id="常见染色体病-1"><p><strong><mark>Leber 遗传性视神经病</mark></strong>（Leber’s hereditary optic neuropathy，<abbr title="Leber's hereditary optic neuropathy，Leber 遗传性视神经病">LHON</abbr>）是一种急性或亚急性发作的母系遗传病，首发症状为中央视物模糊，进而在几个月内出现无痛性完全或接近完全的失明，通常在 20~30 岁发作，男性患者远多于女性患者。</p></div><div class="tab-pane" id="常见染色体病-2"><p><em>肌阵挛性癫痫伴破碎红纤维病</em>（myoclonus epilepsy and ragged-red fibers，MERRF）/ <strong>MERRF 综合征</strong> 具有多系统紊乱的症状，包括肌阵挛性癫痫的短暂发作、共济失调、<strong>肌细胞</strong> 减少、轻度 <strong>痴呆</strong>、<strong>耳聋</strong>、脊髓神经的退化等。<br/>
当神经或肌肉细胞中 90% 的线粒体存在突变（<strong>异质性</strong>），就会出现典型的 MERRF 症状。</p></div><div class="tab-pane" id="常见染色体病-3"><p><em>线粒体肌病脑病伴乳酸酸中毒及中风样发作综合征</em>（mitochondrial encephalomyopathy with lactic acidosis and stroke-like episodes，MELAS）/ 是 <em>最常见</em> 的母系遗传线粒体疾病，临床特点包括 40 岁以前就开始出现的复发性休克、肌病、共济失调、肌阵挛、痴呆和耳聋。<br/>
突变的 <strong>异质性</strong> 达到 40%~50% 时，就可能出现慢性进行性眼外肌麻痹、肌病和耳聋；<em>异质性</em> 达到 ≥ 90% 时，复发性休克、痴呆、癫痫共济失调等症状出现的风险增加。</p></div><div class="tab-pane" id="常见染色体病-4"><p>KSS 病（Kearns-Sayre Syndrome）又称 <em>慢性进行性眼肌麻痹和视网膜色素变性</em>，多由 mtDNA 缺失引起，临床表现包括眼肌麻痹、眼睑下垂、 四肢肌病、视网膜色素变性、心肌传导异常、共济失调、 耳聋、痴呆和糖尿病等。</p></div></div></div>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>呼吸道感染病毒</title>
    <url>/2021/04/26/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<dl>
<dt>呼吸道感染病毒</dt>
<dd>主要以呼吸道为传播途径，侵犯呼吸道黏膜上皮细胞，引起呼吸道局部病变或以呼吸道为敲入门户，导致呼吸道外组织病变的病毒。</dd>
</dl>
<blockquote>
<p>急性呼吸道感染中 90%~95% 是由病毒引起的。</p>
</blockquote>
<span id="more"></span>
<details class="note info"><summary><p>引起普通感冒的常见病毒</p>
</summary>
<ul>
<li>普通感冒中 50% 由<strong>鼻病毒</strong>引起。</li>
<li>冠状病毒</li>
</ul>

</details>
<h2 id="流行性感冒病毒">流行性感冒病毒 <a class="markdownIt-Anchor" href="#流行性感冒病毒">#</a></h2>
<details class="note info"><summary><p>流感和普通感冒的不同点</p>
</summary>
<ul>
<li>病原体：腮腺炎病毒、冠状病毒、呼吸道合胞病毒、鼻病毒</li>
<li>临床表现：发热、三痛（痛、眼、肌肉关节）</li>
<li>传染性：强</li>
<li>流行性：流行范围广，可引起大流行</li>
</ul>

</details>
<dl>
<dt>流行性感冒病毒 | 流感病毒</dt>
<dd>属于正黏病毒科，分为甲（A）、乙（B、）丙（C）三个型。</dd>
<dd>流行性感冒病毒的复制在<strong>细胞核</strong>中进行，出芽释放。</dd>
</dl>
<div class="note info"><dl>
<dt>正黏病毒科（Orthomyxoviridae）</dt>
<dd>与人的呼吸道黏膜蛋白亲合力强、有包膜、遗传物质为分节段的的一类负链 RNA 病毒。</dd>
<dd>希腊文 Orthos 有“正确，直”之意；myxo 有“粘液”之意。</dd>
</dl>
</div>
<ul>
<li>甲型流感病毒：抗原易变异，引起<strong>流感大流行</strong></li>
<li>乙型流感病毒：一定程度的变异，局部小流行</li>
<li>并型流感病毒：抗原稳定，主要感染婴幼儿</li>
</ul>
<details class="note info"><summary><p>流感大流行</p>
</summary>
<dl>
<dt>流感大流行</dt>
<dd>系指新型流感的出现引起全世界范国大规模的流行。</dd>
<dd>人类在上个世纪就曾经历过 3 次这样的流行：
<ol>
<li>1918 年，西班牙流感</li>
<li>1957 年，亚洲流感</li>
<li>1968 年，香港流感</li>
</ol>
</dd>
</dl>

</details>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>形态与染色：球型或丝状，有包膜</li>
<li>分类
<ul>
<li>分型：核蛋白、基质蛋白 M1</li>
<li>分亚型：血凝素（H1~17）、神经氨酸酶（N1~10）</li>
</ul>
</li>
<li>抵抗力：弱，对热、消毒剂菌敏感</li>
</ul>
<div class="note warning"><p>一般有包膜的病毒抵抗力较弱。</p>
</div>
<p>流感病毒的 RNA 分节段，甲型、乙型有 8 节段，丙型有 7 节段。</p>
<details class="note info"><summary><p>流感病毒的抗原性变异</p>
</summary>
<dl>
<dt>抗原漂移（antigen drift）</dt>
<dd>变异幅度小，由点突变造成</dd>
<dd>连续累积后形成亚型内变异，引起流感中、小流行</dd>
<dt>抗原转换（antigen shift）</dt>
<dd>变异幅度大，由基因重组或重配造成</dd>
<dd>导致新亚型的形成，引起<strong>流感大流行</strong></dd>
</dl>

</details>
<details class="note info"><summary><p>禽类和猪</p>
</summary>
<p><strong>流感病毒的储存库</strong> 所有哺乳动物的流感病毒均来源于禽类。</p>
<p><strong>基因混合器</strong> 猪气管上皮具有禽流感病毒和人流感病毒两种病毒的受体。
当猪受到两种病毒同时感染时，两种病毒间科发生基因重组和重配，导致抗原转换。</p>

</details>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="致病物质">致病物质 <a class="markdownIt-Anchor" href="#致病物质">#</a></h4>
<dl>
<dt>核蛋白（nucleoprotein, NP）</dt>
<dd>抗原性免疫，是流感病毒分型的依据</dd>
<dt>基质蛋白 M1</dt>
<dd>抗原结构稳定，也具有型特异性</dd>
<dt>血凝素（hemagglutinin, HA）</dt>
<dd>一种三棱柱状的糖蛋白，具有以下功能：
<ul>
<li>凝集红细胞</li>
<li>吸附宿主细胞</li>
<li>具有抗原性</li>
</ul>
</dd>
<dt>神经氨酸酶（neuraminidase, NA）| 唾液酸</dt>
<dd>也是一种糖蛋白，具有以下功能：
<ul>
<li>具有酶活性，参与成熟病毒出芽释放</li>
<li>具有抗原性</li>
</ul>
</dd>
</dl>
<p>血凝素和神经氨酸酶的抗原性皆不稳定，易发生突变，共同划分<strong>甲型流感细胞</strong>亚型。</p>
<details class="note info"><summary><p>抗原性</p>
</summary>
<p>抗原性一般指两方面（详见 <a href="/2021/04/30/%E6%8A%97%E5%8E%9F/#抗原">抗原的基本特征</a>：</p>
<ul>
<li>可刺激机体产生抗原</li>
<li>可作为区分病毒类型的依据</li>
</ul>

</details>
<h4 id="所致疾病">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病">#</a></h4>
<ul>
<li>传染源：患者和隐性感染者</li>
<li>传播途径：呼吸道，<strong>飞沫传播</strong></li>
</ul>
<dl>
<dt>流感 | 流行性感冒</dt>
<dd>全身性症状，发热（38℃~40℃）、头痛、眼眶痛、关节痛。</dd>
<dd>自限性疾病，无并发症者可在 5~7 天内自行恢复；肺炎是其常见并发症。</dd>
</dl>
<h4 id="免疫性">免疫性 <a class="markdownIt-Anchor" href="#免疫性">#</a></h4>
<p>病后对同型有 1~2 年的免疫力，无交叉免疫。</p>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<ol>
<li>取材：急性患者的咽漱液或鼻咽拭子</li>
<li>接种：<strong>鸡胚</strong>（或培养细胞），初次分离用羊膜腔，传代用尿囊腔</li>
<li>鉴定：<strong>红细胞凝集实验</strong>，红细胞吸附实验</li>
</ol>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
<ul>
<li>预防：采取综合措施</li>
<li>疫苗
<ul>
<li><strong>灭活疫苗</strong>：甲醛脱毒；鸡胚培养，对鸡蛋过敏者不适用</li>
<li><strong>减毒活疫苗</strong>：鼻腔</li>
</ul>
</li>
<li>药物治疗：无特效疗法</li>
</ul>
<h2 id="麻疹病毒">麻疹病毒 <a class="markdownIt-Anchor" href="#麻疹病毒">#</a></h2>
<blockquote>
<p>传染性极强，又名“见面传”。</p>
</blockquote>
<div class="note info"><dl>
<dt>副黏病毒（<em>Paramyxoviridae</em>）</dt>
<dd>病毒体较大，抗原性稳定。</dd>
</dl>
</div>
<h3 id="致病性与免疫性-2">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-2">#</a></h3>
<h4 id="所致疾病-2">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-2">#</a></h4>
<ul>
<li>传染源：患者</li>
<li>传播途径：呼吸道</li>
</ul>
<dl>
<dt>麻疹</dt>
<dd>发热、上呼吸道炎、结膜炎、特征性红色斑丘疹，一般可自愈。</dd>
<dd>临床分期：潜伏期、前驱期、出诊期。</dd>
<dd>并发症：肺炎（最常见）、脑炎（最严重）、亚急性硬化性全脑炎</dd>
<dt>亚急性硬化性全脑炎（SSPE）</dt>
<dd>麻疹病毒急性感染后的<strong>迟发并发症</strong>，大脑渐进性衰退，最后发作 1~3 年后昏迷死亡。</dd>
</dl>
<h4 id="免疫性-2">免疫性 <a class="markdownIt-Anchor" href="#免疫性-2">#</a></h4>
<p>病后可获得牢固免疫力。</p>
<h3 id="防治原则-2">防治原则 <a class="markdownIt-Anchor" href="#防治原则-2">#</a></h3>
<p><strong>麻疹病毒减毒活疫苗</strong></p>
<h2 id="腮腺炎病毒">腮腺炎病毒 <a class="markdownIt-Anchor" href="#腮腺炎病毒">#</a></h2>
<h3 id="致病性与免疫性-3">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-3">#</a></h3>
<h4 id="致病物质-2">致病物质 <a class="markdownIt-Anchor" href="#致病物质-2">#</a></h4>
<h4 id="所致疾病-3">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-3">#</a></h4>
<ul>
<li>传染源：患者和隐性感染者</li>
<li>传播途径：飞沫传播、垂直传播（可导致先天畸形）</li>
</ul>
<p>腮腺炎病毒</p>
<ul>
<li>儿童感染：流行性腮腺炎、无菌性脑膜炎</li>
<li>青春期感染：可致不孕不育
<ul>
<li>男性：睾丸炎</li>
<li>女性：卵巢炎</li>
</ul>
</li>
</ul>
<h4 id="免疫性-3">免疫性 <a class="markdownIt-Anchor" href="#免疫性-3">#</a></h4>
<p>只有一个血清型，感染后可获得牢固免疫。</p>
<h3 id="防治原则-3">防治原则 <a class="markdownIt-Anchor" href="#防治原则-3">#</a></h3>
<p>腮腺炎减毒活疫苗</p>
<h2 id="冠状病毒">冠状病毒 <a class="markdownIt-Anchor" href="#冠状病毒">#</a></h2>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<ul>
<li>+ssRNA，衣壳螺旋对称，有包膜、刺突</li>
<li>抵抗力：弱</li>
</ul>
<h3 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h3>
<ul>
<li>传染源：患者和隐性感染者</li>
<li>传播途径：</li>
<li>所致疾病
<ul>
<li>普通型冠状病毒：30% 的普通感冒或腹泻</li>
<li>SARS-CoV</li>
<li>MERS-CoV：消化道症状</li>
<li>2019-nCoV</li>
</ul>
</li>
</ul>
<h3 id="防治原则-4">防治原则 <a class="markdownIt-Anchor" href="#防治原则-4">#</a></h3>
<ul>
<li>无特效治疗方法</li>
</ul>
<h2 id="腺病毒">腺病毒 <a class="markdownIt-Anchor" href="#腺病毒">#</a></h2>
<dl>
<dt>腺病毒</dt>
<dd>DNA 无包膜病毒，可携带其他病毒的有效成分。</dd>
</dl>
<details class="note info"><summary><p>腺病毒载体疫苗</p>
</summary>

</details>
<h3 id="致病性-2">致病性 <a class="markdownIt-Anchor" href="#致病性-2">#</a></h3>
<p>传播途径</p>
<ul>
<li>呼吸道：急性咽炎、普通感冒、病毒型肺炎</li>
<li>眼结膜：流行性眼膜角膜炎，滤泡性结膜炎</li>
<li>消化道：婴幼儿腹泻</li>
</ul>
<h2 id="风疹病毒">风疹病毒 <a class="markdownIt-Anchor" href="#风疹病毒">#</a></h2>
<h3 id="致病性-3">致病性 <a class="markdownIt-Anchor" href="#致病性-3">#</a></h3>
<ul>
<li>传染源：人类是其唯一自然宿主</li>
<li>传播途径：
<ul>
<li>呼吸道：风疹</li>
<li>垂直传播（先天畸形）：婴儿先天性风疹综合征</li>
</ul>
</li>
</ul>
<details class="note info"><summary><p>ToRCH</p>
</summary>
<ul>
<li>T：</li>
<li>o：other</li>
<li>R</li>
<li>C</li>
<li>H</li>
</ul>

</details>
<h3 id="免疫性-4">免疫性 <a class="markdownIt-Anchor" href="#免疫性-4">#</a></h3>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>呼吸道感染细菌</title>
    <url>/2021/04/01/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/</url>
    <content><![CDATA[<dl>
<dt>呼吸道感染细菌</dt>
<dd>能侵犯呼吸道、引起呼吸道局部病变或以呼吸道为侵入门户，引起呼吸道及其他组织器官病变的病原菌。</dd>
</dl>
<ul>
<li>分枝杆菌属
<ul>
<li><a href="#%E7%BB%93%E6%A0%B8%E5%88%86%E6%9E%9D%E6%9D%86%E8%8F%8C">结核分枝杆菌</a></li>
<li><a href="#%E9%BA%BB%E9%A3%8E%E5%88%86%E6%9E%9D%E6%9D%86%E8%8F%8C">麻风分枝杆菌</a></li>
</ul>
</li>
<li>棒状杆菌属
<ul>
<li><a href="#%E7%99%BD%E5%96%89%E6%A3%92%E7%8A%B6%E6%9D%86%E8%8F%8C">白喉棒状杆菌</a></li>
</ul>
</li>
<li>其他
<ul>
<li><a href="#%E7%99%BE%E6%97%A5%E5%92%B3%E9%B2%8D%E7%89%B9%E8%8F%8C">百日咳鲍特菌</a></li>
<li><a href="#%E5%97%9C%E8%82%BA%E5%86%9B%E5%9B%A2%E8%8F%8C">嗜肺军团菌</a></li>
<li><a href="#%E6%B5%81%E6%84%9F%E5%97%9C%E8%A1%80%E6%9D%86%E8%8F%8C">流感嗜血杆菌</a></li>
<li><a href="#%E8%82%BA%E7%82%8E%E5%85%8B%E9%9B%B7%E4%BC%AF%E8%8F%8C">肺炎克雷伯菌</a></li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="结核分枝杆菌">结核分枝杆菌 <a class="markdownIt-Anchor" href="#结核分枝杆菌">#</a></h2>
<dl>
<dt>结核分枝杆菌（<em>M. tuherculosis</em>）| 结核杆菌 | 抗酸杆菌（acid-fast bacilli）</dt>
<dd>属<strong>分枝杆菌属</strong>，可引起人类<strong>结核病</strong>。</dd>
</dl>
<div class="note info"><dl>
<dt>分枝杆菌属（<em>Mycobacterium</em>）</dt>
<dd>一类细长、直或微弯曲的杆菌，有分枝生长趋势的细菌，可呈丝状或菌丝样生长。</dd>
<dd>主要特点
<ul>
<li>细胞壁含有大量脂质（<strong>分枝菌酸</strong>）</li>
<li>能抵抗 3% 盐酸乙醇的脱色作用，呈<strong>抗酸染色阳性</strong></li>
<li>引起疾病都呈慢性（繁殖缓慢），并伴肉芽肿</li>
</ul>
</dd>
<dd>分类
<ol>
<li>结核分<mark>枝杆菌复合群</mark>（主要致病菌）：<strong>结核分枝杆菌</strong>，牛分枝杆菌</li>
<li>非结核分枝杆菌：机会性致病菌，<strong>艾滋病</strong>患者或免疫力低下者易患</li>
<li>麻风分枝杆菌</li>
</ol>
</dd>
</dl>
</div>
<div class="note info"><dl>
<dt>抗酸染色法（acid-fast stain）</dt>
<dd>以 5% 石炭酸复红加温染色，再用 3% 盐酸酒精脱色，然后用美蓝复染。</dd>
<dd>参见：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXVzdGluY2MuZWR1L21pY3JvYnVnei9hY2lkX2Zhc3Rfc3RhaW4ucGhw">https://www.austincc.edu/microbugz/acid_fast_stain.php<i class="fa fa-external-link-alt"></i></span></dd>
<dd>分枝杆菌呈红色（+），其他细菌和背景物质为蓝色（-）</dd>
</dl>
</div>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>形态与染色：细长略带弯曲，分枝状，有荚膜，<strong>抗酸染色阳性</strong></li>
<li>抗原结构和分类</li>
<li>抵抗力
<ul>
<li>抵抗干燥、酸、碱、抗生素</li>
<li>对乙醇、湿热、紫外线、抗痨药物敏感</li>
</ul>
</li>
<li>培养特性（<strong>懒、馋、丑</strong>）
<ul>
<li>专性需氧、生长缓慢、营养要求高，常用<strong>罗氏培养基</strong></li>
<li>在液体培养基中，最终在液体表面生长，形成菌膜；在固体培养基中为颗粒、结节、花菜状菌落，呈乳白或米黄色，不透明</li>
</ul>
</li>
<li>生化反应
<ul>
<li>不发酵糖类</li>
<li>触酶试验阳性，而热触酶试验阴性</li>
</ul>
</li>
<li>变异性
<ul>
<li>形态结构变异：不良环境中可变为<a href="/2021/03/21/%E7%BB%86%E8%8F%8C/#细胞壁">L 型</a></li>
<li>毒力变异：<strong>卡介苗</strong></li>
<li>耐药型变异：耐抗结核药</li>
</ul>
</li>
</ul>
<div class="note info"><dl>
<dt>卡介苗（BCG）</dt>
<dd>Calmette 和 Guerin 将<strong>牛分枝杆菌</strong>经 13 年 230 次传代获得的<strong>减活活疫苗株</strong>。</dd>
</dl>
</div>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="致病物质">致病物质 <a class="markdownIt-Anchor" href="#致病物质">#</a></h4>
<p>只有<strong>菌体成分</strong>（尤其是脂质）</p>
<ul>
<li>荚膜</li>
<li>脂质：索状因子、磷脂、硫酸脑苷脂、腊质 D</li>
<li>菌体蛋白质</li>
</ul>
<h4 id="所致疾病">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病">#</a></h4>
<p>通过呼吸道、消化道或皮肤损伤侵入机体，引起<strong>结核病</strong>，以<em>肺结核</em>最多见</p>
<p>肺部感染</p>
<ul>
<li><strong>原发感染</strong>：外源性感染，初次感染结核分枝杆菌在肺部形成的原发性病灶，多发于儿童</li>
<li><strong>继发感染</strong>：外源或内源性感染，潜伏在原发病灶内或外界再次入侵而引发的感染，多发于成年人</li>
</ul>
<p>肺外感染：<strong>L 型结核分枝杆菌</strong>检出率高于细菌型。</p>
<h4 id="免疫性">免疫性 <a class="markdownIt-Anchor" href="#免疫性">#</a></h4>
<p>机体抗结核免疫特点：<strong>传染、免疫、迟发型超敏反应共存</strong></p>
<p>抗结核免疫主要依靠细胞免疫，属于<strong>感染免疫（infection immunity）</strong>，又称有菌免疫。</p>
<div class="note info"><dl>
<dt>Ⅳ 型超敏反应 | 迟发型超敏反应</dt>
<dd>由<strong>效应性 T 细胞</strong>与相应抗原作用后，引起的以单个核细胞浸润和组织细胞损伤为主要特征的炎症反应。</dd>
<dd>反应时间 48~72h，明显晚于其他 3 个型。</dd>
</dl>
</div>
<details class="note info"><summary><p>结核菌素试剂</p>
</summary>
<dl>
<dt>旧结核菌素（old tuberculin，OT）</dt>
<dd>将结核分枝杆菌接种于甘油肉汤培养基，培养 4~8 周后加热、浓缩过滤制成</dd>
<dt>纯蛋白衍生物（purified protein derivative，PPD）</dt>
<dd>OT 经三氯乙酸沉淀后的纯化物</dd>
</dl>

</details>
<details class="note info"><summary><p>结核菌素试验</p>
</summary>
<dl>
<dt>结核菌素试验（OT 试验）</dt>
<dd>应用<strong>结核菌素</strong>进行皮肤试验来测定机体对结核分枝杆菌是否能引起迟发型超敏反应的一种试验。</dd>
</dl>
<p>方法：前臂皮内注射 <strong>PPD</strong> 5 单位，2~3 天后看红肿硬结直径</p>
<p>意义：</p>
<ul>
<li>&lt;0.5cm 阴性：<strong>无感染</strong>；早期；严重结核；其他感染性疾病；细胞免疫力低下或缺如（AIDS）</li>
<li>0.5~1.5cm 阳性：<strong>感染</strong>；<strong>接种过疫苗</strong></li>
<li>&gt;1.5cm 强阳性：<strong>可能有活动性结核</strong></li>
</ul>

</details>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
<p>预防</p>
<ul>
<li>一般性预防：卫生宣传、提高机体抵抗力</li>
<li>特异性预防：新生儿接种<strong>卡介苗</strong></li>
</ul>
<p>治疗</p>
<ul>
<li>一般治疗：合理营养，注意休息</li>
<li>抗结核药物链震素、异烟肼、利福平等</li>
<li>治疗原则：“早期发现，早期发现，联合用药，彻底治愈”</li>
</ul>
<h2 id="麻风分枝杆菌">麻风分枝杆菌 <a class="markdownIt-Anchor" href="#麻风分枝杆菌">#</a></h2>
<dl>
<dt>麻风分枝杆菌（<em>Mycobacterium leprae</em>）</dt>
<dd>属分枝杆菌属，与<a href="#%E7%BB%93%E6%A0%B8%E5%88%86%E6%9E%9D%E6%9D%86%E8%8F%8C"><strong>结核分枝杆菌</strong></a>同为胞内寄生菌，为<strong>麻风病</strong>的病原菌。</dd>
<dt>麻风细胞 | 泡沫细胞</dt>
<dd>麻风病患者标本图片中、胞质由于麻风分枝杆菌寄生而呈泡沫状的细胞。</dd>
</dl>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<p>形态与染色与<a href="#%E7%BB%93%E6%A0%B8%E5%88%86%E6%9E%9D%E6%9D%86%E8%8F%8C"><strong>结核分枝杆菌</strong></a>相似。</p>
<h3 id="致病性与免疫性-2">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-2">#</a></h3>
<p>传播方式</p>
<ul>
<li><strong>呼吸道</strong></li>
<li>接触传播</li>
</ul>
<p>麻风病，细菌主要侵犯神经、皮肤。麻风病的免疫主要依靠细胞免疫。</p>
<h2 id="白喉棒状杆菌">白喉棒状杆菌 <a class="markdownIt-Anchor" href="#白喉棒状杆菌">#</a></h2>
<dl>
<dt>白喉棒状杆菌（<em>C. diphtheriea</em>）</dt>
<dd>致病性最强的<strong>棒状杆菌属</strong>细菌，可引起人类<strong>白喉病</strong>。</dd>
</dl>
<div class="note info"><dl>
<dt>棒状杆菌属（<em>Corymebacterium</em>）</dt>
<dd>G<sup>+</sup> 菌，一端或两端膨大呈棒状，无荚膜、无鞭毛、不产生芽胞，除<strong>白喉棒状杆菌</strong>外多为机会致病菌。</dd>
</dl>
</div>
<h3 id="生物学特性-3">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-3">#</a></h3>
<ul>
<li>形态与染色：
<ul>
<li>菌体细长微弯，一端或两端膨大呈棒状，常排列呈 V、L 形</li>
<li><strong>奈瑟染色</strong>（Nsisser’s staining）或<strong>阿氏染色</strong>（Albert’s staining）可出现<mark>异染颗粒</mark>，在鉴定时有重要意义</li>
</ul>
</li>
<li>培养特性
<ul>
<li>营养要求高</li>
<li><strong>吕氏血清斜面</strong>上生长迅速、异染颗粒明显</li>
<li>选择鉴别培养基：<strong>亚碲酸钾血平板</strong>，呈黑色菌落；亚碲酸钾能抑制标本中其他细菌的生长</li>
</ul>
</li>
<li>抵抗力
<ul>
<li>抗寒冷和干燥、对湿热抵抗力弱</li>
<li>对常用消毒剂和青霉素及多数广谱抗生素敏感</li>
</ul>
</li>
</ul>
<h3 id="致病性与免疫性-3">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-3">#</a></h3>
<h4 id="致病物质-2">致病物质 <a class="markdownIt-Anchor" href="#致病物质-2">#</a></h4>
<dl>
<dt>自喉外毒素（diphtheria exotoxin）</dt>
<dd>由 <strong>β-棒状杆菌噬菌体</strong>在溶原阶段将其编码外毒素的 tox 基因整合到白喉棒状杆菌染色体上产生。</dd>
<dd>具有强烈的<strong>细胞毒作用</strong>，主要作用于<strong>心肌和神经细胞</strong>，抑制细胞蛋白质的合成而使组织细胞变性、坏死。</dd>
</dl>
<h4 id="所致疾病-2">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-2">#</a></h4>
<p><strong>白喉</strong></p>
<ul>
<li>早期致死原因：白喉外毒素导致咽、喉、气管黏膜<strong>假膜</strong>脱落，引起呼吸道阻塞，甚至窒息死亡</li>
<li>晚期致死原因：心肌炎</li>
</ul>
<h4 id="免疫性-2">免疫性 <a class="markdownIt-Anchor" href="#免疫性-2">#</a></h4>
<p>病后可获得牢固的<strong>体液免疫</strong>，主要是抗毒素中和外毒素。
胎儿可通过母体胎盘被动获得抗毒素。<strong>六月以下新生儿</strong>不易感染，但六月后易感性逐渐增加（1~5 岁易感性最高）。</p>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<ul>
<li>涂片镜检：形态，<strong>异染颗粒</strong></li>
<li><strong>毒力鉴定</strong>（棒状杆菌属多为机会性致病菌）：动物实验、Elek 平板毒力试验<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
</ul>
<img data-src="/2021/04/01/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/Elek%20test.png" class="" title="Elek test" alt="Elek test">
<h3 id="防治原则-2">防治原则 <a class="markdownIt-Anchor" href="#防治原则-2">#</a></h3>
<blockquote>
<p>与破伤风类似</p>
</blockquote>
<p>预防：</p>
<ul>
<li><strong>人工主动免疫</strong>：<strong>白喉类毒素</strong>（<mark>白百破三联疫苗</mark>）</li>
<li><strong>人工被动免疫</strong>：白喉抗毒素</li>
<li>药物预防：如注射青震素或口服红霉素</li>
</ul>
<p>治疗</p>
<ul>
<li>白喉抗毒素
<ul>
<li>早期使用，防止病情进展</li>
<li>注射前做<strong>皮肤试验</strong>，阳性者进行<strong>脱敏治疗</strong></li>
</ul>
</li>
<li>抗生素</li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Freeman, Victor J. “Influence of Type and Concentration of Antitoxin on the in Vitro Toxigenicity Test for C. Diphtheriae.” Public Health Reports (1896-1970), vol. 65, no. 28, 1950, pp. 875–882. JSTOR, <span class="exturl" data-url="aHR0cDovL3d3dy5qc3Rvci5vcmcvc3RhYmxlLzQ1ODc0MDI=">www.jstor.org/stable/4587402<i class="fa fa-external-link-alt"></i></span>. Accessed 14 Apr. 2021. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>器官、系统的发生与先天性畸形</title>
    <url>/2021/04/10/%E5%99%A8%E5%AE%98%E3%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%85%88%E5%A4%A9%E6%80%A7%E7%95%B8%E5%BD%A2/</url>
    <content><![CDATA[<ul>
<li><a href="/2021/05/27/%E9%A2%9C%E9%9D%A2%E3%80%81%E9%A2%88%E5%92%8C%E5%9B%9B%E8%82%A2%E7%9A%84%E5%8F%91%E7%94%9F/">颜面、颈和四肢的发生</a></li>
<li><a href="/2021/05/29/%E6%B6%88%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%91%BC%E5%90%B8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/">消化系统和呼吸系统的发生</a>，<a href="/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/">心血管系统的发生</a></li>
</ul>
<span id="more"></span>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>噬菌体</title>
    <url>/2021/04/22/%E5%99%AC%E8%8F%8C%E4%BD%93/</url>
    <content><![CDATA[<dl>
<dt>噬菌体</dt>
<dd>微生物病毒，可感染<a href="/2021/03/21/%E7%BB%86%E8%8F%8C/" title="细菌">细菌</a>，<a href="/2021/03/21/%E7%9C%9F%E8%8F%8C/" title="真菌">真菌</a>，<a href="/2021/03/16/%E7%97%85%E5%8E%9F%E7%94%9F%E7%89%A9%E5%AD%A6/#微生物">放线菌</a>，</dd>
</dl>
<span id="more"></span>
<dl>
<dt>λ 噬菌体（lambda phage）</dt>
<dd>可在体外包装的一种细菌病毒</dd>
<dd>具有 <strong>cos 序列</strong></dd>
<dd>另见<a href="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/#载体">重组 DNA 的载体</a></dd>
<dt>cos 序列</dt>
<dd>λ DNA 每条链两端都具有的 12bp 长的单链互补序列末端，类似限制酶切的黏性末端，但更具黏性</dd>
<dt>毒性噬菌体</dt>
<dd>能在宿主菌细胞内复制增殖，产生子代噬菌体并最终裂解细菌</dd>
<dt>温和噬菌体</dt>
<dd>噬菌体基因与宿主菌染色体整合，不产生子代噬菌体</dd>
</dl>
<p>毒性噬菌体的复制周期（溶菌性周期）</p>
<ol>
<li>吸附</li>
<li>穿入</li>
<li>生物合成</li>
<li>成熟与释放</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
      </tags>
  </entry>
  <entry>
    <title>多基因遗传病</title>
    <url>/2021/05/14/%E5%A4%9A%E5%9F%BA%E5%9B%A0%E9%81%97%E4%BC%A0%E7%97%85/</url>
    <content><![CDATA[<dl>
<dt>多基因遗传 | 多因子遗传</dt>
<dd>由多对等位基因的 <strong>微效作用</strong> 及 <strong>累积效应</strong> 导致遗传性状或疾病的遗传方式。
<ul>
<li><strong>主基因</strong>（major gene）：起主要作用</li>
<li><strong>微效基因</strong>（minor gene）：起微效作用</li>
</ul>
</dd>
<dd>此外，多基因性状或疾病还受 <strong>环境因素</strong> 的影响。</dd>
</dl>
<blockquote>
<p>一般而言，多基因遗传病没有“致病基因”的说法，取而代之的是“相关基因”。</p>
</blockquote>
<span id="more"></span>
<h2 id="多基因遗传病的特点">多基因遗传病的特点 <a class="markdownIt-Anchor" href="#多基因遗传病的特点">#</a></h2>
<blockquote>
<p>这类疾病是由多个基因相互作用所致，还与不同的环境因素相互作用才发病，因此又称为
<strong>多因素疾病</strong>（multifactorial disease）。</p>
</blockquote>
<ul>
<li><strong>数量性状</strong>，而非质量性状</li>
<li>近似<strong>正态分布</strong></li>
</ul>
<p>多基因遗传规律</p>
<ol>
<li>两个极端变异杂交，子一代都是中间类型，存在变异；</li>
<li>中间表型子一代杂交，子二代多为中间表型，变异范围广泛，可出现极端变异；</li>
<li>随机杂交的群体中，变异范围广泛，大多数接近中间表型，极端变异很少。</li>
</ol>
<h2 id="多基因遗传病的易患性与阈值模式">多基因遗传病的易患性与阈值模式 <a class="markdownIt-Anchor" href="#多基因遗传病的易患性与阈值模式">#</a></h2>
<dl>
<dt>易感性</dt>
<dd>多基因遗传病中，由 <strong>遗传基础</strong> 决定的一个个体患病的风险。</dd>
<dt>易患性</dt>
<dd>多基因遗传病中，由 <strong>遗传因素</strong> 和 <strong>环境因素</strong> 共同决定的一个个体患病的风险。</dd>
<dd>易患性变异呈正态分布。</dd>
<dt>阈值</dt>
<dd>由 <strong>易患性</strong> 决定的多基因遗传病发病的 <strong>最低限度</strong>。</dd>
</dl>
<hr />
<dl>
<dt>遗传性（Heritability，H）</dt>
<dd>多基因遗传的累加效应对疾病易患性的影响。</dd>
<dd>遗传度越大，表明遗传因素对病因的作用越大。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>心血管系统的发生</title>
    <url>/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/</url>
    <content><![CDATA[<p>心血管系统是 <strong>最早</strong> 形成并执行功能的系统，约发生与第 3 周末，至第 4 周末血液循环开始。<br/>
心血管系统由 <strong>中胚层</strong> 分化而来，首先形成原始心血管，再进一步经过生长、合并、扩大和萎缩等过程逐渐完善。</p>
<span id="more"></span>
<details class="note info"><summary><p>重点</p>
</summary>
<ol>
<li>简述 <a href="#%E5%BF%83%E6%88%BF%E7%9A%84%E5%88%86%E9%9A%94">心房的分隔</a>；</li>
<li><a href="?highlight=%E5%8D%B5%E5%9C%86%E5%AD%94#%E5%BF%83%E6%88%BF%E7%9A%84%E5%88%86%E9%9A%94">卵圆孔</a>；</li>
<li>简述 <a href="#%E6%B3%95%E6%B4%9B%E5%9B%9B%E8%81%94%E7%97%87">法洛四联症</a> 的构成及其形成原因；</li>
</ol>

</details>
<h2 id="原始心血管系统的建立">原始心血管系统的建立 <a class="markdownIt-Anchor" href="#原始心血管系统的建立">#</a></h2>
<p>人胚第 2 周末，来自卵黄囊、体蒂和绒毛膜的胚外中胚层增殖分化形成的细胞索或团，称 <strong><mark>血岛</mark></strong>（blood island）。<br/>
不久，血岛周边细胞分化为扁平的内皮细胞，并围成管道，即 <strong>原始血管</strong>；<br/>
血岛中央部的细胞则分化为 <strong>原始血细胞</strong>（primary blood cell），又称 <strong>造血干细胞</strong>。</p>
<p>原始血管不断延伸，相邻血岛形成血管相互连接，形成 <strong>胚外中胚层毛细血管网</strong>。<br/>
随后，胚体各处 <em>间充质</em> 出现裂隙，形成 <strong>胚内毛细血管网</strong>。</p>
<p>第 3 周，胚内和胚外血管相连，形成了由 <strong>心管</strong> 和动静脉组成的 <strong><mark>胚胎早期血管通路</mark></strong>。</p>
<h2 id="心脏的形成">心脏的形成 <a class="markdownIt-Anchor" href="#心脏的形成">#</a></h2>
<h3 id="心脏的发生">心脏的发生 <a class="markdownIt-Anchor" href="#心脏的发生">#</a></h3>
<h4 id="原始心脏的发生">原始心脏的发生 <a class="markdownIt-Anchor" href="#原始心脏的发生">#</a></h4>
<p>第 18~19 天，口咽膜头端中胚层形成 <strong>生心区</strong>（心脏的原基），随后出现腔隙，称为
<strong>围心腔</strong>（pericardiac coelom），以后演变为 <em>心包腔</em>。<br/>
在围心腔腹侧，一些细胞聚集成一对长条状的细胞索，称 <strong>生心索</strong>（cardiogenic cord）。<br/>
生心索中空，形成左右两条纵管，称 <strong>心管</strong>（cardiac tube）。</p>
<p>心管周围间充质逐渐增厚，形成 <strong>心肌外套层</strong>（myoepicardial mantle），以后分化为 <em>心肌膜</em> 和 <em>心外膜</em>。<br/>
心管内皮和心管外套膜之间的疏松组织，称 <strong>心胶质</strong>（cardiac jelly），将参与形成 <em>心内膜</em>。</p>
<h4 id="心脏外形的建立">心脏外形的建立 <a class="markdownIt-Anchor" href="#心脏外形的建立">#</a></h4>
<p>心管由于 <em>各部分不均等生长</em>，形成了三个膨大，从头端至尾端依次为 <strong>心球</strong>（bulbus cordis）、<strong>心室</strong>（ventricle）和 <strong>心房</strong>（atrium）。<br/>
随后心球头端延伸，形成 <strong>动脉干</strong>（truncus arteriosus）；心房尾部膨大，形成 <strong>静脉窦</strong>（sinus venosus）。</p>
<p>心管头、尾端分别与静脉和动脉相连，两端固定于心包。<br/>
心管游离部（心球和心室）由于生长速度大于心包腔的扩大速度而发生弯曲，形成 <strong>“U”形</strong> 的球室袢，进而形成 <strong>“S”形</strong> 弯曲。<br/>
同时，心房由于心球和食管的限制，只能向左、右两侧扩展，膨出于心球的两侧。</p>
<img data-src="/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/%E5%BF%83%E8%84%8F%E5%A4%96%E5%BD%A2%E6%BC%94%E5%8F%98.png" class="" title="心脏外形演变" alt="心脏外形演变">
<h4 id="心脏的内部分隔">心脏的内部分隔 <a class="markdownIt-Anchor" href="#心脏的内部分隔">#</a></h4>
<p>心脏的内部分隔伴随心脏外形建立同时进行。</p>
<h5 id="房室管的分隔">房室管的分隔 <a class="markdownIt-Anchor" href="#房室管的分隔">#</a></h5>
<dl>
<dt>房室管（atrioventricular canal）</dt>
<dd>心房与心室之间的结构，外面观为一窄缩环，内面观为一狭窄管道。</dd>
</dl>
<p>房室管背、腹侧的心内膜组织增厚各形成一个隆起，称 <strong>心内膜垫</strong>（endocardial cushion）。<br/>
两个心内膜垫相对生长，向中间靠拢并融合，见房室管分隔形成左、右房室管，以后演变为 <strong>二尖瓣</strong> 和 <strong>三尖瓣</strong>。</p>
<h5 id="心房的分隔">心房的分隔 <a class="markdownIt-Anchor" href="#心房的分隔">#</a></h5>
<p>心房头端背侧壁正中线处发生一镰状薄膜，称 <strong>第一房间隔</strong>（septum primum）。其下缘与心内膜垫之间暂留一孔，称为 <strong>第一房间孔</strong> / 原发孔（ostium/foramen primum）。<br/>
随后第一房室隔与心内膜垫融合，第一房室孔封闭，但第一房室隔上部中央处同时变薄，并进一步形成 <strong>第二房间孔</strong> / 继发孔（ostium/foramen secundum）。<br/>
同时，于第一房室隔右侧，心房头端腹侧壁发生一镰状、较厚的隔膜，称 <strong>第二房间隔</strong>，其下方留有一孔，称为 <strong>卵圆孔</strong>（foramen ovale），其左侧被第一房间隔覆盖，相当于其瓣膜。</p>
<img data-src="/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/%E5%BF%83%E6%88%BF%E5%88%86%E9%9A%94.png" class="" title="心房分隔" alt="心房分隔">
<p>出生前肺循环未启动，右心房血液通过卵圆孔流入左心房。出生后肺循环开始，左心房压力增大，使第一房间隔与第二房间隔相贴并逐渐融合，卵圆孔即被封闭。</p>
<h5 id="心室的分隔">心室的分隔 <a class="markdownIt-Anchor" href="#心室的分隔">#</a></h5>
<p>首先于心室底部的心尖处，形成一较厚的半月形肌性瓣膜，称 <strong>肌性室间隔</strong>（muscular ventricular septum）。<br/>
肌性室间隔向心内膜垫方向生长，两者之间的孔称为 <strong>室间孔</strong>（interventricular foramen）。<br/>
随后，心球内形成 <strong>左、右心球嵴</strong>，与心内膜垫及肌性室间隔游离缘组织一起形成 <strong>膜性室间隔</strong>（membranous ventricular septum）。</p>
<img data-src="/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/%E8%86%9C%E6%80%A7%E5%AE%A4%E9%97%B4%E9%9A%94%E7%9A%84%E5%BD%A2%E6%88%90.png" class="" title="膜性室间隔的形成" alt="膜性室间隔的形成">
<h5 id="心球与动脉瓣的分隔">心球与动脉瓣的分隔 <a class="markdownIt-Anchor" href="#心球与动脉瓣的分隔">#</a></h5>
<p>心球和动脉干的心内膜组织局部增厚，分别形成一对螺旋状走位、相对生长的 <strong>心球嵴</strong> 和 <strong>肺动脉嵴</strong>。嵴愈合后形成 <strong>主动脉肺动脉隔</strong>（aortico-pulmonary septum）。将心球和动脉干分隔为 <em>主动脉</em> 和 <em>肺动脉</em>。<br/>
在主动脉和肺动脉开口处，心内膜组织局部增厚、隆起，发育为袋状的 <em>半月瓣</em>。</p>
<img data-src="/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/%E5%BF%83%E7%90%83%E5%8F%8A%E5%8A%A8%E8%84%89%E5%B9%B2%E7%9A%84%E5%88%86%E9%9A%94.png" class="" title="心球及动脉干的分隔" alt="心球及动脉干的分隔">
<h2 id="常见畸形">常见畸形 <a class="markdownIt-Anchor" href="#常见畸形">#</a></h2>
<h3 id="房间隔缺损">房间隔缺损 <a class="markdownIt-Anchor" href="#房间隔缺损">#</a></h3>
<ul>
<li>常见部位：<mark>卵圆孔未闭</mark></li>
<li>主要原因：
<ol>
<li>第二房间孔过大或位置异常；</li>
<li>第二房间隔发育异常，卵圆孔过大；</li>
<li>心内膜垫发育不全。</li>
</ol>
</li>
</ul>
<h3 id="室间隔缺损">室间隔缺损 <a class="markdownIt-Anchor" href="#室间隔缺损">#</a></h3>
<ul>
<li>常见部位：<mark>室间隔膜部</mark></li>
<li>主要原因：
<ol>
<li>心内膜垫未与主动脉肺动脉隔、室间隔肌部愈合；</li>
<li>室间隔肌部缺损（较少见）。</li>
</ol>
</li>
</ul>
<h3 id="动脉干与心球分离异常">动脉干与心球分离异常 <a class="markdownIt-Anchor" href="#动脉干与心球分离异常">#</a></h3>
<ul>
<li><strong>大动脉移位</strong>：主动脉肺动脉隔不呈螺旋状走位，而是形成直的间隔，导致主动脉发自右心室而肺动脉干发自左心室；</li>
<li><strong>大动脉狭窄</strong>：主动脉肺动脉隔发生部位偏向一侧，使一侧动脉粗大而另一侧狭小，常伴有室间隔膜部缺损。</li>
</ul>
<h3 id="法洛四联症">法洛四联症 <a class="markdownIt-Anchor" href="#法洛四联症">#</a></h3>
<dl>
<dt><mark>法洛四联症</mark>（tetralogy of Fallot）</dt>
<dd>主要原因为 <strong>主动脉肺动脉隔</strong> 偏移，导致肺动脉狭窄，同时使主动脉向右偏移而骑跨于两个心室。
由于肺动脉狭窄，右心室排血阻力增大，导致右心室逐渐肥大。</dd>
</dl>
<p>法洛四联症主要特征<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p>
<ol>
<li>肺动脉狭窄（Pulmonic stenosis）</li>
<li>室间隔缺损（Ventricular septal defect）</li>
<li>主动脉骑跨（Overriding aorta）</li>
<li>右心室肥大（Right ventricular hypertrophy）</li>
</ol>
<img data-src="/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/Tetralogy_of_Fallot.svg" class="" title="正常心脏（左）与法洛四联症患者的心脏" alt="正常心脏（左）与法洛四联症患者的心脏">
<h3 id="动脉导管未闭">动脉导管未闭 <a class="markdownIt-Anchor" href="#动脉导管未闭">#</a></h3>
<p>较多见，可能是由于出生后动脉导管壁平滑肌未能收缩，使肺动脉和主动脉保持相通。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>由Mariana Ruiz LadyofHats - the image i made myself using adobe ilustrator using this images as source: [1], [2] ,[3], [4] , [5],[6] .and a diagram found on the book &quot;Pädiatrie&quot; from Karl Heinz Niessen.，公有领域，<span class="exturl" data-url="aHR0cHM6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvdy9pbmRleC5waHA/Y3VyaWQ9ODYwNzQ4">https://commons.wikimedia.org/w/index.php?curid=860748<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
        <category>组织学与胚胎学</category>
        <category>胚胎学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
        <tag>组织学与胚胎学</tag>
        <tag>胚胎学</tag>
      </tags>
  </entry>
  <entry>
    <title>抗体</title>
    <url>/2021/05/10/%E6%8A%97%E4%BD%93/</url>
    <content><![CDATA[<dl>
<dt>抗体（antibody，<abbr title="抗体">Ab</abbr>）</dt>
<dd>介导体液免疫的重要效应分子</dd>
<dd>免疫系统在抗原刺激下，由 B 细胞或记忆 B 细胞增殖分化成的浆细胞所产生的、
可与相应抗原发生特异性结合的 <strong>免疫球蛋白</strong>（<abbr title="免疫球蛋白">Ig</abbr>）。</dd>
<dd>主要存在于血清中，也存在于如呼吸道黏膜、小肠黏膜液、唾液、乳汁等其他体液中。</dd>
</dl>
<dl>
<dt>免疫球蛋白（immunoglobulin，<abbr title="免疫球蛋白">Ig</abbr>）</dt>
<dd>具有抗体活性或化学结构与抗体相似的球蛋白的统称。</dd>
<dd>存在形式
<ul>
<li><strong>膜型</strong>（membrane immunoglobulin，mIg），如 BCR（B 细胞受体）</li>
<li><strong>分泌型</strong>（secreted immunoglobulin，sIg），如抗体</li>
</ul>
</dd>
</dl>
<span id="more"></span>
<h2 id="抗体的结构">抗体的结构 <a class="markdownIt-Anchor" href="#抗体的结构">#</a></h2>
<p>抗体的 <strong>基本结构</strong> 是由两条完全相同的 <strong>重链</strong> 和 <strong>轻链</strong> 通过二硫键链接的“Y”形单体。</p>
<h3 id="抗体的分类和分型">抗体的分类和分型 <a class="markdownIt-Anchor" href="#抗体的分类和分型">#</a></h3>
<h4 id="类和亚类">类和亚类 <a class="markdownIt-Anchor" href="#类和亚类">#</a></h4>
<ul>
<li>类：根据 <strong>H 链</strong> C 区抗原性的差异</li>
<li>亚类：铰链区氨基酸的组成和重链二硫键的数目、位置</li>
</ul>
<p>根据重链的种类，可将完整的抗体分子分为对应的五类（见下表“抗体”列）。</p>
<p class="align-text-center table-caption ">
      抗体的<strong>类</strong>和<strong>亚类</strong>
    </p>
<table>
<thead>
<tr>
<th>类</th>
<th>抗体</th>
<th>亚类</th>
</tr>
</thead>
<tbody>
<tr>
<td>μ(mu)</td>
<td>IgM</td>
<td><em>无</em></td>
</tr>
<tr>
<td>γ(gamma)</td>
<td>IgG</td>
<td>IgG1~IgG4</td>
</tr>
<tr>
<td>α(alpha)</td>
<td>IgA</td>
<td>IgA1、IgA2</td>
</tr>
<tr>
<td>δ(delta)</td>
<td>IgD</td>
<td><em>无</em></td>
</tr>
<tr>
<td>ε(epsilon)</td>
<td>IgE</td>
<td><em>无</em></td>
</tr>
</tbody>
</table>
<h4 id="型和亚型">型和亚型 <a class="markdownIt-Anchor" href="#型和亚型">#</a></h4>
<p><strong>型</strong>：根据 <strong>L 链</strong> C 区氨基酸的组成和排列顺序</p>
<ul>
<li>κ（kappa）型</li>
<li>λ（lambda）型</li>
</ul>
<p><strong>亚型</strong>：根据 λ 链 C 区个别氨基酸的不同：λ1/OZ(+)、λ2/OZ(-)、λ3/Kern(+)、λ4/Kern(-)</p>
<h3 id="可变区和恒定区">可变区和恒定区 <a class="markdownIt-Anchor" href="#可变区和恒定区">#</a></h3>
<img data-src="/2021/05/10/%E6%8A%97%E4%BD%93/%E6%8A%97%E4%BD%93%E7%BB%93%E6%9E%84%E5%9F%9F.jpg" class="" title="抗体分子 V 区和 C 区结构示意图" alt="抗体分子 V 区和 C 区结构示意图">
<dl>
<dt>可变区（variable region，<mark><abbr title="可变区">V 区</abbr></mark>）</dt>
<dd>抗体分子中轻链和重链靠近 N 端的氨基酸形成的结构，此处氨基酸序列变化较大，具有独特的空间构型。
<ul>
<li>高变区</li>
<li>骨架区</li>
</ul>
</dd>
<dd>占 1/4 重链和 1/2 轻链。</dd>
</dl>
<p>轻链和重链的 V 区分别称为 V<sub>H</sub> 和 V<sub>L</sub>，各有三个 <strong><abbr title="高变区（互补决定区）">HVR</abbr></strong>，分别为 CDR1、CDR2、CDR3（或 HVRn，n=1,2,3）。<br/>
V<sub>H</sub> 和 V<sub>L</sub> 共六个 <abbr title="互补决定区（高变区）">CDR</abbr> 共同构成 <abbr title="抗体">Ab</abbr> 的 <strong>抗原结合部位</strong>（antigen-binding site），决定抗体的特异性。</p>
<dl>
<dt>高变区（hypervariable region，<abbr title="高变区（互补决定区）">HVR</abbr>）| 互补决定区（<abbr title="互补决定区（高变区）">CDR</abbr>）</dt>
<dd>氨基酸组成和排列高度可变的区域。</dd>
</dl>
<dl>
<dt>骨架区（<abbr title="骨架区">FR</abbr>）</dt>
<dd><abbr title="可变区">V 区</abbr> <abbr title="高变区（互补决定区）">HVR</abbr> 外的区域，氨基酸组成的排列顺序相对变化不大。</dd>
</dl>
<hr />
<dl>
<dt>恒定区（constant region，<mark><abbr title="恒定区">C 区</abbr></mark>）</dt>
<dd>靠近 C 端的相对恒定的区域。</dd>
<dd>占 3/4 重链和 1/2 轻链。</dd>
</dl>
<p>轻链和重链的 C 区分别称为 C<sub>H</sub> 和 C<sub>L</sub>。</p>
<p>不同型 <abbr title="抗体">Ab</abbr> 的 C<sub>L</sub> 区的长度基本一致，但是不同<strong>类</strong> <abbr title="抗体">Ab</abbr> 的 C<sub>H</sub> 区长度不一。</p>
<ul>
<li>IgG/IgA/IgD：C<sub>H</sub>1、C<sub>H</sub>2、C<sub>H</sub>3</li>
<li>IgM/IgE：C<sub>H</sub>1、C<sub>H</sub>2、C<sub>H</sub>3、C<sub>H</sub>4</li>
</ul>
<h3 id="铰链区">铰链区 <a class="markdownIt-Anchor" href="#铰链区">#</a></h3>
<dl>
<dt>铰链区（hinge region）</dt>
<dd>位于 C<sub>H</sub>1 和 C<sub>H</sub>2 之间，含有丰富的脯氨酸，易弯曲伸展，能改变”Y“形两个臂之间的距离，有利于两个臂同时结合两个相同的抗原表位。</dd>
<dd>铰链区易被蛋白水解酶降解，见 <a href="#%E6%8A%97%E4%BD%93%E5%88%86%E5%AD%90%E7%9A%84%E6%B0%B4%E8%A7%A3%E7%89%87%E6%AE%B5">抗体分子的水解片段</a>。</dd>
</dl>
<blockquote>
<p>IgM 和 IgE 无铰链区</p>
</blockquote>
<h3 id="抗体的辅助成分">抗体的辅助成分 <a class="markdownIt-Anchor" href="#抗体的辅助成分">#</a></h3>
<dl>
<dt>J 链（joining chain）</dt>
<dd>由 <strong>浆细胞</strong> 合成的富含半胱氨酸的酸性糖蛋白，主要功能是 <strong>将单体 <abbr title="抗体">Ab</abbr> 连接形成二聚体或多聚体</strong>。</dd>
<dt>分泌片（secretory piece，<abbr title="分泌片（分泌成分）">SP</abbr>）| 分泌成分（secretory component，<abbr title="分泌成分（分泌片）">SC</abbr>）</dt>
<dd>由 <strong>黏膜上皮细胞</strong> 合成、分泌的一种 <abbr title="分泌型 IgA">SIgA</abbr>（分泌型 IgA）的辅助因子。</dd>
</dl>
<p>分泌片的功能</p>
<ul>
<li>保护 <abbr title="分泌型 IgA">SIgA</abbr> 铰链区免受蛋白水解酶降解</li>
<li>可介导 <abbr title="分泌型 IgA">SIgA</abbr> 从黏膜下通过黏膜上皮细胞转运到黏膜表面（另见 <a href="#%E7%A9%BF%E8%BF%87%E8%83%8E%E7%9B%98%E5%92%8C%E9%BB%8F%E8%86%9C">穿过胎盘和黏膜</a>）</li>
</ul>
<h3 id="抗体分子的水解片段">抗体分子的水解片段 <a class="markdownIt-Anchor" href="#抗体分子的水解片段">#</a></h3>
<p>常用 <strong>木瓜蛋白酶</strong> 和 <strong>胃蛋白酶</strong> 水解蛋白质，借此研究 <abbr title="抗体">Ab</abbr> 的结构和功能。</p>
<ul>
<li><strong>木瓜蛋白酶</strong>：将重链于铰链区 <strong>近 N 端</strong> 切断，产生两个 <abbr title="抗原结合片段">Fab</abbr> 和一个 <abbr title="可结晶片段">Fc</abbr></li>
<li><strong>胃蛋白酶</strong>：将重链于铰链区 <strong>近 C 端</strong> 切断，产生一个 F(ab’)<sub>2</sub>（双价）和一些 pFc’（无生物学活性）</li>
</ul>
<dl>
<dt>抗原结合片段（fragment of antigen-binding，<abbr title="抗原结合片段">Fab</abbr>）</dt>
<dd>可与抗原结合，具有单价抗原活性。</dd>
<dt>可结晶片段（fragment crystallizable，<abbr title="可结晶片段">Fc</abbr>）</dt>
<dd>不可与抗原结合，但可执行免疫球蛋白的其他生物学功能。</dd>
</dl>
<h3 id="超免疫球蛋白家族">超免疫球蛋白家族 <a class="markdownIt-Anchor" href="#超免疫球蛋白家族">#</a></h3>
<dl>
<dt>免疫球蛋白折叠（immunoglobulin fold）</dt>
<dd>抗体分子中 <abbr title="互补决定区（高变区）">CDR</abbr> 外的结构域氨基酸序列相对保守（有较高的同源性），折叠成特定的球状结构。</dd>
<dt>免疫球蛋白基因超家族、免疫球蛋白超家族（immunoglobulin superfamily，<abbr title="免疫球蛋白超家族（immunoglobulin superfamily）">IgSF</abbr>）</dt>
<dd>编码具有 <strong>免疫球蛋白折叠</strong> 的蛋白质的基因称为 <strong>免疫球蛋白基因超家族</strong>，这种蛋白质称为
<strong>免疫球蛋白超家族</strong>。</dd>
</dl>
<h2 id="抗体的多样性和免疫原性">抗体的多样性和免疫原性 <a class="markdownIt-Anchor" href="#抗体的多样性和免疫原性">#</a></h2>
<blockquote>
<p>多样性抗原表位的存在是导致 <strong><abbr title="免疫球蛋白">Ig</abbr> 异质性</strong>（即具有不同的抗原特异性）的外源因素，是
<strong><abbr title="免疫球蛋白">Ig</abbr> 异质性</strong> 的物质基础。<br/>
抗体的多样性是由 <strong>免疫球蛋白基因重排</strong> 决定并经 <strong>抗原选择</strong>
表现出来的，反眺了机体对抗原精细结构的识别和应答。</p>
</blockquote>
<hr />
<p>抗体本身也具有 <a href="/2021/04/30/%E6%8A%97%E5%8E%9F/#抗原的基本特征">免疫原性</a>，即包含
<strong>抗原表位</strong>，可激活机体产生特异性免疫应答。</p>
<dl>
<dt>同种型（isotype）</dt>
<dd>存在于 <strong>同种</strong> 抗体分子中的抗原表位。</dd>
<dd>是同一种属所有个体 <abbr title="抗体">Ab</abbr> 分子共有的抗原特异性标志，为 <strong>种属型标志</strong>，存在于 <strong><abbr title="抗体">Ab</abbr> 的 <abbr title="恒定区">C 区</abbr></strong>。</dd>
<dt>同种异型（allotype）</dt>
<dd>存在于 <strong>同种属中不同个体</strong> <abbr title="抗体">Ab</abbr> 中的抗原表位。</dd>
<dd>是同一种属不同个体 <abbr title="抗体">Ab</abbr> 分子所具有的不同抗原特异性标志，为 <strong>个体型标志</strong>，存在于
<strong><abbr title="抗体">Ab</abbr> 的 <abbr title="恒定区">C 区</abbr></strong>。</dd>
<dt>独特型（idiotype，Id）</dt>
<dd>每个 <strong>抗体分子</strong> 所特有的抗原特异性标志，其表位被称为 <strong>独特位</strong>（idiotope）。</dd>
<dd>是同一种属所有个体 <abbr title="抗体">Ab</abbr> 分子共有的抗原特异性标志，为 <strong>种属型标志</strong>，存在于 <strong><abbr title="抗体">Ab</abbr> 的 <abbr title="恒定区">C 区</abbr></strong>。</dd>
</dl>
<h2 id="抗体的功能">抗体的功能 <a class="markdownIt-Anchor" href="#抗体的功能">#</a></h2>
<h3 id="抗体-v-区的作用">抗体 V 区的作用 <a class="markdownIt-Anchor" href="#抗体-v-区的作用">#</a></h3>
<p>V<sub>L</sub> 和 V<sub>H</sub> 是抗原结合的部位</p>
<ol>
<li>识别并特异性结合抗原，<abbr title="互补决定区（高变区）">CDR</abbr> 起决定性作用；</li>
<li>中和毒素、阻断病原入侵等免疫防御功能。</li>
</ol>
<dl>
<dt>抗原结合价</dt>
<dd><abbr title="抗体">Ab</abbr> 结合抗原表位的个数。</dd>
<dd>单抗原为双价，<abbr title="抗原结合片段">Fab</abbr> 为单价，五聚体理论上为 10 价，但是由于空间位阻的原因，实际上为 5 价。</dd>
</dl>
<h3 id="抗体-c-区的作用">抗体 C 区的作用 <a class="markdownIt-Anchor" href="#抗体-c-区的作用">#</a></h3>
<h4 id="激活补体">激活补体 <a class="markdownIt-Anchor" href="#激活补体">#</a></h4>
<ul>
<li>IgG1、IgG3、IgM：激活补体能力强，通过 <strong>经典途径</strong> 激活</li>
<li>IgG2：也通过 <strong>经典途径</strong>，但能力较弱</li>
<li>IgG4、IgΑ、IgE：本身难以激活补体系统，需依赖 <strong>旁路途径</strong></li>
</ul>
<dl>
<dt>补体依赖的细胞毒作用（complement dependent cytotoxicity，<abbr title="补体依赖的细胞毒作用（complement dependent cytotoxicity）">CDC</abbr>）</dt>
<dd>补体（C1q）参与的细胞毒作用。</dd>
<dd>IgG 和 IgM 与病毒感染细胞或细菌细胞膜表面抗原结合，而后
<strong>C1q</strong>（Complement component 1q）通过与抗体结合激活
<strong>经典途径</strong>，导致 <strong>攻膜复合物</strong>（membrane attack complex）形成并对靶细胞发挥裂解效应。</dd>
</dl>
<p>另见 <a href="/2021/05/17/%E8%A1%A5%E4%BD%93%E7%B3%BB%E7%BB%9F/">补体系统</a>。</p>
<h4 id="结合-fc-受体">结合 <abbr title="可结晶片段">Fc</abbr> 受体 <a class="markdownIt-Anchor" href="#结合-fc-受体">#</a></h4>
<p><strong>IgG、IgA、IgE</strong> 有此功能的 <abbr title="可结晶片段">Fc</abbr> 段可与表面具有相应 <abbr title="可结晶片段">Fc</abbr> 受体（<abbr title="Fc 受体">FcR</abbr>）的细胞结合，产生不同的生物学效应。<br/>
三类抗原的 <abbr title="可结晶片段">Fc</abbr> 受体分别称为 <abbr title="Fc 受体">FcR</abbr>、<abbr title="Fc 受体">FcR</abbr>、<abbr title="Fc 受体">FcR</abbr>。</p>
<h5 id="调理作用opsonization">调理作用（opsonization） <a class="markdownIt-Anchor" href="#调理作用opsonization">#</a></h5>
<p>由 <strong>IgG</strong>（特别是 IgG1、IgG3）介导，IgG <abbr title="抗原结合片段">Fab</abbr> 段与相应细菌的抗原表位结合，<abbr title="可结晶片段">Fc</abbr> 段与巨噬细胞或中性粒细胞表面的 FcγR 结合，通过
IgG 的“桥联”作用，促进吞噬细胞对细菌的吞噬。</p>
<h5 id="抗体依赖的细胞介导的细胞毒作用antibody-dependent-cell-mediated-cytotoxicityadcc">抗体依赖的细胞介导的细胞毒作用（antibody-dependent cell-mediated cytotoxicity，<mark><abbr title="抗体依赖的细胞介导的细胞毒作用（antibody-dependent cell-mediated cytotoxicity）">ADCC</abbr></mark>） <a class="markdownIt-Anchor" href="#抗体依赖的细胞介导的细胞毒作用antibody-dependent-cell-mediated-cytotoxicityadcc">#</a></h5>
<p>由 <strong>IgG</strong> 介导，抗体 <abbr title="抗原结合片段">Fab</abbr> 段结合病毒感染细胞或肿瘤细胞表面抗原，其 <abbr title="可结晶片段">Fc</abbr>
段与杀伤细胞（<strong>NK 细胞</strong>、巨噬细胞等）表面 FcγR 结合，介导杀伤细胞直接杀伤靶细胞。</p>
<blockquote>
<p>抗体与靶细胞上抗原的结合是特异性的，而表达 <abbr title="Fc 受体">FcR</abbr> 细胞的杀伤作用是非特异性的。</p>
</blockquote>
<h5 id="介导-i-型超敏反应">介导 Ⅰ 型超敏反应 <a class="markdownIt-Anchor" href="#介导-i-型超敏反应">#</a></h5>
<p>主要由 <strong>IgE</strong> 介导，IgE 通过其 <abbr title="可结晶片段">Fc</abbr> 段与肥大细胞或嗜碱性粒细胞表面高亲和力 IgE <abbr title="可结晶片段">Fc</abbr>
受体（FcεR Ⅰ）结合，并使其致敏。<br/>
若相同 <strong>应变原</strong> 再次进入机体与致敏靶细胞表面特异性 IgE 结合，即可引起 Ⅰ 型超敏反应。</p>
<div class="note info"><dl>
<dt>Ⅰ 型超敏反应 | 过敏反应（anaphylaxis）| 变态反应（allergy）</dt>
<dd>机体受到某些抗原刺激时，引起的由特异性 IgE 抗体介导产生的一种发生快消退亦快的免疫应答。</dd>
<dd>表现为局部或全身的生理功能紊乱，具有明显个体差异和遗传倾向。</dd>
<dt>变应原（allergen）| 过敏原</dt>
<dd>引起超敏反应的物质。</dd>
</dl>
</div>
<h4 id="穿过胎盘和黏膜">穿过胎盘和黏膜 <a class="markdownIt-Anchor" href="#穿过胎盘和黏膜">#</a></h4>
<p>人类中，<mark>IgG</mark> 是唯一能通过胎盘的细胞。IgG 穿过胎盘是一种重要的 <mark>自然被动免疫机制</mark>。<br/>
胚盘母体一侧的滋养层细胞表达一种 IgG 输送蛋白，称为
<strong>新生儿 <abbr title="可结晶片段">Fc</abbr> 段受体</strong>（neonatal <abbr title="Fc 受体">FcR</abbr>，<strong>FcRn</strong>）。<br/>
FcRn 可与 IgG 特异性结合，将其转运到滋养层的另一侧，使其进入胎儿血液。<br/></p>
<p><a href="#iga"><abbr title="分泌型 IgA">SIgA</abbr></a> 也可通过 <a href="#%E6%8A%97%E4%BD%93%E7%9A%84%E8%BE%85%E5%8A%A9%E6%88%90%E5%88%86"><strong>分泌片</strong></a> 的介导转运到呼吸道或消化道黏膜表面，在黏膜局部免疫中发挥作用。</p>
<h2 id="各类抗体的特性与功能">各类抗体的特性与功能 <a class="markdownIt-Anchor" href="#各类抗体的特性与功能">#</a></h2>
<h3 id="igg">IgG <a class="markdownIt-Anchor" href="#igg">#</a></h3>
<dl>
<dt>IgG（免疫球蛋白 G）</dt>
<dd>IgG 从出生后 3 月后开始合成，3~5 岁接近成人水平，是血清和胞外液中 <strong>含量最高</strong>（75%~80%的 <abbr title="免疫球蛋白">Ig</abbr>。</dd>
<dd>IgG 半衰期约 20~23 天，是 <strong>再次免疫应答产生</strong> 的主要抗体；其亲和力高，是机体抗感染免疫的“主力军”。</dd>
<dd>IgG 的亚类见 <a href="#%E6%8A%97%E4%BD%93%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%88%86%E5%9E%8B">抗体的分类和分型</a>。</dd>
</dl>
<p>生物学活性</p>
<ul>
<li><a href="#%E7%A9%BF%E8%BF%87%E8%83%8E%E7%9B%98%E5%92%8C%E9%BB%8F%E8%86%9C">通过胎盘</a>（新生儿抗感染）：IgG1、3、4</li>
<li><a href="#%E6%BF%80%E6%B4%BB%E8%A1%A5%E4%BD%93">激活补体</a>（裂解细胞）：IgG1、2、3</li>
<li><a href="#%E8%B0%83%E7%90%86%E4%BD%9C%E7%94%A8opsonization">调理作用</a>（促进吞噬）：IgG1、2、3</li>
<li>介导 <a href="#%E6%8A%97%E4%BD%93%E4%BE%9D%E8%B5%96%E7%9A%84%E7%BB%86%E8%83%9E%E4%BB%8B%E5%AF%BC%E7%9A%84%E7%BB%86%E8%83%9E%E6%AF%92%E4%BD%9C%E7%94%A8antibody-dependent-cell-mediated-cytotoxicityadcc"><abbr title="抗体依赖的细胞介导的细胞毒作用（antibody-dependent cell-mediated cytotoxicity）">ADCC</abbr></a>（细胞毒作用）：IgG1、2、3</li>
<li><abbr title="可结晶片段">Fc</abbr> 段与 <a href="/2021/03/25/%E5%8C%96%E8%84%93%E6%80%A7%E7%BB%86%E8%8F%8C/#葡萄球菌">葡萄球菌蛋白 A</a>（SPA）结合（免疫诊断、纯化抗体）：IgG1、2、4</li>
</ul>
<p>实际功能</p>
<ul>
<li>抗感染</li>
<li>自身抗体（自身免疫病）</li>
<li>介导 Ⅱ、Ⅲ 型变态反应</li>
<li>亲合层析法，用于抗体纯化</li>
<li>免疫学检测和诊断</li>
</ul>
<h3 id="igm">IgM <a class="markdownIt-Anchor" href="#igm">#</a></h3>
<dl>
<dt>IgM（免疫球蛋白 M）</dt>
<dd>占血清球蛋白的 5%~10%，分为膜结合性 IgM（mIgM）和分泌型 IgM（SIgM）。</dd>
</dl>
<ul>
<li>mIgM：单体，表达于 B 细胞表面，构成 B 细胞表面抗原受体（BCR）只表达 mIgM 是 <strong>未成熟 B 细胞的标志</strong>。</li>
<li>SIgM：<strong>五聚体</strong>，是 <strong>分子量最大的 <abbr title="免疫球蛋白">Ig</abbr></strong>，称为 <strong>巨球蛋白</strong>（macroglobulin），一般不能通过血管壁，主要存在于血液中。<br/>
抗原结合能力（<abbr title="抗原结合片段">Fab</abbr>）和激活补体的能力（<abbr title="可结晶片段">Fc</abbr>）均较高。</li>
</ul>
<p>IgM 是个体发育过程中 <strong>最早合成和分泌的抗体</strong>，胚胎发育晚期的婴儿即可产生 IgM。<br/>
脐带血某些病毒特异性 IgM 水平升高提示胎儿有 <strong>宫内感染</strong>。</p>
<p>IgM 也是 <strong>初次体液免疫应答</strong> 中最早出现的抗体，而且半衰期短（5 天）。血清中检出病原体特异性 IgM 提示新近发生感染，可用于感染的早期诊断。</p>
<h3 id="iga">IgA <a class="markdownIt-Anchor" href="#iga">#</a></h3>
<dl>
<dt>IgA（免疫球蛋白 A）</dt>
<dd>分为 <strong>血清型</strong>（IgA1）和 <strong>分泌型</strong>（IgA2）两种，另见<a href="#%E6%8A%97%E4%BD%93%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%88%86%E5%9E%8B">抗体的分类和分型</a>。</dd>
<dd>聚合 IgA（<s><abbr title="分泌型 IgA">SIgA</abbr></s>）可激活 <a href="#%E6%BF%80%E6%B4%BB%E8%A1%A5%E4%BD%93">补体替代途径</a>。</dd>
</dl>
<ul>
<li>血清型：单体，主要存在于血清中；</li>
<li><strong>分泌型</strong></li>
</ul>
<dl>
<dt>分泌型 IgA（secretory IgA，<mark><abbr title="分泌型 IgA">SIgA</abbr></mark>）</dt>
<dd><strong>二聚体</strong>，由 <strong>黏膜局部浆细胞</strong> 分泌。
<ul>
<li>可借助 <a href="#%E6%8A%97%E4%BD%93%E7%9A%84%E8%BE%85%E5%8A%A9%E6%88%90%E5%88%86"><strong>分泌片</strong></a> 转运到呼吸道和消化道黏膜表面，参与局部抗感染免疫，阻止病原微生物黏附。</li>
<li>新生儿可从母乳中获得 <abbr title="分泌型 IgA">SIgA</abbr>，是重要的 <mark>自然被动免疫</mark>。</li>
</ul>
</dd>
</dl>
<h3 id="igd">IgD <a class="markdownIt-Anchor" href="#igd">#</a></h3>
<dl>
<dt>IgD（免疫球蛋白 D）</dt>
<dd>为 <strong>单体分子</strong>，有分泌型和膜结合型两种。分泌型的功能尚未确定，mIgD 是 B 细胞分化发育为成熟 B 细胞（<strong>初始 B 细胞</strong>）的标志。</dd>
<dd>B 细胞活化后其表面的 IgD 逐渐消失。</dd>
<dd>IgD 铰链区较长，易被水解，半衰期只有 3 天。</dd>
</dl>
<h3 id="ige">IgE <a class="markdownIt-Anchor" href="#ige">#</a></h3>
<dl>
<dt>IgE（免疫球蛋白 E）</dt>
<dd><strong>单体分子</strong> 主要由黏膜下淋巴组织中的浆细胞分泌，血清中 <strong>含量最低</strong>（0.002%）。</dd>
<dd>IgE 是一类 <mark>亲细胞抗体</mark>，其 C<sub>H</sub>2 和 C<sub>H</sub>3 可与肥大细胞和嗜碱性粒细胞上的高亲和力 <strong>FcεR Ⅰ</strong>
结合，当结合再次进入机体的抗原后可引起 <strong>Ⅰ 型超敏反应</strong>。</dd>
<dd>过敏性疾病和某些 <strong>寄生虫病</strong> 患者体内的特异性 IgE 水平增高。</dd>
</dl>
<h2 id="人工制备抗体">人工制备抗体 <a class="markdownIt-Anchor" href="#人工制备抗体">#</a></h2>
<h3 id="多克隆抗体">多克隆抗体 <a class="markdownIt-Anchor" href="#多克隆抗体">#</a></h3>
<dl>
<dt>多克隆抗体（polyclonal antibody，pAb）</dt>
<dd>以天然抗体（<a href="/2021/04/30/%E6%8A%97%E5%8E%9F/#抗原特异性与抗原表位">多价抗体</a>）刺激机体免疫系统而产生的针对多种不同抗原表位的抗体总和。</dd>
<dd>主要来源于动物免疫血清、恢复期患者血清、免疫接种人群血清。</dd>
</dl>
<ul>
<li>优点
<ul>
<li><strong>作用全面</strong>：中和抗原，免疫调理，介导补体依赖的细胞毒作用（<abbr title="补体依赖的细胞毒作用（complement dependent cytotoxicity）">CDC</abbr>）、<abbr title="抗体依赖的细胞介导的细胞毒作用（antibody-dependent cell-mediated cytotoxicity）">ADCC</abbr></li>
<li>来源广泛，易制备</li>
</ul>
</li>
<li>缺点：特异性不高、易发生交叉反应，不易大量制备</li>
</ul>
<h3 id="单克隆抗体">单克隆抗体 <a class="markdownIt-Anchor" href="#单克隆抗体">#</a></h3>
<dl>
<dt>单克隆抗体（monoclonal antibody，mAb）</dt>
<dd>由单一克隆 B 细胞 <strong>杂交瘤</strong> 所产生的、针对单一抗原表位的、具有 <strong>高度特异性</strong> 的抗体。</dd>
</dl>
<p>优点：结构均一、纯度高、特异性强、易于制备</p>
<dl>
<dt>杂交瘤（hybridoma）</dt>
<dd>将可产生特异性抗体的 B 细胞和无特异性但永生化的骨髓瘤细胞融合形成的杂交细胞系。</dd>
<dd>即具有免疫 B 细胞合成和分泌特异性抗体的能力，又具有骨髓瘤细胞大量扩增和永生的特性。</dd>
</dl>
<h3 id="基因工程抗体">基因工程抗体 <a class="markdownIt-Anchor" href="#基因工程抗体">#</a></h3>
<dl>
<dt>基因工程抗体（genetic engineering antibody）</dt>
<dd>通过基因工程技术制备的抗体或抗原片段。</dd>
<dd>即保持 mAb 的均一性，又能克服鼠源性的缺点。</dd>
</dl>
<ul>
<li>人-鼠嵌合抗体</li>
<li>人源化抗体</li>
<li>双特异性抗体</li>
<li>小分子抗体</li>
<li>人抗体</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>医学免疫学</category>
      </categories>
      <tags>
        <tag>医学免疫学</tag>
      </tags>
  </entry>
  <entry>
    <title>抗原</title>
    <url>/2021/04/30/%E6%8A%97%E5%8E%9F/</url>
    <content><![CDATA[<dl>
<dt>抗原（antigen, <abbr title="抗原">Ag</abbr>）</dt>
<dd>所有能激活和诱导免疫应答的物质。</dd>
<dd>通常指能被 T、B 淋巴细胞表面特异性抗原受体识别及结合，激活 T、B 细胞增殖、分化、产生免疫应答效应产物（<strong>免疫原性</strong>），并与效应产物结合（<strong>免疫反应性</strong>），进而发挥适应性免疫应答效应的物质。</dd>
</dl>
<span id="more"></span>
<h2 id="抗原的性质与分子结构基础">抗原的性质与分子结构基础 <a class="markdownIt-Anchor" href="#抗原的性质与分子结构基础">#</a></h2>
<h3 id="抗原的基本特征">抗原的基本特征 <a class="markdownIt-Anchor" href="#抗原的基本特征">#</a></h3>
<dl>
<dt>免疫原性（immunogenicity）</dt>
<dd>抗原被 <abbr title="T 细胞表面抗原">TCR</abbr> 或 <abbr title="B 细胞表面抗原">BCR</abbr> 识别及结合，诱导机体产生适应性免疫及产生抗体或特异性淋巴细胞的能力。</dd>
</dl>
<dl>
<dt>免疫反应性（immunoreactivity）| 抗原性</dt>
<dd>抗原与其诱导产生的免疫应答效应物质特异性结合的能力。</dd>
</dl>
<h3 id="适应性免疫应答的抗原特异性">适应性免疫应答的抗原特异性 <a class="markdownIt-Anchor" href="#适应性免疫应答的抗原特异性">#</a></h3>
<h4 id="抗原特异性与抗原表位">抗原特异性与抗原表位 <a class="markdownIt-Anchor" href="#抗原特异性与抗原表位">#</a></h4>
<dl>
<dt>抗原特异性（antigenic specificity）</dt>
<dd>抗原刺激机体产生适应性免疫应答及其与应答效应产物发生结合均表现出专一性。</dd>
<dt>抗原表位（epitope） | 抗原决定簇（/基）（antigenic determinant）</dt>
<dd>抗原分子中决定抗原特异性的特殊化学基团。</dd>
<dd>是抗原与 <abbr title="T 细胞表面抗原">TCR</abbr>/<abbr title="B 细胞表面抗原">BCR</abbr> 或者抗体特异性结合的 <strong>最小结构和功能单位</strong>。</dd>
</dl>
<div class="note default"><p>抗体和抗原上的某一个 <strong>表位</strong> 结合具有特异性，而一个抗原上可存在多个表位。</p>
</div>
<dl>
<dt>抗原结合价（antigenic valence）</dt>
<dd>一个抗原分子中能够与抗体分子结合的抗原表位的总数。</dd>
</dl>
<blockquote>
<p>天然抗原是多价抗原。</p>
</blockquote>
<h4 id="抗原表位的分类">抗原表位的分类 <a class="markdownIt-Anchor" href="#抗原表位的分类">#</a></h4>
<p>根据抗原表位中氨基酸的空间结构特点，可分为：</p>
<dl>
<dt>顺序表位（sequential epitope）| 线性表位（linear epitope）</dt>
<dd>由线性排列的氨基酸构成。</dd>
<dt>构象表位（conformational epitope）</dt>
<dd>由不连续排列、但在空间上彼此接近形成特定构象的氨基酸构成。</dd>
</dl>
<hr />
<p>根据 T、B 细胞所识别的表位不同，可分为：</p>
<dl>
<dt>T 细胞表位</dt>
<dd><ins>可位于抗原分子的任何部位</ins>，由 <abbr title="抗原提呈细胞">APC</abbr> 降解为 <strong>线性表位</strong>、结合于 <abbr title="主要组织相容性复合体（major histocompatibility complex）">MHC</abbr> 分子沟槽并提呈于 <abbr title="抗原提呈细胞">APC</abbr> 表面，供 <abbr title="T 细胞表面抗原">TCR</abbr> 识别。
<ul>
<li>CD8<sup>+</sup>T 细胞识别的表位：8~10 个氨基酸，第 2、9 位为 <strong>锚定氨基酸</strong>（anchor residue）</li>
<li>CD4<sup>+</sup>T 细胞识别的表位：13~17 个氨基酸</li>
</ul>
</dd>
</dl>
<dl>
<dt>B 细胞表位</dt>
<dd>无需 <abbr title="抗原提呈细胞">APC</abbr> 加工和提呈，<ins>位于抗原分子表面</ins>，多为 <strong>构象表位</strong>，少数为 <strong>线性表位</strong>，供 <abbr title="B 细胞表面抗原">BCR</abbr> 识别。</dd>
</dl>
<h4 id="半抗原-载体反应">半抗原-载体反应 <a class="markdownIt-Anchor" href="#半抗原-载体反应">#</a></h4>
<dl>
<dt>完全抗原（complete antigen）| 免疫原（immunogen）</dt>
<dd>同时具有 <strong>免疫原性</strong> 和 <strong>免疫反应性</strong> 的物质，即通常所说的抗原。</dd>
<dt>半抗原（hapten）| 不完全抗原（incomplete antigen）</dt>
<dd>可与抗体结合（<strong>免疫原性</strong>）而不能单独诱导免疫应答（<strong><s>免疫原性</s></strong>，<ins>可特异性结合 <abbr title="B 细胞表面抗原">BCR</abbr>，但不足以活化 B 细胞</ins>），但与
<strong>蛋白载体</strong> 交联或结合和可获得 <strong>免疫反应性</strong>。</dd>
<dt><em>蛋白载体</em></dt>
<dd>可赋予半抗原免疫原性的大分子蛋白质。</dd>
<dd>含 CD4<sup>+</sup>T 细胞表位，可活化 CD4<sup>+</sup>T 细胞。</dd>
</dl>
<p>对 <strong>人工抗原</strong>（半抗体+载体），B 细胞识别半抗原的 B 细胞表位；CD4<sup>+</sup>T 细胞识别载体蛋白的
T 细胞表位。</p>
<blockquote>
<p>一个半抗原相当于一个抗原表位。</p>
</blockquote>
<p>天然蛋白抗原同时存在 T、B 细胞表位，可分别激活 T 细胞和 B 细胞，其中 B 细胞激活有赖于
T 细胞辅助。</p>
<p>半抗原须与蛋白质载体偶联才可诱导抗体产生：</p>
<ol>
<li><strong>半抗原</strong> 特异性结合 <abbr title="B 细胞表面抗原">BCR</abbr>，但是不足以活化 B 细胞</li>
<li><strong>蛋白载体</strong> 含 CD4<sup>+</sup>T 细胞表位，可活化 CD4<sup>+</sup>T 细胞</li>
</ol>
<h4 id="共同抗原表位与交叉反应">共同抗原表位与交叉反应 <a class="markdownIt-Anchor" href="#共同抗原表位与交叉反应">#</a></h4>
<dl>
<dt>共同抗原表位（common epitope）</dt>
<dd>不同抗原间含有的相同或相似抗原表位。</dd>
<dt>交叉抗原（cross antigen）</dt>
<dd>含有共同抗原表位的不同抗原。</dd>
</dl>
<h2 id="影响抗原免疫原性的因素">影响抗原免疫原性的因素 <a class="markdownIt-Anchor" href="#影响抗原免疫原性的因素">#</a></h2>
<h3 id="抗原分子的理化与结构性质">抗原分子的理化与结构性质 <a class="markdownIt-Anchor" href="#抗原分子的理化与结构性质">#</a></h3>
<ol>
<li><strong>异物性</strong>：抗原与机体 <strong>亲缘越远</strong>，组织结构差异越大，免疫原性越强</li>
<li>化学属性、分子量、分子结构
<ol>
<li><strong>化学属性</strong>：<strong>大分子</strong> 有机物和蛋白质免疫原性较强</li>
<li><strong>分子量</strong>：<strong>分子量越大</strong>，一般含抗原表位越多，免疫原性越强</li>
<li><strong>分子结构</strong>：<strong>分子量越大</strong>，结构约复杂，免疫原性越强</li>
</ol>
</li>
<li><strong>分子构象</strong>：抗原大分子中所含抗原表位的性质、数目、位置和空间构象均可影响抗原的免疫原性和免疫反应性</li>
<li><strong>易接近性</strong>：抗原表位在空间上被 <abbr title="B 细胞表面抗原">BCR</abbr> 接近的程度，显著影响免疫原性</li>
<li><strong>物理性质</strong>
<ul>
<li><strong>聚合态</strong>、<strong>颗粒性</strong> 抗原与单体和可溶性抗原相比，免疫原性更强</li>
<li>将免疫原性弱的物质吸附于颗粒物质表面或组装为颗粒性物质，可显著增强其免疫原性</li>
</ul>
</li>
</ol>
<h3 id="宿主的特性">宿主的特性 <a class="markdownIt-Anchor" href="#宿主的特性">#</a></h3>
<ol>
<li><strong>遗传因素</strong>：<abbr title="主要组织相容性复合体（major histocompatibility complex）">MHC</abbr> 基因呈高度多态性，从遗传上决定个体对抗原的应答与否及应答程度</li>
<li><strong>年龄、性别、健康状态</strong>
<ul>
<li>幼、老年免疫应答弱</li>
<li>雌性诱导产生抗体能力强，自身免疫率增高</li>
</ul>
</li>
</ol>
<h3 id="抗原进入宿主的方式">抗原进入宿主的方式 <a class="markdownIt-Anchor" href="#抗原进入宿主的方式">#</a></h3>
<ol>
<li><strong>抗原剂量</strong>：过低、过高都以诱导免疫耐受</li>
<li><strong>抗原进入机体的途径影响免疫应答强度</strong>：<mark>皮内、皮下&gt;肌肉&gt;静脉&gt;口服</mark></li>
<li>抗原进入机体的时间间隔：适当间隔（如 1~2 周）可诱导较好的免疫应答，频繁注射易引起免疫耐受</li>
<li>佐剂：见 <a href="#%E9%9D%9E%E7%89%B9%E5%BC%82%E6%80%A7%E5%85%8D%E7%96%AB%E5%88%BA%E6%BF%80%E5%89%82">非特异性免疫刺激剂</a></li>
</ol>
<h2 id="抗原的种类">抗原的种类 <a class="markdownIt-Anchor" href="#抗原的种类">#</a></h2>
<h3 id="根据诱生抗体时是否需要-th-细胞参与">根据诱生抗体时是否需要 Th 细胞参与 <a class="markdownIt-Anchor" href="#根据诱生抗体时是否需要-th-细胞参与">#</a></h3>
<dl>
<dt>胸腺依赖性抗原（thymus dependent antigen, TD-<abbr title="抗原">Ag</abbr>）</dt>
<dd>绝大多数蛋白质抗原刺激 B 细胞产生抗体时，需要 T 细胞的辅助。</dd>
<dt>非胸腺依赖性抗原（thymus independent antigen, TI-<abbr title="抗原">Ag</abbr>）</dt>
<dd>可非特异性激活多克隆 B 细胞，产生抗体时无需 T 细胞的辅助。
<ul>
<li>TI-1Ag
<ul>
<li>既含有重复 B 细胞表位，又具有 B 细胞丝裂原</li>
<li>可特异性或非特异性激活 B 细胞</li>
</ul>
</li>
<li>TI-2Ag
<ul>
<li>既含有重复 B 细胞表位</li>
<li>通过交联 <abbr title="B 细胞表面抗原">BCR</abbr> 刺激成熟 B 细胞应答</li>
</ul>
</li>
</ul>
</dd>
</dl>
<p class="align-text-center table-caption ">
      TD-Ag 与 TI-Ag 对比
    </p>
<table>
<thead>
<tr>
<th></th>
<th>TD-<abbr title="抗原">Ag</abbr></th>
<th>TI-<abbr title="抗原">Ag</abbr></th>
</tr>
</thead>
<tbody>
<tr>
<td>结构特点</td>
<td>复杂，含多种表位</td>
<td>含单一表位</td>
</tr>
<tr>
<td>表位组成</td>
<td>B 细胞和 T 细胞表位</td>
<td>重复 B 细胞表位</td>
</tr>
<tr>
<td>T 细胞辅助</td>
<td>必需</td>
<td>无需</td>
</tr>
<tr>
<td><abbr title="主要组织相容性复合体（major histocompatibility complex）">MHC</abbr> 限制性</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>激活的 B 细胞</td>
<td>B2</td>
<td>B1</td>
</tr>
<tr>
<td>免疫应答类型</td>
<td>体液免疫和细胞免疫</td>
<td>细胞免疫</td>
</tr>
<tr>
<td>抗体类型</td>
<td>IgM、IgG、IgA 等</td>
<td>IgM</td>
</tr>
<tr>
<td>免疫记忆</td>
<td>有</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="根据抗原与机体的亲缘关系">根据抗原与机体的亲缘关系 <a class="markdownIt-Anchor" href="#根据抗原与机体的亲缘关系">#</a></h3>
<p>另见 <a href="/2021/05/10/%E6%8A%97%E4%BD%93/#抗体的多样性和免疫原性">抗体的多样性和免疫原性</a>。</p>
<dl>
<dt>异嗜性抗原 | Forssman 抗原</dt>
<dd>存在于人、动物及微生物等不同种属间的共同抗原。</dd>
<dd>与人体自身物质存在 <strong>共同表位</strong> 的病菌侵入人体可导致自身免疫。</dd>
<dt>异种抗原</dt>
<dd>另一物种来源的抗原。</dd>
<dt>同种异型抗原 | 同种异体抗原</dt>
<dd>同一物种不同个体间存在的不同抗原，如血型抗原和人 <abbr title="主要组织相容性复合体（major histocompatibility complex）">MHC</abbr>（即 <abbr title="人白细胞抗原">HLA</abbr>）。</dd>
</dl>
<div class="note info"><p>HLA（人白细胞抗原）是人群中多态性最高的同种异型抗原，成为个体区别于他人的
<strong>独特遗传标志</strong>，是介导人体间 <strong>移植排斥反应</strong> 的主要移植抗原。</p>
</div>
<dl>
<dt>自身抗原</dt>
<dd>发生改变或修饰的自身组织细胞成分、外伤导致释放的 <strong>免疫隔离</strong> 的自身物质。</dd>
<dd>产生原因：
<ul>
<li>隐蔽抗原释放：晶状体蛋白（交感性眼炎）、精子（自身免疫性睾丸炎）</li>
<li>自身抗原被修饰：生物因素、化学修饰、物理修饰</li>
</ul>
</dd>
<dt><a href="/2021/05/10/%E6%8A%97%E4%BD%93/#抗体的多样性和免疫原性">独特型</a>（idiotype, Id）抗原（idiotypic antigen）</dt>
<dd>具有 <strong>免疫原性</strong>，可刺激机体内的其他 B 细胞产生相应抗体的 <strong>抗体</strong>，其上抗原表位称为 <strong>独特型抗原</strong>。</dd>
<dd>Id 抗原诱导产生的抗体（即 <strong>抗抗体</strong>），称为 <strong>抗独特型抗体</strong>（AId）。</dd>
</dl>
<h3 id="根据抗原提呈细胞内抗原的来源">根据抗原提呈细胞内抗原的来源 <a class="markdownIt-Anchor" href="#根据抗原提呈细胞内抗原的来源">#</a></h3>
<dl>
<dt>内源性抗原（endogenous antibody）</dt>
<dd>在 <abbr title="抗原提呈细胞">APC</abbr> 内新合成的抗原，如病毒感染细胞合成的病毒蛋白、肿瘤细胞合成的肿瘤抗原等。</dd>
<dd>在胞质内被处理为抗原肽与 <strong><abbr title="主要组织相容性复合体（major histocompatibility complex）">MHC</abbr> Ⅰ 类分子</strong> 结合，激活 <strong>CD8<sup>+</sup>T 细胞</strong>。</dd>
<dt>外源性抗原（exogenous antibody）</dt>
<dd>细菌蛋白等外来抗原。</dd>
<dd>通过胞吞、胞饮或受体介导内吞进入 <abbr title="抗原提呈细胞">APC</abbr>，在内体-溶酶体中被降解为抗原肽并与
<strong><abbr title="主要组织相容性复合体（major histocompatibility complex）">MHC</abbr> Ⅱ 类分子</strong> 结合，提呈于 <abbr title="抗原提呈细胞">APC</abbr> 表面，激活 <strong>CD4<sup>+</sup>T 细胞</strong>。</dd>
</dl>
<h2 id="非特异性免疫刺激剂">非特异性免疫刺激剂 <a class="markdownIt-Anchor" href="#非特异性免疫刺激剂">#</a></h2>
<h3 id="超抗原">超抗原 <a class="markdownIt-Anchor" href="#超抗原">#</a></h3>
<dl>
<dt>超抗原（superantigen，SAg）</dt>
<dd>某些只需极低浓度（1~10ng/ml）即可非特异性激活人体总 T 细胞库中 2%~20% 的 T
细胞克隆，产生极强的免疫应答的抗原物质，其实质为 <strong>多克隆抑制剂</strong>。</dd>
</dl>
<p class="align-text-center table-caption ">
      超抗原和普通抗原的区别
    </p>
<table>
<thead>
<tr>
<th></th>
<th>超抗原</th>
<th>普通抗原</th>
</tr>
</thead>
<tbody>
<tr>
<td>化学性质</td>
<td>菌体外毒素、逆转录病毒蛋白等</td>
<td>普通蛋白质、多糖等</td>
</tr>
<tr>
<td><abbr title="主要组织相容性复合体（major histocompatibility complex）">MHC</abbr> 结合部位</td>
<td><strong>抗原结合槽外部</strong></td>
<td>抗原结合槽内部</td>
</tr>
<tr>
<td><abbr title="T 细胞表面抗原">TCR</abbr> 结合部位</td>
<td><strong>Vβ 链</strong> CDR3 外侧区域</td>
<td>Vα、Jα 及 Vβ、Dβ、Jβ</td>
</tr>
<tr>
<td>应答特点</td>
<td>直接激活大量 T 细胞</td>
<td><abbr title="抗原提呈细胞">APC</abbr> 加工后激活特异性 T 细胞</td>
</tr>
<tr>
<td>反应细胞</td>
<td>CD4<sup>+</sup> 细胞</td>
<td>T、B 细胞</td>
</tr>
<tr>
<td>T 细胞库反应频率</td>
<td>1/50~1/5（2%~20%）</td>
<td>1/10<sup>6</sup>~1/10<sup>4</sup></td>
</tr>
</tbody>
</table>
<h3 id="佐剂">佐剂 <a class="markdownIt-Anchor" href="#佐剂">#</a></h3>
<dl>
<dt>佐剂（adjuvant）</dt>
<dd>预先或与抗原同时注入体内，增强抗原特异性免疫应答或改变应答类型的非特异性免疫增强物质。</dd>
</dl>
<h4 id="佐剂的类型">佐剂的类型 <a class="markdownIt-Anchor" href="#佐剂的类型">#</a></h4>
<ol>
<li><strong>生物性佐剂</strong>：卡介苗</li>
<li><strong>无机化合物</strong>：氢氧化铝</li>
<li><strong>人工合成物</strong>：低甲基化 CpG 寡核苷酸</li>
<li><strong>有机物</strong>：矿物油</li>
<li><strong>脂质体</strong>：免疫刺激复合物</li>
</ol>
<p>动物实验常用 <strong>弗氏完全佐剂</strong>（Freund complete adjuvant，FCA） 和 <strong>弗氏不完全佐剂</strong>（Freund incomplete adjuvant，FIA）。</p>
<p class="align-text-center table-caption ">
      两种弗氏佐剂对比
    </p>
<table>
<thead>
<tr>
<th></th>
<th>弗氏不完全佐剂</th>
<th>弗氏完全佐剂</th>
</tr>
</thead>
<tbody>
<tr>
<td>成分</td>
<td>矿物油</td>
<td>矿物油、灭活结核分枝杆菌</td>
</tr>
<tr>
<td>增强的免疫应答类型</td>
<td>体液免疫</td>
<td>体液免疫、细胞免疫</td>
</tr>
</tbody>
</table>
<h4 id="佐剂作用机制">佐剂作用机制 <a class="markdownIt-Anchor" href="#佐剂作用机制">#</a></h4>
<ol>
<li><strong>改变抗原物理性质</strong>，延缓抗原降解；</li>
<li><strong>刺激抗原提呈细胞</strong>，增强其对抗原的加工和提呈；</li>
<li><strong>刺激淋巴细胞增殖分化</strong>，增强和扩大免疫应答。</li>
</ol>
<h3 id="丝裂原">丝裂原 <a class="markdownIt-Anchor" href="#丝裂原">#</a></h3>
<dl>
<dt>丝裂原（mitogen）| 有丝分裂原</dt>
<dd>属于非特异性淋巴细胞多克隆激活剂，通过与淋巴细胞表面 <strong>丝裂原受体</strong>
结合，刺激静止淋巴细胞转化为淋巴母细胞并进行有丝分裂，从而激活一类淋巴细胞的全部克隆。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>医学免疫学</category>
      </categories>
      <tags>
        <tag>医学免疫学</tag>
      </tags>
  </entry>
  <entry>
    <title>抗细菌感染免疫</title>
    <url>/2021/03/25/%E6%8A%97%E7%BB%86%E8%8F%8C%E6%84%9F%E6%9F%93%E5%85%8D%E7%96%AB/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%AD%A3%E5%B8%B8%E8%8F%8C%E7%BE%A4%E5%92%8C%E6%9C%BA%E4%BC%9A%E8%87%B4%E7%97%85%E8%8F%8C">正常菌群和机会致病菌</a></li>
<li><a href="#%E6%84%9F%E6%9F%93%E4%B8%8E%E9%80%82%E5%BA%94%E6%80%A7%E5%85%8D%E7%96%AB">感染与适应性免疫</a></li>
</ul>
</p>
<span id="more"></span>
<h2 id="正常菌群和机会致病菌">正常菌群和机会致病菌 <a class="markdownIt-Anchor" href="#正常菌群和机会致病菌">#</a></h2>
<dl>
<dt>正常菌群</dt>
<dd>正常寄居于人的<em>体表和与外界相通的腔道</em>中的微生物群的总称。</dd>
<dd>人的免疫功能正常时，其不致病且与机体处于共生状态。</dd>
</dl>
<ul>
<li>常驻菌群</li>
<li>过路菌群</li>
</ul>
<p>正常菌群的生理功能</p>
<ul>
<li>生物拮抗</li>
<li>帮助消化</li>
<li>营养功能</li>
<li>调节免疫：刺激免疫系统的成熟和免疫应答</li>
<li>抗肿瘤、抗衰老</li>
</ul>
<p>重要正常菌群</p>
<ul>
<li>多形拟杆菌：降解碳水化合物</li>
<li>脆弱拟杆菌：与免疫系统的功能的发挥有关</li>
</ul>
<dl>
<dt>机会致病菌 | 条件致病菌</dt>
<dd>在正常菌群与宿主之间的生态平衡关系被打破时，会变成致病菌的平时不致病的正常菌群中的细菌。</dd>
</dl>
<p>致病条件</p>
<ul>
<li>定居部位改变</li>
<li>机体免疫功能低下</li>
<li>菌群失调（最常见的微生态失调）</li>
</ul>
<h2 id="感染与适应性免疫">感染与适应性免疫 <a class="markdownIt-Anchor" href="#感染与适应性免疫">#</a></h2>
<dl>
<dt>适应性免疫 | 获得性免疫</dt>
<dd>个体出生后，在生活过程中与病原体和即其产物等抗原分子接触后产生的一系列免疫防御功能。</dd>
</dl>
<ul>
<li>体液免疫
<ul>
<li>抗菌抗体</li>
<li>抗毒素抗体</li>
</ul>
</li>
<li>细胞免疫</li>
<li>黏膜免疫</li>
</ul>
<p>感染种类</p>
<ul>
<li>胞外菌感染</li>
<li>胞内菌感染</li>
<li>外毒素感染</li>
</ul>
<dl>
<dt>胞外菌</dt>
<dd>寄居在细胞外的细菌</dd>
<dd><em>胞外菌感染</em>主要依赖<strong>体液免疫</strong></dd>
<dt>胞内菌</dt>
<dd>寄居在细胞内的细菌</dd>
<dd><em>胞内菌感染</em>主要依赖<strong>细胞免疫</strong></dd>
</dl>
<ul>
<li>专性胞内菌</li>
<li>兼性胞内菌</li>
</ul>
<p><strong>外毒素</strong>（参见 <a href="/2021/03/21/%E7%BB%86%E8%8F%8C/#细菌的合成性代谢产物">细菌的合成性代谢产物</a>）主要依赖抗毒素中和作用。</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>支原体</title>
    <url>/2021/04/15/%E6%94%AF%E5%8E%9F%E4%BD%93/</url>
    <content><![CDATA[<dl>
<dt>支原体（<em>Mycoplasma</em>）</dt>
<dd>一类缺乏细胞壁、呈高度多形性、可通过细菌滤器、能在<strong>无生命培养基</strong>中生长繁殖的<strong>最小的<a href="/2021/03/16/%E7%97%85%E5%8E%9F%E7%94%9F%E7%89%A9%E5%AD%A6/#微生物">原核细胞型微生物</a></strong>。</dd>
<dd>归属柔膜体门柔膜体纲支原体目支原体科的<strong>支原体属</strong>和脲原体属。</dd>
</dl>
<p>对人体致病的支原体</p>
<ul>
<li><a href="#%E8%82%BA%E7%82%8E%E6%94%AF%E5%8E%9F%E4%BD%93">肺炎支原体</a></li>
<li>人型支原体</li>
<li>生殖器支原体</li>
<li>穿透支原体</li>
<li><a href="#%E8%A7%A3%E8%84%B2%E6%94%AF%E5%8E%9F%E4%BD%93">解脲支原体</a></li>
</ul>
<span id="more"></span>
<h2 id="概述">概述 <a class="markdownIt-Anchor" href="#概述">#</a></h2>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>形态：菌体小，呈高度多形性，可呈球、杆、丝状</li>
<li>特殊结构：荚膜，顶端结构，微丝
<ul>
<li>荚膜：抗吞噬，重要的毒力因子</li>
<li>顶端结构：黏附定植，重要致病物质</li>
</ul>
</li>
<li>繁殖方式：二分裂、出芽</li>
<li>染色：Giemsa 染色呈淡紫色；革兰氏染色阴性</li>
<li>培养特性：营养要求高，生长缓慢；菌落小，称 <strong>T 株</strong>（tiny strain），呈<strong>荷包蛋样</strong>（同<a href="/2021/03/21/%E7%BB%86%E8%8F%8C/#细胞壁">L 型细菌</a></li>
<li>抵抗力
<ul>
<li><strong>对青霉素耐药</strong>——没有细胞壁</li>
<li>对乙酸铊（脲原体敏感）、结晶紫、亚碲酸钾抵抗</li>
</ul>
</li>
</ul>
<div class="note warning"><p>支原体是引起细胞培养污染的一个重要因素。</p>
</div>
<p>支原体细胞膜含有<strong>胆固醇</strong>，有利于其维持细胞形态。</p>
<h3 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h3>
<ul>
<li>黏附素：黏附于上皮细胞导致<strong>细胞损伤</strong></li>
<li>荚膜或微荚膜：抗吞噬</li>
<li>毒性代谢产物</li>
<li>超抗原：刺激炎症细胞，产生大量细胞因子，引起组织损伤。</li>
<li>穿透支原体可导致<strong>免疫损伤</strong></li>
</ul>
<dl>
<dt>免疫损伤</dt>
<dd>由内源性或外源性抗原所致的细胞或体液介导的免疫应答导致的组织损伤称免疫损伤（immune injury）通常称之为变态反应（allergic reaction）或超敏反应( hypersensitivity reaction )。</dd>
</dl>
<h2 id="肺炎支原体">肺炎支原体 <a class="markdownIt-Anchor" href="#肺炎支原体">#</a></h2>
<dl>
<dt>肺炎支原体（<em>Mycoplasma pneumoniae</em>）</dt>
<dd>寄居于人和动物呼吸道黏膜表面，局部抵抗力降低时可致<strong>原发性非典型肺炎</strong>，是下呼吸道的主要机会致病性支原体。</dd>
</dl>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="致病性-2">致病性 <a class="markdownIt-Anchor" href="#致病性-2">#</a></h4>
<p>致病机制</p>
<ul>
<li>P1 粘附蛋白的粘附作用</li>
<li>代谢产物及酶类直接毒性</li>
<li>迟发性超敏反应</li>
</ul>
<dl>
<dt>支原体肺炎 | 原发性非典型肺炎（primary atypical pneumonia）</dt>
<dd>一种<strong>间质性肺炎</strong>。</dd>
</dl>
<details class="note info"><summary><p>间质性肺炎</p>
</summary>
<dl>
<dt>间质性肺炎</dt>
<dd>是一群主要侵犯肺泡上皮细胞，肺微血管内皮细胞、基底膜以及肺内血管及淋巴周围组织的微生物引起的疾病。</dd>
<dd>多数的间质肺病末期时会产生肺纤维化。</dd>
</dl>

</details>
<ul>
<li>占非细菌型肺炎的 50% 左右。</li>
<li>主要经飞沫传播，多见于 5~15 岁儿童，夏未秋初为好发季节</li>
<li>症状较轻，发热、咬嗽、有时有呼吸道外并发症</li>
</ul>
<p>临床表现</p>
<ul>
<li>类似病毒性肺炎</li>
<li>发热、咳瞰、WBC 低、咳嗽剧烈而持久</li>
<li><strong>自限性</strong>，不用抗生素可自愈</li>
</ul>
<p>常用<strong>冷凝集试验</strong>辅助诊断。</p>
<details class="note info"><summary><p>冷凝集试验</p>
</summary>
<dl>
<dt>冷凝集试验</dt>
<dd>冷凝集素抗体为自身抗体，针对红细胞表面抗原，在低温条件下使红细胞可逆性聚集。</dd>
<dd>健康人体内有低效价的冷凝集素，一般不会引起临床症状。但在如支原体肺炎、肝硬化、传染性单核细胞增多症、淋巴瘤等病理情况下，可能有高效价冷凝集素存在。</dd>
<dd>高效价冷凝集素经常造成检验项目的失真，最常见的影响就是血细胞分析结果异常、血型鉴定及交叉配血困难。</dd>
</dl>
<p>冷凝集试验为非特异性试验，不能排除其他病毒感染。</p>
<dl>
<dt>冷凝集素（cold agglutinating, Ca）</dt>
<dd>抗红细胞 I 抗原的 IgM 抗体。</dd>
</dl>

</details>
<h2 id="解脲脲原体">解脲脲原体 <a class="markdownIt-Anchor" href="#解脲脲原体">#</a></h2>
<dl>
<dt>解脲脲原体（<em>Ureaplasma urealyticum</em>）| 溶脲脲原体</dt>
<dd>人类泌尿生殖道常见的寄生菌，脲酶丰富，可分解尿素产生 NH<sub>3</sub>，可在特定环境下致病，是性传播疾病的主要病原体之一。</dd>
</dl>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<ul>
<li>形态与染色：见<a href="#%E6%A6%82%E8%BF%B0">支原体</a></li>
<li>抵抗力：对乙酸铊、红霉素敏感</li>
</ul>
<h3 id="致病性-3">致病性 <a class="markdownIt-Anchor" href="#致病性-3">#</a></h3>
<p>传播途径</p>
<ul>
<li>垂直传播：自然流产、出生缺陷、死胎</li>
<li>性传播
<ul>
<li>非淋菌性尿道炎（NGU）</li>
<li>输卵管炎、盆腔感染等</li>
<li>不孕症（脲原体可附着在精子表面，阻碍其运动、诱导其凋亡、影响与卵子结合）</li>
</ul>
</li>
</ul>
<h2 id="穿透支原体">穿透支原体 <a class="markdownIt-Anchor" href="#穿透支原体">#</a></h2>
<dl>
<dt>穿透支原体（<em>Mycoplasma penetrans</em>）</dt>
<dd>1990 年首次从 1 例 HIV 阳性艾滋病患者尿中分离出的一种新支原体。穿透支原体感染是<strong>艾滋病</strong>的辅助致病因素。</dd>
<dd>致病性与其尖形结构有关，具粘附和穿入作用，引起细胞损伤。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>放线菌</title>
    <url>/2021/04/15/%E6%94%BE%E7%BA%BF%E8%8F%8C/</url>
    <content><![CDATA[<dl>
<dt>放线菌（Actinomycetes）</dt>
<dd>一群<strong>革兰氏阳性</strong>，呈菌丝状生长和以孢子繁殖（与真菌相似）的<strong>原核生物</strong>。因在固体培养基上菌落呈放线状生长而得名。</dd>
</dl>
<ul>
<li>益处：生产<strong>抗生素</strong>（80% 的抗生素种类）、酶、维生素等</li>
<li>害处：放线菌科下的<a href="#%E6%94%BE%E7%BA%BF%E8%8F%8C%E5%B1%9E"><strong>放线菌属</strong></a>和<a href="#%E8%AF%BA%E5%8D%A1%E8%8F%8C%E5%B1%9E"><strong>诺卡菌属</strong></a>可分别引起放线菌病和诺卡菌病</li>
</ul>
<span id="more"></span>
<h2 id="放线菌属">放线菌属 <a class="markdownIt-Anchor" href="#放线菌属">#</a></h2>
<dl>
<dt>放线菌属（<em>Actinomyces</em>）</dt>
<dd>属于人体正常菌群，主要引起<strong>内源性感染</strong>。</dd>
</dl>
<div class="note info"><p>人类放线菌感染中 90% 的病原体为<mark>衣氏放线菌</mark>。其对人类致病性最强。</p>
</div>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>形态与染色：与<a href="/2021/04/01/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/#白喉棒状杆菌">棒状杆菌</a>相似——无荚膜、无芽孢、无鞭毛</li>
<li>培养特性和生化反应：<strong>专性厌氧</strong></li>
</ul>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<p>放线菌属于人体<mark>正常菌群</mark>，存在于口腔、呼吸道、胃肠道及泌尿生殖道，毒力弱，利用创伤、手术等机会入侵，引起<mark>内源性感染</mark>。</p>
<h4 id="所致疾病">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病">#</a></h4>
<dl>
<dt>放线菌病（actinomycosis）</dt>
<dd>临床表现：软组织<strong>肉芽肿性及化脓性炎症</strong>，可形成多发性脓肿、多发性瘘管</dd>
<dd>好发部位：面颈、舌、下颌等部位多见；也可发生于腹、胸、盆腔、皮肤等处</dd>
</dl>
<div class="note info"><p>也可能与牙周炎的发生有关。</p>
</div>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<p>脓液和痰液中可见<mark>硫磺样颗粒</mark>。</p>
<dl>
<dt>“硫磺样颗粒” | 放线菌块</dt>
<dd>放线菌在组织中形成的菌落，存在于病灶组织或脓性分泌物中，是临床辅助诊断放线菌病的指标
<ul>
<li>外观：直径 0.1~0.2mm，黄、硬</li>
<li>压片或组织切片
<ul>
<li>直接镜检（HE 染色）：可见放射状、<strong>形似菊花</strong>的菌丝。</li>
<li>革兰染色：中心 G<sup>+</sup>，边缘 G<sup>-</sup></li>
</ul>
</li>
</ul>
</dd>
</dl>
<h2 id="诺卡菌属">诺卡菌属 <a class="markdownIt-Anchor" href="#诺卡菌属">#</a></h2>
<dl>
<dt>诺卡菌属（<em>Nocardia</em>）</dt>
<dd>主要通过呼吸道或伤口侵入，引起<strong>外源性感染</strong>。</dd>
</dl>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<ul>
<li>形态与染色：形态与放线菌属类似但菌丝末端不膨大，G<sup>+</sup></li>
<li>培养特性：<strong>专性需氧</strong></li>
</ul>
<h3 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h3>
<ul>
<li>感染来源：<strong>外源性感染</strong></li>
<li>感染途径：呼吸道、伤口</li>
<li>易感人群：免疫功能低下者、长期使用广谱抗生素的患者</li>
</ul>
<p>临床表现</p>
<ul>
<li>肺部感染会产生类似<a href="/2021/04/01/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/#结核分枝杆菌">肺结核</a>的症状</li>
<li>皮肤刺伤引起的感染，以<strong>化脓和坏死</strong>为特征，可形成化脓性肉芽肿，多发性瘘管，好发于足、腿部，故又称为<strong>足菌肿(mycetoma)</strong></li>
</ul>
<h3 id="微生物学检查-2">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查-2">#</a></h3>
<p><strong>诺卡菌属抗酸染色呈弱阳性</strong>。</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模大赛准备</title>
    <url>/2021/04/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%A4%A7%E8%B5%9B%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<ul>
<li>名称：高教社杯全国大学生数学建模竞赛</li>
<li>时间：9.9（周四）18:00 - 9.12（周日）20:00</li>
</ul>
<span id="more"></span>
<h2 id="事程">事程 <a class="markdownIt-Anchor" href="#事程">#</a></h2>
<p>优先级由高到低：</p>
<ul class="task-list">
<li class="task-list-item"><div class="checkbox" /><input type="checkbox" id="cbx_0" disabled="true" /><label for="cbx_0"> SPSS/MatLab/R</label></div></li>
<li class="task-list-item"><div class="checkbox" /><input type="checkbox" id="cbx_1" disabled="true" /><label for="cbx_1"> 《数学建模算法与应用》</label></div></li>
<li class="task-list-item"><div class="checkbox" /><input type="checkbox" id="cbx_2" disabled="true" /><label for="cbx_2"> LaTeX</label></div></li>
</ul>
<h2 id="论文结构">论文结构 <a class="markdownIt-Anchor" href="#论文结构">#</a></h2>
<ol>
<li><a href="#%E6%91%98%E8%A6%81">摘要</a>（一页以内）</li>
<li><a href="#%E9%97%AE%E9%A2%98%E9%87%8D%E8%BF%B0">问题重述</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">问题分析</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E5%81%87%E8%AE%BE">模型假设</a></li>
<li><a href="#%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">符号说明</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E5%BB%BA%E7%AB%8B%E5%8F%8A%E6%B1%82%E8%A7%A3">模型建立及求解</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7">模型评价</a>（或加上模型推广 / 灵敏度分析 / 模型改进）</li>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ol>
<h3 id="摘要">摘要 <a class="markdownIt-Anchor" href="#摘要">#</a></h3>
<p>摘要是一篇文章的核心，应非常重视，一篇好的摘要是取胜的关键！一个好的摘要应突出模型的闪光点，用了什么样的模型，有什么样的创新，应说明研究工作的目的、方法、结和最终结论。切勿不能超过一页（研究生竞赛除外）！！！！</p>
<p>首先第一段为背景+结论</p>
<p>针对问题一：采用了什么模型，创新点在哪，得到了什么结论。</p>
<p>针对问题二：采用了什么模型，创新点在哪，得到了什么结论。</p>
<p>针对问题三：采用了什么模型，创新点在哪，得到了什么结论。</p>
<p>关键词（采用了什么模型，如插值、GM(1,1)、多元回归、主成分分析等等）</p>
<h3 id="问题重述">问题重述 <a class="markdownIt-Anchor" href="#问题重述">#</a></h3>
<p>阐明论文所研究的问题具有实际意义及建模的原题意思，列出所要研究的主要问题。不要直接把题目复制粘贴过来，另一方面也是降低查重率。</p>
<h3 id="问题分析">问题分析 <a class="markdownIt-Anchor" href="#问题分析">#</a></h3>
<p>分析问题，简述解决问题需要哪些条件和大体的解题思路，刨析问题的实质，确定解决问题的方法，为下面的模型假设、建立模型提供良好的基础。</p>
<h3 id="模型假设">模型假设 <a class="markdownIt-Anchor" href="#模型假设">#</a></h3>
<p>可以从题目和要求进行挖掘，运用模型的假设可以很好的对问题进行简化，但又不能建立太多假设，使求解与原意不符，应注意量与度。一般三到五条。</p>
<h3 id="符号说明">符号说明 <a class="markdownIt-Anchor" href="#符号说明">#</a></h3>
<p>文中出现的符号变量，便于读者阅读。</p>
<h3 id="模型建立及求解">模型建立及求解 <a class="markdownIt-Anchor" href="#模型建立及求解">#</a></h3>
<p>对问题的分析和模型的深入理解是建立一个好的模型的关键，比如该问题是一个预测问题，那么预测有很多模型，像前面所提到的插值、回归、GM(1,1)、GM（2，1）、时间序列、神经网络等等均可，那么采用什么样的模型取决于数据形式，如果数据量很少那么显然就不适合用神经网络，如果数据形式是单调的，那么推荐采用灰色预测模型，那么非单调的就不能用灰色预测模型。一个合适的模型是解决问题的关键，当然需要对我们的模型结果进行评估，比如R^2，RMSE等等来度量我们模型建立的优劣。引入一些创新点，比如将算法项结合可以得到一个更合适的模型和结果。</p>
<h3 id="模型评价">模型评价 <a class="markdownIt-Anchor" href="#模型评价">#</a></h3>
<p>（或加上模型推广 / 灵敏度分析 / 模型改进）</p>
<p>模型评价就是模型的优点和缺点，优点比如采用了什么样的模型，得到了一个很好的结果，或者对数据进行了合理的预处理，为后续建模做了合理的铺垫，创新性的建立了什么模型，使得结果更为科学准确等等，缺点切勿写得太多，不要暴露文章的重大问题，大家都是聪明人就不用我再多说了。</p>
<h3 id="参考文献">参考文献 <a class="markdownIt-Anchor" href="#参考文献">#</a></h3>
<h4 id="专著-论文集-报告">专著、论文集、报告 <a class="markdownIt-Anchor" href="#专著-论文集-报告">#</a></h4>
<p>[序号]主要责任者.文献题名[文献类型标识].出版地:出版者,出版年:起止页码(可选).</p>
<p>例如：[1]刘国钧,陈绍业.图书目录[M].北京:高等教育出版社,1957:15-18.</p>
<h4 id="期刊文章">期刊文章 <a class="markdownIt-Anchor" href="#期刊文章">#</a></h4>
<p>[序号]主要责任者.文献题名[J].刊名,年,卷(期):起止页码.
例如：[1]何龄修.读南明史[J].中国史研究,1998,(3):167-173.</p>
<p>[2]OU J P,SOONG T T,et al.Recent advance in research on applications of passive energy dissipation systems[J].Earthquack Eng,1997,38(3):358-361.</p>
<h4 id="论文集中的析出文献">论文集中的析出文献 <a class="markdownIt-Anchor" href="#论文集中的析出文献">#</a></h4>
<p>[序号]析出文献主要责任者.析出文献题名[A].原文献主要责任者(可选)原文献题名[C].出版地:出版者,出版年:起止页码.</p>
<p>例如：[7]钟文发.非线性规划在可燃毒物配置中的应用[A].赵炜.运筹学的理论与应用——中国运筹学会第五届大会论文集[C].西安:西安电子科技大学出版社,1996:468.</p>
<h4 id="学位论文">学位论文 <a class="markdownIt-Anchor" href="#学位论文">#</a></h4>
<p>[序号]主要责任者.文献题名[D].出版地:出版单位,出版年:起止页码(可选).</p>
<p>例如：[4]赵天书.诺西肽分阶段补料分批发酵过程优化研究[D].沈阳:东北大学,2013.</p>
<h4 id="报纸文章">报纸文章 <a class="markdownIt-Anchor" href="#报纸文章">#</a></h4>
<p>[序号]主要责任者.文献题名[N].报纸名,出版日期(版次).</p>
<p>例如：[8]谢希德.创造学习的新思路[N].人民日报,1998-12-25(10).</p>
<h4 id="电子文献">电子文献 <a class="markdownIt-Anchor" href="#电子文献">#</a></h4>
<p>[文献类型/载体类型标识]：[J/OL]网上期刊、[EB/OL]网上电子公告、
[M/CD]光盘图书、[DB/OL]网上数据库、[DB/MT]磁带数据库
[序号]主要责任者.电子文献题名[电子文献及载体类型标识].电子文献的出版或获得地址,发表更新日期/引用日期.
例如：[12]王明亮.关于中国学术期刊标准化数据库系统工程的进展[EB/OL].1998-08-16/1998-10-01.
[8]万锦.中国大学学报文摘(1983-1993).英文版[DB/CD].北京:中国大百科全书出版社,1996.</p>
<h3 id="代码">代码 <a class="markdownIt-Anchor" href="#代码">#</a></h3>
<p>美赛中不附代码，其余竞赛中必须附上。</p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>数学建模</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>染色体病</title>
    <url>/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/</url>
    <content><![CDATA[<dl>
<dt>染色体病</dt>
<dd>染色体数目异常或结构畸变引起的疾病，多表现为生长迟缓、智力低下和各种身体异常的复杂综合征。</dd>
</dl>
<p>涉及 1~22 号染色体者称为 <strong>常染色体病</strong>（autosomal disease）；涉及 X 染色体或 Y 染色体者称为 <strong>性染色体病</strong>（sex chromosomal disease）。</p>
<span id="more"></span>
<h2 id="染色体形态学">染色体形态学 <a class="markdownIt-Anchor" href="#染色体形态学">#</a></h2>
<h3 id="人类染色体的结构-形态和分类">人类染色体的结构、形态和分类 <a class="markdownIt-Anchor" href="#人类染色体的结构-形态和分类">#</a></h3>
<blockquote>
<p>典型的染色体出现于 <strong>分裂中期</strong>。</p>
</blockquote>
<h4 id="着丝粒">着丝粒 <a class="markdownIt-Anchor" href="#着丝粒">#</a></h4>
<dl>
<dt>着丝粒（centromere）</dt>
<dd>主要由 <a href="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/?highlight=串联重复序列#单一序列和重复序列">短串联重复 DNA 序列</a> 构成，是 <em>动粒</em> （kinetochore）形成的位点。</dd>
</dl>
<p>着丝粒将染色体纵轴分为 <strong>短臂</strong>（p）或 <strong>长臂</strong>（q）两部分。</p>
<p>根据着丝粒的位置，将人类染色体分为 3 种类型：</p>
<ol>
<li><strong>中央着丝粒染色体</strong>（metacentric chromosome）：着丝粒位于或接近染色体中央（1/2~5/8）；</li>
<li><strong>亚中着丝粒染色体</strong>（submetacentric chromosome）：着丝粒位于染色体纵轴 5/8~7/8 之间，短、长臂差异明显；</li>
<li><strong>近端着丝粒染色体</strong>（acrocentric chromosome）：着丝粒位于染色体纵轴 7/8 至末端之间，短臂很短，短臂末端往往存在 <a href="?highlight=%E9%9A%8F%E4%BD%93#%E9%9A%8F%E4%BD%93">随体</a> 结构。</li>
</ol>
<h4 id="主缢痕和次缢痕">主缢痕和次缢痕 <a class="markdownIt-Anchor" href="#主缢痕和次缢痕">#</a></h4>
<dl>
<dt>主（初级）缢痕（primary constriction）</dt>
<dd>每一条染色体的两条染色单体之间，由着丝粒相连处向内凹陷缩窄的部分。</dd>
<dt>次缢痕（secondary constriction）</dt>
<dd>某些染色体（如 1、9、16 号染色体等）的长臂或短臂上凹陷缩窄的部分。</dd>
</dl>
<p>次缢痕可作为染色体的 <em>特异性标志</em>。</p>
<h4 id="随体">随体 <a class="markdownIt-Anchor" href="#随体">#</a></h4>
<dl>
<dt>随体（satellite）</dt>
<dd>人类 <a href="?highlight=%E8%BF%91%E7%AB%AF%E7%9D%80%E4%B8%9D%E7%B2%92%E6%9F%93%E8%89%B2%E4%BD%93#%E7%9D%80%E4%B8%9D%E7%B2%92">近端着丝粒染色体</a> 短臂末端的一球状结构。</dd>
</dl>
<p>随体与染色体主题的连接部位为 <em>次缢痕</em>，该部位与核仁的形成有关，称为 <strong><mark>核仁组织区</mark></strong>（nucleolus organizer region，<mark><abbr title="nucleolus organizer region，核仁组织区">NOR</abbr></mark>）。</p>
<h4 id="端粒">端粒 <a class="markdownIt-Anchor" href="#端粒">#</a></h4>
<dl>
<dt>端粒（telomere）</dt>
<dd>染色体短臂和长臂末端分别存在的一特化部位，主要由短串联六核苷酸重复单位 (TTAGGG)<sub>n</sub> 组成。</dd>
</dl>
<h3 id="人类染色体的非显带核型">人类染色体的非显带核型 <a class="markdownIt-Anchor" href="#人类染色体的非显带核型">#</a></h3>
<p><strong>丹佛体制</strong>（Denver system）将人类染色体分为 23 对，共 7 组。</p>
<p class="align-text-center table-caption ">
      染色体分组
    </p>
<table>
<thead>
<tr>
<th>组</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>染色体</td>
<td>1~3</td>
<td>4，5</td>
<td>6~12，X</td>
<td>13~15</td>
<td>16~18</td>
<td>19，20</td>
<td>21，22，Y</td>
</tr>
</tbody>
</table>
<dl>
<dt>核型（karyotype）</dt>
<dd>即一个体细胞中全部中期染色体的构成。</dd>
<dd>也可指一个细胞中的全部染色体，按其大小和形态特征排列所构成的图像。</dd>
<dt>核型分析（karyotype analysis）</dt>
<dd>依照 <em>丹佛体系</em>，对中期染色体进行配对、编号、分组以及形态分析的过程。</dd>
</dl>
<h3 id="染色体显带">染色体显带 <a class="markdownIt-Anchor" href="#染色体显带">#</a></h3>
<h4 id="常用染色体显带技术">常用染色体显带技术 <a class="markdownIt-Anchor" href="#常用染色体显带技术">#</a></h4>
<ol>
<li><strong>Q 显带</strong>：用荧光燃料染色，在荧光显微镜下可见每条染色体沿其纵轴呈现明暗相间、宽窄不同的带纹；</li>
<li><strong>G 显带</strong>（<mark>常用</mark>）：先用胰酶或热、碱等预处理后再进行 Giemsa 染色，可见 Q 显带的亮带都被染成了深色，而暗带则被染成了浅色；</li>
<li><strong>R 显带</strong>：用盐溶液预处理后再进行 Giemsa 染色，带型与 G 显带相反，对于研究 <strong>末端缺失和重排</strong> 特别有用；</li>
<li><strong>C 显带</strong>：用 NaOH 或 Ba(OH)2 预处理染色体后再进行 Giemsa 染色，可特异地将着丝粒和副缢痕区的 <strong>组成型异染色质</strong> 染成深色；</li>
<li><strong>N 显带</strong>：用硝酸银预处理后再行 Giemsa 染色，可特异性地将人类 <em>近端着丝粒染色体</em> 短臂副缢痕区的 <strong>核仁组织区</strong> 浓染成黑色。</li>
</ol>
<h4 id="染色体显带的描述">染色体显带的描述 <a class="markdownIt-Anchor" href="#染色体显带的描述">#</a></h4>
<p>染色体的 <strong>界标</strong>（landmark）指对于识别染色体具有重要意义、稳定而显著的形态学特征，如染色体末端、着丝粒以及某些恒定的带。<br/>
<strong>区</strong>（region）指相临 <em>界标</em> 之间的区域。</p>
<p><em>区</em> 和 <em>带</em> 均从着丝粒开始编号。</p>
<p>描述某染色体带，需写明（如 1p31 表示 1 号染色体短臂 3 区 1 带）：</p>
<ol>
<li>染色体号</li>
<li>臂的符号</li>
<li>区的序号</li>
<li>带的序号</li>
</ol>
<h4 id="高分辨率显带技术">高分辨率显带技术 <a class="markdownIt-Anchor" href="#高分辨率显带技术">#</a></h4>
<p>从早中期、前中期、晚前期细胞中获得的更长、带纹更丰富的染色体，由 320 条代细分为 <strong>亚带</strong> 和 <strong>次亚带</strong>。</p>
<h3 id="荧光原位杂交技术">荧光原位杂交技术 <a class="markdownIt-Anchor" href="#荧光原位杂交技术">#</a></h3>
<dl>
<dt>荧光原位杂交（fluorescence <em>in situ</em> hybridization，<mark><abbr title="fluorescence in situ hybridization，荧光原位杂交">FISH</abbr></mark>）</dt>
<dd>使用荧光基因代替传统原位杂交技术中的同位素，避免了使用放射性标记，具有直观、快速、安全、特异性好、灵敏度高的优点，包括 <strong>DNA 纤维荧光原位杂交</strong>、<strong>染色体涂染</strong> 等。</dd>
</dl>
<dl>
<dt>DNA 纤维荧光原位杂交（DNA fiber fluorescence <em>in situ</em> hybridization，DNA fiber-<abbr title="fluorescence in situ hybridization，荧光原位杂交">FISH</abbr>）</dt>
<dd>一种制备细胞间期染色质纤维样本后再进行荧光原位杂交的技术。</dd>
<dt>染色体涂染（chromosome painting）</dt>
<dd>用荧光染料对整条染色体或染色体的特定区段的 DNA 进行标记的技术。</dd>
</dl>
<h2 id="染色体畸变">染色体畸变 <a class="markdownIt-Anchor" href="#染色体畸变">#</a></h2>
<h3 id="染色体数目畸变">染色体数目畸变 <a class="markdownIt-Anchor" href="#染色体数目畸变">#</a></h3>
<dl>
<dt>染色体组（chromosome set）</dt>
<dd>二倍体生物的正常精子或卵子中所包含的全部染色体（22+X 或 22+Y）。</dd>
</dl>
<p>对人类来说，正常体细胞染色体数超过或少于 46 条，即为 <em>数目异常</em>。</p>
<h4 id="整倍体">整倍体 <a class="markdownIt-Anchor" href="#整倍体">#</a></h4>
<p>仅包含一个染色体组的细胞或个体称为 <strong>单倍体</strong>（haploid）。</p>
<p>染色体成组（染色体组）地增加即形成 <strong>整倍体</strong>，三倍体以上的细胞或个体又称为 <strong>多倍体</strong>（polyploid）。</p>
<h5 id="三倍体">三倍体 <a class="markdownIt-Anchor" href="#三倍体">#</a></h5>
<p>形成原因：</p>
<ol>
<li><strong>双雄受精</strong>（diandry）：同时有两个精子进入卵细胞；</li>
<li><strong>双雌受精</strong>（digyny）：第二次减数分裂时，第二极体的染色体组由于某些原因未排出次级卵母细胞之外。</li>
</ol>
<h5 id="四倍体">四倍体 <a class="markdownIt-Anchor" href="#四倍体">#</a></h5>
<p>形成原因：</p>
<ol>
<li><strong>核内复制</strong>（endoreduplication）：一次细胞分裂中，染色体复制两次［双倍染色体（diplochromosome）］；</li>
<li><strong>核内有丝分裂</strong>（endomitosis）：分裂中期时，核膜未破裂、消失，亦无纺锤丝形成及胞质分裂。</li>
</ol>
<h4 id="非整倍体">非整倍体 <a class="markdownIt-Anchor" href="#非整倍体">#</a></h4>
<dl>
<dt>非整倍体（aneuploid）</dt>
<dd>染色体数目非 23 的倍数的细泵或个体。</dd>
</dl>
<ul>
<li><strong>亚二倍体</strong>（hypodiploid）：体细胞染色体数目少于 46 条，其中丢失一条染色体的情况被称为某染色体 <strong>单体</strong>（monosomy）；</li>
<li><strong>超二倍体</strong>（hyperdiploid）：体细胞染色体数目多于 46 条，多出一条者称为某染色体 <strong>三体</strong>（trisomy）。</li>
</ul>
<dl>
<dt>嵌合体（mosaic）</dt>
<dd>起源于同一合子发育成不同核型的细胞系所形成的个体。</dd>
</dl>
<p>形成原因：</p>
<ol>
<li><strong>染色体不分离</strong>（non-disjunction）：细胞分裂中后期，两条同源染色体或姐妹染色单体进入同一个细胞：
<ol>
<li>减数分裂不分离（meiotic  non-disjunction）（初级不分离、次级不分离）→ 亚二倍体、超二倍体</li>
<li>有丝分裂不分离（mitotic non-disjunction）→ 嵌合体</li>
</ol>
</li>
<li><strong>染色体丢失</strong>：有丝分裂中至后期，一条染色单体的着丝粒未与纺锤丝相连或由于某些原因导致移动迟缓，最终使该染色体滞留在细胞质中而被分解消失。</li>
</ol>
<h3 id="染色体结构畸变">染色体结构畸变 <a class="markdownIt-Anchor" href="#染色体结构畸变">#</a></h3>
<p><strong>染色体结构畸变</strong>（structural aberration）的结构基础是 <strong>染色体断裂</strong>（breakage）及随后的 <em>异常<strong>重接</strong></em>（rejoin）。</p>
<dl>
<dt>染色体重排（chromosome rearrangement）</dt>
<dd>染色体在辐射等因素的影响下发生断裂后，不在 <em>原位重接</em>，发生结构畸变。</dd>
</dl>
<h4 id="染色体畸变的描述方法">染色体畸变的描述方法 <a class="markdownIt-Anchor" href="#染色体畸变的描述方法">#</a></h4>
<ul>
<li><strong>简式</strong> 仅用断裂点来描述染色体的结构改变：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;染色体总数&gt;，&lt;性染色体组成&gt;，&lt;染色体重排的类型&gt;（&lt;染色体号&gt;）（&lt;断裂点所在臂、区、带号&gt;）</span><br><span class="line">46,XX,del(1)(q21)</span><br></pre></td></tr></table></figure>
</li>
<li><strong>详式</strong> 最后的括弧中描述重排染色体的组成，如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">46,XX,del(1)(pter→q21)</span><br></pre></td></tr></table></figure>
表示重排染色体组成为 pter→q21（ter 表示“末端”），q21→qter 丢失。</li>
</ul>
<h4 id="染色体结构畸变的类型和发生机制">染色体结构畸变的类型和发生机制 <a class="markdownIt-Anchor" href="#染色体结构畸变的类型和发生机制">#</a></h4>
<img data-src="/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/%E5%9B%9B%E5%B0%84%E4%BD%93.png" class="right" title="四射体" alt="四射体">
<ol>
<li><strong>缺失</strong>：del，染色体片段的缺失；</li>
<li><strong>倒位</strong>：inv，染色体发生两次断裂后，两断裂点之间的片段旋转 180 度后重接，造成染色体上的基因重排；</li>
<li><strong>相互易位</strong>：t，两条染色体分别发生断裂后，相互交换断裂片段、重接而形成两条衍生染色体。两对同源染色体可因为相互易位而形成 <strong>四射体</strong>。涉及 3 条染色体以上的易位称为 <em>复杂易位</em>；</li>
<li><strong>罗伯逊易位</strong>：+t，两条近端着丝粒染色体在着丝粒处断裂后重接；</li>
<li><strong>重复</strong>：dup，一条染色体上某一片段增加了与本身相同的部分区段；</li>
<li><strong>环状染色体</strong>：r，染色体两臂分别断裂后，含着丝粒的中间片段断端相连；</li>
<li><strong>等臂染色体</strong>：i，有丝分裂中期，连接两条姐妹染色单体的着丝粒未能正常发生纵裂，而是发生了横裂；</li>
<li><em>双着丝粒染色体</em>：两条染色体断裂后，具有着丝粒的残臂相连而成；</li>
<li><strong>插入</strong>：ins，一条染色体臂上发生两处断裂，同时另一条染色体也发生了断裂，前者断片插入后者，形成一条衍生染色体；</li>
<li><strong>标记染色体</strong>：形态上可辨认，但又无法确定其来源或特征的染色体，用 mar 表示。</li>
</ol>
<dl>
<dt>罗伯逊易位 | 着丝粒融合</dt>
<dd>易位的一种特殊类型，两条 <strong>近端着丝粒染色体</strong> 在着丝粒处断裂后重接，形成一条由长臂构成的衍生染色体。</dd>
<dt>平衡易位携带者</dt>
<dd>染色体发生了易位，单从基因成分来看仍保持平衡，故 <strong>表型正常</strong>，但子代可发生疾病，如 21 三体综合征。</dd>
</dl>
<h2 id="常见染色体病">常见染色体病 <a class="markdownIt-Anchor" href="#常见染色体病">#</a></h2>
<h3 id="常染色体异常综合征">常染色体异常综合征 <a class="markdownIt-Anchor" href="#常染色体异常综合征">#</a></h3>
<h4 id="21-三体综合征">21 三体综合征 <a class="markdownIt-Anchor" href="#21-三体综合征">#</a></h4>
<p><strong>21 三体综合征</strong>（trisomy 21 syndrome）又称<strong>先天愚型</strong>、<strong>唐氏综合症</strong>（Down syndrome），由于患者细胞内多了一条 21 号染色体所导致，是人类的第一个被发现的染色体病，也是最常见的染色体病。</p>
<h5 id="临床表现">临床表现 <a class="markdownIt-Anchor" href="#临床表现">#</a></h5>
<p>新生儿中 Down 综合征的发病率为 1/800~1/600，且发病率随母亲年龄的增高而增高。</p>
<ul>
<li>严重智力低下，<strong>智力发育不全</strong> 是本病最突出的症状</li>
<li>生长发育迟缓</li>
<li>眼裂小、眼距宽、外眼角上斜、内眦赘皮、鼻梁低平、耳朵小 ，低位或畸形、伸舌、有时流涎</li>
<li>通贯手、第1、2趾间间距宽</li>
</ul>
<h5 id="遗传学类型">遗传学类型 <a class="markdownIt-Anchor" href="#遗传学类型">#</a></h5>
<p>根据核型可分为三类：</p>
<ol>
<li><strong>单纯型</strong>（92.5%）：47，XX（或 XY），+21</li>
<li><strong>嵌合型</strong>（2.5%）：患者为 <a href="?highlight=%E5%B5%8C%E5%90%88%E4%BD%93#%E9%9D%9E%E6%95%B4%E5%80%8D%E4%BD%93">嵌合体</a>，核型常为 46/47，XX（或 XY），+21 嵌合型<br/>
根据染色体不分离发生的早晚，三体核型的细胞所占比例有所不同，47，+21 细胞比例越高，临床症状越重，低于 9% 时不表现出临床症状</li>
<li><strong>易位型</strong>（5%）：多余的染色体不单独存在，而是易位到了一近端着丝粒染色体（通常为 14 号）上形成 <strong>假二倍体</strong>（pseudoploid）个体，如 46，XX（或 XY），-<mark>14</mark>，+t（14；21）（p11；q11）</li>
</ol>
<h5 id="临床诊断-治疗和预防">临床诊断、治疗和预防 <a class="markdownIt-Anchor" href="#临床诊断-治疗和预防">#</a></h5>
<ul>
<li>超声：胎儿颈部皮褶增厚</li>
<li>孕妇血清（<strong>唐筛</strong>）：AFP（甲胎蛋白）及 E3（雌三醇）低于平均水平，HCG（绒毛膜促性腺激素）高于平均水平</li>
<li><strong>羊膜腔穿刺</strong>（amniocentesis）&amp; <a href="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/?highlight=绒毛膜取样#叶状绒毛膜"><strong>绒毛膜取样</strong></a>（CVS）</li>
<li>无创产前 DNA 检测/<strong>无创性产前筛查</strong>（noninvasive prenatal screening，NIPS）：</li>
</ul>
<h4 id="18-三体综合征">18 三体综合征 <a class="markdownIt-Anchor" href="#18-三体综合征">#</a></h4>
<ul>
<li>发病率：1/5000~1/4000</li>
<li>临床表现：
<ul>
<li><mark>特殊握拳姿势</mark>：握拳时第 3、4 指贴掌心，第 2、5 指重叠其上</li>
<li><mark>摇椅形足底</mark></li>
</ul>
</li>
</ul>
<h4 id="13-三体综合征">13 三体综合征 <a class="markdownIt-Anchor" href="#13-三体综合征">#</a></h4>
<ul>
<li>发病率：1/7000~1/5000</li>
<li>临床症状：唇裂/腭裂、多指、多趾</li>
</ul>
<h4 id="猫叫综合症">猫叫综合症 <a class="markdownIt-Anchor" href="#猫叫综合症">#</a></h4>
<p>由 <strong>5 号染色体短臂缺失</strong> 造成，故又称为 <strong>5<sup>-</sup> 综合征</strong>，因患者在婴幼儿期间由猫叫样哭声而被命名为 <strong>猫叫综合征</strong>（Cri du Chat syndrome）。猫叫综合征是 <em>最常见</em> 的染色体部分缺失综合征。</p>
<ul>
<li>发病率：1/50,000</li>
<li>临床症状：
<ul>
<li>生长发育迟缓、智力低下；</li>
<li>婴儿期 <strong>脸圆似满月</strong>，小下颌，少年期变成长脸；</li>
<li>婴儿期由于喉肌发育不良，哭声声波 <strong>似猫叫</strong>。</li>
</ul>
</li>
</ul>
<h3 id="性染色体异常综合征">性染色体异常综合征 <a class="markdownIt-Anchor" href="#性染色体异常综合征">#</a></h3>
<h4 id="性染色体和性别分化">性染色体和性别分化 <a class="markdownIt-Anchor" href="#性染色体和性别分化">#</a></h4>
<p>性染色体和性别分化见 <a href="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/#生殖系统发育">生殖系统发育</a>：<strong>SPY</strong>……。</p>
<h5 id="性染色质">性染色质 <a class="markdownIt-Anchor" href="#性染色质">#</a></h5>
<dl>
<dt>性染色质（sex chromatin）</dt>
<dd>间期细胞核中由 X he Y 染色体上的异染色质所呈现的一种特殊结构，见 <a href="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/#人类染色体">人类染色体</a> - <strong>X 染色质</strong>、Y 染色质。</dd>
</dl>
<h5 id="lyon-假说">Lyon 假说 <a class="markdownIt-Anchor" href="#lyon-假说">#</a></h5>
<p><strong><mark>Lyon 假说</mark></strong> 的要点：</p>
<ol>
<li>在细胞分裂间期，女性（或雌性哺乳动物）的两条 X 染色体中仅一条具有转录活性，另一条则高度螺旋化而呈 <strong>异固缩</strong>，形成浓染的染色质；</li>
<li>异固缩的 X 染色体可以来自父方，也可以来自母方，即 <strong>失活是随机发生的</strong>；</li>
<li>在女性胚胎发育初期，两条 X 染色体均有活性；至 <strong>发育早期</strong>（人胚第16天），其中一条即失活，呈异固缩而形成 X 染色质，并持续存在于子细胞中；</li>
<li>细胞中一旦决定了哪条 X 染色体失活，该细胞的 <strong>所有后裔细胞</strong> 中均是这条 X 染色体失活。</li>
</ol>
<h4 id="常见性染色体异常综合征">常见性染色体异常综合征 <a class="markdownIt-Anchor" href="#常见性染色体异常综合征">#</a></h4>
<h5 id="turner-综合征">Turner 综合征 <a class="markdownIt-Anchor" href="#turner-综合征">#</a></h5>
<dl>
<dt>Turner 综合征（Turner syndrome, TS）| 性腺发育不全综合征 | 先天性卵巢发育不全</dt>
<dd>是雌性个体因 X 染色体部分或完全缺失而引发的疾病，核型为 <strong>45,X</strong>、46,X,i(Xq)、46,X,del(Xq)、46,X,r(X)。</dd>
</dl>
<p>临床表现：</p>
<ul>
<li>原始生殖细胞退化，导致性腺不分化呈条索状、无雌激产生</li>
<li>生殖系统幼稚，第二性征不良，原发性闭经，不孕</li>
</ul>
<h5 id="klinefelter-综合征">Klinefelter 综合征 <a class="markdownIt-Anchor" href="#klinefelter-综合征">#</a></h5>
<dl>
<dt>Klinefelter 综合征 | 克氏综合征 | XXY 综合征 | 次雄性综合征</dt>
<dd>是由于男性有两条或两条以上的X染色体所致的疾病，核型为 <strong>47,XXY</strong>、48,XXXY、49,XXXXY。</dd>
</dl>
<p>临床表现：</p>
<ul>
<li>睾酮少，雌激素多，睾丸发育不良（隐睾、睾丸小）</li>
<li>身材高大、四肢细长、第二性征发育不良，乳房发育</li>
<li>无精子，不育</li>
</ul>
<h5 id="脆性-x-染色体综合征">脆性 X 染色体综合征 <a class="markdownIt-Anchor" href="#脆性-x-染色体综合征">#</a></h5>
<dl>
<dt>脆性 X 染色体综合征（fragile X chromosome，<abbr title="fragile X chromosome，脆性 X 染色体综合征">fra X</abbr>）</dt>
<dd>Xq27.3 包含 <strong>脆性部位</strong>，造成染色体断裂而末端呈 <strong>随体样</strong>。</dd>
</dl>
<p>Fra X 发病率高达 1/850，仅次于 <em>先天愚型</em>。</p>
<dl>
<dt>脆性部位（fragile site）</dt>
<dd>染色体上呈细丝状的部位，容易断裂。</dd>
</dl>
<p>现已证明 <abbr title="fragile X chromosome，脆性 X 染色体综合征">fra X</abbr> 为 <strong>X 连锁智力低下</strong> 的最常见原因。</p>
<p>一在脑组织中表达的基因 <em>FMR-Ⅰ</em>（fragile X mental retardation-Ⅰ）的 5’ 端存在一段编码精氨酸的三核苷酸重复序列 (CGG)<sub>n</sub>。<br/>
正常人群中 (CGG)<sub>n</sub> 的重复次数为 6~46（平均为 29）。重复超过 59 次时，该区域在减数分裂期呈现不稳定状态，重复次数可大幅度增加。</p>
<p><em>FMR-Ⅰ</em> 的突变：</p>
<ol>
<li>CGG 序列扩增形成 <strong>前突变</strong>（premutation），无症状的临床携带者具有 60~200 次重复；</li>
<li>CGG 进一步扩增并出现异常甲基化，演变为 <strong>全突变</strong>（full mutation），有症状者的重复超过 230 次。</li>
</ol>
<p>Fra X 即是 <em>CGG 串联重复过度增加</em>（<a href="/2021/03/24/%E4%BA%BA%E7%B1%BB%E5%8F%91%E8%82%B2%E7%9A%84%E7%BB%86%E8%83%9E%E5%AD%A6%E5%92%8C%E9%81%97%E4%BC%A0%E5%AD%A6%E5%9F%BA%E7%A1%80/?highlight=动态突变#动态突变"><strong><mark>动态突变</mark></strong></a>）和 <em>相邻区异常甲基化</em> 的结果。</p>
<p>男性携带者的女儿可携带全突变的基因而由于 X 染色体正常失活而表型正常。</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>消化系统和呼吸系统的发生</title>
    <url>/2021/05/29/%E6%B6%88%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%91%BC%E5%90%B8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/</url>
    <content><![CDATA[<dl>
<dt>原始消化管（primitive gut）</dt>
<dd>人胚第 3 周末，由于三胚层胚盘头尾和周边向腹侧卷曲，<strong>内胚层</strong> 被卷入胚体形成的一条纵行管道。</dd>
</dl>
<span id="more"></span>
<p>在胚体的头、尾部分，原始消化管分别形成 <strong>前肠</strong>（foregut）和
<strong>后肠</strong>（hindgut），其与卵黄囊相连的中间部分则称为 <strong>中肠</strong>（midgut）。<br/>
随着胚体发育，卵黄囊相对变小，中肠与卵黄囊相连的部分逐渐变细，形成 <strong>卵黄蒂</strong>（yolk stalk）。<br/>
前肠头端膨大形成 <strong>原始咽</strong>（primitive pharyngeal gut 或 primitive pharynx），与口凹相对处被 <strong>口咽膜</strong> 封闭；<br/>
后肠尾端膨大形成泄殖腔，其 <em>腹侧</em> 与肛凹相对处被 <strong>泄殖腔膜</strong> 封闭。</p>
<dl>
<dt>口咽膜（oropharyngeal membrane）、泄殖腔膜（cloacal membrane）</dt>
<dd>分别位于脊索头侧、原条尾侧的无中胚层、直接由内、外胚层相贴形成的薄膜区。</dd>
</dl>
<p>口咽膜和泄殖腔膜分别于 <mark>第 4 周</mark>、<mark>第 8 周</mark> 破裂。</p>
<h2 id="消化系统的发生">消化系统的发生 <a class="markdownIt-Anchor" href="#消化系统的发生">#</a></h2>
<p>消化系统的上皮组织大部分来源自内胚层，结缔组织和肌肉组织则由中胚层发育而来。<br/>
原始消化管的内胚层也分化为甲状腺、甲状旁腺、胸腺（原始咽）以及舌的上皮（咽壁内胚层）。</p>
<p>原始消化管的分化：</p>
<ul>
<li><strong>前肠</strong>：咽、食管、胃、十二指肠上段，以及肝、胆、胰和呼吸系统的原基；</li>
<li><strong>中肠</strong>：十二指肠下段、空肠、回肠、横结肠右 2/3 部；</li>
<li><strong>后肠</strong>：横结肠左 1/3、降结肠、乙状结肠、肛管上段，以及泌尿系统部分器官。</li>
</ul>
<h3 id="咽的发生及咽囊的演变">咽的发生及咽囊的演变 <a class="markdownIt-Anchor" href="#咽的发生及咽囊的演变">#</a></h3>
<p><a href="?highlight=%E5%8E%9F%E5%A7%8B%E5%92%BD#more">原始咽</a> 由前肠头端膨大形成，其侧壁有5 对囊状结构，称 <strong>咽囊</strong>（见 <a href="/2021/05/27/%E9%A2%9C%E9%9D%A2%E3%80%81%E9%A2%88%E5%92%8C%E5%9B%9B%E8%82%A2%E7%9A%84%E5%8F%91%E7%94%9F/?highlight=咽囊#鳃器的发生和演化">鳃器的发生和演化</a>）。</p>
<p>咽囊的演变：</p>
<ol>
<li>第 1 对咽囊：内侧 → 咽鼓管，末端 → 中耳鼓室，顶部鳃膜 → 鼓膜：</li>
<li>第 2 对咽囊：内侧 → 腭扁桃体，外侧 → 退化；</li>
<li>第 3 对咽囊：背侧份 → 下一对甲状旁腺，腹侧份 → 胸腺原基；</li>
<li>第 4 对咽囊：背侧份 → 上一对甲状旁腺，腹侧份 → 退化；</li>
<li>第 5 对咽囊 → <strong>后鳃体</strong>（ultimobranchial body）→ 滤泡旁细胞。</li>
</ol>
<h3 id="甲状腺的发生">甲状腺的发生 <a class="markdownIt-Anchor" href="#甲状腺的发生">#</a></h3>
<dl>
<dt>甲状舌管（thyroglossal duct）</dt>
<dd>及 <strong>甲状腺原基</strong>，在人胚第 4 周，在原始咽底壁正中线的与第 1
对咽囊相当的平面上，由上皮细胞增生形成的一伸向尾侧的盲管。</dd>
</dl>
<p>甲状舌管沿胚颈部正中向下延伸至为来的气管前方，末端向两侧逐渐膨大，形成左、右两个甲状腺侧叶和峡部。<br/>
甲状舌管上段则退化消失，其起始部分开口仍残留一浅凹，称 <strong>盲孔</strong>（foramen caecum）。</p>
<h3 id="食管的发生">食管的发生 <a class="markdownIt-Anchor" href="#食管的发生">#</a></h3>
<p>食管由 <strong>原始咽尾部</strong> 的一小段原始消化管发育而来。第 4 周时，食管很短。<br/>
随着胚体发育，食管逐渐生长变长，其腔面的内胚层分化为表皮上层，并由单层变成复层，使食管腔变窄甚至封闭。<br/>
人胚第 8 周时，过度增生的上皮逐渐退化，但保持复层，使食管腔再次出现。</p>
<h3 id="胃的发生">胃的发生 <a class="markdownIt-Anchor" href="#胃的发生">#</a></h3>
<p>第 4 周时，胃管尾端的前肠形成一梭形的膨大，即为 <strong>胃的原基</strong>，并以 <strong>背系膜</strong>（dorsal
mesogastrium）和 <strong>腹系膜</strong>（ventral mesogastrium）与体壁相连。</p>
<dl>
<dt>胃大弯（greater curvature）、胃小弯（lesser curvature）</dt>
<dd>胃背侧缘生长迅速，使胃体向背侧扩展，形成 <strong>胃大弯</strong>，胃大弯头端膨出，形成 <strong>胃底</strong>；而胃体腹侧缘生长缓慢，则形成 <strong>胃小弯</strong>。</dd>
</dl>
<p>胃背系膜生长较快，并向左侧扩展，膨出形成 <strong>网膜囊</strong> 和 <strong>大网膜</strong>，致使胃体沿纵轴顺时针（由上向下观）旋转 <mark>90°</mark>。<br/>
同时由于肝的发育，将胃的头端推向左侧，使胃由原来的垂直方位变成从左上斜向右下的方位。</p>
<h3 id="肠的发生">肠的发生 <a class="markdownIt-Anchor" href="#肠的发生">#</a></h3>
<p>肠发生与前肠的尾段、中肠、后肠。<br/>
肠的背系膜与腹后壁融合而被固定，而肠的腹系膜则很早就退化消失。</p>
<p>直肠发生见 <a href="?highlight=%E7%9B%B4%E8%82%A0#%E7%9B%B4%E8%82%A0%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E6%B3%84%E6%AE%96%E8%85%94%E7%9A%84%E5%88%86%E9%9A%94">直肠的发生与泄殖腔的分隔</a>。</p>
<h4 id="十二指肠的发生">十二指肠的发生 <a class="markdownIt-Anchor" href="#十二指肠的发生">#</a></h4>
<p>人胚第 4 周，在胃的尾侧形成十二指肠。<br/>
十二指肠生长较快，形成一凸向腹侧的“C”形 <strong>十二指肠襻</strong>（duodenum
loop），之后随胃的旋转转向左侧，并通过背系膜固定在右侧腹后壁。</p>
<h4 id="中肠的演变">中肠的演变 <a class="markdownIt-Anchor" href="#中肠的演变">#</a></h4>
<p>人胚第 5 周，中肠增长迅速，使肠管形成一个凸向腹侧的 <strong>中肠襻</strong>（midgut loop）<br/>
中肠襻与 <strong>卵黄管</strong> 相连，并由相连部位分为头至和尾支。<br/>
中肠襻背系膜将其固定于腹后壁，<strong>肠系膜上动脉</strong> 行走于其中轴部位。</p>
<dl>
<dt>盲肠突（caecal bud）</dt>
<dd>人胚第 5 周时，中肠襻尾支近卵黄囊处形成的一囊状突起。</dd>
</dl>
<p>盲肠突是大肠和小肠的分界点，也是 <strong>盲肠</strong>（近端）和<strong>阑尾</strong>（远端狭窄部分）的原基。</p>
<p>由于中肠迅速生长和肝、肾的发育长大，使中肠襻突入 <strong>脐腔</strong>，形成胚时期的 <strong><mark>生理性脐疝</mark></strong>。<br/>
同时，腹腔内的肠襻逆时针（由胚腹面观）旋转 <mark>90°</mark>，中肠襻由垂直方向转成水平方向。</p>
<dl>
<dt>脐腔（umbilical coelom）</dt>
<dd>脐带内残留的 <strong>胚外体腔</strong>，于第 10 周封闭。</dd>
</dl>
<p>第 10 周时，腹腔增大，中肠襻退回腹腔，中肠襻随之封闭。<br/>
中肠襻退回腹腔退回腹腔的同时，再次以肠系膜上动脉为轴向相同方向旋转
<mark>180°</mark>，头支转至腹腔左下方，尾支转至右上方。</p>
<ul>
<li>头支：空肠、回肠大部；</li>
<li>尾支
<ul>
<li>盲肠突前：回肠小部；</li>
<li>盲肠突后：横结肠右 2/3；</li>
</ul>
</li>
</ul>
<h4 id="后肠的演变">后肠的演变 <a class="markdownIt-Anchor" href="#后肠的演变">#</a></h4>
<p>肠襻退回腹腔时，<strong>后肠</strong> 被推向左侧，形成横结肠左 2/3 部分、降结肠和乙状结肠等。</p>
<h3 id="直肠的发生与泄殖腔的分隔">直肠的发生与泄殖腔的分隔 <a class="markdownIt-Anchor" href="#直肠的发生与泄殖腔的分隔">#</a></h3>
<dl>
<dt>泄殖腔（cloaca）</dt>
<dd>后肠末端的膨大部分。</dd>
</dl>
<p>泄殖腔腹侧端与 <strong>尿囊</strong> 相连，末端由 <strong>泄殖腔膜</strong> 封闭。</p>
<dl>
<dt>尿直肠隔（urorectal septum）</dt>
<dd>人胚第 6~7 周时，尿囊起始部和泄殖腔之间的间充质增生，形成一突入泄殖腔内的镰状隔膜。</dd>
</dl>
<p>尿直肠隔迅速增长，与泄殖腔膜相连，将泄殖腔分为背、腹侧两份。<br/>
与尿囊相连的腹侧份称为 <strong>尿生殖窦</strong>（urogenital sinus），将演变为膀胱和尿道；背侧份为
<strong>原始直肠</strong>，将演变为直肠和肛管上段。<br/>
泄殖腔膜也被分为背、腹侧两份，分别为 <strong>尿生殖膜</strong>（urogenital membrane）和 <strong>肛膜</strong>（anal membrane）。</p>
<p>肛膜周围形成一浅凹，称为 <strong>肛凹</strong> 或 <strong>原肛</strong>（proctodeum），在肛膜破裂后加深，演变为肛管下段。</p>
<div class="note info"><p>肛管上段上皮来自于内胚层（原始直肠），下段上皮则来自外胚层（原肛），两者之间以 <strong>尺状线</strong>（pectinate line）分隔。</p>
</div>
<h2 id="消化系统常见先天畸形">消化系统常见先天畸形 <a class="markdownIt-Anchor" href="#消化系统常见先天畸形">#</a></h2>
<dl>
<dt>回肠憩室 | 梅克尔憩室（Meckel’s diverticulum）</dt>
<dd>由于 <strong>卵黄蒂</strong> 退化不全而导致距回盲部 40~50cm 处的回肠壁上形成一个小囊状突起，有时有纤维索连于脐。</dd>
</dl>
<p>梅克尔憩室一般无临床症状，有时可发生肠扭转或肠梗阻。</p>
<dl>
<dt>脐粪瘘（umbilical fistula）</dt>
<dd>由于 <strong>卵黄蒂</strong> 未退化以致肠与脐之间残存一个瘘管，内容物可通过瘘管漏出。</dd>
<dt>先天性脐疝（congenital umbilical hernia）</dt>
<dd>由于 <a href="?highlight=%E8%84%90%E8%85%94#%E4%B8%AD%E8%82%A0%E7%9A%84%E6%BC%94%E5%8F%98">脐腔</a> 未正常闭锁所致。</dd>
</dl>
<p>腹内压升高时，肠管从脐部膨出，有时会形成嵌顿疝。</p>
<details class="note info"><summary><p>嵌顿疝</p>
</summary>
<p>指当腹内压突然升高时，疝内容物可强行扩张疝囊颈而突入疝囊，随后因疝囊颈弹性收缩，将疝内容物卡住而不能回纳腹腔的情况。</p>
<p>与绞窄性疝是同一疾病的不同阶段。两者的区别在于嵌顿疝尚未发生肠壁的缺血坏死。</p>

</details>
<h2 id="呼吸系统的发生">呼吸系统的发生 <a class="markdownIt-Anchor" href="#呼吸系统的发生">#</a></h2>
<h3 id="喉-气管和肺的发生">喉、气管和肺的发生 <a class="markdownIt-Anchor" href="#喉-气管和肺的发生">#</a></h3>
<p>第 4 周时，前肠原始咽的尾端腹侧正中部位出现一条纵行浅沟，称为 <strong>喉气管沟</strong>（laryngotracheal groove）。<br/>
喉气管沟逐渐加深，并从其尾端逐渐愈合，形成一个长条形盲囊，并向咽的腹侧膨出，称
<strong>喉气管憩室</strong>（laryngotracheal groove），为喉、气管、支气管和肺的原基。<br/>
喉气管憩室与其背侧的食管之间的间充质增生形成 <strong>气管食管隔</strong>（tracheoesophageal septum）。</p>

<h4 id="喉的发生">喉的发生 <a class="markdownIt-Anchor" href="#喉的发生">#</a></h4>
<p>喉由喉气管憩室的上端开口于咽的部分形成。<br/>
其黏膜上皮由内胚层分化而来，软骨、肌组织和结缔组织则由第 4、5 对 <a href="/2021/05/27/%E9%A2%9C%E9%9D%A2%E3%80%81%E9%A2%88%E5%92%8C%E5%9B%9B%E8%82%A2%E7%9A%84%E5%8F%91%E7%94%9F/?highlight=鳃弓#鳃器的发生和演化">鳃弓</a> 发育而来。</p>
<h4 id="气管和支气管的发生">气管和支气管的发生 <a class="markdownIt-Anchor" href="#气管和支气管的发生">#</a></h4>
<p><em>气管</em> 由喉气管憩室的中段发育形成，<em>支气管</em> 和 <em>肺</em> 则由 <strong>肺芽</strong> 演化而成。</p>
<dl>
<dt>肺芽（lung bud）</dt>
<dd>喉气管憩室末端膨大形成的左右两个分支。</dd>
</dl>
<h4 id="肺的发生">肺的发生 <a class="markdownIt-Anchor" href="#肺的发生">#</a></h4>
<p>人胚 2 个月时，<strong>肺芽</strong> 形成的肺叶支气管（2 支）分支形成肺段支气管（左肺 8~9 支，右肺
10 支）之后（包括出生后）支气管数的分支继续发育，形成总计 24 级的分支。</p>
<p>人胚 7 个月时，支气管树黏膜上皮细胞的一些立方上皮细胞逐渐分化为 <strong>Ⅰ 型肺泡细胞</strong>，形成原始肺泡。<br/>
同时 <strong>Ⅱ 型肺泡细胞</strong> 在 Ⅰ 型肺泡细胞之间出现，并开始分泌表面活性物质。<br/>
此时的肺已经具备了进行气体交换功能的结构，若此时早产，婴儿可有正常的呼吸功能。</p>
<h2 id="呼吸系统常见先天畸形">呼吸系统常见先天畸形 <a class="markdownIt-Anchor" href="#呼吸系统常见先天畸形">#</a></h2>
<dl>
<dt>肺<em>透明膜病</em>（hyaline membrane disease）</dt>
<dd><strong>Ⅱ 型肺泡细胞</strong> 发育不良，不能分泌表面活性物质，致使肺泡萎缩不张。若萎缩的肺泡上皮细胞表面覆盖一层从血管渗透出来的血浆蛋白膜，则可形成透明薄膜，称为 <em><strong>透明膜病</strong></em>。</dd>
</dl>
<p>透明膜病的新生儿出生后无法正常呼吸，可导致 <strong>呼吸窘迫综合征</strong>（respiratory distress syndrome，RDS）。</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
        <category>组织学与胚胎学</category>
        <category>胚胎学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
        <tag>组织学与胚胎学</tag>
        <tag>胚胎学</tag>
      </tags>
  </entry>
  <entry>
    <title>消化道感染病毒</title>
    <url>/2021/05/10/%E6%B6%88%E5%8C%96%E9%81%93%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<dl>
<dt>消化道感染病毒</dt>
<dd>经消化道感染并在消化道内繁殖
<ul>
<li>多引起 <strong>肠道外病变</strong>，如 <strong>肠道病毒属病毒</strong></li>
<li>引起 <strong>急性胃肠炎</strong></li>
</ul>
</dd>
</dl>
<span id="more"></span>
<h2 id="肠道病毒属病毒">肠道病毒属病毒 <a class="markdownIt-Anchor" href="#肠道病毒属病毒">#</a></h2>
<details class="note info"><summary><p>肠道病毒属病毒的共性</p>
</summary>
<ul>
<li>RNA 无包膜病毒
<ul>
<li>RNA：在细胞质内增殖</li>
<li>无包膜病毒：抵抗力强</li>
</ul>
</li>
<li>经粪-口途径传播</li>
<li>肠道外病变</li>
</ul>

</details>
<h3 id="脊髓灰质炎病毒">脊髓灰质炎病毒 <a class="markdownIt-Anchor" href="#脊髓灰质炎病毒">#</a></h3>
<h4 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h4>
<ul>
<li>形态：具有肠道病毒的典型特征</li>
<li>抗原结构和分类：应用 FLISA 或补体实验可分为三个血清型，不同型别见无价叉反应</li>
</ul>
<blockquote>
<p>脊髓灰质炎病毒疫苗均为三价混合疫苗</p>
</blockquote>
<ul>
<li>抵抗力</li>
<li>培养特性和生化反应</li>
</ul>
<h4 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h4>
<dl>
<dt>脊髓灰质炎</dt>
<dd>脊髓灰质炎病毒侵犯 <strong>中枢神经系统</strong> 所致的一种急性传染病</dd>
<dd>脊髓前角的运动神经细胞，进行性</dd>
</dl>
<ul>
<li>传染源：患者和隐性感染者</li>
<li>传播途径：粪-口途径</li>
<li>感染形式
<ul>
<li>95% 以上：</li>
<li>1%：</li>
</ul>
</li>
</ul>
<details class="note info"><summary><p>脊髓灰质炎病毒灭活疫苗和减毒活疫苗的区别</p>
</summary>
<ul>
<li>灭活脊髓灰质炎病毒（OPV）——Sabin 疫苗</li>
<li>脊髓灰质炎病毒减毒活疫苗（IPV）——Salk 疫苗</li>
</ul>
<table>
<thead>
<tr>
<th>接种项目</th>
<th>OPV</th>
<th>IPV</th>
</tr>
</thead>
<tbody>
<tr>
<td>接种方式</td>
<td>口服糖丸</td>
<td>肌肉注射</td>
</tr>
<tr>
<td>抗体产生</td>
<td>血清抗体、SIgA（黏膜免疫）</td>
<td>血清抗体</td>
</tr>
<tr>
<td>细胞免疫</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>间接免疫</td>
<td></td>
<td></td>
</tr>
<tr>
<td>稳定性</td>
<td>差，不易保存</td>
<td>易保存</td>
</tr>
<tr>
<td>副作用</td>
<td>毒力返主（<abbr title="疫苗相关麻痹型脊髓灰质炎">VAPP</abbr>）</td>
<td>无</td>
</tr>
<tr>
<td>免疫效果</td>
<td>更好</td>
<td>好</td>
</tr>
</tbody>
</table>

</details>
<h3 id="柯萨奇病毒">柯萨奇病毒 <a class="markdownIt-Anchor" href="#柯萨奇病毒">#</a></h3>
<h4 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h4>
<ul>
<li>形态与染色</li>
<li>抗原结构和分类</li>
<li>抵抗力</li>
<li>培养特性和生化反应</li>
</ul>
<h4 id="致病性-2">致病性 <a class="markdownIt-Anchor" href="#致病性-2">#</a></h4>
<ul>
<li>
<p>传播途径：消化道、呼吸道、垂直传播</p>
</li>
<li>
<p>致病特点：</p>
</li>
<li>
<p>对 <strong>乳鼠</strong> 有致病性</p>
</li>
<li>
<p>无菌性脑膜炎、类脊髓灰质炎样麻痹（非瘫痪型麻痹）</p>
</li>
<li>
<p>疱疹性咽峡炎、手足口病</p>
</li>
</ul>
<h3 id="埃可病毒">埃可病毒 <a class="markdownIt-Anchor" href="#埃可病毒">#</a></h3>
<p>埃可病毒（ECHOV 病毒）</p>
<ul>
<li>传播途径：xiao xia dao</li>
<li>所致疾病
<ul>
<li>神经：无菌性脑膜炎、类脊髓灰质炎样麻痹</li>
<li>普通感冒</li>
<li>婴幼儿腹泻</li>
</ul>
</li>
</ul>
<h3 id="新型肠道病毒">新型肠道病毒 <a class="markdownIt-Anchor" href="#新型肠道病毒">#</a></h3>
<ul>
<li>肠道病毒 70 型：对眼结膜有亲嗜性，可引起 <strong>急性出血性结膜炎（红眼病）</strong></li>
<li>肠道病毒 71 型
<ul>
<li>中枢神经系统疾病：无菌性脑膜炎、类脊髓灰质炎样麻痹</li>
<li>手足口病：自限性，若出现高烧不退的症状则需注意并发症</li>
</ul>
</li>
</ul>
<details class="note info"><summary><p>引起手足口病的病原体</p>
</summary>
<ul>
<li>柯萨奇病毒</li>
<li>肠道病毒 71 型（较严重）</li>
</ul>

</details>
<h2 id="胃肠炎病毒">胃肠炎病毒 <a class="markdownIt-Anchor" href="#胃肠炎病毒">#</a></h2>
<ol>
<li>轮状病毒</li>
<li>腺病毒</li>
<li>杯状病毒：如诺瓦克病毒，引起 <strong>胃肠炎爆发性流行</strong> ，自限性，注意补水补盐</li>
<li>星状病毒</li>
</ol>
<h3 id="轮状病毒">轮状病毒 <a class="markdownIt-Anchor" href="#轮状病毒">#</a></h3>
<ul>
<li><strong>分节段</strong> RNA</li>
<li>无包膜，衣壳分层，壳粒排列成车轮状</li>
</ul>
<h4 id="致病性-3">致病性 <a class="markdownIt-Anchor" href="#致病性-3">#</a></h4>
<ul>
<li>传染源：患者和</li>
<li>传播途径：消化道、呼吸道</li>
<li>所致疾病（自限性）
<ul>
<li>婴幼儿秋冬季腹泻</li>
<li>成人腹泻：免疫低下者，仅在我国分离得到</li>
</ul>
</li>
</ul>
<h4 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h4>
<p>减毒活疫苗，肠道畸形者禁止接种</p>
<h3 id="星状病毒">星状病毒 <a class="markdownIt-Anchor" href="#星状病毒">#</a></h3>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
      </tags>
  </entry>
  <entry>
    <title>消化道感染细菌</title>
    <url>/2021/03/29/%E6%B6%88%E5%8C%96%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/</url>
    <content><![CDATA[<dl>
<dt>消化道感染细菌</dt>
<dd>在胃肠道中增殖引起以胃肠道症状为主的病原菌</dd>
<dd>或引起食物中毒的病原菌</dd>
<dd>以及一些正常定居于肠道，引起<strong>肠道外感染</strong>的病原菌</dd>
</dl>
<ol>
<li>肠杆菌科细菌：<a href="#%E5%9F%83%E5%B8%8C%E6%B0%8F%E8%8F%8C%E5%B1%9E">埃希氏菌属</a>、<a href="#%E5%BF%97%E8%B4%BA%E8%8F%8C%E5%B1%9E">志贺菌属</a>、<a href="#%E6%B2%99%E9%97%A8%E8%8F%8C%E5%B1%9E">沙门菌属</a></li>
<li><a href="#%E5%B9%BD%E9%97%A8%E8%9E%BA%E6%9D%86%E8%8F%8C">幽门螺杆菌</a></li>
<li><a href="#%E9%9C%8D%E4%B9%B1%E5%BC%A7%E8%8F%8C">霍乱弧菌</a></li>
<li><a href="#%E5%89%AF%E6%BA%B6%E8%A1%80%E6%80%A7%E5%BC%A7%E8%8F%8C">副溶血性弧菌</a></li>
<li><a href="#%E5%BC%AF%E6%9B%B2%E8%8F%8C%E5%B1%9E">弯曲杆菌</a></li>
</ol>
<span id="more"></span>
<p>消化道感染细菌通过<strong>粪-口传播途径</strong>进行传播。</p>
<img data-src="/2021/03/29/%E6%B6%88%E5%8C%96%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/%E8%82%A0%E9%81%93%E6%9D%86%E8%8F%8C%E7%94%9F%E5%8C%96%E5%8F%8D%E5%BA%94.png" class="" title="肠道杆菌生化反应" alt="肠道杆菌生化反应">
<h2 id="肠杆菌科">肠杆菌科 <a class="markdownIt-Anchor" href="#肠杆菌科">#</a></h2>
<blockquote>
<p>肠杆菌科细菌的共同生物学特征</p>
</blockquote>
<ul>
<li>至少有 30 个菌属，120 个以上的菌种</li>
<li>多数是肠道的正常菌群；少数为致病菌，且是人类肠传染病的最重要病原菌</li>
</ul>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>形态与染色：革兰氏阴性（G<sup>-</sup>）杆菌，多数有鞭毛，有菌毛，无芽孢</li>
<li>抗原构造复杂</li>
<li>抵抗力：不强，60℃ 30min 即可灭活</li>
<li>培养特性
<ul>
<li>需氧或兼性厌氧</li>
<li>营养要求不高，普通培养基上可以生长，形成中等大小 S（光滑）型菌落</li>
</ul>
</li>
<li>生化反应活跃，可用于鉴别肠道杆菌</li>
<li>易变异：见<a href="/2021/03/21/%E7%BB%86%E8%8F%8C/#细菌的遗传和变异">细菌的遗传和变异</a>
<ul>
<li>接合、转导、溶源性转换</li>
<li>耐药型变异、毒力性变异、生化反应性变异</li>
</ul>
</li>
</ul>
<h3 id="引发的疾病">引发的疾病 <a class="markdownIt-Anchor" href="#引发的疾病">#</a></h3>
<ul>
<li>胃肠道疾病
<ul>
<li>大肠杆菌
<ul>
<li>机会致病菌，属于正常菌群</li>
<li><strong>乳糖发酵阳性</strong></li>
</ul>
</li>
<li>伤寒沙门菌、痢疾志贺菌、鼠疫耶尔菌
<ul>
<li>致病菌</li>
<li><strong>乳糖发酵阴性</strong></li>
</ul>
</li>
</ul>
</li>
<li>机会型感染：败血症、肺炎、脑膜炎、泌尿系统疾病</li>
</ul>
<dl>
<dt>乳糖发酵试验</dt>
<dd>初步鉴别肠道致病菌和肠道非致病菌
<ul>
<li>阳性：非致病菌（正常菌群可帮助人体分解糖类物质）</li>
<li>阴性：致病菌</li>
</ul>
</dd>
<dt>EMB 培养基 | 伊红-美兰培养基</dt>
<dd>含乳糖、伊红、美兰
<ul>
<li>鉴别作用（弱选）
<ul>
<li>大肠埃希菌（非致病菌）：发酵乳糖→产酸→伊红、美兰结合形成<strong>紫黑色金属光泽</strong>化合物</li>
<li>伤寒沙门菌（致病菌）：不发酵乳糖→无色</li>
</ul>
</li>
<li>选择作用：所含色素有轻微的抑制杂菌的作用</li>
</ul>
</dd>
<dt>SS 培养基 | 沙门志贺培养基</dt>
<dd>乳糖、中性红指示剂、胆盐、煌绿等抑制剂
<ul>
<li>选择抑制作用（强选）
<ul>
<li>大肠埃希菌：发酵乳糖→产酸→中性红呈<strong>桃红色</strong></li>
<li>伤寒沙门菌：不发酵乳糖→无色</li>
</ul>
</li>
<li>胆盐、煌绿等抑制剂：抑制大肠埃希菌及 G<sup>+</sup> 菌，提高肠道细菌检出率</li>
</ul>
</dd>
</dl>
<h2 id="埃希氏菌属">埃希氏菌属 <a class="markdownIt-Anchor" href="#埃希氏菌属">#</a></h2>
<dl>
<dt>埃希氏菌属</dt>
<dd>属于肠杆菌科，是人类和动物肠道的正常菌群，出生后数小时就进入肠道，并终生伴随
<ul>
<li>多数感染来自自身</li>
<li>是<mark>医源性感染</mark>的主要原因</li>
</ul>
</dd>
<dt>大肠埃希菌 | 大肠杆菌</dt>
<dd>埃希菌属的一种，为最常见的临床分离菌</dd>
<dd>常被用作<strong>粪便污染</strong>的检测指标</dd>
</dl>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<ul>
<li>形态与染色：G<sup>-</sup> 杆菌，有周身鞭毛，有菌毛</li>
<li>抗原结构和分类
<ul>
<li>菌体抗原（O 抗原）、鞭毛抗原（H 抗原）、荚膜抗原（K 抗原）</li>
<li>血清学分型以 <code>O:K:H</code> 排列，如 O157:H7</li>
</ul>
</li>
<li>抵抗力：见<a href="#%E8%82%A0%E6%9D%86%E8%8F%8C%E7%A7%91">肠杆菌科</a></li>
<li>培养特性和生化反应
<ul>
<li>符合<a href="#%E8%82%A0%E6%9D%86%E8%8F%8C%E7%A7%91">肠杆菌科</a>特点，多数能发酵乳糖</li>
<li>生化反应活泼，<strong>IMViC 试验</strong>结果为“+ + - -”</li>
</ul>
</li>
</ul>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="致病物质">致病物质 <a class="markdownIt-Anchor" href="#致病物质">#</a></h4>
<ol>
<li>菌毛：黏附</li>
<li>外毒素：引起腹泻
<ul>
<li>肠毒素</li>
<li>志贺毒素</li>
<li>溶血素</li>
</ul>
</li>
</ol>
<p>肠毒素</p>
<ul>
<li>不耐热肠毒素（LT）</li>
<li>耐热肠毒素（ST）</li>
</ul>
<dl>
<dt>志贺毒素（Stx）| 类志贺毒素/志贺样毒素（SLT） | Vero 毒素（Vt）</dt>
<dd>可导致肠上皮细胞死亡脱落、肠道出血、肾远曲小管和集合管变性、血小板凝聚、内皮细胞损伤、Vero 细胞病变</dd>
</dl>
<p>毒性</p>
<ul>
<li>肠毒素毒性：腹泻</li>
<li>细胞毒素毒性：细胞损伤</li>
<li>神经毒素毒性</li>
</ul>
<h4 id="所致疾病">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病">#</a></h4>
<ul>
<li>肠外感染——正常菌群
<ul>
<li>泌尿系统感染</li>
<li>化脓性感染：新生儿脑膜炎、败血症</li>
</ul>
</li>
<li>肠道感染——致病性大肠杆菌，带有致病基因的血清型
<ol>
<li>ETEC（肠产毒性大肠埃希菌）：
<ul>
<li>所致疾病：类似霍乱，婴幼儿和旅游者（<strong>水土不服</strong>）<strong>水样腹泻</strong></li>
<li>致病物质/机理
<ul>
<li>肠毒素</li>
<li>定植因子（菌毛）</li>
</ul>
</li>
</ul>
</li>
<li>EIEC（肠侵袭性大肠埃希菌）
<ul>
<li>所致疾病：类似菌痢（细菌性痢疾），<strong>脓血便</strong>，<mark>里急后重</mark></li>
<li>致病物质/机理
<ul>
<li>侵袭结肠粘膜上皮并繁殖</li>
<li>细菌死亡后释放内毒素，引起炎症</li>
</ul>
</li>
</ul>
</li>
<li>EPEC（肠致病性大肠埃希菌）
<ul>
<li>所致疾病：<strong>婴幼儿腹泻</strong></li>
<li>致病物质/机理
<ul>
<li>粘附和破坏肠粘膜微绒毛</li>
<li>上皮细胞排列紊乱，功能受损，导致腹泻</li>
</ul>
</li>
</ul>
</li>
<li>EHEC（肠出血性大肠埃希菌） | VTEC（Vero 毒素大肠埃希菌）
血清型为 O157:H7
<ul>
<li>所致疾病：<strong>出血性结肠炎</strong>，轻重不一、10% 的十岁以下患者有严重并发症——急性肾衰竭、溶血性尿毒综合征（HUS），<strong>死亡率高</strong></li>
<li>致病物质/机理
<ul>
<li>菌毛：黏附</li>
<li>毒素：Vero 毒素、内毒素、溶血素</li>
</ul>
</li>
</ul>
</li>
<li>EAEC 或 EAggEC（肠集聚性大肠埃希菌）
<ul>
<li>所致疾病：<strong>婴儿持续性腹泻</strong>（14 天以上）</li>
<li>致病物质/机理
<ul>
<li>菌毛</li>
<li>外毒素
<ul>
<li>肠集聚耐热毒素（EAST）：抗原上和 ETEC 的 ST 有关，可导致大量液体分泌</li>
<li>α 溶血素</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="微生物学检查与防治">微生物学检查与防治 <a class="markdownIt-Anchor" href="#微生物学检查与防治">#</a></h3>
<ul>
<li>肠道外感染
<ul>
<li>标本→涂片、染色→分离培养→鉴定</li>
<li>尿路感染是每 ml 尿含菌 ≥10 万 , 有诊断价值</li>
</ul>
</li>
<li>肠道内感染
<ul>
<li>鉴别培养基→大肠埃希菌→肠毒素、毒力因子、血清型鉴定</li>
</ul>
</li>
</ul>
<p>卫生学指标</p>
<ul>
<li>环境和食品卫生学上，常被用作粪便污染的检测指标</li>
<li>100ml 水样中，大肠杆菌不得被检出</li>
</ul>
<h2 id="志贺菌属">志贺菌属 <a class="markdownIt-Anchor" href="#志贺菌属">#</a></h2>
<dl>
<dt>志贺菌属（shigella）</dt>
<dd>又称<strong>痢疾杆菌</strong>，是人类<strong>细菌性痢疾</strong>最为常见的病原菌</dd>
</dl>
<h3 id="生物学特性-3">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-3">#</a></h3>
<ul>
<li>形态与染色：符合肠杆菌特征，<mark>无鞭毛</mark>（利用此特性可借助<strong>半固体培养基</strong>鉴定）</li>
<li>抗原结构和分类：根据 O 抗原（菌体抗原），分群和型
<ol>
<li>A 群：痢疾志贺菌</li>
<li>B 群：福氏志贺菌</li>
<li>C 群：鲍氏志贺菌</li>
<li>D 群：宋内志贺菌</li>
</ol>
</li>
<li>抵抗力：<strong>低</strong>于其他肠道杆菌，对酸敏感</li>
<li>培养特性：肠道鉴别培养基（EMB、SS）上，呈现为无色半透明的不发酵乳糖菌落</li>
<li>生化反应：葡萄糖（+），乳糖（-）（<strong>宋内志贺菌</strong>除外），<mark>H<sub>2</sub>S（-）</mark></li>
</ul>
<h3 id="致病性与免疫性-2">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-2">#</a></h3>
<p>主要传染源为患者，经粪-口途径传播</p>
<h4 id="致病物质-2">致病物质 <a class="markdownIt-Anchor" href="#致病物质-2">#</a></h4>
<ul>
<li>侵袭力：菌毛——有利于细胞黏附至肠黏膜</li>
<li>毒素
<ul>
<li>内毒素：局部，脓血粘液便，里急后重</li>
<li>外毒素（A 群 1 型和 2 型）——<a href="#%E5%9F%83%E5%B8%8C%E6%B0%8F%E8%8F%8C%E5%B1%9E"><strong>志贺毒素</strong></a></li>
</ul>
</li>
</ul>
<h4 id="所致疾病-2">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-2">#</a></h4>
<p>痢疾，<mark>感染灶局限于结肠粘膜层，一般不入血</mark></p>
<ul>
<li>急性痢疾：发热、腹痛、脓血粘液便、里急后重</li>
<li>中毒性痢疾：以小儿多见，主要表现为全身中毒症状</li>
<li>慢性痢疾：病程迁移 2 个月以上</li>
</ul>
<h4 id="免疫性">免疫性 <a class="markdownIt-Anchor" href="#免疫性">#</a></h4>
<p>病后免疫期短，也不巩固</p>
<h3 id="治疗">治疗 <a class="markdownIt-Anchor" href="#治疗">#</a></h3>
<p>一般使用<strong>抗生素</strong></p>
<h2 id="沙门菌属">沙门菌属 <a class="markdownIt-Anchor" href="#沙门菌属">#</a></h2>
<dl>
<dt>沙门菌属</dt>
<dd>一群寄生在人类和动物肠道中的 G<sup>-</sup> 菌，许多为人畜共患病</dd>
</dl>
<h3 id="生物学特性-4">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-4">#</a></h3>
<ul>
<li>形态与染色：符合肠杆菌特点，均有周身鞭毛，有菌毛</li>
<li>抗原结构和分类：O 抗原，H 抗原，少数有 Vi 抗原（荚膜抗原）</li>
<li>培养特性和生化反应：不发酵乳糖，发酵葡萄糖，<mark>产生H<sub>2</sub>S</mark>（伤寒沙门菌产生的量较少）</li>
</ul>
<dl>
<dt>Vi 抗原</dt>
<dd>抗原性弱，起保护作用，<strong>Vi 抗体</strong>可用于带菌者的检出</dd>
</dl>
<h3 id="致病性与免疫性-3">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-3">#</a></h3>
<p>无症状带菌者——“伤寒玛丽”</p>
<h4 id="致病物质-3">致病物质 <a class="markdownIt-Anchor" href="#致病物质-3">#</a></h4>
<ul>
<li>侵袭力：侵袭素（侵袭素基因 inv）、Vi 抗原</li>
<li>毒素
<ul>
<li>内毒素</li>
<li>外毒素（鼠伤寒沙门菌）——肠毒素，引起腹泻</li>
</ul>
</li>
</ul>
<h4 id="所致疾病-3">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-3">#</a></h4>
<ul>
<li>肠热症
<ul>
<li>伤寒：伤寒沙门菌</li>
<li>副伤寒：甲型副伤寒沙门菌、肖氏沙门菌（原称乙型副伤寒沙门菌）、希氏沙门菌</li>
</ul>
</li>
<li>胃肠炎（食物中毒）：多可自愈，体弱者可能死亡</li>
<li>败血症：多见于儿童和免疫力低下的成人</li>
</ul>
<img data-src="/2021/03/29/%E6%B6%88%E5%8C%96%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/%E8%82%A0%E7%83%AD%E7%97%87.png" class="" title="肠热症" alt="肠热症">
<h4 id="免疫性-2">免疫性 <a class="markdownIt-Anchor" href="#免疫性-2">#</a></h4>
<p>伤寒和副伤寒主要靠细胞免疫，病后可获得牢固的免疫力</p>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<p>标本采集</p>
<ul>
<li>第一周：外周血</li>
<li>第二周：粪便</li>
<li>第三周：尿液</li>
<li>全程可采骨髓液</li>
</ul>
<dl>
<dt>肥达试验</dt>
<dd>用已知伤寒沙门菌 O、H 抗原，以及引起副伤寒的甲型副伤寒沙门菌、肖氏沙门菌和希氏沙门菌 H 抗原的诊断菌液与受检血清作定量凝集试验，测定受检血清中有无相应抗体及其效价的试验</dd>
<dd>用于辅助诊断伤寒、副伤寒</dd>
</dl>
<table>
<thead>
<tr>
<th>O 抗体</th>
<th>H 抗体</th>
<th>诊断</th>
</tr>
</thead>
<tbody>
<tr>
<td>高</td>
<td>高</td>
<td>肠热症可能性大</td>
</tr>
<tr>
<td>低</td>
<td>低</td>
<td>排除</td>
</tr>
<tr>
<td>高</td>
<td>低</td>
<td>早期或有交叉反应的其他沙门菌感染</td>
</tr>
<tr>
<td>低</td>
<td>高</td>
<td>预防接种或曾患过伤寒</td>
</tr>
</tbody>
</table>
<ul>
<li>O 抗体（IgM 类）：出现早，维持时间短，特异性差</li>
<li>H 抗体（IgG 类）：出现晚，维持时间长，特异性强</li>
</ul>
<h2 id="幽门螺杆菌">幽门螺杆菌 <a class="markdownIt-Anchor" href="#幽门螺杆菌">#</a></h2>
<dl>
<dt>幽门螺杆菌</dt>
<dd><strong>螺杆菌属</strong>的代表菌种，与胃炎、胃溃疡、胃癌等疾病的发生密切相关</dd>
</dl>
<h3 id="生物学特性-5">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-5">#</a></h3>
<ul>
<li>形态与染色：G<sup>-</sup>，细长弯曲，有鞭毛</li>
<li>培养特性
<ul>
<li><strong>微需氧</strong>，在高氧或厌氧条件下均不长</li>
<li>湿度要求高</li>
<li>营养成分要求高</li>
<li>生长缓慢</li>
</ul>
</li>
<li>生化反应：<mark>快速尿素酶试验</mark></li>
</ul>
<h3 id="致病性与免疫性-4">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-4">#</a></h3>
<h4 id="所致疾病-4">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-4">#</a></h4>
<ul>
<li>胃炎</li>
<li>消化性溃疡</li>
<li>胃癌</li>
</ul>
<h3 id="微生物学检查-2">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查-2">#</a></h3>
<ul>
<li>创伤性：如<strong>快速脲酶试验</strong></li>
<li>非创伤性：如<strong>尿素呼气试验</strong></li>
</ul>
<h3 id="治疗-2">治疗 <a class="markdownIt-Anchor" href="#治疗-2">#</a></h3>
<p>三联疗法：</p>
<ul>
<li>胶体铋剂或质子抑酸素</li>
<li>两种抗生素：四环素、阿莫西林、甲硝唑、替硝唑、克拉霉素……</li>
</ul>
<h2 id="霍乱弧菌">霍乱弧菌 <a class="markdownIt-Anchor" href="#霍乱弧菌">#</a></h2>
<h3 id="生物学特性-6">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-6">#</a></h3>
<ul>
<li>形态与染色：革兰染色阴性，弧型或逗点状，单鞭毛</li>
<li>抗原结构和分类：O 抗原分群，O1、O139 引起霍乱；O1 可根据表型差异分为古典生物型和 El Tor生物型</li>
<li>抵抗力</li>
<li>培养特性和生化反应
<ul>
<li>耐碱不耐酸，在 pH 8.8~9.2 的碱性蛇蛋白胨水中生长良好</li>
<li>可分解蔗糖，在 TCBS 平板上菌落呈黄色，培养基呈暗绿色</li>
</ul>
</li>
</ul>
<p><strong>硫代硫酸盐-枸橼酸盐-胆盐-蔗糖琼脂 | TCBS</strong></p>
<h3 id="致病性与免疫性-5">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-5">#</a></h3>
<h4 id="致病物质-4">致病物质 <a class="markdownIt-Anchor" href="#致病物质-4">#</a></h4>
<ul>
<li>鞭毛：运动，有助于细菌穿过肠黏膜表面黏液层</li>
<li>菌毛：黏附作用，有利于细菌定居与小肠</li>
<li><mark>霍乱肠毒素</mark></li>
</ul>
<dl>
<dt>霍乱肠毒素（cholera toxin，Ctx）</dt>
<dd>目前已知的致泻毒素中最为强烈的毒素，是<strong>肠毒素</strong>的典型代表</dd>
</dl>
<ul>
<li>A 亚单位：一个，活性亚单位，发挥毒性作用</li>
<li>B 亚单位：五个，结合小肠上皮细胞上的受体</li>
</ul>
<h4 id="所致疾病-5">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-5">#</a></h4>
<dl>
<dt><mark>霍乱</mark></dt>
<dd>一种烈性肠道传染病，在我国为法定甲类传染病</dd>
</dl>
<ul>
<li>传染源：患者及无症状感染者</li>
<li>传播途径：主要是通过污染的水源或食物经口摄入</li>
<li>临床表现：严重的呕吐、腹泻，水和电解质大量流失，低容量性休克、肾衰竭，轻型表现为致死性腹泻、米泔水样便；致死率高达 60%；O139 引起的较 O1 严重</li>
</ul>
<p>致病机制：</p>
<ol>
<li><strong>霍乱肠毒素</strong>使小肠黏膜上皮细胞中的<strong>腺甘酸环化酶</strong>活化</li>
<li><strong>腺甘酸环化酶</strong>活化导致细胞内 <strong>cAMP</strong> 水平升高</li>
<li>进而导致大量<strong>水和电解质</strong>进入肠腔，引起严重的腹泻和呕吐</li>
</ol>
<h4 id="免疫性-3">免疫性 <a class="markdownIt-Anchor" href="#免疫性-3">#</a></h4>
<ul>
<li>感染霍乱弧菌后，机体可获得牢固免疫力</li>
<li>SIgA 起主要作用</li>
<li>O1 群引起的免疫不能交叉保护 O139 的感染</li>
</ul>
<h3 id="治疗-3">治疗 <a class="markdownIt-Anchor" href="#治疗-3">#</a></h3>
<p>霍乱为<strong>自限性</strong>疾病，治疗的关键是<strong>及时补充液体和电解质</strong></p>
<details class="note info"><summary><p>自限性疾病</p>
</summary>
<p>在发生发展到一定程度后能自动停止并逐渐恢复，只需对症治疗或不治疗，靠自身免疫就可痊愈的疾病。</p>

</details>
<h2 id="其他">其他 <a class="markdownIt-Anchor" href="#其他">#</a></h2>
<h3 id="副溶血性弧菌">副溶血性弧菌 <a class="markdownIt-Anchor" href="#副溶血性弧菌">#</a></h3>
<p>生物学特性</p>
<ul>
<li>嗜盐，3.5% NaCl 最为适宜</li>
<li>不耐热、不耐酸</li>
<li><mark>神奈川现象</mark></li>
</ul>
<dl>
<dt>神奈川现象（Kanagnwa phenomenon）</dt>
<dd>副溶血性弧菌的某些菌株在 D-甘露醇作为碳源的高盐（7%）人 O 型血或兔血的我萋琼脂（Kanagnwa agar）平板上可产生 β 溶血的现象</dd>
<dd>可用于鉴别致病菌</dd>
</dl>
<ul>
<li>致病性：<strong>食物中毒</strong>，表现为从自限性腹泻至中度霍乱样病症</li>
<li>免疫性：病后免疫性不强，可重复感染</li>
<li>传播：该菌经烹饪不当的海产品或盐腌制品所传播</li>
</ul>
<h3 id="弯曲菌属">弯曲菌属 <a class="markdownIt-Anchor" href="#弯曲菌属">#</a></h3>
<p>生物学特性</p>
<ul>
<li>形态细长，呈弧形、螺旋形、S 型或海鸥形</li>
<li>单鞭毛、运动活泼</li>
<li>微需氧，42℃ 能生长，营养要求高</li>
<li>抵抗力弱</li>
</ul>
<p>致病性</p>
<ul>
<li>产生细胞毒素和一种不耐热肠毒素，<strong>散发性细菌性肠炎</strong></li>
<li>症状：腹痛、腹泻、血便或果酱样便、头痛，病程 5～8 天，可自愈</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>生殖内分泌</title>
    <url>/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/</url>
    <content><![CDATA[<p><a href="#%E8%83%8E%E5%84%BF%E9%99%84%E5%B1%9E%E7%89%A9">胎儿附属物</a>、<a href="#%E7%94%9F%E6%AE%96%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2">生殖系统发育</a>，以及常见畸形……</p>
<span id="more"></span>
<h2 id="胎儿附属物">胎儿附属物 <a class="markdownIt-Anchor" href="#胎儿附属物">#</a></h2>
<dl>
<dt>胎儿附属物（fetal qppendage）</dt>
<dd>胎儿以外的组织，包括 <a href="?highlight=%E8%83%8E%E7%9B%98#%E8%83%8E%E7%9B%98">胎盘</a>、<a href="?highlight=%E8%83%8E%E8%86%9C#%E8%83%8E%E8%86%9C">胎膜</a>、<a href="?highlight=%E8%84%90%E5%B8%A6#%E8%84%90%E5%B8%A6">脐带</a> 和 <a href="?highlight=%E7%BE%8A%E6%B0%B4#%E7%BE%8A%E6%B0%B4">羊水</a>。</dd>
</dl>
<h3 id="胎盘">胎盘 <a class="markdownIt-Anchor" href="#胎盘">#</a></h3>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/Placenta.png" class="" width="640" title="胎盘" alt="胎盘">
<p><strong>胎盘</strong>（placenta）是胎儿和母体的结合体，由 <em>胎儿</em> 的 <a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=羊膜#羊膜囊和卵黄囊的形成"><strong>羊膜</strong></a>（amniotic membrane）和 <strong>叶状绒毛膜</strong>（chorion frondosum）及 <em>母体</em> 的 <a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=底蜕膜#植入后的子宫内膜的变化"><strong>底蜕膜</strong></a>（basal deciduas）共同构成。</p>
<h4 id="胎盘的形成">胎盘的形成 <a class="markdownIt-Anchor" href="#胎盘的形成">#</a></h4>
<h5 id="羊膜">羊膜 <a class="markdownIt-Anchor" href="#羊膜">#</a></h5>
<p>另见 <a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=羊膜#羊膜囊和卵黄囊的形成">羊膜囊和卵黄囊的形成</a>。</p>
<h5 id="叶状绒毛膜">叶状绒毛膜 <a class="markdownIt-Anchor" href="#叶状绒毛膜">#</a></h5>
<p><a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=滋养层#植入后的滋养层的变化">滋养层</a>内面和 <a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=胚外中胚层#胚外中胚层和胚外体腔的形成">胚外中胚层</a> 共同组成绒毛膜。<br/>
人胚 13~21 天时，绒毛膜发育分化最旺盛。经历 <em>一级绒毛</em>、<em>二级绒毛</em> 和 <em>三级绒毛</em> 3 个阶段，<strong>绒毛</strong> 逐渐形成。<br/>
当绒毛内毛细血管形成时，胚胎血管与绒毛血管连接，之后建立 <em>胎儿-胎盘循环</em>。</p>
<p>与底蜕膜相接触的绒毛因营养丰富而发育良好，称 <strong><mark>叶状绒毛膜</mark></strong>（villous chorion），其余部分则萎缩退化成 <strong>平滑绒毛膜</strong>（smooth chorion），构成 <a href="?highlight=%E8%83%8E%E8%86%9C#%E8%83%8E%E8%86%9C"><strong>胎膜</strong></a> 的外层。</p>
<dl>
<dt>游离绒毛（free villus）</dt>
<dd>末端悬浮与充满母血的绒毛间隙中的绒毛。</dd>
<dt>固定绒毛（anchoring villus）</dt>
<dd><strong>绒毛干</strong> 固定于蜕膜上的绒毛。</dd>
</dl>
<details class="note info"><summary><p>绒毛膜取样/活检</p>
</summary>
<p>绒毛膜取样/活检（chorionic villus sampling，CVS）指在超声引导下行穿刺术，取出胎盘内的绒毛组织进行细胞培养、分子遗传学或生化遗传学检查，进行染色体诊断或基因诊断。分为经腹绒毛活检及经宫颈绒毛活检。</p>

</details>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E8%83%8E%E5%84%BF%E5%8F%B6%E5%92%8C%E8%83%8E%E5%84%BF%E5%B0%8F%E5%8F%B6.png" class="right" width="500" title="胎儿叶和胎儿小叶" alt="胎儿叶和胎儿小叶">
<p>绒毛膜板上伸出 60~80 个 <strong>绒毛干</strong>，每个绒毛干中均含有 <em>脐动脉</em> 和 <em>脐静脉</em>。脐血管随绒毛不断分支，最终成为毛细血管进入绒毛末端。<br/>
一个初级绒毛干及其分支形成一个 <strong>胎儿叶</strong>（fetal lobe）；一个次级绒毛干及其分支形成一个 <strong>胎儿小叶</strong>（fetal lobule）。</p>
<p>病理改变：</p>
<ul>
<li><strong>葡萄胎</strong>（hydatidiform mole）：绒毛滋养层细胞过度增生，间质变性水肿，血管消失，绒毛呈水泡状和葡萄状；</li>
<li><strong>绒毛上皮癌</strong>（choriocarcinoma）：滋养层过度增生并癌变；</li>
<li>绒毛血管发育不良或与胚体血管连接不良，会导致胚胎发育不良甚至死亡。</li>
</ul>
<h5 id="底蜕膜">底蜕膜 <a class="markdownIt-Anchor" href="#底蜕膜">#</a></h5>
<p>另见：<a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=底蜕膜#植入后的子宫内膜的变化">植入后的子宫内膜的变化</a>。</p>
<p>底蜕膜表面来自 <em>固定绒毛</em> 的滋养层细胞，与底蜕膜共同构成 <em>绒毛间隙</em> 的底，称为 <strong>蜕膜板</strong>。
从蜕膜板相绒毛膜方向形成一些蜕膜间隔，称为 <strong>胎盘隔</strong>（placenta septa），一般不超过胎盘全层厚度的 2/3。<br/>
将 <em>胎儿叶</em> 们不完全地分隔为 15~30 个（一般为 20 个）<em>母体叶</em>，又称 <strong>胎盘小叶</strong>（cotyledon）。<br/>
<strong>子宫螺旋动脉</strong> 和 <strong>子宫静脉</strong> 开口于绒毛间隙，使之充满母体血液。</p>
<h4 id="胎盘的血液循环">胎盘的血液循环 <a class="markdownIt-Anchor" href="#胎盘的血液循环">#</a></h4>
<p>胎盘内有母体和胎儿两套血液循环系统：</p>
<ul>
<li><strong>母体</strong>：子宫螺旋动脉 → 绒毛间隙，与绒毛毛细血管内的胎儿血进行物质交换 → 子宫静脉</li>
<li><strong>胎儿</strong>：脐动脉（2 条） → 绒毛毛细血管，与绒毛间隙中的母体血进行物质交换 → 脐静脉（1 条）</li>
</ul>
<h4 id="胎盘的功能">胎盘的功能 <a class="markdownIt-Anchor" href="#胎盘的功能">#</a></h4>
<ol>
<li><strong>物质交换</strong>：气体交换功能、营养物质供应、排除胎儿代谢产物；</li>
<li><strong>防御功能</strong>：<em><strong>胎盘屏障</strong></em> 是一种 <em>选择性通透膜</em>、<em>母体 IgG</em> 可通过胎膜，使胎儿获得被动免疫力；</li>
<li><strong>再循环功能</strong>：液体交换，见 <a href="?highlight=%E8%83%8E%E7%9B%98#%E7%BE%8A%E6%B0%B4%E7%9A%84%E5%8A%A8%E6%80%81%E5%B9%B3%E8%A1%A1%E7%8A%B6%E6%80%81">羊水的动态平衡状态</a>；</li>
<li><strong>合成功能</strong>：激素、酶、细胞因子和生长因子等，如 <em><strong>人绒毛膜促性腺激素</strong></em>；</li>
<li><strong>免疫功能</strong>：胎儿及胎盘作为同种异体移植物，能在母体子宫内存活而不备排斥。</li>
</ol>
<details class="note info"><summary><p>胎盘屏障</p>
</summary>
<p>一般认为，氧、二氧化碳和许多小分子依靠扩散与渗透；大分子如蛋白质、抗体、激素等则依靠主动转运和吞饮转运。一些更大的分子（如Rh阳性抗原等）一般不能转运；但在缺氧、创伤、特殊分娩的情况下，也可能发生窜流而混杂。正常妊娠期间母血与子血分开，互不干扰，同时又进行选择性的物质交换，这一现象称为 <strong>胎盘屏障</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<p>胎盘屏障的组成包括合体滋养细胞、合体滋养细胞基底膜、绒毛间质、毛细血管基底膜和毛细血管内皮细胞。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><span class="exturl" data-url="aHR0cDovL3d3dy5hLWhvc3BpdGFsLmNvbS93LyVFOCU4MyU4RSVFNyU5QiU5OCVFNSVCMSU4RiVFOSU5QSU5Qw==">http://www.a-hospital.com/w/胎盘屏障<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</details>
<details class="note info"><summary><p>人绒毛膜促性腺激素</p>
</summary>
<p>人绒毛膜促性腺激素（human chorionic gonadotropin，HCG）</p>
<ul>
<li>合体滋养细胞分泌，受精后第6天开始分泌，至妊娠8～10周血清浓度达最高峰，产后2周内消失。</li>
<li>可用于诊断早孕、检查诊断滋养细胞疾病、进行流产的保胎治疗、不孕症的促卵泡成熟及促排卵治疗。</li>
</ul>

</details>
<h4 id="胎盘异常">胎盘异常 <a class="markdownIt-Anchor" href="#胎盘异常">#</a></h4>
<ol>
<li>胎盘位置异常：前置胎盘</li>
<li>胎盘形状异常：副胎盘</li>
<li>胎盘植入异常：粘连性胎盘、植入性胎盘、穿透性胎盘</li>
<li>胎盘重量异常：巨大胎盘（&gt;800g）、胎盘过小（&lt;400g）</li>
<li>胎盘结构异常：球拍状胎盘；脐带帆状附着</li>
</ol>
<h3 id="胎膜">胎膜 <a class="markdownIt-Anchor" href="#胎膜">#</a></h3>
<h4 id="胎膜的形成和结构">胎膜的形成和结构 <a class="markdownIt-Anchor" href="#胎膜的形成和结构">#</a></h4>
<dl>
<dt><strong>胎膜</strong>（fetal membrane）</dt>
<dd>由 <a href="?highlight=%E7%BB%92%E6%AF%9B%E8%86%9C#%E5%8F%B6%E7%8A%B6%E7%BB%92%E6%AF%9B%E8%86%9C"><strong>绒毛膜</strong></a>（chorion）和 <a href="?highlight=%E7%BE%8A%E8%86%9C#%E7%BE%8A%E8%86%9C"><strong>羊膜</strong></a> 组成，是维持羊膜完整和储存羊水的外周屏障。<br/></dd>
</dl>
<p><a href="?highlight=%E7%BB%92%E6%AF%9B%E8%86%9C#%E5%8F%B6%E7%8A%B6%E7%BB%92%E6%AF%9B%E8%86%9C"><strong>绒毛膜</strong></a> 和 <a href="?highlight=%E7%BE%8A%E8%86%9C#%E7%BE%8A%E8%86%9C"><strong>羊膜</strong></a> 分别构成胎膜的外层和内层。</p>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E8%83%8E%E8%86%9C.png" class="" width="500" title="胎膜" alt="胎膜">
<h4 id="胎膜的异常">胎膜的异常 <a class="markdownIt-Anchor" href="#胎膜的异常">#</a></h4>
<dl>
<dt>胎膜早破（premature rupture of membranes，PROM）</dt>
<dd>胎膜在临产前破裂。</dd>
</dl>
<h3 id="脐带">脐带 <a class="markdownIt-Anchor" href="#脐带">#</a></h3>
<h4 id="脐带的形成和结构">脐带的形成和结构 <a class="markdownIt-Anchor" href="#脐带的形成和结构">#</a></h4>
<dl>
<dt>脐带（umbilical cord）</dt>
<dd>连接胎儿和胎盘的条索状结构，妊娠足月时脐带长 30~70 cm，直径 0.8~2.0cm，表面被羊膜覆盖呈灰白色，内有 1 条 <em>脐静脉</em> 和 2 条 <em>脐动脉</em>。</dd>
</dl>
<p>脐带由 <a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=体蒂#胚外中胚层和胚外体腔的形成"><strong>体蒂</strong></a> 发育而来。早期胚胎通过体蒂与绒毛膜相连，而后卵黄囊被推向体蒂，羊膜将体蒂和卵黄囊包绕在一起形成圆柱状的脐带。</p>
<h4 id="脐带的异常">脐带的异常 <a class="markdownIt-Anchor" href="#脐带的异常">#</a></h4>
<ol>
<li>脐带长度异常：脐带过长（≥ 80cm）、脐带过短（≤ 30cm）</li>
<li><em>脐带先露</em>（隐性脐带脱垂）和 <em>脐带脱垂</em></li>
<li>脐带缠绕</li>
<li>脐带附着异常</li>
<li>脐带打结</li>
<li>脐带扭转</li>
</ol>
<h3 id="羊水">羊水 <a class="markdownIt-Anchor" href="#羊水">#</a></h3>
<dl>
<dt><strong>羊水</strong>（amniotic fluid）</dt>
<dd>即充满羊膜腔的液体，其来源、成分和组成在妊娠不同时期均有不同。</dd>
</dl>
<h4 id="羊水的来源">羊水的来源 <a class="markdownIt-Anchor" href="#羊水的来源">#</a></h4>
<ol>
<li>早期羊水：主要是 <strong>母体血清</strong> 经胎膜进入羊膜腔的透析液；</li>
<li>中晚期羊水：主要是 <strong>胎儿尿液</strong>。</li>
</ol>
<h4 id="羊水的动态平衡">羊水的动态平衡 <a class="markdownIt-Anchor" href="#羊水的动态平衡">#</a></h4>
<p>母体、羊水、胎儿之间一直进行着双向的水和电解质的交换：</p>
<ol>
<li>母体和胎儿：<a href="?highlight=%E8%83%8E%E7%9B%98#%E8%83%8E%E7%9B%98%E7%9A%84%E5%8A%9F%E8%83%BD">胎盘</a>；</li>
<li>母体和羊水：<a href="?highlight=%E8%83%8E%E8%86%9C#%E8%83%8E%E8%86%9C">胎膜</a>；</li>
<li>胎儿和羊水：胎儿消化道、呼吸道、泌尿道和角化前的皮肤。</li>
</ol>
<h4 id="羊水的功能">羊水的功能 <a class="markdownIt-Anchor" href="#羊水的功能">#</a></h4>
<ol>
<li>保护胎儿：
<ul>
<li>自由活动，避免胎儿受到挤压，防止胎体畸形和粘连；</li>
<li>抑菌作用。</li>
</ul>
</li>
<li>保护母体：
<ul>
<li>减少胎动引起的不适感；</li>
<li>临产后扩张宫颈口和阴道；</li>
<li>冲洗和润滑阴道。</li>
</ul>
</li>
</ol>
<h4 id="羊水量的异常">羊水量的异常 <a class="markdownIt-Anchor" href="#羊水量的异常">#</a></h4>
<ol>
<li><strong>羊水过多</strong>（polyhydramnios）：&gt; 2000ml
<ul>
<li>可引起 <em>胎儿畸形</em>，中枢神经系统和消化道畸形最常见；</li>
<li><em>双胎妊娠</em> 羊水过多的发生率约为单胎妊娠的 10 倍。</li>
</ul>
</li>
<li><strong>羊水过少</strong>（oligohydramnios）：&lt; 300ml
<ul>
<li><strong>羊膜带综合征</strong>；</li>
<li>可由 <em>胎儿泌尿系统畸形</em> 和 <em>胎膜早破</em> 引起。</li>
</ul>
</li>
</ol>
<dl>
<dt>羊膜带综合征（amniotic band syndrome）</dt>
<dd>孕妇腹围宫高小于同期妊娠者，若在妊娠早期以发生过 <em>羊水过少</em>，常使羊膜粘在胎儿肢体上，造成胎儿畸形甚至肢体短缺。</dd>
</dl>
<h2 id="生殖系统发育">生殖系统发育 <a class="markdownIt-Anchor" href="#生殖系统发育">#</a></h2>
<h3 id="生殖腺的发育">生殖腺的发育 <a class="markdownIt-Anchor" href="#生殖腺的发育">#</a></h3>
<dl>
<dt>生殖嵴（gonadal ridge）</dt>
<dd><strong>生殖腺的原基</strong>（primordium of gonad），位于胚体正中线两侧、中肾嵴和背系膜之间的一对纵嵴，由体腔上皮的增生和深面 <a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/#中胚层分化">间充质</a> 的聚集而形成。</dd>
<dt>初级性索（primary sex cord）</dt>
<dd>生殖嵴表面的上皮增生穿入到深面的 <a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=间充质#中胚层的分化">间充质</a> 内，形成的若干不规则的细胞索。</dd>
</dl>
<ul>
<li>第 4 周，<a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/#羊膜囊和卵黄囊的形成">卵黄囊</a> 出现 <strong>原始生殖细胞</strong>（primordial germ cell）；</li>
<li>第 6 周，原始生殖细胞迁入 <strong>初级性索</strong>。此时不能分辨性腺是睾丸还是卵巢，因此称为 <strong>未分化性腺</strong>。</li>
</ul>
<dl>
<dt><mark>Y 染色体的性别决定区</mark>（sex determining region of Y chromosome, <mark><abbr title="sex determining region of Y chromosome，Y 染色体的性别决定区">SRY</abbr></mark>）</dt>
<dd>Y 染色体上的一段非同源区段，目前被认为真正决定性别。</dd>
</dl>
<p>生殖腺分化（原始生殖腺有向卵巢发育的趋势）：</p>
<ul>
<li>男性 <abbr title="sex determining region of Y chromosome，Y 染色体的性别决定区">SRY</abbr>(+) 且表达 → <a href="#%E7%9D%BE%E4%B8%B8%E7%9A%84%E5%8F%91%E7%94%9F">睾丸</a></li>
<li>女性 <abbr title="sex determining region of Y chromosome，Y 染色体的性别决定区">SRY</abbr>(-) → <a href="#%E5%8D%B5%E5%B7%A2%E7%9A%84%E5%8F%91%E7%94%9F">卵巢</a></li>
</ul>
<h4 id="睾丸的发生">睾丸的发生 <a class="markdownIt-Anchor" href="#睾丸的发生">#</a></h4>
<p>初级性索 → 睾丸索 → 生精小管</p>
<dl>
<dt>睾丸索（testicular cord）| 曲精索</dt>
<dd>第 7~8 周时，在 <abbr title="sex determining region of Y chromosome，Y 染色体的性别决定区">SRY</abbr> 基因的作用下，初级性索与表面上皮分离，向生殖腺嵴深处生长，形成的许多界限清楚的、相互吻合的细胞索。</dd>
</dl>
<p>睾丸索进一步分化形成的襻状的 <strong>生精小管</strong>（seminiferous tubules），其末端相互连接，形成 <strong>睾丸网</strong>（rete testis）。</p>
<p>睾丸内的细胞分化</p>
<ul>
<li>生精小管间
<ul>
<li>间充质细胞 → <strong>睾丸间质细胞</strong></li>
</ul>
</li>
<li>生精小管腔
<ul>
<li>初级性索 → <strong>支持细胞</strong>（Sertoli 细胞）</li>
<li>原始生殖细胞 → <strong>精原细胞</strong>（spermatogonium）</li>
</ul>
</li>
</ul>
<dl>
<dt>睾丸间质细胞 | Leydig 细胞</dt>
<dd>分散在生精小管之间的 <strong>间充质细胞</strong> 分化而来，分泌 <strong>雄激素</strong>，促进尿道生殖窦和 <strong>中肾管</strong> 向男性生殖管道分化。</dd>
</dl>
<p>人胚 14~18 周，间质细胞占睾丸体积一般以上，随后迅速减少，出生时几乎见不到间质细胞，直至青春期才重现。</p>
<details class="note info"><summary><p>雄激素</p>
</summary>
<dl>
<dt>雄激素（androgen, androgenic hormones, testoids）| 雄性激素 | 男性荷尔蒙</dt>
<dd>系泛称，指任何能与 <strong>雄激素受体</strong>（androgen receptor）结合，调节脊椎动物雄性性征的发育与维持的 <strong>类固醇激素</strong>。</dd>
</dl>
<p>男性体内的主要雄激素为 <strong>睾酮</strong> 和 <strong>双氢睾酮</strong>。</p>

</details>
<dl>
<dt>支持细胞 | Sertoli 细胞</dt>
<dd>由 <strong>初级性索</strong> 分化形成，分泌 <strong>抗 Müllerian 激素</strong>，对 <strong>中肾旁管</strong> 起抑制作用。</dd>
</dl>
<p>另见：<a href="#%E7%94%B7%E6%80%A7%E5%86%85%E7%94%9F%E6%AE%96%E5%99%A8">男性内生殖器</a>。</p>
<h4 id="卵巢的发生">卵巢的发生 <a class="markdownIt-Anchor" href="#卵巢的发生">#</a></h4>
<p>卵巢的发生比睾丸晚 2 周，是原始生殖腺分化的自然趋势。</p>
<dl>
<dt>次级性索（secondary sex cord）| 皮质索（cortical cord）</dt>
<dd>第 10 周时，由于无 <abbr title="sex determining region of Y chromosome，Y 染色体的性别决定区">SRY</abbr> 基因的作用，<a href="?highlight=%E5%88%9D%E7%BA%A7%E6%80%A7%E7%B4%A2#%E7%94%9F%E6%AE%96%E8%85%BA%E7%9A%84%E5%8F%91%E8%82%B2"><strong>初级性索</strong></a> 退化消失，性腺表面上皮细胞继续增生，形成 <strong>次级性索</strong>。</dd>
</dl>
<ul>
<li>次级性腺/皮质索 → 原始卵泡的 <strong>卵泡细胞</strong></li>
<li>原始生殖细胞 → <strong>卵原细胞</strong></li>
<li>间充质 → <strong>卵巢间质</strong></li>
</ul>
<dl>
<dt>原始卵泡（primordial ovarian folliele）</dt>
<dd><strong>皮质索</strong> 断裂形成的细胞团。</dd>
<dd>周围的 <strong>卵泡细胞</strong> 由 <strong>皮质索</strong> 的细胞分化形成；中心的 <strong>卵原细胞</strong>（oogonium）由 <strong>原始生殖细胞</strong> 分化而来。</dd>
</dl>
<h3 id="内生殖器的发育">内生殖器的发育 <a class="markdownIt-Anchor" href="#内生殖器的发育">#</a></h3>
<p>在第 6 周的未分化期，男性和女性均有两套生殖管道——<strong>中肾管</strong>、<strong>中肾旁管</strong>。</p>
<dl>
<dt>中肾管（mesonephric duct）| Wolfian 管</dt>
<dd>在中肾退化时，保留下来形成男性生殖管道。</dd>
<dt>中肾旁管（paramesonephric duct）| Müllerian 管</dt>
<dd>开口于 <strong>窦结节</strong>（sinus tubercle, Müllerian 结节），将来发育称为女性生殖管道。</dd>
</dl>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E7%94%9F%E6%AE%96%E7%AE%A1%E9%81%93%E7%9A%84%E5%88%86%E5%8C%96.png" class="" width="500" title="生殖管道的分化" alt="生殖管道的分化">
<h4 id="男性内生殖器">男性内生殖器 <a class="markdownIt-Anchor" href="#男性内生殖器">#</a></h4>
<ul>
<li>支持细胞 <strong>抗 Müllerian 激素</strong>：中肾旁管 → 退化</li>
<li>睾丸间质细胞 <a href="?highlight=%E9%9B%84%E6%BF%80%E7%B4%A0#%E7%9D%BE%E4%B8%B8%E7%9A%84%E5%8F%91%E7%94%9F">雄激素</a>：中肾管（和部分未退化的中肾小管）→ 副睾管、输精管</li>
</ul>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E7%94%B7%E6%80%A7%E7%94%9F%E6%AE%96%E7%AE%A1%E9%81%93%E7%9A%84%E5%8F%91%E8%82%B2.png" class="" title="男性生殖管道的发育" alt="男性生殖管道的发育">
<p>另见：<a href="#%E7%9D%BE%E4%B8%B8%E7%9A%84%E5%8F%91%E7%94%9F">睾丸的发生</a>。</p>
<dl>
<dt>抗 Müllerian 激素（anti-Müllerian hormone，<abbr title="anti-Müllerian hormone, 抗 Müllerian 激素">AMH</abbr>）| Müllerian 抑制因子（Müllerian inhibiting factor, <abbr title="Müllerian inhibiting factor, Müllerian 抑制因子">MIF</abbr>）</dt>
<dd>由 <strong>支持细胞</strong> 产生，抑制中肾旁管，使其逐渐退化。</dd>
</dl>
<h4 id="女性内生殖器">女性内生殖器 <a class="markdownIt-Anchor" href="#女性内生殖器">#</a></h4>
<p>无抗 Müllerian 激素和雄激素的作用</p>
<ul>
<li>中肾管退化</li>
<li>中肾旁管发育
<ul>
<li>上段、中段 → 输卵管（uterine tube）</li>
<li>下段 → 合并成子宫</li>
<li>副中肾管最尾端 → 阴道板（vaginal plate）</li>
</ul>
</li>
</ul>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E5%A5%B3%E6%80%A7%E7%94%9F%E6%AE%96%E7%AE%A1%E9%81%93%E7%9A%84%E5%8F%91%E8%82%B2.png" class="" title="女性生殖管道的发育" alt="女性生殖管道的发育">
<h4 id="内生殖腺发育异常">内生殖腺发育异常 <a class="markdownIt-Anchor" href="#内生殖腺发育异常">#</a></h4>
<ol>
<li>睾丸发育异常
<ol>
<li>先天性睾丸缺如（congenital absence of testis）</li>
<li><strong>隐睾</strong></li>
<li>异位睾丸（ectopic testis）</li>
</ol>
</li>
<li><strong>先天性腹股沟疝</strong> 和 <strong>阴囊积水</strong></li>
<li>阴道发育异常</li>
<li>子宫发育异常</li>
</ol>
<dl>
<dt>隐睾（cryptorchidism）</dt>
<dd>睾丸未下降至阴囊，多停留在腹腔或腹股沟等处，65% 的患者伴有 <em>先天性腹股沟疝</em>。</dd>
<dt>先天性腹股沟疝（congenital inguinal hernia）</dt>
<dd>腹膜腔和 <em>鞘膜腔</em> 之间的通路未闭合，腹压升高时，肠管可突入鞘膜腔。</dd>
<dd>新生儿腹股沟疝常有鞘膜积液，可致 <strong>阴囊积水</strong>（scrotal hydrocele）。</dd>
</dl>
<h3 id="外生殖器的发育">外生殖器的发育 <a class="markdownIt-Anchor" href="#外生殖器的发育">#</a></h3>
<p>胚胎第 3 周，起源于原条区域的间充质细胞迁移到泄殖腔膜周围，形成头尾方向的 2 条隆起，称 <strong>泄殖腔褶</strong>。</p>
<dl>
<dt>生殖结节（genital tubercle）</dt>
<dd>胚胎第 5 周初，<em>泄殖腔褶</em> 在紧靠泄殖腔膜的头端联合形成的结节。</dd>
<dt>尿生殖褶（urogenital fold）</dt>
<dd>在第 6 周由部分 <em>泄殖腔褶</em> 分化而来的两条纵行隆起。</dd>
</dl>
<p>尿生殖褶中间的凹陷称 <strong>尿生殖沟</strong>，沟底为 <strong>尿生殖膜</strong>。<br/>
<strong>尿生殖膜</strong> 于第 7~9 周破裂，之后形成 <strong>尿道沟</strong>，正常情况下最终愈合。</p>
<dl>
<dt>阴唇阴囊隆起（labioscrotal swelling）</dt>
<dd>第 7~9 周时，在 <strong>尿生殖褶</strong> 外侧又形成的两条纵行隆起。</dd>
</dl>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E6%9C%AA%E5%88%86%E5%8C%96%E5%A4%96%E7%94%9F%E6%AE%96%E5%99%A8.png" class="" width="500" title="未分化外生殖器" alt="未分化外生殖器">
<h4 id="男性外生殖器的发育">男性外生殖器的发育 <a class="markdownIt-Anchor" href="#男性外生殖器的发育">#</a></h4>
<p>在睾丸产生的 <a href="?highlight=%E9%9B%84%E6%BF%80%E7%B4%A0#%E7%9D%BE%E4%B8%B8%E7%9A%84%E5%8F%91%E7%94%9F">雄激素</a> 作用下：</p>
<ul>
<li>间充质细胞 → <strong>泄殖腔褶</strong> →
<ul>
<li>生殖结节 → <strong>阴茎</strong>（penis）</li>
<li>尿生殖褶 → 尿道 <strong>海绵体</strong> 部</li>
</ul>
</li>
<li>阴唇阴囊隆起 → <strong>阴囊</strong>（scrotum）</li>
</ul>
<p><strong><mark>5α 二氢睾酮</mark></strong> 对男性外阴的形成至关重要，其受体的缺陷将导致睾丸女性化。</p>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E7%94%B7%E6%80%A7%E5%A4%96%E7%94%9F%E6%AE%96%E5%99%A8.png" class="" width="500" title="男性外生殖器" alt="男性外生殖器">
<h4 id="女性外生殖器的发育">女性外生殖器的发育 <a class="markdownIt-Anchor" href="#女性外生殖器的发育">#</a></h4>
<p>外生殖器向女性方向分化，是胚胎发育的 <em>自然趋势</em>，不需要雌激素的作用。</p>
<ul>
<li>生殖结节 → <strong>阴蒂</strong>（clitoris）</li>
<li>尿生殖褶 → <strong>小阴唇</strong>（labia minora）</li>
<li>阴囊阴唇隆起 → <strong>大阴唇</strong>（labia majora）</li>
</ul>
<img data-src="/2021/04/17/%E7%94%9F%E6%AE%96%E5%86%85%E5%88%86%E6%B3%8C/%E5%A5%B3%E6%80%A7%E5%A4%96%E7%94%9F%E6%AE%96%E5%99%A8.png" class="" width="600" title="女性外生殖器" alt="女性外生殖器">
<h4 id="外生殖器发育异常">外生殖器发育异常 <a class="markdownIt-Anchor" href="#外生殖器发育异常">#</a></h4>
<dl>
<dt>尿道下裂（hypospadias）</dt>
<dd>左右 <strong>尿生殖褶</strong> 不闭合或闭合不全，导致尿道外口不在阴茎顶端而在阴茎 <em>腹侧</em>。</dd>
</dl>
<h3 id="性别发育异常">性别发育异常 <a class="markdownIt-Anchor" href="#性别发育异常">#</a></h3>
<ul>
<li>原始生殖腺的决定因素
<ul>
<li><strong><abbr title="sex determining region of Y chromosome，Y 染色体的性别决定区">SRY</abbr></strong> 基因：决定睾丸的形成</li>
<li>其他基因</li>
</ul>
</li>
<li>性器官分化的决定因素
<ul>
<li>内生殖器：<strong>睾酮</strong>、<abbr title="anti-Müllerian hormone, 抗 Müllerian 激素">AMH</abbr>/<abbr title="Müllerian inhibiting factor, Müllerian 抑制因子">MIF</abbr>、雌激素</li>
<li>外生殖器：<strong>双氢睾酮</strong>（<abbr title="双氢睾酮">DHT</abbr>）</li>
</ul>
</li>
</ul>
<dl>
<dt>双氢睾酮（<abbr title="双氢睾酮">DHT</abbr>）</dt>
<dd>由男性外生殖器通过 <strong>5α-还原酶</strong> 将 <strong>睾酮</strong> 还原形成，使外阴向男性分化。</dd>
</dl>
<hr />
<dl>
<dt>性别发育异常 | 两性畸形</dt>
<dd>患者的性腺或其内外生殖器、副性征具有不同程度的两性特征。</dd>
</dl>
<h4 id="真两性畸形">真两性畸形 <a class="markdownIt-Anchor" href="#真两性畸形">#</a></h4>
<dl>
<dt>真两性畸形（true hermaphrodite）</dt>
<dd>同时具有卵巢和睾丸两种性腺或者 <strong>卵巢睾</strong>（ovotestis）。</dd>
</dl>
<ul>
<li>46,XX</li>
<li>46,XY</li>
<li>46,XX/46,XY 嵌合</li>
</ul>
<h4 id="假两性畸形">假两性畸形 <a class="markdownIt-Anchor" href="#假两性畸形">#</a></h4>
<dl>
<dt>假两性畸形（pseudohermaphrodite）</dt>
<dd>核型和性腺只有一种，外生殖器或副性征有两型特征或畸形。</dd>
</dl>
<hr />
<p><strong>男性假两性畸形</strong></p>
<ul>
<li>核型：46,XY</li>
<li>类型
<ul>
<li>雄激素不敏感综合征</li>
<li>5α-还原酶缺陷</li>
</ul>
</li>
</ul>
<dl>
<dt>雄激素不敏感综合征（testicular feminization syndrome） | 睾丸女性化综合征（androgen insensitive syndrome）</dt>
<dd>睾丸分泌雄激素，但是体细胞雄性激素受体合成缺陷，不能使生殖器男性化。</dd>
</dl>
<hr />
<p><strong>女性假两性畸形</strong>（内生殖腺只有卵巢）</p>
<ul>
<li>核型：46,XX</li>
<li>类型
<ul>
<li>先天性肾上腺皮质增生症</li>
<li>母体高雄激素血症</li>
</ul>
</li>
</ul>
<dl>
<dt>先天性肾上腺皮质增生症（congenital adrenal hyperplasia, <abbr title="congenital adrenal hyperplasia，先天性肾上腺皮质增生症">CAH</abbr>）</dt>
<dd>由于肾上腺多种合成皮质醇的酶缺陷，导致雄激素大量分泌而表现为外生殖器男性化。</dd>
</dl>
<dl>
<dt>母体高雄激素血症</dt>
<dd>孕期母亲血液雄激素水平高引起。</dd>
<dd>无需激素治疗，只需外科手术校正外生殖器畸形。</dd>
</dl>
<h4 id="性逆转综合征">性逆转综合征 <a class="markdownIt-Anchor" href="#性逆转综合征">#</a></h4>
<dl>
<dt>性逆转综合征（sex reversal syndrome）| 性反转综合征</dt>
<dd>染色体核型与性表型相反。</dd>
</dl>
<ul>
<li>46,XX 男性：临床症状类似于 Klinefelter 综合征（见 <a href="/2021/04/26/%E6%9F%93%E8%89%B2%E4%BD%93%E7%97%85/?highlight=Klinefelter#常见性染色体异常综合征">常见性染色体异常综合征</a>）</li>
<li>46,XY 女性</li>
</ul>
<h3 id="生殖内分泌">生殖内分泌 <a class="markdownIt-Anchor" href="#生殖内分泌">#</a></h3>
<ul>
<li>下丘脑：促性腺激素释放激素（GnRH）</li>
<li>垂体前叶：促性腺激素，如卵泡刺激素（FSH）、黄体生成素（LH）</li>
<li>睾丸（男性）；卵巢（女性）/ 胎盘（孕期）</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>病原生物学</title>
    <url>/2021/03/16/%E7%97%85%E5%8E%9F%E7%94%9F%E7%89%A9%E5%AD%A6/</url>
    <content><![CDATA[<blockquote>
<p>病原生物学导论</p>
</blockquote>
<dl>
<dt>生物 | 生命体 | 有机体（Organism）</dt>
<dd>能进行新陈代谢、能生长、具有应激性、能生殖发育、遗传变异，能再一定程度上适应和影响环境。</dd>
<dt>病原生物</dt>
<dd>能给人类、动植物带来疾患的生物。</dd>
</dl>
<span id="more"></span>
<h2 id="微生物">微生物 <a class="markdownIt-Anchor" href="#微生物">#</a></h2>
<ul>
<li><em>非细胞型</em>微生物（e.g. <strong><a href="/2021/03/21/%E7%97%85%E6%AF%92/" title="病毒">病毒</a></strong>、<strong>脘粒</strong>）</li>
<li><em>原核细胞型</em>微生物（e.g. <strong><a href="/2021/03/21/%E7%BB%86%E8%8F%8C/" title="细菌">细菌</a></strong>）</li>
<li><em>真核细胞型</em>微生物（e.g. <strong><a href="/2021/03/21/%E7%9C%9F%E8%8F%8C/" title="真菌">真菌</a></strong>）</li>
</ul>
<dl>
<dt>微生物</dt>
<dd>肉眼不可见的微小生物的总称。</dd>
<dd>特点：个体微小、结构简单、繁殖迅速、容易变异、种类繁多、分布广泛 。</dd>
</dl>
<p>原核型微生物包括<em>两菌四体</em>：</p>
<ul>
<li><strong><a href="/2021/03/21/%E7%BB%86%E8%8F%8C/" title="细菌">细菌</a></strong>（代表）、<a href="/2021/04/15/%E6%94%BE%E7%BA%BF%E8%8F%8C/">放线菌</a></li>
<li><a href="/2021/04/15/%E6%94%AF%E5%8E%9F%E4%BD%93/">支原体</a>、衣原体、立克次（氏）体、<a href="/2021/04/15/%E8%9E%BA%E6%97%8B%E4%BD%93/">螺旋体</a></li>
</ul>
<h2 id="寄生虫">寄生虫 <a class="markdownIt-Anchor" href="#寄生虫">#</a></h2>
<p>医学寄生虫学</p>
<ul>
<li>~ 萌芽时期</li>
<li>近代 ~ 时期</li>
<li>现代 ~ 时期</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒</title>
    <url>/2021/03/21/%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<dl>
<dt>病毒（virus）</dt>
<dd>最微小的、结构最简单的、专性细胞内寄生的一类<a href="/2021/03/16/%E7%97%85%E5%8E%9F%E7%94%9F%E7%89%A9%E5%AD%A6/#微生物">非细胞型微生物</a>。</dd>
</dl>
<p>病毒的特点：</p>
<ol>
<li><strong>体积微小</strong>（<strong>nm 级</strong>），可通过细胞滤器，需借助电子显微镜观察</li>
<li><strong>遗传物质单一</strong>，仅有一种核酸（DNA 或 RNA）</li>
<li><strong>严格的活细胞内寄生</strong></li>
<li>增殖方式为<strong>复制</strong></li>
<li>对<em>抗生素</em>不敏感，对<strong>干扰素</strong>敏感</li>
</ol>
<p>病毒分类：</p>
<ol>
<li><a href="/2021/04/22/%E5%99%AC%E8%8F%8C%E4%BD%93/">噬菌体</a></li>
<li>动物病毒</li>
<li>植物病毒</li>
</ol>
<p>病原生物学分类</p>
<ol>
<li><a href="/2021/04/26/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/">呼吸道感染病毒</a></li>
<li><a href="/2021/05/10/%E6%B6%88%E5%8C%96%E9%81%93%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/">消化道感染病毒</a></li>
<li><a href="/2021/05/10/%E8%82%9D%E7%82%8E%E7%97%85%E6%AF%92/">肝炎病毒</a></li>
<li><a href="/2021/05/13/%E8%99%AB%E5%AA%92%E7%97%85%E6%AF%92%E5%92%8C%E5%87%BA%E8%A1%80%E7%83%AD%E7%97%85%E6%AF%92/">虫媒病毒和出血热病毒</a></li>
<li><a href="/2021/05/17/%E4%BA%BA%E7%B1%BB%E7%96%B1%E7%96%B9%E7%97%85%E6%AF%92/">人类疱疹病毒</a></li>
<li><a href="/2021/05/20/%E9%80%86%E8%BD%AC%E5%BD%95%E7%97%85%E6%AF%92/">逆转录病毒</a></li>
<li>其他病毒</li>
</ol>
<span id="more"></span>
<details class="note info"><summary><p>亚病毒</p>
</summary>
<dl>
<dt>亚病毒（subvirus）</dt>
<dd>一些新的非寻常病毒的致病因子，为比病毒更小、结构更简单的微生物。</dd>
<dd>包括<strong>类病毒</strong>、<strong>卫星病毒</strong>和<strong>脘粒</strong>。</dd>
<dt>类病毒（viroid）</dt>
<dd>均为<strong>植物病毒</strong>，仅由 250~400 个核酸组成，核酸为单链杆状 RNA，有二级结构，无包膜或衣壳，不含蛋白质。</dd>
<dd>类病毒通常通过种子或花粉传播。</dd>
<dt>卫星病毒（satellite virus）</dt>
<dd>一种引起苜蓿（mùxu）绒毛菸（yū）等植物损害的致病因子。分为两大类：
<ul>
<li>可编码自身的衣壳蛋白</li>
<li><strong>卫星病毒 RNA 分子</strong>，曾称为<em>拟病毒</em>（virusoid）,需利用<strong>辅助病毒</strong>的蛋白质衣壳。</li>
</ul>
</dd>
<dt>朊粒（prion）</dt>
<dd>生物学地位尚未确定，目前归类于亚病毒。</dd>
</dl>

</details>
<details class="note info"><summary><p>病毒是生命吗？</p>
</summary>
<p>病毒是介于生命与非生命之间的一种物质形式。</p>
<p>什么是生命？</p>
<ol>
<li>复制、增殖；</li>
<li>进行新陈代谢：
<ul>
<li>获得和利用能量；</li>
<li>出生、生长及死亡；</li>
</ul>
</li>
<li>应激性：对外界刺激</li>
</ol>
<p><strong>病毒不是生命</strong>——大多数科学家普遍认为它们是<strong>非生命感染颗粒</strong>；另外的科学家则表示异议，他们因为病毒在宿主细胞内的活动而认为病毒是活的。</p>
<p><strong>病毒是生物</strong>——生物分为六个届：病毒届、真菌届、原核生物届、原生生物届、植物届和动物届。</p>

</details>
<h2 id="病毒的基本性状">病毒的基本性状 <a class="markdownIt-Anchor" href="#病毒的基本性状">#</a></h2>
<h3 id="病毒的大小和形态">病毒的大小和形态 <a class="markdownIt-Anchor" href="#病毒的大小和形态">#</a></h3>
<dl>
<dt><mark>病毒体</mark>（virion）</dt>
<dd>有感染性、结构完整、成熟的病毒颗粒。</dd>
</dl>
<blockquote>
<p>病毒的大小指的是病毒体的大小。</p>
</blockquote>
<p>病毒体积微小，测量单位为 nm，必须借助电子显微镜观察。不同病毒体大小相差很大。</p>
<p>不同病毒的性状不同，多为球型或近似球型，而植物病毒多为杆状。
大多数病毒形状较固定，但有些病毒具有多形性。</p>
<h3 id="病毒的结构和化学组成">病毒的结构和化学组成 <a class="markdownIt-Anchor" href="#病毒的结构和化学组成">#</a></h3>
<h4 id="病毒的结构">病毒的结构 <a class="markdownIt-Anchor" href="#病毒的结构">#</a></h4>
<ul>
<li><strong>核衣壳</strong>（capsid）
<ul>
<li>核心</li>
<li>衣壳</li>
</ul>
</li>
<li>包膜</li>
</ul>
<dl>
<dt>病毒核心（viral core）</dt>
<dd>病毒体的核心部分，主要为核酸，构成病毒<strong>基因组</strong>（genome），另外还有少量功能性的<strong>非结构蛋白</strong>。</dd>
<dt>衣壳（capsid）</dt>
<dd>由一定数量的<strong>壳粒</strong>组成。</dd>
<dd>不同病毒体衣壳所含壳粒数目和排列方式不同，可作为病毒鉴别和分类的依据。</dd>
</dl>
<p>衣壳作用：</p>
<ul>
<li>保护核酸</li>
<li>抗原性/免疫原性：诱导机体产生特异性免疫</li>
<li>决定病毒对细胞的亲嗜性，介导病毒进入宿主细胞</li>
<li>病毒鉴别和分类的依据</li>
</ul>
<p>衣壳组成：</p>
<ul>
<li>形态亚单位（morphologic subunit）：壳粒（capsomere）</li>
<li>结构亚单位（structural subunit）：组成壳粒的多肽分子</li>
</ul>
<p>根据壳粒排列方式的不同，可将病毒分为三种对称型：</p>
<ol>
<li>螺旋对称型（helical symmetry）</li>
<li>20 面体立体对称型（icosahedral symmetry）</li>
<li>复合对称型（complex symmetry）</li>
</ol>
<dl>
<dt>包膜（envelope）</dt>
<dd>由病毒在成熟过程中以<strong>出芽</strong>的形式穿过宿主细胞、向外释放过程中获得的宿主细胞的细胞膜或核膜的成分。</dd>
</dl>
<h4 id="病毒的化学组成和功能">病毒的化学组成和功能 <a class="markdownIt-Anchor" href="#病毒的化学组成和功能">#</a></h4>
<h5 id="核酸">核酸 <a class="markdownIt-Anchor" href="#核酸">#</a></h5>
<p>核酸的功能</p>
<ul>
<li>病毒复制</li>
<li>病毒的遗传信息，决定病毒的遗传特性</li>
<li>具有感染性</li>
</ul>
<h5 id="蛋白质">蛋白质 <a class="markdownIt-Anchor" href="#蛋白质">#</a></h5>
<ul>
<li>结构蛋白
<ul>
<li>衣壳蛋白：由多肽亚单位组成，抗原性强</li>
<li>包膜蛋白：属糖蛋白</li>
<li>基质蛋白：连接衣壳蛋白和包膜蛋白</li>
</ul>
</li>
<li>非结构蛋白/功能性蛋白：由病毒的基因组编码，但不参与病毒体构成部分的病毒蛋白多肽</li>
</ul>
<p>蛋白质的功能</p>
<ul>
<li>保护病毒核酸</li>
<li>参与感染过程</li>
<li>具有抗原性</li>
</ul>
<h5 id="脂质和糖">脂质和糖 <a class="markdownIt-Anchor" href="#脂质和糖">#</a></h5>
<p>病毒体的脂类主要存在于包膜中，几乎都是从宿主细胞的细胞膜或核膜上得到的。
可通过脂溶剂去除包膜，使病毒失去感染性。</p>
<h2 id="病毒的增殖">病毒的增殖 <a class="markdownIt-Anchor" href="#病毒的增殖">#</a></h2>
<h3 id="病毒的复制周期">病毒的复制周期 <a class="markdownIt-Anchor" href="#病毒的复制周期">#</a></h3>
<dl>
<dt>复制周期（replicative cycle）</dt>
<dd>从病毒体侵入易感细胞到子代病毒体生成并释放的过程。</dd>
</dl>
<ol>
<li><a href="#%E5%90%B8%E9%99%84%E5%92%8C%E7%A9%BF%E5%85%A5">吸附和穿入</a></li>
<li><a href="#%E8%84%B1%E5%A3%B3">脱壳</a></li>
<li><a href="#%E7%94%9F%E7%89%A9%E5%90%88%E6%88%90">生物合成</a></li>
<li><a href="#%E7%BB%84%E8%A3%85%E3%80%81%E6%88%90%E7%86%9F%E3%80%81%E9%87%8A%E6%94%BE">组装、成熟、释放</a></li>
</ol>
<h4 id="吸附和穿入">吸附和穿入 <a class="markdownIt-Anchor" href="#吸附和穿入">#</a></h4>
<dl>
<dt>吸附（adsorption）</dt>
<dd>病毒体依靠其表面结构与易感细胞膜上特定的病毒受体结合并黏附在细胞膜表面的过程。</dd>
<dd>吸附可分为两个阶段：
<ol>
<li><strong>病毒和细胞的静电结合</strong>：非特异性、可逆</li>
<li><strong>宿主表面受体与病毒表面结构的特异性结合</strong>：特异性、不可逆。
<strong>是决定病毒感染的真正开始</strong>。</li>
</ol>
</dd>
</dl>
<hr />
<dl>
<dt>穿入（penetration）</dt>
<dd>即细胞进入宿主细胞的过程，主要通过<strong>吞饮</strong>、<strong>融合</strong>等方式。</dd>
<dt>吞饮（endocytosis）</dt>
<dd>病毒与细胞表面结合后内凹入细胞，胞膜内陷形式类似吞噬泡。</dd>
<dd><strong>无包膜病毒</strong>多为此方式穿入细胞。</dd>
<dt>融合（fusion）</dt>
<dd>病毒包膜与细胞膜密切接触，在融合蛋白的催化下，融合孔开口，病毒包膜与胞膜融合，将病毒的核衣壳释放至细胞内。</dd>
<dd><strong>有包膜病毒</strong>以此方式穿入细胞。</dd>
</dl>
<div class="note info"><p>噬菌体穿入细胞的方式为<strong>直接注入</strong>。</p>
</div>
<h4 id="脱壳">脱壳 <a class="markdownIt-Anchor" href="#脱壳">#</a></h4>
<dl>
<dt>脱壳（uncoating）</dt>
<dd>病毒进入易感细菌拖去蛋白质衣壳的过程。</dd>
<dd>多数病毒在穿入宿主细胞的过程中，靠<strong>宿主细胞溶酶体酶</strong>的作用使衣壳蛋白水解。</dd>
</dl>
<h4 id="生物合成">生物合成 <a class="markdownIt-Anchor" href="#生物合成">#</a></h4>
<dl>
<dt>生物合成（biosynthesis）</dt>
<dd>即病毒利用宿主细胞提供的低分子物质大量合成病毒<strong>核酸</strong>和<strong>结构蛋白</strong>。</dd>
</dl>
<details class="note info"><summary><p>隐蔽期</p>
</summary>
<p>用血清学方法和电镜检查宿主细胞，在生物合成阶段找不到病毒颗粒，故称为隐蔽期。
实质是在病毒基因控制下进行病毒核酸和蛋白质合成的阶段。</p>

</details>
<p>病毒合成的蛋白质：</p>
<ul>
<li>转录早期 mRNA → <strong>早期蛋白</strong>：是在病毒核酸复制之前合成的，主要为用于合成子代 DNA 分子的多种酶类，为<strong>功能性蛋白</strong>；</li>
<li>转录晚期 mRNA → <strong>晚期蛋白</strong>：病毒核酸自我复制后，以<strong>子代的病毒核酸</strong>为模版翻译出来的，主要为构成病毒衣壳的<strong>结构蛋白</strong>。</li>
</ul>
<hr />
<p>病毒核酸的复制方式因核酸类型的不同而异，可分为 7 个类型：</p>
<ol>
<li><strong>双链 DNA 病毒</strong></li>
<li>单链 DNA 病毒</li>
<li><strong>单正链 RNA 病毒</strong></li>
<li>单负链 RNA 病毒</li>
<li>双链 RNA 病毒</li>
<li><strong>逆转录病毒</strong>/<strong>反转录病毒</strong></li>
<li>嗜肝 DNA 病毒</li>
</ol>
<p>TODO: 图示</p>
<p><strong>双链 RNA（dsDNA）病毒</strong> 在细胞核内合成 DNA，细胞质内合成病毒蛋白，<strong>痘病毒</strong>除外。</p>
<details class="note "><summary><p>痘病毒科</p>
</summary>
<p>本科为病毒粒最大的一类DNA病毒，结构复杂。
病毒在<strong>细胞质</strong>内增殖，形成包涵体，病毒粒由微绒毛或由细胞裂解而释放。</p>

</details>
<p><strong>单正链 RNA 病毒</strong> 这类病毒本身就具有 mRNA 的功能。</p>
<p><strong>逆转录病毒</strong> 核酸以单正链 RNA 形式存在，但不具 mRNA 功能，只能作为逆转录的模版。</p>
<h4 id="组装-成熟-释放">组装、成熟、释放 <a class="markdownIt-Anchor" href="#组装-成熟-释放">#</a></h4>
<dl>
<dt>组装（ssembly）</dt>
<dd>新合成的子代病毒核酸和蛋白质在宿主细胞内组合成新病毒颗粒的过程。</dd>
</dl>
<ul>
<li>除<strong>痘病毒</strong>外，DNA 病毒均在细胞核内组装</li>
<li>RNA 病毒与痘病毒在胞质内组装</li>
</ul>
<p><strong>释放（release）</strong></p>
<ul>
<li>破胞释放：<strong>无包膜的病毒</strong>在宿主细胞内积累到一定数量后，随细胞裂解释放</li>
<li>出芽：<strong>有包膜的病毒</strong>在释放过程中包被上了宿主细胞的核膜（疱疹病毒）或细胞膜</li>
<li>通过<strong>细胞间桥</strong>或<strong>细胞融合</strong>的方式在细胞间传播，很少释放到细胞外</li>
</ul>
<h3 id="病毒的异常增殖与干扰现象">病毒的异常增殖与干扰现象 <a class="markdownIt-Anchor" href="#病毒的异常增殖与干扰现象">#</a></h3>
<h4 id="病毒的异常增殖">病毒的异常增殖 <a class="markdownIt-Anchor" href="#病毒的异常增殖">#</a></h4>
<dl>
<dt>顿挫感染 | 流产感染（abortive infection）</dt>
<dd>病毒感染宿主细胞后，因细胞不能为病毒提供复制的必要条件（如酶类、能量及必要成分）而没有完整病毒体的产生。</dd>
<dt>非容纳细胞（non-permissive cell）</dt>
<dd>引起病毒顿挫感染的细胞。</dd>
<dt>容纳细胞（permissive cell）</dt>
<dd>能支持病毒完成正常增殖的细胞。</dd>
</dl>
<hr />
<dl>
<dt>缺陷病毒（defective virus）| 缺陷干扰颗粒（defective interfering particle, DIP）</dt>
<dd>因基因组不完整或发生严重改变，而不能复制出完整子代病毒的病毒。</dd>
<dd>缺陷干扰颗粒能干扰同种成熟病毒体进入细胞。</dd>
<dt>辅助病毒（helper virus）</dt>
<dd>具有弥补缺陷病毒的不足，使之增殖除完整病毒的辅助功能的病毒。</dd>
</dl>
<h4 id="干扰现象">干扰现象 <a class="markdownIt-Anchor" href="#干扰现象">#</a></h4>
<dl>
<dt>干扰现象（interference）</dt>
<dd>两种病毒感染同一细胞时，一种病毒的增殖可以抑制另一种病毒增殖的现象。</dd>
</dl>
<blockquote>
<p>干扰现象不仅在活病毒间发生，灭活病毒也能干扰活病毒。</p>
</blockquote>
<h2 id="病毒的遗传与变异">病毒的遗传与变异 <a class="markdownIt-Anchor" href="#病毒的遗传与变异">#</a></h2>
<h3 id="遗传型变异">遗传型变异 <a class="markdownIt-Anchor" href="#遗传型变异">#</a></h3>
<h4 id="基因突变">基因突变 <a class="markdownIt-Anchor" href="#基因突变">#</a></h4>
<dl>
<dt>突变株（mutant）</dt>
<dd>由基因突变产生的病毒表型性状改变的毒株。</dd>
</dl>
<ol>
<li>毒力改变</li>
<li>条件致死突变株</li>
<li>宿主范围突变株</li>
<li>耐药性突变株（drug-resistant mutant）</li>
<li>……</li>
</ol>
<dl>
<dt>条件致死突变株（conditional lethal mutant）</dt>
<dd>病毒突变后在特定条件下能增殖，在原来的条件下不能增殖而致死的突变株。</dd>
<dt>宿主范围突变株（host-range mutant, hr 突变株）</dt>
<dd>病毒基因组的改变影响了其对宿主细胞的吸附或相互作用。</dd>
</dl>
<h4 id="重组和重配">重组和重配 <a class="markdownIt-Anchor" href="#重组和重配">#</a></h4>
<dl>
<dt>重组（recombination）</dt>
<dd>多种病毒感染同一细胞时，两者发生核酸水平上的交换和重新组合（<strong>分子内</strong>）。</dd>
<dt>重配（reassortment）</dt>
<dd>在<strong>分节段的 RNA 病毒基因组</strong>之间，两个病毒株通过基因节段的交换使子代基因组发生突变的过程。</dd>
<dd>核酸分节段的常见病毒有<a href="/2021/04/26/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%97%85%E6%AF%92/#流行性感冒病毒">流行性感冒病毒</a></dd>
</dl>
<h4 id="基因整合">基因整合 <a class="markdownIt-Anchor" href="#基因整合">#</a></h4>
<dl>
<dt>整合（integration）</dt>
<dd>病毒基因组或基因组中的某些片段插入宿主细胞染色体 DNA 的重组过程。</dd>
<dd>可引起病毒基因的变异及宿主细胞染色体基因的改变，导致细胞转化发生肿瘤等。</dd>
</dl>
<h3 id="非遗传性变异">非遗传性变异 <a class="markdownIt-Anchor" href="#非遗传性变异">#</a></h3>
<h4 id="表型混合与核衣壳转移">表型混合与核衣壳转移 <a class="markdownIt-Anchor" href="#表型混合与核衣壳转移">#</a></h4>
<dl>
<dt>表型混合（phenotypic mixing）</dt>
<dd>一种病毒复制的核酸被另一种病毒编码的蛋白质衣壳或包膜包裹，是<strong>基因产物的交换</strong>。</dd>
<dt>核壳转移（transcapsidation）</dt>
<dd><strong>无包膜病毒</strong>发生的表型混合。</dd>
</dl>
<h4 id="基因型混合">基因型混合 <a class="markdownIt-Anchor" href="#基因型混合">#</a></h4>
<dl>
<dt>基因型混合（genotype mixing）</dt>
<dd>两种病毒的核酸偶尔混合装在同一个病毒衣壳内，或两种病毒的核衣壳偶尔装在同一个包膜内，</dd>
<dd>核酸未重组，没有遗传性，传代后子代恢复其亲代的性状。</dd>
</dl>
<h4 id="互补和增强">互补和增强 <a class="markdownIt-Anchor" href="#互补和增强">#</a></h4>
<dl>
<dt>互补（complementation）</dt>
<dd>两种病毒通过产生的蛋白质产物互相弥补不足，如辅助病毒和缺损病毒。</dd>
<dt>增强（enhancement）</dt>
<dd>一种病毒对另一种病毒的产量有促进作用。</dd>
</dl>
<h2 id="理化因素对病毒的影响">理化因素对病毒的影响 <a class="markdownIt-Anchor" href="#理化因素对病毒的影响">#</a></h2>
<ul>
<li>物理因素：温度、PH、射线</li>
<li>化学因素：脂溶剂、化学消毒剂、抗生素与中草药、其他（离子等）</li>
</ul>
<h2 id="病毒的感染与抗病毒免疫">病毒的感染与抗病毒免疫 <a class="markdownIt-Anchor" href="#病毒的感染与抗病毒免疫">#</a></h2>
<p><a href="/2021/04/23/%E7%97%85%E6%AF%92%E7%9A%84%E6%84%9F%E6%9F%93%E4%B8%8E%E6%8A%97%E7%97%85%E6%AF%92%E5%85%8D%E7%96%AB/">病毒的感染与抗病毒免疫</a></p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
      </tags>
  </entry>
  <entry>
    <title>病毒的感染与抗病毒免疫</title>
    <url>/2021/04/23/%E7%97%85%E6%AF%92%E7%9A%84%E6%84%9F%E6%9F%93%E4%B8%8E%E6%8A%97%E7%97%85%E6%AF%92%E5%85%8D%E7%96%AB/</url>
    <content><![CDATA[<dl>
<dt>病毒感染（viral infection）</dt>
<dd>病毒侵入体内并在靶细胞内增殖，与机体发生相互作用的过程。</dd>
</dl>
<span id="more"></span>
<h2 id="病毒传播和播散">病毒传播和播散 <a class="markdownIt-Anchor" href="#病毒传播和播散">#</a></h2>
<p>传播方式</p>
<ul>
<li>水平传播</li>
<li>垂直传播</li>
</ul>
<p>病毒在宿主体内的播散方式</p>
<ul>
<li>直接接触播散</li>
<li>经血液播散</li>
<li>经神经系统播散</li>
</ul>
<h2 id="病毒的致病机制">病毒的致病机制 <a class="markdownIt-Anchor" href="#病毒的致病机制">#</a></h2>
<h3 id="病毒感染对宿主细胞的直接作用">病毒感染对宿主细胞的直接作用 <a class="markdownIt-Anchor" href="#病毒感染对宿主细胞的直接作用">#</a></h3>
<ol>
<li>杀细胞性感染</li>
<li>稳定状态感染</li>
<li>细胞凋亡</li>
<li>病毒基因组的整合</li>
<li>细胞增生与细胞转化：少数病毒感染宿主细胞后反而会促进宿主细胞 DNA 的合成。</li>
<li>包涵体的彤成</li>
</ol>
<dl>
<dt>杀细胞性感染（cytocidal infection）| 溶细胞性感染（cytolytic infection）</dt>
<dd>病毒在宿主细胞内复制增殖后，在短时间内释放大量二代病毒，细胞被破坏、死亡，这种作用称为<strong>杀细胞效应</strong>，这种感染称为<strong>杀细胞性感染</strong>。</dd>
<dt>稳定状态感染（steady state infection）</dt>
<dd>有些病毒增殖较慢，所致病变较轻；以出芽的方式释放子代病毒，细胞短时间内不会溶解死亡。</dd>
<dt>细胞凋亡（cell apoptosis）</dt>
<dd>由宿主基因控制的细胞程序性死亡，属于正常的生理学现象。</dd>
<dt>病毒基因组的整合（viral integration）</dt>
<dd>病毒的遗传物质结合至宿主细胞的染色体内。</dd>
<dt>细胞转化（cell transformation）</dt>
<dd>某些病毒感染导致宿主细胞出现形态发生改变、细胞增殖加快、失去细胞间的接触抑制等细胞生物学行为的改变。转化的细胞可能变成肿瘤细胞。</dd>
<dt>包涵体（inclusion body）</dt>
<dd>某些病毒感染细胞后，在细胞浆或/和细胞核内出现的嗜酸性或嗜碱性、大小数量不同的圆形或卵圆形斑块状结构。</dd>
<dd>病毒包涵体是由病毒颗粒和未装配的病毒成分在细胞内堆积而成。</dd>
<dd><a href="/2021/04/19/%E8%A1%A3%E5%8E%9F%E4%BD%93/">衣原体</a>也能形成包涵体。</dd>
</dl>
<h3 id="病毒感染的免疫病理作用">病毒感染的免疫病理作用 <a class="markdownIt-Anchor" href="#病毒感染的免疫病理作用">#</a></h3>
<ol>
<li>体液免疫病理作用</li>
<li>细胞免疫病理作用</li>
<li>病毒感染对免疫系统的致病作用</li>
<li>病毒感染引起的自身免疫病</li>
</ol>
<h2 id="病毒感染类型">病毒感染类型 <a class="markdownIt-Anchor" href="#病毒感染类型">#</a></h2>
<h3 id="隐性感染">隐性感染 <a class="markdownIt-Anchor" href="#隐性感染">#</a></h3>
<dl>
<dt>隐性感染（inapparent infection）| 亚临床感染（subclinical infection）</dt>
<dd>病毒侵入机体后，由于病毒毒力较弱或机体防御力较强，病毒不能大量增殖，对细胞损伤不严重，<strong>临床无症状或症状不典型</strong>。</dd>
</dl>
<h3 id="显性感染">显性感染 <a class="markdownIt-Anchor" href="#显性感染">#</a></h3>
<dl>
<dt>显性感染（apparent infection）</dt>
<dd>病毒侵入后大量增殖致使机体出现典型临床症状。
<ul>
<li>急性病毒感染</li>
<li>持续性病毒感染</li>
</ul>
</dd>
<dt>急性病毒感染（acute viral infection）</dt>
<dd>潜伏期短，发病急，病程短，恢复后机体不在携带病毒。</dd>
<dt>持续性病毒感染（persistent viral infection）</dt>
<dd>机体可携带潜伏病毒数月至数（十）年；可出现症状，也可不出现症状；引起慢性进行性疾病，并可称为重要的传染源。
<ul>
<li>潜伏感染</li>
<li>慢性感染</li>
<li>慢发病毒感染</li>
</ul>
</dd>
<dt>潜伏（性）感染（latent infection）</dt>
<dd>持续性感染伴有疾病的间歇性发作，在两次发作间用常规方法不能分离到病毒，如 HSV 、水痘-带状疱疹病毒及 CMV 感染等。</dd>
<dt>慢性感染（chronic infection）</dt>
<dd>持续感染可检出病毒，并常排出病毒，但不发病或带有免疫病理失调，如 HBV 、jc 病毒、BK 病毒、HIV 及 LCMV 感染等。</dd>
<dt>慢发病毒感染（slow virus infection）| 迟发（病毒）感染 | 长程感染</dt>
<dd>持续感染有很长的潜伏期，随后缓慢的发展成致死性疾病，如 HIV 和 痲疹病毒的感染。</dd>
<dd>儿童期感染痲疹病毒恢复后，极少数人于十余年后可发生<strong>亚急性硬化性全脑炎（SSPE）</strong>。</dd>
</dl>
<h2 id="抗病毒感染免疫">抗病毒感染免疫 <a class="markdownIt-Anchor" href="#抗病毒感染免疫">#</a></h2>
<h3 id="固有抗病毒免疫">固有抗病毒免疫 <a class="markdownIt-Anchor" href="#固有抗病毒免疫">#</a></h3>
<ol>
<li>先天不感受性：细胞膜上无病毒受体</li>
<li>屏障作用：机械和化学屏障</li>
<li>细胞作用：单核吞噬细胞、自然杀伤细胞（NK 细胞）</li>
<li>干扰素</li>
</ol>
<dl>
<dt>干扰素（interferon, IFN）</dt>
<dd>由病毒或其他干扰素诱生剂刺激人或动物细胞产生的一种糖蛋白。</dd>
</dl>
<p>另见 <a href="/2021/05/21/%E7%BB%86%E8%83%9E%E5%9B%A0%E5%AD%90/#细胞">TODO</a></p>
<p>干扰素的作用</p>
<ul>
<li>广谱抗病毒（无病毒特异性）</li>
<li>调节免疫功能</li>
<li>抑制肿瘤细胞生长</li>
</ul>
<p>干扰素不是直接杀伤细胞，而是于宿主细胞的受体结合，进而作用于宿主细胞的基因，使之合成抗病毒蛋白。</p>
<p>干扰素的种类</p>
<ul>
<li>Ⅰ型干扰素：α 干扰素、β 干扰素
<ul>
<li>由白细胞（α）和成纤维细胞（β）产生</li>
<li>抗病毒作用较强</li>
</ul>
</li>
<li>Ⅱ型干扰素：γ 干扰素
<ul>
<li>由 T 细胞产生</li>
<li>对免疫细胞的调节作用较强</li>
</ul>
</li>
</ul>
<h3 id="适应性抗病毒免疫">适应性抗病毒免疫 <a class="markdownIt-Anchor" href="#适应性抗病毒免疫">#</a></h3>
<p>即病毒的各种结构蛋白及少数 DNA 多聚酶作为抗原在体内诱生细胞免疫及体液免疫。</p>
<h4 id="抗体介导的抗病毒作用">抗体介导的抗病毒作用 <a class="markdownIt-Anchor" href="#抗体介导的抗病毒作用">#</a></h4>
<p>另见：<a href="/2021/05/10/%E6%8A%97%E4%BD%93/"><mark class="label default">抗体</mark></a></p>
<dl>
<dt>中和抗体（neutralization antibody）</dt>
<dd>具有与病毒结合后消除病毒感染能力的抗体。</dd>
<dt>非中和抗体</dt>
<dd>指哪些不具有吸附穿入作用的病毒表面抗原及病毒体内部抗原所诱生的抗体。
<ul>
<li>神经氨酸抗体：抑制病毒释放及扩散</li>
<li>血凝抑制抗体</li>
<li>补体结合抗体</li>
</ul>
</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
      </tags>
  </entry>
  <entry>
    <title>真菌</title>
    <url>/2021/03/21/%E7%9C%9F%E8%8F%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>社会医学</title>
    <url>/2021/05/11/%E7%A4%BE%E4%BC%9A%E5%8C%BB%E5%AD%A6/</url>
    <content><![CDATA[<p>社会医学知识点总结。</p>
<p style="text-align: right;font-style: italic">By 陈可睿，刘其焕，李嘉朋</p>
<blockquote>
<p>以 103 期 83 班马滔学姐总结的word为基础，根据 105 期社会医学老师给出的重点对知识点进行的增加和删减。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>斜体小标题表示次要内容。</p>
</blockquote>
<ol>
<li><strong>社会医学的研究内容</strong>
<ol>
<li>研究社会卫生状况（主要是人群健康状况）</li>
<li>研究影响人群健康的因素（主要是社会因素）</li>
<li>研究社会卫生策略和措施</li>
</ol>
</li>
<li><em><strong>三次卫生革命</strong></em>
<ol>
<li>第一次卫生革命：以传染病、寄生虫病和地方病为主要防治对象</li>
<li>第二次卫生革命：以慢性非传染性疾病为主攻目标</li>
<li>第三次卫生革命：以提高生命质量、促进全人类健康长寿、实现 WHO 倡导的“人人享有卫生保健”为目标</li>
</ol>
</li>
<li><strong>社会医学的任务</strong>
<ol>
<li>倡导积极健康观和现代医学模式</li>
<li>改善社会卫生状况，提高人群健康水平</li>
<li>制定社会卫生策略和措施</li>
<li>开展健康弱势人群保健和社会病控制</li>
</ol>
</li>
<li><strong>社会医学的特色理论和创新观点</strong>
<ol>
<li>卫生事业与社会协调发展</li>
<li>健康与社会经济发展的双向作用</li>
<li>生理、心理、社会的健康观</li>
<li>高危人群和高危因素</li>
<li>疾病防治中社会因素的决定作用</li>
<li>全社会参与的大卫生观</li>
</ol>
</li>
<li><strong>医学模式的演变</strong>
<ol>
<li>神灵主义医学模式</li>
<li>自然哲学医学模式</li>
<li>机械论医学模式</li>
<li>生物医学模式</li>
<li>生物-心理-社会医学模式</li>
</ol>
</li>
<li><strong>生物-心理-社会医学模式的产生背景</strong>
<ol>
<li>疾病谱和死因谱的转变</li>
<li>健康需求的提高</li>
<li>医学的社会化</li>
<li>医学学科的内部融合与外部交叉发展</li>
</ol>
</li>
<li><strong>综合健康医学模式</strong>（参考书 19 页 <a href="/2021/05/11/%E7%A4%BE%E4%BC%9A%E5%8C%BB%E5%AD%A6/%E7%BB%BC%E5%90%88%E5%81%A5%E5%BA%B7%E5%8C%BB%E5%AD%A6%E6%A8%A1%E5%BC%8F.jpg" title="图 2-3 综合健康医学模式">图 2-3 综合健康医学模式</a> ）
<ol>
<li>环境因素：自然、心理、社会环境因素</li>
<li>生活方式与行为因素：职业危险因素、消费形式、生活危险因素</li>
<li>生物遗传因素：成熟老化、综合内因、遗传</li>
<li>医疗卫生服务因素：康复、治疗、预防</li>
</ol>
</li>
<li><strong>影响健康的主要社会因素</strong>
<ol>
<li>年龄、性别和遗传因素</li>
<li>个体生活方式</li>
<li>社会支持网络</li>
<li>社会经济地位</li>
<li>其他社会结构因素</li>
<li>宏观社会经济、文化和环境</li>
</ol>
</li>
<li><strong>将健康融入所有政策的行动框架</strong>
<ol>
<li>确定需求和优先领域</li>
<li>制定行动计划</li>
<li>确认支持性的组织机构和程序</li>
<li>促进评估和参与</li>
<li>确保监测、评价和报告</li>
<li>加强能力</li>
</ol>
</li>
<li><strong>经济发展与健康之间的关系</strong>
<ol>
<li>经济发展对健康的作用
<ol>
<li>经济发展促进健康水平提高</li>
<li>经济发展提高了居民物质生活水平</li>
<li>经济发展有利于增加健康投资</li>
<li>经济发展通过对教育的影响间接影响人群健康</li>
</ol>
</li>
<li>经济发展带来新的健康问题
<ol>
<li>环境污染和生态破坏</li>
<li>生活方式的改变</li>
<li>现代社会病的产生</li>
<li>心理健康问题的凸显</li>
<li>负性社会事件的增多</li>
<li>社会人口特征的剧烈变化</li>
</ol>
</li>
<li>健康对经济发展的作用
<ol>
<li>增加劳动力供给</li>
<li>提高劳动生产率</li>
<li>减少疾病损失和资源耗费</li>
<li>促进教育收益实现</li>
<li>促进自然资源利用</li>
</ol>
</li>
</ol>
</li>
<li><em><strong>文化的构成</strong></em>：认知成分、规范成分、符号成分</li>
<li><em><strong>文化影响健康的特点</strong></em>：无形性、本源性、软约束性、稳定性、民族性</li>
<li><strong>教育对健康的影响</strong>
<ol>
<li>教育影响人们对生活方式的选择</li>
<li>教育影响人们对于卫生服务的利用</li>
<li>教育影响人们的就业机会及收入</li>
</ol>
</li>
<li><strong>行为心理问题的干预</strong>
<ol>
<li>政策干预</li>
<li>环境工程设施干预</li>
<li>大众媒体干预</li>
<li>社区干预</li>
<li>组织干预</li>
</ol>
</li>
<li><strong>控烟的政策措施</strong>
<ol>
<li>监测烟草使用与预防政策</li>
<li>保护人们免受烟雾危害</li>
<li>提供戒烟帮助</li>
<li>警示烟草危害</li>
<li>禁止烟草广告、促销和赞助</li>
<li>增加烟税和提高烟价</li>
</ol>
</li>
<li><strong>社会医学的相关研究方法</strong>：调查研究、实验研究、评价研究、文献研究</li>
<li><strong>德尔菲法</strong>
<ol>
<li>定义：德尔菲法是在专家会议预测法的基础上发展而来，其核心是专家独立评价，但又互相了解、逐渐取得一致</li>
<li>德尔菲法流程：在设计好专家咨询表的基础上，通过多轮函询征求专家对某一问题的意见，并对每一轮的意见汇总，剔除专家共同否定的问题，增加专家提出的新建议，在下一轮函询时随函询表寄给专家供其在评价时参考。通过 2~4 轮的反复评价，使专家的意见逐渐趋于一致，最终达到研究的目的</li>
</ol>
</li>
<li><strong>社会医学研究的步骤</strong>
<ol>
<li>选择课题</li>
<li>制定研究方案</li>
<li>收集资料</li>
<li>整理和分析资料</li>
<li>解释结果</li>
</ol>
</li>
<li><strong>定性研究方法</strong>
<ol>
<li>深入访谈法</li>
<li>专题小组讨论法</li>
<li>选题小组讨论法</li>
<li>观察法</li>
</ol>
</li>
<li><strong>问卷设计的步骤</strong>
<ol>
<li>明确研究目的</li>
<li>建立问题库</li>
<li>设计问卷初稿</li>
<li>试用和修改</li>
<li>信度与效度的检验</li>
</ol>
</li>
<li><strong>问卷的评价</strong>
<ol>
<li>信度：复测信度、复本信度、折半信度</li>
<li>效度：表面效度、内容效度、结构效度、准则效度</li>
</ol>
</li>
<li><strong>卫生服务研究的内容</strong>
<ol>
<li>社会因素对卫生系统的影响</li>
<li>评价人群的医疗卫生服务需要</li>
<li>卫生资源的合理配置和有效使用</li>
<li>卫生系统的组织结构与功能</li>
<li>卫生系统的经济分析</li>
<li>卫生服务效果评价</li>
</ol>
</li>
<li><em><strong>卫生服务研究的方法</strong></em>
<ol>
<li>描述性研究</li>
<li>分析性研究</li>
<li>实验性研究</li>
<li>数学模型方法</li>
<li>系统分析法</li>
<li>综合评价法</li>
<li>投入产出分析法</li>
<li>家庭健康询问抽样调查</li>
</ol>
</li>
<li><strong>健康危险因素的分类</strong>
<ol>
<li>环境危险因素（自然环境危险因素、社会环境危险因素）</li>
<li>心理、行为危险因素</li>
<li>生物遗传危险因素</li>
<li>医疗卫生服务中的危险因素</li>
</ol>
</li>
<li><strong>健康危险因素的特点</strong>：潜伏期长、特异性弱、联合作用、广泛存在</li>
<li><strong>健康危险因素的作用过程</strong>
<ol>
<li>无危险阶段</li>
<li>出现危险因素</li>
<li>致病因素出现</li>
<li>症状出现</li>
<li>体征出现</li>
<li>劳动力丧失</li>
</ol>
</li>
<li><strong>个体评价结果的四种类型</strong>
<ol>
<li>健康型：<em>个体的评价年龄小于实际年龄；</em></li>
<li>自创性危险因素型：<em>个体的评价年龄大于实际年龄，并且评价年龄与增长年龄的差值大，说明个体危险因素高于平均水平；</em></li>
<li>难以改变的危险因素型：<em>个体评价年龄大于实际年龄，但评价年龄与增长年龄之差较小；</em></li>
<li>一般性危险型：<em>个体的评价年龄接近实际年龄，死亡水平相当于当地的平均水平，个体存在的危险因素类型和水平接近当地人群的平均水平，降低危险因素的可能性限，增长年龄与评价年龄接近。</em></li>
</ol>
</li>
<li><strong>生命质量的评价内容</strong>
<ol>
<li>生理状态（<em>活动受限、角色受限、体力适度</em>）</li>
<li>心理状态（<em>情绪反应、认知功能</em>）</li>
<li>社会功能状态</li>
<li>主观判断与满意度（<em>自身健康和生活判断、满意度与幸福感</em>）</li>
<li>其他内容</li>
</ol>
</li>
<li><strong>生命质量的应用</strong>
<ol>
<li>人群健康状况的评定</li>
<li>卫生服务的效果评价与方案选择</li>
<li>卫生资源的配置与利用的决策。</li>
</ol>
</li>
<li><em><strong>社会卫生状况的指标 - 复合型指标</strong></em>：减寿人年数、无残疾期望寿命、伤残调整生命年、健康期望寿命</li>
<li><strong>健康中国 2020、2030、2050 年三步走的战略目标</strong>
<ol>
<li>到 2020 年，建立覆盖城乡居民的中国特色基本医疗卫生制度，健康素养水平持续提高，健康服务体系完善高效，人人享有基本医疗卫生服务和基本体育健身服务, 基本形成内涵丰富、结构合理的健康产业体系，主要健康指标居于中高收入国家前列</li>
<li>到 2030 年，促进全民健康的制度体系更加完善，健康领域发展更加协调，健康生活方式得到普及，健康服务质量和健康保障水平不断提高，健康产业繁荣发展，基本实现健康公平，主要健康指标进入高收入国家前列</li>
<li>到 2050 年，建成与社会主义现代化国家相适应的健康国家</li>
</ol>
</li>
<li><strong>卫生保健制度的基本模式（世界）</strong>
<ol>
<li>自费医疗模式（非洲）</li>
<li>国家医疗保险模式【集成式、合同式】（英国、澳大利亚、加拿大、俄罗斯、新西兰、瑞典、丹麦、挪威、芬兰、葡萄牙、西班牙、冰岛、爱尔兰）</li>
<li>社会医疗保险模式（德国、法国、意大利、西班牙、日本、巴西、阿根廷、奥地利、比利时、卢森堡）</li>
<li>商业医疗保险模式【集成式、合同式、病人赔偿式】（美国）</li>
<li>储蓄积累型模式（新加坡、马来西亚、印度尼西亚）</li>
</ol>
</li>
<li><strong>我国卫生保健制度</strong>
<ol>
<li>公费医疗制度</li>
<li>城镇职工基本医疗保险制度</li>
<li>新型农村合作医疗制度</li>
<li>城镇居民基本医疗保险制度</li>
<li>补充医疗保险制度</li>
</ol>
</li>
<li><strong>社区卫生服务的特点</strong>
<ol>
<li>以健康为中心</li>
<li>以需求为导向</li>
<li>以家庭为单位</li>
<li>以预防为主</li>
<li>人性化服务</li>
<li>综合性服务</li>
<li>连续性服务</li>
<li>协调性与团队合作式服务</li>
<li>可及性服务</li>
<li>首诊医疗服务</li>
</ol>
</li>
<li><strong>慢性病三级预防</strong>
<ol>
<li>一级预防（病因预防）
<ol>
<li>目的：是消除疾病的危险因素，预防疾病的发生和促进健康</li>
<li>策略：采取双向策略即全人群策略和高危策略</li>
<li>手段：健康促进和健康保护</li>
</ol>
</li>
<li>二级预防（临床前期预防）
<ol>
<li>目的：阻止或延缓疾病向临床阶段发展</li>
<li>措施：早期发现、早期诊断和早期治疗</li>
</ol>
</li>
<li>三级预防（临床期预防）
<ol>
<li>目的：防止伤残和促进功能恢复，提高生命质量，延长寿命，降低病死率</li>
<li>措施：临床治疗和康复治疗</li>
</ol>
</li>
</ol>
</li>
<li><em><strong>自杀的预防</strong></em>
<ol>
<li>建立国家自杀预防战略</li>
<li>提高人群心理健康素质</li>
<li>普及有关自杀和自杀预防知识</li>
<li>指导媒体有关自杀时间的报道</li>
<li>减少自杀的机会</li>
<li>建立预防自杀的专门机构</li>
<li>对医务工作者和心理咨询工作者进行培训</li>
<li>提供完善的精神卫生服务</li>
<li>加强学校和工作场所的自杀预防工作</li>
<li>关注自杀死亡的亲人</li>
</ol>
<blockquote>
<p>认为想自杀不会向别人暴露自己的自杀意图是错误的</p>
</blockquote>
</li>
<li><strong>吸毒的社会根源</strong>
<ol>
<li>毒品的可获得性</li>
<li>同伴影响和团伙压力</li>
<li>成长环境的影响</li>
<li>社会文化对毒品的容忍程度</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>社会医学</category>
      </categories>
      <tags>
        <tag>社会医学</tag>
      </tags>
  </entry>
  <entry>
    <title>立克次体</title>
    <url>/2021/04/19/%E7%AB%8B%E5%85%8B%E6%AC%A1%E4%BD%93/</url>
    <content><![CDATA[<dl>
<dt>立克次体（<em>Rickettsia</em>）</dt>
<dd>一类<strong>严格细胞内寄生</strong>、以<strong>节肢动物</strong>为传播媒介、大小介于细菌和病毒之间的<a href="/2021/03/16/%E7%97%85%E5%8E%9F%E7%94%9F%E7%89%A9%E5%AD%A6/#微生物">原核细胞型微生物</a>。</dd>
<dd>其生物学性状与细菌相似。</dd>
</dl>
<span id="more"></span>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>
<p>多形态、大小介于细菌与病毒之间</p>
</li>
<li>
<p>与<mark>节肢动物</mark>关系密切，寄生在吸血节肢动物体内，或为寄生宿主、或为储存宿主、或同时为传播媒介</p>
</li>
<li>
<p>类似病毒的特性</p>
<ul>
<li>缺少酶系统，细胞器不完善</li>
<li><mark>专性胞内寄生</mark></li>
<li>不能用人工培养基培养</li>
</ul>
</li>
<li>
<p>类似细菌的特点</p>
<ul>
<li>二分裂繁殖</li>
<li>含两种核酸</li>
<li>对多种抗生素敏感</li>
<li><em>革兰氏染色阴性</em></li>
</ul>
</li>
<li>
<p>培养特性</p>
</li>
</ul>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="致病物质">致病物质 <a class="markdownIt-Anchor" href="#致病物质">#</a></h4>
<h4 id="所致疾病">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病">#</a></h4>
<h4 id="免疫性">免疫性 <a class="markdownIt-Anchor" href="#免疫性">#</a></h4>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>细胞因子</title>
    <url>/2021/05/21/%E7%BB%86%E8%83%9E%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<dl>
<dt>细胞因子（cytokine，<abbr title="细胞因子（cytokine）">CK</abbr>）</dt>
<dd>由免疫细胞及组织细胞分泌的在细胞间发挥相互调控作用的一类小分子可溶性蛋白质。</dd>
</dl>
<blockquote>
<p>早期认为细胞因子由白细胞产生，因此曾称为“白细胞介素”。</p>
</blockquote>
<span id="more"></span>
<h2 id="细胞因子的共同特点">细胞因子的共同特点 <a class="markdownIt-Anchor" href="#细胞因子的共同特点">#</a></h2>
<p>细胞因子的基本特性</p>
<ol>
<li>小分子糖蛋白</li>
<li>高效性</li>
<li>通过与受体结合发挥生物学作用</li>
<li>可诱导产生，且合成具有自限性</li>
<li>半寿期短</li>
<li>效应范围小</li>
</ol>
<h3 id="细胞因子的作用方式">细胞因子的作用方式 <a class="markdownIt-Anchor" href="#细胞因子的作用方式">#</a></h3>
<ol>
<li><strong>自分泌</strong>（autocrine）方式：T 细胞产生白细胞介素-2 可刺激自身生长；</li>
<li><strong>旁分泌</strong>（paracrine）方式：</li>
<li><strong>内分泌</strong>（endocrine）方式</li>
</ol>
<h3 id="细胞因子的功能特点">细胞因子的功能特点 <a class="markdownIt-Anchor" href="#细胞因子的功能特点">#</a></h3>
<ol>
<li><strong>多效性</strong></li>
</ol>
<ul>
<li><abbr title="白细胞介素">IL</abbr>-4 可刺激 B 细胞增殖分化，也可以刺激胸腺细胞和肥大细胞的增殖；</li>
</ul>
<ol start="2">
<li><strong>重叠性</strong>：Il-2、<abbr title="白细胞介素">IL</abbr>-7、<abbr title="白细胞介素">IL</abbr>-15 均可以刺激 T 细胞增殖；</li>
<li><strong>协同性</strong>：</li>
<li><strong>拮抗性</strong></li>
<li><strong>网络性</strong></li>
</ol>
<h2 id="细胞因子的分类">细胞因子的分类 <a class="markdownIt-Anchor" href="#细胞因子的分类">#</a></h2>
<ol>
<li><strong>白细胞介素</strong>（<abbr title="白细胞介素">IL</abbr>）</li>
<li><strong>集落刺激因子</strong>（<abbr title="集落刺激因子">CSF</abbr>）</li>
<li><a href="/2021/04/23/%E7%97%85%E6%AF%92%E7%9A%84%E6%84%9F%E6%9F%93%E4%B8%8E%E6%8A%97%E7%97%85%E6%AF%92%E5%85%8D%E7%96%AB/#固有抗病毒免疫"><strong>干扰素</strong></a>（IFN）</li>
<li>Ⅰ 型；</li>
<li>Ⅱ 型</li>
<li>Ⅲ 型</li>
<li><strong>肿瘤坏死因子</strong>（<abbr title="肿瘤坏死因子">TNF</abbr>）</li>
<li><strong>生长因子</strong>（<abbr title="生长因子">GF</abbr>）</li>
<li><strong>趋化因子</strong></li>
</ol>
<h2 id="细胞因子受体">细胞因子受体 <a class="markdownIt-Anchor" href="#细胞因子受体">#</a></h2>
<h3 id="细胞因子受体的分类">细胞因子受体的分类 <a class="markdownIt-Anchor" href="#细胞因子受体的分类">#</a></h3>
<ol>
<li>Ⅰ 型细胞因子受体/血细胞生成素受体家族</li>
<li>Ⅱ 型细胞因子受体/干扰素受体家族</li>
<li>肿瘤坏死因子受体</li>
<li>免疫球蛋白超家族受体/ <abbr title="白细胞介素">IL</abbr>-1 受体家族</li>
<li><abbr title="白细胞介素">IL</abbr>-17 受体家族</li>
<li>趋化因子受体家族/ 7 次跨膜蛋白受体家族
<ul>
<li>特异性趋化因子受体</li>
<li>共享性趋化因子受体</li>
</ul>
</li>
</ol>
<h3 id="细胞因子受体的共有链">细胞因子受体的共有链 <a class="markdownIt-Anchor" href="#细胞因子受体的共有链">#</a></h3>
<ul>
<li>共有 γ 链</li>
<li>共有 β 链</li>
<li>gp130</li>
</ul>
<h3 id="可溶性细胞因子受体">可溶性细胞因子受体、 <a class="markdownIt-Anchor" href="#可溶性细胞因子受体">#</a></h3>
<h4 id="可溶性细胞因子受体-2">可溶性细胞因子受体 <a class="markdownIt-Anchor" href="#可溶性细胞因子受体-2">#</a></h4>
<p>竞争性与受体结合，</p>
<h4 id="细胞因子诱饵受体">细胞因子诱饵受体 <a class="markdownIt-Anchor" href="#细胞因子诱饵受体">#</a></h4>
<h4 id="细胞因子受体拮抗剂">细胞因子受体拮抗剂 <a class="markdownIt-Anchor" href="#细胞因子受体拮抗剂">#</a></h4>
<h2 id="细胞因子的免疫学功能">细胞因子的免疫学功能 <a class="markdownIt-Anchor" href="#细胞因子的免疫学功能">#</a></h2>
<ol>
<li>调控免疫细胞发育、分化和功能</li>
<li>调控免疫细胞在中枢免疫器官中的发育、分化</li>
<li>调控免疫细胞在外周免疫器官中的发育、分化、活化和功能</li>
<li>调控机体的免疫应答</li>
<li>抗感染作用：抗菌免疫、抗病毒免疫</li>
<li>抗肿瘤作用</li>
<li>诱导细胞凋亡</li>
<li><em>其他功能</em>：刺激造血；促进组织创伤的修复；</li>
</ol>
<h2 id="细胞因子和临床">细胞因子和临床 <a class="markdownIt-Anchor" href="#细胞因子和临床">#</a></h2>
<h3 id="细胞因子与疾病的发生">细胞因子与疾病的发生 <a class="markdownIt-Anchor" href="#细胞因子与疾病的发生">#</a></h3>
<ol>
<li>细胞因子风暴</li>
<li>致热与炎症病理损害</li>
<li>肿瘤的发生与免疫逃逸</li>
<li>参与多种免疫系统相关疾病</li>
<li>参与代谢性疾病</li>
</ol>
<dl>
<dt>细胞因子风暴（cytokine storm）</dt>
<dd>短期内机体大量分泌多种细胞因子，引起全身性炎症反应综合征，严重者可致多器官功能障碍综合征。</dd>
</dl>
<h3 id="细胞因子与疾病治疗">细胞因子与疾病治疗 <a class="markdownIt-Anchor" href="#细胞因子与疾病治疗">#</a></h3>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>医学免疫学</category>
      </categories>
      <tags>
        <tag>医学免疫学</tag>
      </tags>
  </entry>
  <entry>
    <title>细胞生物学</title>
    <url>/2021/05/19/%E7%BB%86%E8%83%9E%E7%94%9F%E7%89%A9%E5%AD%A6/</url>
    <content><![CDATA[<p class="center">Empty</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>细胞生物学</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>细胞生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>细菌</title>
    <url>/2021/03/21/%E7%BB%86%E8%8F%8C/</url>
    <content><![CDATA[<dl>
<dt>细菌</dt>
<dd>一类有细胞壁，以无性二分裂方式进行繁殖的原核细胞型微生物。</dd>
<dd>大小为微米（μm）级</dd>
</dl>
<span id="more"></span>
<h2 id="分类">分类 <a class="markdownIt-Anchor" href="#分类">#</a></h2>
<h3 id="按形态">按形态 <a class="markdownIt-Anchor" href="#按形态">#</a></h3>
<ul>
<li>球菌：单球菌、双球菌、链球菌、四联球菌、八叠球菌、葡萄球菌</li>
<li>杆菌：球杆菌、梭杆菌、棒状杆菌、链杆菌</li>
<li>螺旋菌
<ul>
<li>弧菌：一个弯曲</li>
<li>螺菌：多个弯曲，较僵硬（<a href="/2021/04/15/%E8%9E%BA%E6%97%8B%E4%BD%93/">螺旋体</a>较软）</li>
<li>螺杆菌：细长弯曲成弧状或螺旋状</li>
</ul>
</li>
</ul>
<h3 id="病原生物学分类">病原生物学分类 <a class="markdownIt-Anchor" href="#病原生物学分类">#</a></h3>
<ul>
<li><a href="/2021/03/25/%E5%8C%96%E8%84%93%E6%80%A7%E7%BB%86%E8%8F%8C/">化脓性细菌</a></li>
<li><a href="/2021/03/29/%E6%B6%88%E5%8C%96%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/">消化道感染细菌</a></li>
<li><a href="/2021/04/01/%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E7%BB%86%E8%8F%8C/">呼吸道感染细菌</a></li>
</ul>
<h2 id="结构">结构 <a class="markdownIt-Anchor" href="#结构">#</a></h2>
<ul>
<li>基本结构（各种细菌共有的结构）：<a href="#%E7%BB%86%E8%83%9E%E5%A3%81">细胞壁</a>、<a href="#%E7%BB%86%E8%83%9E%E8%86%9C">细胞膜</a>、<a href="#%E7%BB%86%E8%83%9E%E8%B4%A8">细胞质</a>、<a href="#%E6%A0%B8%E8%B4%A8">核质</a></li>
<li>特殊结构：<a href="#%E8%8D%9A%E8%86%9C">荚膜</a>、<a href="#%E9%9E%AD%E6%AF%9B">鞭毛</a>、<a href="#%E8%8F%8C%E6%AF%9B">菌毛</a>、<a href="#%E8%8A%BD%E5%AD%A2">芽孢</a></li>
</ul>
<h3 id="细胞壁">细胞壁 <a class="markdownIt-Anchor" href="#细胞壁">#</a></h3>
<dl>
<dt>肽聚糖 | 黏肽 | 胞壁质</dt>
<dd>为原核细胞特有的成分，是其细胞壁的主要成分</dd>
</dl>
<blockquote>
<p>使用<em>革兰氏染色法</em>可将细菌分为<strong>革兰氏阳性菌</strong>（G<sup>+</sup>）和<strong>格兰氏阴性菌</strong>（G<sup>-</sup>）两大类。
两者染色不同的原因在于<em>细胞壁组成不同</em>，除了共有的肽聚糖成分之外，各自还有<em>特殊组分</em>。</p>
</blockquote>
<img data-src="/2021/03/21/%E7%BB%86%E8%8F%8C/Gram-stain.jpg" class="" title="Gram stain" alt="Gram stain">
<p>革兰氏阳性菌：<em>三维立体结构</em>，较厚</p>
<ul>
<li>结构
<ul>
<li>聚糖骨架：N-乙酰葡糖胺（G）和 N-乙酰胞壁酸（M）以 β-1,4糖苷键连接而成</li>
<li>四肽侧链：L-谷、D-谷、L-赖、D-丙</li>
<li>五肽交联桥：五个甘氨酸</li>
</ul>
</li>
<li><em>特殊成分</em>
<ul>
<li><strong>磷壁酸</strong>：膜磷壁酸、壁磷壁酸
<ul>
<li>功能：黏附、抗原性</li>
<li>特殊成分：A蛋白、M蛋白</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>格兰氏阴性菌：<em>二维平面结构</em>，较薄</p>
<ul>
<li>结构：
<ul>
<li>聚糖骨架：同 G<sup>+</sup></li>
<li>四肽侧链：L-谷、D-谷、<em>DIP</em>、D-丙</li>
<li>五肽交联桥：无（<em>G<sup>-</sup> 没有抗生素的作用位点</em>）</li>
</ul>
</li>
<li><em>特殊成分</em>（由内到外）
<ul>
<li>脂蛋白：连接肽聚糖的四肽侧链和外膜脂质双层的磷脂</li>
<li><strong>外膜</strong></li>
<li>脂多糖（LAPS）：即 G<sup>-</sup> 的<strong>内毒素</strong>，包括（由内向外）
<ul>
<li><strong>脂质A</strong>：毒性部份和主要成分，无种属特异性</li>
<li>核心多糖</li>
<li>特异多糖：即 G<sup>-</sup> 的菌体抗原（O 抗原）、S-R 转变</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对细胞壁的灭菌物质</p>
<ul>
<li>溶菌酶：切断 M 和 G 之间的连接——致细菌裂解</li>
<li>青霉素：干扰侧链和交联桥之间的连接——致细菌死亡</li>
</ul>
<dl>
<dt>细菌L型</dt>
<dd>细胞壁部份或完全缺陷的细菌
<ul>
<li>形成机制：自发形成或人工诱发</li>
<li>特性
<ul>
<li>染色性：变为革兰氏阴性</li>
<li>形态：多形性</li>
</ul>
</li>
</ul>
</dd>
<dt>原生质体</dt>
<dd><em>L型 G<sup>+</sup> 菌</em></dd>
<dd>必须在高渗环境中才能存活</dd>
<dt>原生质球</dt>
<dd><em>L型 G<sup>-</sup> 菌</em></dd>
<dd>因其肽聚糖层受损后外膜仍存在，而对低渗环境仍有一定的抵抗力</dd>
</dl>
<h3 id="细胞膜">细胞膜 <a class="markdownIt-Anchor" href="#细胞膜">#</a></h3>
<ul>
<li>组成：<strong>不含胆固醇</strong></li>
<li>功能：
<ul>
<li><strong>生物合成</strong>、渗透和运输、呼吸作用</li>
<li>参与<strong>细胞分裂</strong>（中介体）</li>
</ul>
</li>
</ul>
<dl>
<dt>中介体</dt>
<dd>细胞膜内陷折叠形成的囊状物</dd>
</dl>
<ul>
<li>功能
<ul>
<li>类似真核生物的线粒体，故称<em>拟线粒体</em></li>
<li>起着类似于真核生物有丝分裂时纺锤丝的作用</li>
</ul>
</li>
</ul>
<h3 id="细胞质">细胞质 <a class="markdownIt-Anchor" href="#细胞质">#</a></h3>
<p>细菌的 <strong>核糖体</strong> 沉降系数为 70S（50S+30S），一些针对专门细菌的抗生素的接合点在核糖体上。</p>
<dl>
<dt>质粒（plasmid）</dt>
<dd>细菌和简单核细胞中独立于染色体外的闭环双链 DNA 分子，为双股闭合环状
DNA，可携带细菌的某些遗传物质。</dd>
<dd>能独立复制，与染色体复制同步（<strong>严密型质粒</strong>）或不同步（<em>松弛型质粒</em>）。</dd>
<dt>胞质颗粒</dt>
<dd>多数是细菌营养储存物，少数为代谢产物，可作为某些细菌（如白喉棒状杆菌）的 <mark>鉴定依据</mark>。</dd>
</dl>
<h3 id="核质">核质 <a class="markdownIt-Anchor" href="#核质">#</a></h3>
<dl>
<dt>核质 | 拟核</dt>
<dd>细菌的遗传物质</dd>
</dl>
<h3 id="荚膜">荚膜 <a class="markdownIt-Anchor" href="#荚膜">#</a></h3>
<dl>
<dt>荚膜</dt>
<dd>是细菌细胞壁外一层疏松、透明 、排列有序 、不易被洗脱 、不易被染色的粘液物质</dd>
</dl>
<ul>
<li>化学组成：<strong>多糖</strong>（多数）或多肽（少数，如<em>炭疽杆菌</em>）</li>
<li>功能——增强致病性：保护、储存营养、黏附</li>
</ul>
<h3 id="鞭毛">鞭毛 <a class="markdownIt-Anchor" href="#鞭毛">#</a></h3>
<blockquote>
<p>鞭毛具有特殊的抗原性，称为 <strong>H抗原</strong></p>
</blockquote>
<ul>
<li>种类：单鞭毛、双鞭毛、丛鞭毛、周鞭毛</li>
<li>功能：黏附、鉴别、抗原性</li>
</ul>
<h3 id="菌毛">菌毛 <a class="markdownIt-Anchor" href="#菌毛">#</a></h3>
<dl>
<dt>菌毛</dt>
<dd>大多 G<sup>+</sup> 和少数 G<sup>-</sup> 表面的比鞭毛更为纤细、短而直的丝状物</dd>
<dd>化学成分为菌毛蛋白</dd>
</dl>
<ul>
<li>普通菌毛：粘附作用，与致病性有关</li>
<li>性菌毛：传递可遗传物质</li>
</ul>
<h3 id="芽孢">芽孢 <a class="markdownIt-Anchor" href="#芽孢">#</a></h3>
<dl>
<dt>芽孢</dt>
<dd>细菌的休眠体</dd>
</dl>
<p>芽孢具有强大抵抗力，因此被作为灭菌的标准。</p>
<h2 id="细菌的生长代谢">细菌的生长代谢 <a class="markdownIt-Anchor" href="#细菌的生长代谢">#</a></h2>
<h3 id="细菌的合成性代谢产物">细菌的合成性代谢产物 <a class="markdownIt-Anchor" href="#细菌的合成性代谢产物">#</a></h3>
<dl>
<dt>热原质 | 致热原</dt>
<dd>细胞壁的能多糖致热作用，耐高温</dd>
<dd>除去方法：蒸馏或活性炭吸附</dd>
</dl>
<p><strong>毒素和侵袭性酶</strong></p>
<ul>
<li>内毒素</li>
<li>外毒素</li>
<li>具有侵袭性的酶类</li>
</ul>
<p><strong>色素</strong></p>
<ul>
<li>水溶性：铜绿假单胞菌</li>
<li>脂溶性：金黄色葡萄球菌</li>
<li>意义：鉴别细菌</li>
</ul>
<dl>
<dt>抗生素</dt>
<dd>某些微生物产生的一类能抑制或杀死其他微生物或肿瘤细胞的物质</dd>
<dd>产生：放线菌、真菌、少数细菌（细菌产生的较少，只有多黏菌素、杆菌肽等）</dd>
</dl>
<p><strong>维生素</strong></p>
<dl>
<dt>细菌素</dt>
<dd>某些菌株产生的具有抗菌作用的<em>蛋白质</em></dd>
</dl>
<h3 id="细菌生长繁殖的条件">细菌生长繁殖的条件 <a class="markdownIt-Anchor" href="#细菌生长繁殖的条件">#</a></h3>
<ol>
<li>充足的营养物质</li>
<li>合适的温度</li>
<li>适宜的 pH 值</li>
<li>必要的气体环境</li>
</ol>
<h3 id="细菌的生长繁殖规律">细菌的生长繁殖规律 <a class="markdownIt-Anchor" href="#细菌的生长繁殖规律">#</a></h3>
<p>繁殖方式为<strong>二分裂</strong>，<em>代时</em>通常为 20~30min，少数（如结核杆菌）为 18~24h</p>
<p><strong>生长曲线</strong></p>
<ul>
<li>迟缓期</li>
<li><strong>对数（增殖）期</strong>：细菌形态、染色性、生理活性最典型</li>
<li>稳定期：产生抗生素、外毒素</li>
<li>衰亡期</li>
</ul>
<h2 id="细菌的遗传和变异">细菌的遗传和变异 <a class="markdownIt-Anchor" href="#细菌的遗传和变异">#</a></h2>
<p>噬菌体：见<a href="/2021/03/21/%E7%97%85%E6%AF%92/" title="病毒">病毒</a></p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>细菌感染的诊断与防治</title>
    <url>/2021/03/25/%E7%BB%86%E8%8F%8C%E6%84%9F%E6%9F%93%E7%9A%84%E8%AF%8A%E6%96%AD%E4%B8%8E%E9%98%B2%E6%B2%BB/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%A0%87%E6%9C%AC%E7%9A%84%E9%87%87%E9%9B%86%E4%B8%8E%E9%80%81%E6%A3%80">标本的采集与送检</a></li>
<li><a href="#%E7%97%85%E5%8E%9F%E8%8F%8C%E6%A3%80%E9%AA%8C%E7%A8%8B%E5%BA%8F">病原菌检验程序</a></li>
</ul>
</p>
<span id="more"></span>
<h2 id="标本的采集与送检">标本的采集与送检 <a class="markdownIt-Anchor" href="#标本的采集与送检">#</a></h2>
<p>六个原则</p>
<ol>
<li>避免杂菌污染</li>
<li>不同期不同标本</li>
<li>在使用抗菌物质前采集</li>
<li>标本必须新鲜</li>
<li>运送注意保存</li>
<li>采集病变明显部位/标本做好标记</li>
</ol>
<h2 id="病原菌检验程序">病原菌检验程序 <a class="markdownIt-Anchor" href="#病原菌检验程序">#</a></h2>
<ol>
<li>细菌形态学检查：直接染色（如革兰氏染色）涂片镜检</li>
<li>分离培养：平板三段划线法</li>
<li>生化实验：细菌的酶系统，代谢产物</li>
<li>血清学实验：抗原抗体杂交</li>
<li>动物实验</li>
<li>药物敏感试验：最低抑菌浓度、最低杀菌浓度，抑菌环大小</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>群体遗传学</title>
    <url>/2021/05/12/%E7%BE%A4%E4%BD%93%E9%81%97%E4%BC%A0%E5%AD%A6/</url>
    <content><![CDATA[<dl>
<dt>群体（population）</dt>
<dd>由位于同一地区的一群可以相互交配并可产生可育后代的个体组成。</dd>
</dl>
<span id="more"></span>
<h2 id="hardy-weinherg-平衡定律">Hardy-Weinherg 平衡定律 <a class="markdownIt-Anchor" href="#hardy-weinherg-平衡定律">#</a></h2>
<p>贝叶斯定律（Bayes’s 定律）</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(A_i|B) = \frac{P(B|A_i)P(A_i)}{\sum\limits^{n}_{i=1}P(B|A_i)P(A_i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6460660000000007em;vertical-align:-2.2190660000000006em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.1099999999999994em;"><span class="pstrut" style="height:3.3513970000000004em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.5813970000000004em;"><span class="pstrut" style="height:3.3513970000000004em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.028397em;"><span class="pstrut" style="height:3.3513970000000004em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.2190660000000006em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<dl>
<dt>Hardy-Weinherg 平衡定律</dt>
<dd>在一个大群体中，如果随机分配，没有突变，没有自然选择，没有大规模迁移及基因流，那么群体中的
<strong>基因频率</strong> 和 <strong>基因型频率</strong> 在一代代传递中保持不变。</dd>
</dl>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo separator="true">,</mo><mtext> </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>q</mi><mi>f</mi><mo stretchy="false">(</mo><mi>A</mi><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>p</mi><mn>2</mn></msup><mo separator="true">,</mo><mtext> </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>A</mi><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>p</mi><mi>q</mi><mo separator="true">,</mo><mtext> </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>q</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(A)=p,\ f(a)=q
f(AA)=p^2,\ f(Aa)=2pq,\ f(aa)=q^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Hardy-Weinherg 平衡的判定</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 11: X^2&lt;3.84\ &amp;̲&amp;\ P&gt;0.05
x^2 =…'>X^2&lt;3.84\ &amp;&amp;\ P&gt;0.05
x^2 = \sum\frac{(O-E)^2}{E}
</p>
<h2 id="影响遗传平衡的因素">影响遗传平衡的因素 <a class="markdownIt-Anchor" href="#影响遗传平衡的因素">#</a></h2>
<h3 id="非随机婚配">非随机婚配 <a class="markdownIt-Anchor" href="#非随机婚配">#</a></h3>
<h3 id="近亲婚配">近亲婚配 <a class="markdownIt-Anchor" href="#近亲婚配">#</a></h3>
<h3 id="突变">突变 <a class="markdownIt-Anchor" href="#突变">#</a></h3>
<h3 id="选择">选择 <a class="markdownIt-Anchor" href="#选择">#</a></h3>
<h3 id="遗传漂变">遗传漂变 <a class="markdownIt-Anchor" href="#遗传漂变">#</a></h3>
<h3 id="基因流">基因流 <a class="markdownIt-Anchor" href="#基因流">#</a></h3>
<h2 id="遗传负荷">遗传负荷 <a class="markdownIt-Anchor" href="#遗传负荷">#</a></h2>
<p>突变负荷</p>
<p>分离负荷</p>
<h2 id="遗传多态性">遗传多态性 <a class="markdownIt-Anchor" href="#遗传多态性">#</a></h2>
<ol>
<li><a href="#dna-%E5%A4%9A%E6%80%81%E6%80%A7">DNA 多态性</a></li>
<li><a href="#%E6%9F%93%E8%89%B2%E4%BD%93%E5%A4%9A%E6%80%81%E6%80%A7">染色体多态性</a></li>
<li>蛋白质多态性</li>
<li>酶多态性</li>
<li>抗原多态性</li>
</ol>
<h3 id="dna-多态性">DNA 多态性 <a class="markdownIt-Anchor" href="#dna-多态性">#</a></h3>
<dl>
<dt>遗传多态性</dt>
<dd>一个群体中存在由遗传决定的两种或两种以上的</dd>
</dl>
<ul>
<li>第一代：限制性片段多态性</li>
<li>第二代：可变数目串联重复</li>
<li>第三代：单核苷酸多态</li>
</ul>
<dl>
<dt>拷贝数变异（CNV）</dt>
<dd>由基因组发生重排二导致的，一般指长度为 1kb 以上的基因组大片段的拷贝数增加或减少，主要表现为亚显微水平的缺失或重复。</dd>
</dl>
<details class="note info"><summary><p>单体型</p>
</summary>

</details>
<h3 id="染色体多态性">染色体多态性 <a class="markdownIt-Anchor" href="#染色体多态性">#</a></h3>
<p>染色体多态性
:</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
      </tags>
  </entry>
  <entry>
    <title>肝炎病毒</title>
    <url>/2021/05/10/%E8%82%9D%E7%82%8E%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>病毒类型</th>
<th>核酸类型</th>
<th>传播途径</th>
<th>慢性肝炎</th>
<th>预后</th>
</tr>
</thead>
<tbody>
<tr>
<td><abbr title="甲型肝炎病毒">HAV</abbr></td>
<td>+ssRNA</td>
<td>粪-口途径</td>
<td>未见</td>
<td>急性感染，预后好</td>
</tr>
<tr>
<td><abbr title="乙型肝炎病毒">HBV</abbr></td>
<td>dsDNA</td>
<td>血液、医源性</td>
<td>常见</td>
<td></td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="甲型肝炎病毒">甲型肝炎病毒 <a class="markdownIt-Anchor" href="#甲型肝炎病毒">#</a></h2>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>抗原结构和分类：仅有一个血清型</li>
<li>抵抗力：极强，</li>
</ul>
<h3 id="致病性和免疫性">致病性和免疫性 <a class="markdownIt-Anchor" href="#致病性和免疫性">#</a></h3>
<h4 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h4>
<ul>
<li>传染源：患者和隐性感染者</li>
<li>传播方式：粪-口途径</li>
<li>所致疾病：甲肝（传染型肝炎，为自限性疾病）</li>
</ul>
<h4 id="免疫性">免疫性 <a class="markdownIt-Anchor" href="#免疫性">#</a></h4>
<p>感染后可获得持久性牢固免疫免疫。</p>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<p>血清学诊断</p>
<ul>
<li>IgM：早期感染诊断指标</li>
<li>IgG
<ul>
<li>急性肝炎恢复期后期</li>
<li>隐性感染</li>
<li>疫苗接种</li>
</ul>
</li>
</ul>
<h2 id="乙型肝炎病毒">乙型肝炎病毒 <a class="markdownIt-Anchor" href="#乙型肝炎病毒">#</a></h2>
<p>乙型肝炎（血清型肝炎）：慢性肝炎→肝硬化→肝癌</p>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<details class="note info"><summary><p>HBV 感染者血清中常见的颗粒类型及意义</p>
</summary>
<ol>
<li>大球形颗粒：即 <strong>Dane 颗粒</strong>，为完整的病毒体</li>
<li>小球形颗粒：HBV 增殖合成过剩的 HBsAg</li>
<li>管形颗粒：小球形颗粒的串联物，乙型肝炎病毒的 <strong>表面抗原</strong>（包膜上的糖蛋白）</li>
</ol>

</details>
<dl>
<dt>Dane 颗粒</dt>
<dd>即乙型肝炎病毒的病毒体。</dd>
</dl>
<ul>
<li>形态与染色：有双层衣壳：<strong>外衣壳</strong>（相当于包膜）、内衣壳
<ul>
<li>主蛋白：</li>
<li>中蛋白：</li>
<li>小抗原：</li>
</ul>
</li>
<li>抵抗力：强</li>
</ul>
<p>乙型肝炎病毒的表面抗原—— <abbr title="乙型肝炎病毒">HBV</abbr> S 抗原</p>
<p>乙型肝炎病毒基因组：双股不完全闭合 DNA</p>
<details class="note info"><summary><p>乙型肝炎病毒基因组的结构及其功能</p>
</summary>
<ol>
<li>S 区
<ul>
<li>S 基因包膜糖蛋白</li>
<li>HBsAg、PreS1Ag、PreS2Ag</li>
</ul>
</li>
<li>C 区
<ul>
<li>C 基因、PreC 基因</li>
<li>编码</li>
</ul>
</li>
<li>P 区
<ul>
<li>P 基因</li>
<li>编码</li>
</ul>
</li>
<li>X 区
<ul>
<li>X 基因</li>
<li>X 蛋白（HBxAg）</li>
</ul>
</li>
</ol>

</details>
<details class="note info"><summary><p>HBV 的三个重要抗原及其意义</p>
</summary>
<ol>
<li>S 抗原
<ul>
<li>adr/adw、ayr/ayw：a 为抗原决定簇</li>
<li>HBV 感染的重要标志</li>
</ul>
</li>
<li>C 抗原：肝细胞表面 CD8<sup>+</sup> T 细胞作用的靶抗原</li>
<li>HBeAg：消长与病毒体及 DNA 聚合酶的消长一致，可作为体内有 HBV 复制及血清具有强感染性的指标</li>
</ol>
<blockquote>
<p>HBxAg 抗原为致癌抗原，不作为临床血清学诊断。</p>
</blockquote>

</details>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="致病性-2">致病性 <a class="markdownIt-Anchor" href="#致病性-2">#</a></h4>
<details class="note info"><summary><p>HBV 的传染源及传播途径</p>
</summary>
<ul>
<li>传染源：乙肝患者和 HBsAg 阳性携带者</li>
<li>传播途径
<ol>
<li>血液及医源性传播</li>
<li>母婴传播（不引起先天畸形）</li>
<li>性传播</li>
</ol>
</li>
</ul>

</details>
<details class="note info"><summary><p>HBV 感染的常见临床表现类型</p>
</summary>
<ol>
<li>无症状携带者</li>
<li>急性肝炎：1% 黄疸性肝炎患者发生重症肝炎</li>
<li>慢性肝炎：5%~10% 的 HBV 感染者，其中 10% 转变为肝硬化，并继而发展为肝功能衰竭</li>
<li>原发性肝细胞癌：80% 归因于慢性肝炎</li>
</ol>
<blockquote>
<p>临床表现主要由肝细胞是否裂解决定。</p>
</blockquote>

</details>
<h4 id="免疫性-2">免疫性 <a class="markdownIt-Anchor" href="#免疫性-2">#</a></h4>
<ul>
<li>细胞免疫：CD8<sup>+</sup>T 细胞</li>
<li>体液免疫：</li>
</ul>
<h3 id="微生物学检查-2">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查-2">#</a></h3>
<details class="note info"><summary><p>HBV 感染的血清学检测指标及意义</p>
</summary>
<p>两对半抗原抗体检测指标（肝炎五项）</p>
<ol>
<li>乙肝表面抗原：乙肝病毒抗原感染，肝功能正常表示为无症状携带者</li>
<li>乙肝表面抗体：隐性感染者、急性感染恢复期、疫苗接种者</li>
<li>乙肝 e 抗原：传染性强</li>
<li>乙肝 e 抗体：恢复阶段，预后良好</li>
<li>乙肝核心抗原：处于<strong>窗口期</strong>（传染性强）或既往感染过</li>
</ol>

</details>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
<ol>
<li>乙型肝炎病毒基因工程疫苗</li>
<li>抗体</li>
</ol>
<h2 id="丙型肝炎病毒">丙型肝炎病毒 <a class="markdownIt-Anchor" href="#丙型肝炎病毒">#</a></h2>
<h3 id="生物学特性-3">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-3">#</a></h3>
<p>RNA 有包膜病毒</p>
<h3 id="致病性与免疫性-2">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-2">#</a></h3>
<h4 id="致病性-3">致病性 <a class="markdownIt-Anchor" href="#致病性-3">#</a></h4>
<p>丙肝又称 <strong>输血型肝炎</strong>，传播途径同 <a href="#%E4%B9%99%E5%9E%8B%E8%82%9D%E7%82%8E%E7%97%85%E6%AF%92">乙型肝炎病毒</a>。</p>
<h4 id="免疫性-3">免疫性 <a class="markdownIt-Anchor" href="#免疫性-3">#</a></h4>
<p>病毒包膜抗原容易变异，免疫力不牢固。</p>
<h2 id="丁型肝炎病毒">丁型肝炎病毒 <a class="markdownIt-Anchor" href="#丁型肝炎病毒">#</a></h2>
<dl>
<dt>丁型肝炎病毒</dt>
<dd>RNA 有包膜病毒，自身缺乏合成包膜的基因（即为缺陷病毒），其包膜由 <abbr title="乙型肝炎病毒">HBV</abbr>（即其辅助病毒）提供。</dd>
</dl>
<h2 id="戊型肝炎病毒">戊型肝炎病毒 <a class="markdownIt-Anchor" href="#戊型肝炎病毒">#</a></h2>
<p>RNA 无包膜</p>
<h3 id="致病性-4">致病性 <a class="markdownIt-Anchor" href="#致病性-4">#</a></h3>
<ul>
<li>传播途径：粪-口途径</li>
<li>所致疾病：戊型肝炎（人兽共患）</li>
</ul>
<h3 id="微生物学检查-3">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查-3">#</a></h3>
<p>检测抗 HEVIgM 抗体</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>胚胎学</title>
    <url>/2021/05/26/%E8%83%9A%E8%83%8E%E5%AD%A6/</url>
    <content><![CDATA[<dl>
<dt>胚胎学（embryology）</dt>
<dd>研究个体发生、发育及其机制的科学。</dd>
<dd>研究内容包括生殖细胞的形成、受精胚胎早期发育、器官与系统的发生、胚胎与母体的关系、先天性畸形、环境因素对胚胎发育的影响等。</dd>
</dl>
<span id="more"></span>
<ul>
<li><a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/">人胚发生和早期发育</a></li>
<li><a href="/2021/05/27/%E9%A2%9C%E9%9D%A2%E3%80%81%E9%A2%88%E5%92%8C%E5%9B%9B%E8%82%A2%E7%9A%84%E5%8F%91%E7%94%9F/">颜面、颈和四肢的发生</a></li>
<li><a href="/2021/05/29/%E6%B6%88%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%91%BC%E5%90%B8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/">消化系统和呼吸系统的发生</a>，<a href="/2021/05/29/%E5%BF%83%E8%A1%80%E7%AE%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/">心血管系统的发生</a></li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
        <category>组织学与胚胎学</category>
        <category>胚胎学</category>
      </categories>
      <tags>
        <tag>Index</tag>
        <tag>人类发育与遗传学</tag>
        <tag>组织学与胚胎学</tag>
        <tag>胚胎学</tag>
      </tags>
  </entry>
  <entry>
    <title>自制伪终端</title>
    <url>/2021/04/12/%E8%87%AA%E5%88%B6%E4%BC%AA%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<p>参见：<a href="/2021/03/15/The-TTY-Demystified/">The TTY Demystified</a></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Projects</category>
        <category>Softwares</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Index</tag>
        <tag>TTY</tag>
      </tags>
  </entry>
  <entry>
    <title>虫媒病毒和出血热病毒</title>
    <url>/2021/05/13/%E8%99%AB%E5%AA%92%E7%97%85%E6%AF%92%E5%92%8C%E5%87%BA%E8%A1%80%E7%83%AD%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<dl>
<dt>虫媒病毒</dt>
<dd>通过</dd>
</dl>
<span id="more"></span>
<details class="note info"><summary><p>虫媒病毒共同特点</p>
</summary>
<ol>
<li>均为 RNA 有包膜病毒，包膜表面由血凝素</li>
</ol>

</details>
<h2 id="流行性乙型脑炎病毒">流行性乙型脑炎病毒 <a class="markdownIt-Anchor" href="#流行性乙型脑炎病毒">#</a></h2>
<p>流行性乙型脑炎病毒 | 乙脑病毒</p>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<ul>
<li>形态与染色</li>
<li>抗原结构和分类</li>
<li>抵抗力</li>
<li>培养特性和生化反应</li>
</ul>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<ul>
<li>传播媒介：三带喙库蚊，也是长期储存宿主</li>
<li>传染源：猪，尤其是幼猪，病毒滴度高</li>
</ul>
<p>感染后可获得牢固免疫力</p>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
<ul>
<li>诊断：</li>
<li>预防：</li>
<li>疫苗：灭活疫苗</li>
</ul>
<h2 id="登革病毒">登革病毒 <a class="markdownIt-Anchor" href="#登革病毒">#</a></h2>
<p>登革病毒 | 登革热病毒</p>
<h3 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h3>
<p>传播途径：伊蚊</p>
<dl>
<dt>登革热</dt>
<dd>可自愈性的轻度症状，发热、头痛、肌肉和关节酸痛。</dd>
<dt>登革出血症 | 登革休克综合征</dt>
<dd>症状重，登革热的症状以及皮肤症状、休克。</dd>
</dl>
<h3 id="防治原则-2">防治原则 <a class="markdownIt-Anchor" href="#防治原则-2">#</a></h3>
<p>疫苗尚未研究成功</p>
<h2 id="寨卡病毒">寨卡病毒 <a class="markdownIt-Anchor" href="#寨卡病毒">#</a></h2>
<p>传播媒介：伊蚊</p>
<p>孕妇感染可致新生儿小头畸形</p>
<h2 id="汉坦病毒">汉坦病毒 <a class="markdownIt-Anchor" href="#汉坦病毒">#</a></h2>
<dl>
<dt>汉坦病毒</dt>
<dd>流行性出血热/肾病综合征的病原体</dd>
</dl>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<ul>
<li>形态与结构：分节段 RNA，有包膜</li>
</ul>
<details class="note info"><summary><p>汉坦病毒的核酸片段与功能</p>
</summary>
<ol>
<li>L（large）片段：编码 RNA 聚合酶</li>
<li>M（middle）片段：糖蛋白</li>
<li>S（small）片段：核蛋白</li>
</ol>

</details>
<ul>
<li>抗原结构和分型：分为 6 个血清型，我国流行两个型：
<ul>
<li>Ⅰ 型（黑线姬鼠型）</li>
<li>Ⅱ 型（家鼠或大鼠型）</li>
</ul>
</li>
</ul>
<h3 id="致病性与免疫性-2">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-2">#</a></h3>
<details class="note info"><summary><p>汉坦病毒的传染源及传播途径</p>
</summary>
<ul>
<li>传染源：多种啮齿动物（姬鼠、田鼠）</li>
<li>传播途径
<ul>
<li>动物源性传播：消化道、呼吸道、破碎皮肤黏膜</li>
<li>母婴传播</li>
<li>虫媒传播</li>
</ul>
</li>
</ul>

</details>
<p>所致疾病</p>
<ul>
<li><strong>肾病综合征</strong>（HFRS）：出血现象和肾损害</li>
<li>汉坦病毒肺综合征（HPS）：病死率高</li>
</ul>
<p>肾病综合征</p>
<ol>
<li>出血现象</li>
<li>肾损害</li>
</ol>
<ul>
<li>病后可获得较强的免疫力，以抗体为主</li>
<li>疫苗：<strong>双价灭活疫苗</strong></li>
</ul>
<h2 id="埃博拉病毒">埃博拉病毒 <a class="markdownIt-Anchor" href="#埃博拉病毒">#</a></h2>
<h3 id="生物学特性-3">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-3">#</a></h3>
<p>RNA，有包膜，呈长丝状体</p>
<h3 id="致病性-2">致病性 <a class="markdownIt-Anchor" href="#致病性-2">#</a></h3>
<p><strong>埃博拉出血热</strong>，病死率高</p>
<h3 id="防治原则-3">防治原则 <a class="markdownIt-Anchor" href="#防治原则-3">#</a></h3>
<p>尚无有效治疗方法和疫苗</p>
<h2 id="克里米亚-刚果出血热病毒">克里米亚-刚果出血热病毒 <a class="markdownIt-Anchor" href="#克里米亚-刚果出血热病毒">#</a></h2>
<p>又称新疆出血热病毒</p>
<h3 id="致病性-3">致病性 <a class="markdownIt-Anchor" href="#致病性-3">#</a></h3>
<ul>
<li>传染源：</li>
<li>传播途径：虫媒传播——蜱</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋体</title>
    <url>/2021/04/15/%E8%9E%BA%E6%97%8B%E4%BD%93/</url>
    <content><![CDATA[<dl>
<dt>螺旋体（spirochete）</dt>
<dd>细长、<strong>柔软</strong>、螺旋状、运动活泼的<a href="/2021/03/16/%E7%97%85%E5%8E%9F%E7%94%9F%E7%89%A9%E5%AD%A6/#微生物">原核细胞型微生物</a>。</dd>
<dd>基本结构与细菌相似，如有细胞壁、原始核质，以二分裂方式繁殖和对抗生素等药物敏感等。</dd>
</dl>
<p>对人致病的有三属：</p>
<ul>
<li>钩端螺旋体科
<ul>
<li><a href="#%E9%92%A9%E7%AB%AF%E8%9E%BA%E6%97%8B%E4%BD%93%E5%B1%9E">钩端螺旋体属</a>：螺旋多、规律、细密，<strong>两端（或一端）钩状</strong>：问号钩端螺旋体</li>
</ul>
</li>
<li>螺旋体科
<ul>
<li>密螺旋体属：螺旋 8~14 个、规律、细密，<strong>两端尖</strong>：<a href="#%E6%A2%85%E6%AF%92%E8%9E%BA%E6%97%8B%E4%BD%93">梅毒螺旋体</a></li>
<li><a href="#%E4%BC%AF%E6%B0%8F%E7%96%8F%E8%9E%BA%E6%97%8B%E4%BD%93">疏螺旋体属</a>：螺旋 3~10 个、不规则：<a href="#%E4%BC%AF%E6%B0%8F%E7%96%8F%E8%9E%BA%E6%97%8B%E4%BD%93">伯氏疏螺旋体</a>、<a href="#%E5%9B%9E%E5%BD%92%E7%83%AD%E7%96%8F%E8%9E%BA%E6%97%8B%E4%BD%93">回归热疏螺旋体</a></li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="钩端螺旋体属">钩端螺旋体属 <a class="markdownIt-Anchor" href="#钩端螺旋体属">#</a></h2>
<p><strong>钩端螺旋体属</strong></p>
<ul>
<li><strong>问号钩端螺旋体</strong>（<em>L. interrogans</em>）：<strong>钩端螺旋体病</strong>（leptospirosis），为人畜共患病</li>
<li>双曲钩端螺旋体（<em>L. biflexa</em>）：一般为非致病性腐生微生物</li>
</ul>
<h3 id="生物学特性">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性">#</a></h3>
<p>形态与染色</p>
<ul>
<li>形态如前所述</li>
<li>革兰氏染色阴性，不易着色</li>
<li>镀银染色效果好，菌体染成棕褐色</li>
</ul>
<p>抵抗力弱</p>
<ul>
<li>对热、消毒剂、青霉素敏感</li>
<li>在<strong>湿土或水</strong>中可存活数月</li>
</ul>
<h3 id="致病性与免疫性">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性">#</a></h3>
<h4 id="所致疾病">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病">#</a></h4>
<dl>
<dt>钩端螺旋体病（leptospirosis）</dt>
<dd>人畜共患病，主要通过感染的<mark>啮齿动物</mark>和<mark>家畜（猪）<mark>的尿液经过破损的皮肤或完整的粘膜进入人体，也可经胎盘</mark>垂直传播</mark>。</dd>
</dl>
<h4 id="免疫性">免疫性 <a class="markdownIt-Anchor" href="#免疫性">#</a></h4>
<p>疾病后可获得抗同型钩体的持久免疫力。</p>
<h2 id="梅毒螺旋体">梅毒螺旋体 <a class="markdownIt-Anchor" href="#梅毒螺旋体">#</a></h2>
<dl>
<dt>梅毒螺旋体（Treponema pallidum）| 苍白密螺旋体苍白亚种</dt>
<dd>引起人类<strong>梅毒</strong>（syphilis）的病原体。</dd>
</dl>
<h3 id="生物学特性-2">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-2">#</a></h3>
<ul>
<li>形态与染色：同<a href="#%E9%92%A9%E7%AB%AF%E8%9E%BA%E6%97%8B%E4%BD%93%E5%B1%9E">钩端螺旋体属</a></li>
<li>抵抗力：极弱，与<a href="#%E9%92%A9%E7%AB%AF%E8%9E%BA%E6%97%8B%E4%BD%93%E5%B1%9E">钩端螺旋体属</a>类似</li>
<li>培养特性和生化反应
<ul>
<li>不能在无活细胞的人工培养基中生长繁殖</li>
<li>在家免上皮细胞培养中能有限生长，繁殖慢</li>
</ul>
</li>
</ul>
<h3 id="致病性与免疫性-2">致病性与免疫性 <a class="markdownIt-Anchor" href="#致病性与免疫性-2">#</a></h3>
<h4 id="所致疾病-2">所致疾病 <a class="markdownIt-Anchor" href="#所致疾病-2">#</a></h4>
<dl>
<dt>梅毒</dt>
<dd>人是梅毒的唯一传染源。</dd>
<dd>根据感染方式分为两类：
<ul>
<li><strong>先天性梅毒</strong>：母体通过胎盘垂直传播给婴儿</li>
<li><strong>后天性梅毒</strong>（获得性梅毒）：性接触传播</li>
</ul>
</dd>
</dl>
<details class="note info"><summary><p>获得性梅毒</p>
</summary>
<ul>
<li>早期梅毒：此时治疗效果好
<ul>
<li><strong>Ⅰ 期梅毒</strong></li>
<li><strong>Ⅱ 期梅毒</strong></li>
</ul>
</li>
<li>晚期梅毒——<strong>Ⅲ 期梅毒</strong></li>
</ul>
<p><strong>Ⅰ 期梅毒</strong></p>
<ul>
<li>感染性极强，破坏性小</li>
<li>感染后 3 周，出现<mark>无痛性硬下疳</mark>，常自愈</li>
</ul>
<p><strong>Ⅱ 期梅毒</strong></p>
<ul>
<li>感染性强，破坏性小</li>
<li>出现<mark>梅毒疹</mark></li>
</ul>
<p><strong>Ⅲ 期梅毒</strong></p>
<ul>
<li>感染性小，破坏性大，可危及生命</li>
<li>发生于感染 2 年以后，亦可长达 10~15 年</li>
</ul>

</details>
<details class="note info"><summary><p>先天性梅毒</p>
</summary>
<dl>
<dt>先天性梅毒 | 胎传梅毒</dt>
<dd>多发生于妊娠 4 个月之后。引起胎儿的全身性感染，导致流产、早产或死胎；</dd>
<dd>出生梅毒儿呈现马鞍鼻、锯齿形牙、间质性角膜炎、先天性耳联等特殊体征。</dd>
</dl>

</details>
<h4 id="免疫性-2">免疫性 <a class="markdownIt-Anchor" href="#免疫性-2">#</a></h4>
<p>为<strong>感染性免疫</strong>（带菌免疫）：有菌体感染时才有免疫力</p>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<p>标本</p>
<ul>
<li>Ⅰ 期梅毒：硬下疳渗出液</li>
<li>Ⅱ 期梅毒：梅毒痉渗出液或局部淋巴结抽出液</li>
</ul>
<p>血清学诊断</p>
<ul>
<li>非特异性——非密螺旋体抗原试验：适用于大量过筛</li>
<li>特异性——密螺旋体抗原试验：特异性强，可用作梅毒证实试验</li>
</ul>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
<p>确诊后使用<strong>青霉素</strong>（首选）等药物及早彻底治疗。</p>
<h2 id="伯氏疏螺旋体">伯氏疏螺旋体 <a class="markdownIt-Anchor" href="#伯氏疏螺旋体">#</a></h2>
<dl>
<dt>伯氏疏螺旋体（<em>B. burgdorefri</em>）</dt>
<dd><strong>莱姆病</strong>病原体存在异质性，分类尚未统一，目前将伯氏疏螺旋体作为<strong>莱姆病</strong>病原体的统称。</dd>
</dl>
<details class="note info"><summary><p>疏螺旋菌体属</p>
</summary>
<dl>
<dt>疏螺旋菌体属（Borrelia）| 包柔螺旋菌体属</dt>
<dd>有 3~10 个稀疏而不规则的螺旋，呈波状。</dd>
<dd>对人体致病的主要有<a href="#%E4%BC%AF%E6%B0%8F%E7%96%8F%E8%9E%BA%E6%97%8B%E4%BD%93"><strong>伯氏疏螺旋体</strong></a>和<a href="#%E5%9B%9E%E5%BD%92%E7%83%AD%E7%96%8F%E8%9E%BA%E6%97%8B%E4%BD%93"><strong>回归热疏螺旋体</strong></a>，它们均通过<strong>吸血昆虫</strong>传播，分别致<strong>莱姆病</strong>和<strong>回归热</strong>。</dd>
</dl>

</details>
<h3 id="生物学特性-3">生物学特性 <a class="markdownIt-Anchor" href="#生物学特性-3">#</a></h3>
<ul>
<li>形态：疏螺旋体，两端稍尖，运动活泼</li>
<li>抵抗力</li>
<li>培养特性和生化反应</li>
</ul>
<h3 id="致病性">致病性 <a class="markdownIt-Anchor" href="#致病性">#</a></h3>
<dl>
<dt>莱姆病（Lyme disease）</dt>
<dd>一种自然疫源性传染病，储存宿主主要是野生和驯养的哺乳动物。</dd>
<dd>主要传播媒介是<mark>硬蜱</mark>。</dd>
</dl>
<p>致病物质</p>
<ul>
<li>侵袭力：黏附素等</li>
<li>内毒素</li>
</ul>
<p>临床表现</p>
<ul>
<li>早期局部性感染：经 3~30 天潜伏期，出现<strong>皮肤慢性游走性红斑</strong>（erythema chronicum migrans, ECM）</li>
<li>早期播散性感染：继发性红斑、面神经麻痹、脑膜炎</li>
<li>晚期持续性感染：慢性关节炎、周围神经炎、慢性萎缩性匹炎</li>
</ul>
<h2 id="回归热疏螺旋体">回归热疏螺旋体 <a class="markdownIt-Anchor" href="#回归热疏螺旋体">#</a></h2>
<dl>
<dt>回归热疏螺旋体（<em>B. recurrentis</em>）</dt>
<dd><strong>回归热</strong>的主要病原体，可引起<strong>虱传回归热</strong>（流行性回归热）。</dd>
<dt>回归热（relapsing fever）</dt>
<dd>由多种疏螺旋体引起的急性传染病。其临床特点为急起急退的高热，全身肌肉酸痛，1 次或多次复发，肝、脾肿大，重症可出现黄疸和出血倾向。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>衣原体</title>
    <url>/2021/04/19/%E8%A1%A3%E5%8E%9F%E4%BD%93/</url>
    <content><![CDATA[<dl>
<dt>包涵体（inclusion body）</dt>
<dd>某些病毒也能形成包涵体，见<a href="/2021/04/23/%E7%97%85%E6%AF%92%E7%9A%84%E6%84%9F%E6%9F%93%E4%B8%8E%E6%8A%97%E7%97%85%E6%AF%92%E5%85%8D%E7%96%AB/#病毒的致病机制">病毒的致病机制</a>。</dd>
</dl>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>补体系统</title>
    <url>/2021/05/17/%E8%A1%A5%E4%BD%93%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<dl>
<dt>补体系统（complement system）| 补体级联反应（complement cascade）</dt>
<dd>是先天免疫系统的一部分，由存在于 <strong>人和脊椎动物血清、组织液中及细包膜表面</strong> 的一种
<strong>活化后具有酶活性的蛋白质</strong>（补体固有成分）、调节蛋白和补体受体组成。</dd>
<dd>可增强抗体和吞噬细胞清除机体中的病原微生物和损伤细胞的能力，增强炎症反应，并攻击病原体的细胞膜。</dd>
</dl>
<span id="more"></span>
<h2 id="补体的组成和生物学特性">补体的组成和生物学特性 <a class="markdownIt-Anchor" href="#补体的组成和生物学特性">#</a></h2>
<h3 id="补体系统的组成">补体系统的组成 <a class="markdownIt-Anchor" href="#补体系统的组成">#</a></h3>
<dl>
<dt>补体固有成分</dt>
<dd>存在于血浆及体液中，参与补体激活的蛋白质，包括：
<ol>
<li>经典途径：C1q、C1r、C1s、C2、C4</li>
<li>旁路途径：B 因子、D 因子、P 因子（properdin，备解素）、I 因子</li>
<li>凝集素途径：<abbr title="甘露醇结合凝集素（mannose-binging lectin）">MBL</abbr>/<abbr title="纤维胶原素（ficolin）">FCN</abbr>、<abbr title="甘露醇结合凝集素（mannose-binging lectin）">MBL</abbr> 相关丝氨酸蛋白酶（<abbr title="MBL 相关丝氨酸蛋白酶">MASP</abbr>）</li>
<li>共同成分：C3、C5、C6、C7、C8、C9</li>
</ol>
</dd>
</dl>
<dl>
<dt>补体调节蛋白（complement regulatory protein）</dt>
<dd>存在于血浆和细胞膜表面、通过调节补体激活途径中关键酶而控制补体活化强度和范围的蛋白质。</dd>
<dd>包括 C1 抑制剂、I 因子、H 因子、D 因子、C4 结合蛋白等。</dd>
<dt>补体受体（complement receptor，<abbr title="补体受体（complement receptor）">CR</abbr>）</dt>
<dd>存在于细包膜表面，能够与补体活化后所形成的活性片段相结合，介导多种生物效应的受体分子。</dd>
<dd>包括 CR1~5、C3aR、C2aR、C4aR 等。</dd>
</dl>
<h3 id="补体的理化性质">补体的理化性质 <a class="markdownIt-Anchor" href="#补体的理化性质">#</a></h3>
<p>补体系统各成分均为 <strong>糖蛋白</strong>，但有不同的肽链结构。<br/>
<strong>补体固有成分对热不稳定</strong>，56℃，30min 灭活，应保存在 -20℃ 以下；紫外线照射和机械振荡可使补体失活。<br/>
正常生理情况下，以非活化形式存在。<br/>
血清中 C3 含量最多，D 因子最少。</p>
<h3 id="补体的代谢">补体的代谢 <a class="markdownIt-Anchor" href="#补体的代谢">#</a></h3>
<ol>
<li>来源
<ul>
<li>肝细胞：血浆中大部份补体；</li>
<li>巨噬细胞：在不同组织中，尤其是炎症灶中，巨噬细胞是补体的主要来源。</li>
</ul>
</li>
<li>生物合成的调节
<ul>
<li>补体基因表达存在组织特异性：如家族性 C3 缺乏综合征患者肝细胞产生的 C3 含量减少，但巨噬细胞产生的 C3 可超正常水平。</li>
<li>补体的合成受多种因素的影响</li>
</ul>
</li>
<li>分解代谢：代谢率快，每天约有一般更新。</li>
</ol>
<h2 id="补体激活途径">补体激活途径 <a class="markdownIt-Anchor" href="#补体激活途径">#</a></h2>
<dl>
<dt>补体激活</dt>
<dd>补体从酶原状态转化为具有酶活性状态的过程。</dd>
<dd>根据 <strong>激活物</strong> 的不同，可将补体激活途径分为 <strong>经典途径</strong>、<strong><abbr title="甘露醇结合凝集素（mannose-binging lectin）">MBL</abbr> 途径</strong> 和 <strong>旁路途径</strong>。</dd>
</dl>
<p>三种激活途径中从 C3 转化酶形成开始，之后的过程基本相同。</p>
<img data-src="/2021/05/17/%E8%A1%A5%E4%BD%93%E7%B3%BB%E7%BB%9F/%E8%A1%A5%E4%BD%93%E6%BF%80%E6%B4%BB%E9%80%94%E5%BE%84%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9.svg" class="" title="补体激活途径的共同点" alt="补体激活途径的共同点">
<p>TODO: 三种激活途径的示意图</p>
<h3 id="经典途径">经典途径 <a class="markdownIt-Anchor" href="#经典途径">#</a></h3>
<ol>
<li>激活物：抗原-抗体复合物（IgG 或 IgM）</li>
<li>参与成分：见 <a href="#%E8%A1%A5%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90">补体系统的组成</a></li>
<li>激活过程
<ol>
<li>识别阶段：C1q 与两个以上 Fc 段结合 → 活化 C1r → 激活 C1s → 形成 <strong>C1 脂酶（C1 复合物）</strong>（C1qr<sub>2</sub>s<sub>2</sub>）</li>
<li>活化阶段：<strong>C3 转化酶</strong>（C4b2a）形成；<strong>C5 转化酶</strong>（C4b2a3b）形成</li>
<li>膜攻击阶段：<abbr title="膜攻击复合物">MAC</abbr>（C5b6789<sub>n</sub>）</li>
</ol>
</li>
<li>效应特点：在感染后期或再次感染中发挥作用</li>
</ol>
<p>TODO: C3 转化酶和 C5 转换酶的的形成图示</p>
<h3 id="mbl-途径"><abbr title="甘露醇结合凝集素（mannose-binging lectin）">MBL</abbr> 途径 <a class="markdownIt-Anchor" href="#mbl-途径">#</a></h3>
<ol>
<li>激活物：微生物表面的糖结构</li>
<li>参与成分：见 <a href="#%E8%A1%A5%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90">补体系统的组成</a>，<abbr title="甘露醇结合凝集素（mannose-binging lectin）">MBL</abbr> 或 <abbr title="纤维胶原素（ficolin）">FCN</abbr> 和 <abbr title="MBL 相关丝氨酸蛋白酶">MASP</abbr>-1、<abbr title="MBL 相关丝氨酸蛋白酶">MASP</abbr>-2
各两个结合形成 <abbr title="甘露醇结合凝集素（mannose-binging lectin）">MBL</abbr>-<abbr title="MBL 相关丝氨酸蛋白酶">MASP</abbr> 或 <abbr title="纤维胶原素（ficolin）">FCN</abbr>-<abbr title="MBL 相关丝氨酸蛋白酶">MASP</abbr> 复合物，相当于经典途径中的 C1 脂酶</li>
<li>激活过程：除了以 <abbr title="甘露醇结合凝集素（mannose-binging lectin）">MBL</abbr>-<abbr title="MBL 相关丝氨酸蛋白酶">MASP</abbr> 或 <abbr title="纤维胶原素（ficolin）">FCN</abbr>-<abbr title="MBL 相关丝氨酸蛋白酶">MASP</abbr> 复合物 取代 C1 脂酶外，均与经典途径一致</li>
<li>效应特点：在感染早期或初次感染中发挥作用</li>
</ol>
<h3 id="旁路途径">旁路途径 <a class="markdownIt-Anchor" href="#旁路途径">#</a></h3>
<p>又称 <strong>替代途径</strong>，其不依赖抗体，而是由微生物或外源异物直接激活
C3，在多种辅助因子的参与下激活补体。</p>
<ol>
<li>激活物：细菌、真菌或病毒感染的细胞（或聚合 IgA、IgG4）</li>
<li>参与成分：见 <a href="#%E8%A1%A5%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90">补体系统的组成</a></li>
<li>激活过程
<ol>
<li>准备阶段：旁路途径 C3 转化酶（C3bBb）形成</li>
<li>激活阶段：膜表面结构保护 C3b，C3 转化酶（C3bBb）、C5 转化酶（C3bBb3b）形成</li>
<li><strong>正反馈环路</strong>：C3 被裂解后与 B 因子形成更多的低浓度 C3 转化酶</li>
</ol>
</li>
<li>效应特点：在感染早期或初次感染即可发挥作用</li>
</ol>
<p><strong>备解素</strong>（P 因子）可结合细菌表面，稳定 C3b 与 Bb 结合形成 C3 转化酶，防止其被降解。</p>
<h2 id="补体激活的调节">补体激活的调节 <a class="markdownIt-Anchor" href="#补体激活的调节">#</a></h2>
<ol>
<li>针对经典途径前端反应的调节机制
<ul>
<li>主要抑制 <strong>C3 转化酶 C4a2b</strong>（或 C5 转化酶 C4a2b3b）的形成以及抑制以形成的 C3 转化酶</li>
<li><strong>C1INH</strong>（C1 抑制物）、CR1、C4bp、膜辅蛋白（MCP）、I 因子、衰变加速因子（DAF）</li>
</ul>
</li>
<li>针对旁路途径前端反应的调节机制
<ul>
<li>主要抑制 <strong>C3 转化酶 C3aBb</strong>（或 C5 转化酶 C3bBb3b）的形成及抑制其活性</li>
<li>P 因子起正调节作用</li>
</ul>
</li>
<li>针对 <abbr title="膜攻击复合物">MAC</abbr> 的调节机制
<ul>
<li>主要是抑制 <strong><abbr title="膜攻击复合物">MAC</abbr></strong> 的形成和活性</li>
<li>膜反应性溶破抑制物（MIRL）、同源限制因子（HRF）/C8 结合蛋白（C8bp）、S 蛋白（SP）、群集素</li>
</ul>
</li>
</ol>
<blockquote>
<p>某些病原微生物也可以产生一些物质抑制补体活化。</p>
</blockquote>
<h2 id="补体的生物学意义">补体的生物学意义 <a class="markdownIt-Anchor" href="#补体的生物学意义">#</a></h2>
<h3 id="补体的生物学功能">补体的生物学功能 <a class="markdownIt-Anchor" href="#补体的生物学功能">#</a></h3>
<ol>
<li>细胞毒作用：<abbr title="膜攻击复合物">MAC</abbr> 攻击靶细胞（主要是 G<sup>-</sup> 菌），致细胞溶破</li>
<li>调理作用：C3b、C4b、iC3b 和抗体与细菌或颗粒物质结合，分别结合于
<strong>吞噬细胞</strong> 表面的 <abbr title="补体受体（complement receptor）">CR</abbr> 和 FcR，促进吞噬细胞的吞噬作用。</li>
<li>炎症介质作用
<ol>
<li>过敏毒素作用：C5a、C3a、C4a，与肥大细胞或嗜碱性粒细胞结合，使其释放活性物质，导致过敏性病理变化</li>
<li>趋化作用：C5a、C3a、C4a、C5b67，使吞噬细胞向感染部位聚集，引发炎症反应</li>
<li>激肽样作用：C2a 能增强血管的通透性，引起炎症渗出和水肿</li>
</ol>
</li>
<li>清除免疫复合物：<strong>免疫黏附</strong></li>
</ol>
<dl>
<dt>免疫黏附（immune adherence）</dt>
<dd><strong>C3b</strong> 与<strong>免疫复合物</strong>（immune complex，IC）（抗原-抗体复合物）结合，黏附于
<strong>红细胞</strong> 或 <strong>血小板</strong>，到达肝脏或脾脏被巨噬细胞吞噬、清除。</dd>
</dl>
<h3 id="补体的病理生理学意义">补体的病理生理学意义 <a class="markdownIt-Anchor" href="#补体的病理生理学意义">#</a></h3>
<ol>
<li>是机体抗感染防御的主要机制</li>
<li>参与适应性免疫应答（调理作用和的趋化作用）</li>
<li>与血液中其他级联反应系统相互作用：与体内凝血系统、纤溶系统、激肽系统关系密切</li>
</ol>
<h2 id="补体与疾病的关系">补体与疾病的关系 <a class="markdownIt-Anchor" href="#补体与疾病的关系">#</a></h2>
<ol>
<li>遗传性补体缺陷相关疾病：C1INH（见 <a href="#%E8%A1%A5%E4%BD%93%E6%BF%80%E6%B4%BB%E7%9A%84%E8%B0%83%E8%8A%82">补体激活的调节</a>）缺乏可引起 <strong>遗传性血管神经性水肿</strong>（HAE）</li>
<li>感染性疾病</li>
<li>炎症性疾病</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>医学免疫学</category>
      </categories>
      <tags>
        <tag>医学免疫学</tag>
      </tags>
  </entry>
  <entry>
    <title>逆转录病毒</title>
    <url>/2021/05/20/%E9%80%86%E8%BD%AC%E5%BD%95%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<span id="more"></span>
<p>HIV 感染的过程及其特点</p>
<ol>
<li><strong>HIV 感染急性期</strong>：</li>
<li><strong>潜伏期</strong>：</li>
<li><strong>艾滋病相关综合征</strong>：</li>
<li><strong>典型 AIDS 期</strong>：</li>
</ol>
<p>典型 AIDS 期的基本特征</p>
<ol>
<li>CD44<sup>+</sup>T 细胞严重下降</li>
<li>严重机会性感染</li>
<li>机会性肿瘤，卡波西（kaposi）肉瘤、恶性淋巴瘤</li>
<li>全身症状加重或神经系统疾患</li>
</ol>
<p>常见机会性感染的病原体，如</p>
<ol>
<li>细菌：结核杆菌</li>
<li>病毒：巨细胞病毒、HBV</li>
<li>真菌：真菌肺胞子菌</li>
<li>寄生虫：弓形虫、眼孢子虫</li>
</ol>
<h3 id="微生物学检查">微生物学检查 <a class="markdownIt-Anchor" href="#微生物学检查">#</a></h3>
<ol>
<li>初筛：用 ELISA 法对抗抗体</li>
<li>确诊：免疫印记实验</li>
</ol>
<h3 id="防治原则">防治原则 <a class="markdownIt-Anchor" href="#防治原则">#</a></h3>
<p>临床上常采用 <strong>高效抗逆转录病毒治疗</strong>（“鸡尾酒疗法”，即多种抗病毒药物联合治疗。</p>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>病原生物学</category>
      </categories>
      <tags>
        <tag>病原生物学</tag>
        <tag>病毒学</tag>
      </tags>
  </entry>
  <entry>
    <title>配子的发生与受精</title>
    <url>/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/</url>
    <content><![CDATA[<p>配子（生殖细胞）发生的主要时相：</p>
<ol>
<li>生殖细胞的起源（<strong>卵黄囊</strong>）及其迁徙至性腺；</li>
<li>性腺中生殖细胞通过 <strong>有丝分裂</strong> 过程进行增殖；</li>
<li>通过 <strong>减数分裂</strong> 将染色体数目减少一半；</li>
<li>配子 <strong>成熟和分化</strong> 成为精子和卵子。</li>
</ol>
<span id="more"></span>
<h2 id="减数分裂">减数分裂 <a class="markdownIt-Anchor" href="#减数分裂">#</a></h2>
<p>减数分裂（meiosis）</p>
<ul>
<li>第一次减数分裂（Ⅰ）：<strong>同源染色体</strong> 分离
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%8F%E6%95%B0%E5%88%86%E8%A3%82%E5%89%8D%E6%9C%9F">第一次减数分裂前期</a>（prophase of meiosis Ⅰ）/ 前期 Ⅰ（prophase I）</li>
<li>第一次减数分裂中期（metaphase of meiosis Ⅰ）/ 中期 Ⅰ（metaphase I）</li>
<li>第一次减数分裂后期（anaphase of meiosis Ⅰ） / 后期 Ⅰ（anaphase I）</li>
<li>第一次减数分裂末期（telophase of meiosis Ⅰ） / 末期 Ⅰ（telophase I）</li>
</ul>
</li>
<li>第二次减数分裂（Ⅱ）：<strong>姐妹染色单体</strong> 分离
<ul>
<li>第二次减数分裂中期（metaphase of meiosis Ⅱ） / 中期 Ⅱ（metaphase Ⅱ）</li>
<li>第二次减数分裂后期（anaphase of meiosis Ⅱ） / 后期 Ⅱ（anaphase Ⅱ）</li>
<li>第二次减数分裂末期（telophase of meiosis Ⅱ） / 末期 Ⅱ（telophase Ⅱ）</li>
</ul>
</li>
</ul>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E5%87%8F%E6%95%B0%E5%88%86%E8%A3%82.png" class="" title="减数分裂" alt="减数分裂">
<h3 id="第一次减数分裂前期">第一次减数分裂前期 <a class="markdownIt-Anchor" href="#第一次减数分裂前期">#</a></h3>
<p>第一次减数分裂前期可分为 5 个亚期：</p>
<ol>
<li>细线期（leptotene）：染色体呈细线状；</li>
<li><strong>偶线期</strong>（zygotene）：同源染色体 <strong>联会</strong>（synapsis）；</li>
<li><strong>粗线期</strong>（pachytene）：染色体变粗，开始 <strong>交换</strong>（crossing over）；</li>
<li>双线期（diplotene）：配对的染色体开始分开；</li>
<li>终变期（diakinesis）：染色体缩短，同源染色体继续分开。</li>
</ol>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%8F%E6%95%B0%E5%88%86%E8%A3%82%E5%89%8D%E6%9C%9F.png" class="" title="第一次减数分裂前期" alt="第一次减数分裂前期">
<dl>
<dt>同源染色体（homologous chromosome）</dt>
<dd>分别来自父方和母方、形态结构和大小相同的一对染色体。</dd>
</dl>
<h3 id="减数分裂的生物学意义">减数分裂的生物学意义 <a class="markdownIt-Anchor" href="#减数分裂的生物学意义">#</a></h3>
<ol>
<li>产生单倍体的配子 → 维持人类 <strong>染色体数目的稳定</strong>；</li>
<li><strong>随机配对</strong>、<strong>同源重组</strong> → <strong>多样性</strong>，适应性，进化；</li>
<li>两种类型的精子 → 决定受精卵的 <strong>性别</strong>；</li>
<li>成熟分裂 → 形态与功能上差异显著的 <strong>精子</strong> 和 <strong>卵子</strong>。</li>
</ol>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E9%9A%8F%E6%9C%BA%E9%85%8D%E5%AF%B9.png" class="" title="随机配对" alt="随机配对">
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E5%90%8C%E6%BA%90%E9%87%8D%E7%BB%84.png" class="" title="同源重组" alt="同源重组">
<h2 id="精子和卵子的发生">精子和卵子的发生 <a class="markdownIt-Anchor" href="#精子和卵子的发生">#</a></h2>
<dl>
<dt>精子发生（spermatogenesis）</dt>
<dd>睾丸中，具有有丝分裂活性的原始生殖细胞（primordial germ cell）——精原细胞（spermatogonium）发育成为成熟精子（spermatozoa）的过程。</dd>
<dt>卵子发生（oogenesis）</dt>
<dd>卵巢中，卵原细胞（oogonium）经过增殖、生长和成熟阶段的变化最终形成卵子的过程。</dd>
</dl>
<details class="note info"><summary><p>精子发生和卵子发生的比较</p>
</summary>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E7%B2%BE%E5%AD%90%E5%8F%91%E7%94%9F%E5%92%8C%E5%8D%B5%E5%AD%90%E5%8F%91%E7%94%9F.png" class="" title="精子发生和卵子发生" alt="精子发生和卵子发生">
<table>
<thead>
<tr>
<th></th>
<th>精子发生</th>
<th>卵子发生</th>
</tr>
</thead>
<tbody>
<tr>
<td>开始时期</td>
<td>青春期</td>
<td>胚胎早期</td>
</tr>
<tr>
<td>持续时间</td>
<td>60~65 天</td>
<td>10~50 年</td>
</tr>
<tr>
<td>单次减数分裂形成的细胞</td>
<td>4 个精细胞</td>
<td>1 个卵子、3 个极体</td>
</tr>
<tr>
<td>配子数量</td>
<td>1~2 亿/射精</td>
<td>1 个/月经期</td>
</tr>
</tbody>
</table>

</details>
<h3 id="精子发生">精子发生 <a class="markdownIt-Anchor" href="#精子发生">#</a></h3>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E7%B2%BE%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F.png" class="" title="精子的发生" alt="精子的发生">
<ol>
<li><strong>有丝分裂增殖期</strong>：在 <strong>生精小管</strong>（seminiferous tubule）中 <strong>B 型精原细胞</strong>（type B spermatogonia）分化为 <strong>初级精母细胞</strong>（primary spermatocytes）；</li>
<li><strong>减数分裂成熟期</strong>：1 个初级精母细胞 → 2 个次级精母细胞（secondary spermatocytes）→4 个精子细胞（spermatid）；</li>
<li><strong>精子形成期</strong>：精子细胞形成 <strong>顶体</strong>（acrosome）、<strong>鞭毛</strong>（flagellum），特化为精子（spermatozoa）。</li>
</ol>

<dl>
<dt>胞质桥（cytoplasmic bridges）</dt>
<dd>一个精原细胞增殖分化的各级生精细胞，其细胞质并为完全分离，通过 <strong>胞质桥</strong> 相互连接，形成同步发育的 <strong>同源细胞群</strong>（isogeneous group）。</dd>
<dt>支持细胞（Sertoli cell）</dt>
<dd>支持细胞沿生精小管以一定间隔排列，并与生精细胞保持密切的联系，对各级生精细胞发挥支持、诱导和保护的作用。</dd>
</dl>
<h3 id="卵子发生">卵子发生 <a class="markdownIt-Anchor" href="#卵子发生">#</a></h3>
<ol>
<li>第一阶段，<strong>胎儿 7 个月</strong> 时卵原细胞（oogonium）数目达到峰值，出生前后所有的卵原细胞进入减数分裂，并在 <strong><mark>第一次减数分裂前期</mark></strong>（前期Ⅰ：双线期）<strong>第一次停滞</strong>——初级卵母细胞（primary oocyte）/ 原始卵泡（primordial follicle）；</li>
<li>第二阶段，从 <strong>青春期</strong> 开始，部分原始卵泡发育为初级卵泡，出现透明带、卵泡膜；</li>
<li>第三阶段，在卵泡刺激素（FSH）作用下，初级卵泡进一步发育为次级卵泡，出现卵泡腔、卵丘、放射冠、颗粒细胞；</li>
<li>第四阶段，仅有 1 个优势卵泡继续生长发育为成熟卵泡；</li>
</ol>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E5%8D%B5%E5%AD%90%E5%8F%91%E7%94%9F.png" class="" title="卵子发生" alt="卵子发生">
<ul>
<li><strong>排卵（ovulation）前</strong>，初级卵母细胞完成 <strong>第一次减数分裂</strong>，形成次级卵母细胞（secondary oocyte）和第一极体（polar body I），进入第二次减数分裂并停滞在中期（<strong><mark>中期Ⅱ</mark></strong>），成熟卵泡破裂后，次级卵母细胞从卵巢排出；</li>
</ul>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E6%8E%92%E5%8D%B5%E5%89%8D.png" class="" title="排卵前" alt="排卵前">
<ul>
<li><strong>排卵后</strong>，卵母细胞 <strong>第二次停滞</strong> 等待受精，此时如果能与精子相遇并受精，则会继续完成 <strong>第二次减数分裂</strong>，排出第二极体，否则<em>退化</em>。</li>
</ul>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E6%8E%92%E5%8D%B5%E5%90%8E.png" class="" title="排卵后" alt="排卵后">
<h2 id="受精">受精 <a class="markdownIt-Anchor" href="#受精">#</a></h2>
<dl>
<dt>受精（fertilization）</dt>
<dd>从精子与卵子的 <strong>外层被膜相互接触</strong> 至第一次卵裂前 <strong>母源与父源染色体</strong>
在中期赤道板完全整合结束的过程。</dd>
</dl>
<p>在排卵后 12~24h（又说 12h 内），受精发生于 <strong>输卵管壶腹部</strong>（ampulla tubae uterinae）。</p>
<img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E5%8F%97%E7%B2%BE.png" class="" title="受精" alt="受精">
<p>受精过程：</p>
<ol>
<li>精子和卵母细胞的识别和接触（<strong>顶体反应</strong>）；</li>
<li>精子穿过放射冠和透明带；</li>
<li>精子头部质膜和卵细胞膜融合（<strong>皮质反应</strong>、<strong>透明带反应</strong>）；</li>
<li>卵母细胞完成第二次减数分裂；</li>
<li>雌、雄原核融合，形成一个二倍体的 <strong>受精卵</strong>（fertilized ovum），又称 <strong>合子</strong>（zygote）；</li>
<li>合子启动第一次有丝分裂（<strong>卵裂</strong>）。</li>
</ol>
<dl>
<dt>精子获能（sperm capacitation）</dt>
<dd>精子表面覆盖糖蛋白衣和精浆蛋白，通过子宫和输卵管时被去除，获得与卵子结合的能力的过程。</dd>
<dt>顶体反应（acrosome reaction, AR）</dt>
<dd>获能后的精子释放顶体酶，解离放射冠以及溶蚀透明带的过程。</dd>
<dt>皮质反应（cortical reaction）</dt>
<dd>精子接触卵表面以及穿入卵时，卵细胞质表层所发生的一系列变化过程，对防止 <strong>多精入卵</strong>
起信号作用。</dd>
</dl>
<p>受精前，卵细胞膜下存在高尔基复合体形成的分泌小泡（<strong>皮质颗粒</strong>）。
在 <strong>皮质反应</strong> 中，精子穿入点处的皮质颗粒首先与细胞膜融合，随后迅速波及整个卵细胞表面。皮质颗粒中各种蛋白水解酶、结构蛋白和粘多糖等释放到达透明带，使其结构发生变化并分解其中的
ZP<sub>3</sub> 使其不能与其他精子结合（<strong>透明带反应</strong>）。</p>
<details class="note info"><summary><p>卵膜、透明带和卵黄膜</p>
</summary>
<dl>
<dt>卵膜（egg membrane）</dt>
<dd>包裹于动物卵细胞的非细胞性被膜的总称。</dd>
<dd>根据卵膜来源，可将其分为三类：
<ul>
<li><strong>初级卵膜</strong>（primary egg membrane）：由卵细胞本身分泌的物质，在卵巢中形成，如
<strong>卵黄膜</strong>、<strong>透明带</strong>；</li>
<li><strong>次级卵膜</strong>（secondary egg membrane）：由卵巢内滤泡细胞分泌的物质所形成，如昆虫的卵壳；</li>
<li><strong>三级卵膜</strong>（tertiary egg membrane）：输卵管或生殖器官附属部分分泌形成，如蛙卵外的胶膜、鸟壳的蛋白、纤维膜和蛋壳。</li>
</ul>
</dd>
<dt>透明带（zona pellucida）</dt>
<dd>在初级卵泡时期，由 <strong>颗粒细胞</strong>（granulosa cell）和卵母细胞共同分泌形成的一层卵膜。</dd>
<dd>透明带主要由 ZP<sub>1</sub>，ZP<sub>2</sub>，ZP<sub>3</sub> 组成，其中 <strong>ZP<sub>3</sub></strong> 为精子受体，有利于精子和卵子相互识别和特异性结合。<br/></dd>
<dd>在非哺乳动物中，透明带被称为 <strong>卵黄膜</strong>（vitelline membrane）或
<strong>卵黄被</strong>（vitelline envelope）。</dd>
<dt>颗粒细胞（granulosa cell）| 滤泡细胞（folicular cell）</dt>
<dd>与雌配子在哺乳动物卵巢中的发育密切相关的一种体细胞。</dd>
<dd>在卵泡发育过程中，颗粒细胞发育形成排卵前卵泡中卵母细胞周围的卵丘细胞。</dd>
</dl>

</details>
<p>受精的意义：</p>
<ol>
<li>受精卵形成新个体；</li>
<li>恢复二倍体，维持了物种的延续性；</li>
<li>决定新个体的遗传性状；</li>
<li>新个体具有不同于亲代的新性状；</li>
</ol>
<h3 id="辅助生殖">辅助生殖 <a class="markdownIt-Anchor" href="#辅助生殖">#</a></h3>
<dl>
<dt>体外受精（in vitro fertilization，IVF）</dt>
<dd>在人工辅助条件下使成熟的卵子与精子在体外结合并完成受精的过程。</dd>
</dl>
<p>通常将 <strong>体外受精</strong> + <strong>胚胎移植</strong>（embryo transferring，ET）技术产生的婴儿称为“试管婴儿”（test tube baby）。</p>
<ul>
<li>Ⅰ 代试管婴儿技术：体外受精 + 胚胎移植</li>
<li>Ⅱ 代试管婴儿技术：卵胞浆内单精子注射（intracytoplasmic sperm injection，ICSI）</li>
<li>Ⅲ 代试管婴儿技术：移植前遗传学诊断（preimplantation genetic diagnosis, PGD）</li>
</ul>
<!-- **线粒体替代治疗（mitochondrial replacement therapy）** -->
<!--  -->
<!-- <img data-src="/2021/03/31/%E9%85%8D%E5%AD%90%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E5%8F%97%E7%B2%BE/%E7%BA%BF%E7%B2%92%E4%BD%93%E6%9B%BF%E4%BB%A3%E6%B2%BB%E7%96%97.png" class="" title="线粒体替代治疗" alt="线粒体替代治疗"> -->
<!--  -->
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
        <category>组织学与胚胎学</category>
        <category>胚胎学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
        <tag>组织学与胚胎学</tag>
        <tag>胚胎学</tag>
      </tags>
  </entry>
  <entry>
    <title>颜面、颈和四肢的发生</title>
    <url>/2021/05/27/%E9%A2%9C%E9%9D%A2%E3%80%81%E9%A2%88%E5%92%8C%E5%9B%9B%E8%82%A2%E7%9A%84%E5%8F%91%E7%94%9F/</url>
    <content><![CDATA[<p>第 4 周时，<strong>鳃弓</strong>发生，它参与形成颜面和颈部的主要结构。<br/>
同时 <strong>上肢芽</strong> 与 <strong>下肢芽</strong> 发生，它们为四肢的原基。</p>
<span id="more"></span>
<h2 id="鳃器的发生和演化">鳃器的发生和演化 <a class="markdownIt-Anchor" href="#鳃器的发生和演化">#</a></h2>
<dl>
<dt>额鼻突（frontonasal process）</dt>
<dd>人胚第 4 周，<a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=胚体#胚体形成">胚体</a> 神经管头端迅速膨大形成 <strong>脑泡</strong>，脑泡侧腹的间充质增生，使胚体头端增生弯向腹侧形成的较大圆形隆起。</dd>
<dt>心隆起（heart bulge）| 心突</dt>
<dd>人胚第 4 周末，心脏发育在原始口腔下方形成的隆起。</dd>
</dl>
<hr />
<dl>
<dt>鳃弓（branchial arch）</dt>
<dd>人胚第 4 周（第 22~29 天），头部两侧的间充质迅速增生，在额鼻突和心隆起之间形成的 6 对左右对称、背腹走向的弓状隆起。</dd>
<dt>腮沟（bronchial groove）</dt>
<dd>相邻鳃弓之间的 5 对凹陷。</dd>
<dt>咽囊（pharyngeal pouch）</dt>
<dd>原始消化管头段（原始咽）的内胚层膨出，在与腮沟（外胚层）对应的侧壁形成的 5 对囊状结构。</dd>
<dt>鳃膜（bronchial membrane）</dt>
<dd>咽囊和腮沟之间的薄膜。</dd>
</dl>
<p>鳃弓、咽囊、鳃沟和鳃膜统称为 <strong><mark>腮器</mark></strong>（branchial apparatus）。<br/>
鳃器在鱼类两栖类幼体中是呼吸器官，但在人类胚胎中，鳃器的存在时间短，并不发育成鳃，而是参与颜面、颈部和某些器官的形成。</p>
<ul>
<li><strong>鳃弓</strong>：参与颜面、颈的形成，其间充质分化为肌肉组织、软骨和骨（如 <a href="/2021/05/29/%E6%B6%88%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%91%BC%E5%90%B8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/?highlight=软骨#喉-气管和肺的发生">喉部</a> 的软骨等）；</li>
<li><strong>咽囊</strong>：许多重要器官的原基，参与中耳、扁桃体、甲状腺等器官的形成（见 <a href="/2021/05/29/%E6%B6%88%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%91%BC%E5%90%B8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E7%94%9F/?highlight=咽囊#咽的发生及咽囊的咽囊的演变">咽的发生及咽囊的咽囊的演变</a>；</li>
<li><strong>腮沟</strong>：参与形成外耳道（第 1 腮沟）、颈窦等；</li>
<li><strong>鳃膜</strong>：形成鼓膜等。</li>
</ul>
<h2 id="颜面的形成">颜面的形成 <a class="markdownIt-Anchor" href="#颜面的形成">#</a></h2>
<p>颜面由 <strong>额鼻突</strong> 和 <strong>上颌突</strong> 和 <strong>下颌突</strong> 形成。</p>
<dl>
<dt>上颌突（maxillary process）| 下颌突（mandibular process）</dt>
<dd>第一对鳃弓腹侧部分分叉形成的上、下两支</dd>
</dl>
<p>左、右下颌突很快向腹侧中线生长，融合为一个整体。</p>
<dl>
<dt>原始口腔（primitive mouth）| 口凹（stomodeum）</dt>
<dd>人胚第 4 周，<a href="/2021/05/26/%E4%BA%BA%E8%83%9A%E5%8F%91%E7%94%9F%E5%92%8C%E6%97%A9%E6%9C%9F%E5%8F%91%E8%82%B2/?highlight=口咽膜#三胚层胚盘及相关结构的发生">口咽膜</a> 周围组织增生隆起，中央形成的浅凹。</dd>
</dl>
<hr />
<dl>
<dt>鼻板（nasal placode）</dt>
<dd>第 4 周末，额鼻突下缘两侧的外胚层增生在左、右形成的的卵圆形增厚区。</dd>
<dt>鼻窝（nasal pit）</dt>
<dd>第 5 周时，鼻板中央凹陷形成，<em>鼻窝下缘有一条细沟与原始口腔相通</em>。</dd>
<dt>内侧鼻突（median nasal process）、外侧鼻突（lateral nasal process）</dt>
<dd>鼻窝内、外侧间充质增生，分别形成的隆起。</dd>
</dl>
<hr />
<p>颜面形成过程中，各结构都是逐渐向中央靠拢的。<br/>
首先是左、右 <strong>下颌突</strong> 向腹侧中线生长相互融合并进一步发育成下颌和下唇；<br/>
稍后，左、右 <strong>上颌突</strong> 也向中央靠拢并与外侧鼻突融合；<br/>
左、右 <strong>内侧鼻突</strong> 逐渐在中线融合，中间融合的部分形成人中和上唇，下缘向下迁移而与上颌突融合；<br/>
<strong>眼</strong> 发生的原基最初是在额鼻突下缘的外侧，随着脑的发育及颜面的形成，才逐渐向中线靠近并转向前方。</p>
<p>颜面各部分的形成：</p>
<ul>
<li><strong>额鼻突</strong> → 前额、鼻梁、鼻尖；</li>
<li><strong>下颌突</strong> → 下颌、下唇；<strong>上颌突</strong> → 上唇外侧、上颌；</li>
<li><strong>内侧鼻突</strong> → 人中、上唇正中部分；<strong>外侧鼻突</strong> → 鼻侧壁、鼻翼；</li>
<li><strong>鼻窝</strong> → 开口转向下 → 外鼻孔；<strong>鼻窝</strong> → 向深处扩大 → 原始鼻腔；<strong>口鼻膜</strong> → 破裂 → 原始鼻后孔；</li>
<li><strong>第 1 腮沟</strong> → 外耳道；<strong>第 1 腮沟间充质</strong> → 耳廓。</li>
</ul>
<dl>
<dt>唇板（labial lamina）</dt>
<dd>第 7 周，由上、下颌突边缘的外胚层增厚形成。</dd>
</dl>
<p>唇板中央部分的上皮很快退化，形成一道深沟，将上、下颌的唇和龈分隔区分开。</p>
<h3 id="腭的发生">腭的发生 <a class="markdownIt-Anchor" href="#腭的发生">#</a></h3>
<div class="note info"><p>腭的发生即口腔和鼻腔分隔的过程。<br/>
腭的形成将原始口腔与原始鼻腔分隔成为永久的口腔与鼻腔，鼻腔后缘即后鼻孔与咽相通。</p>
</div>
<p>腭起源于 <strong>正中腭突</strong> 和 <strong>外侧腭突</strong> 两部分。</p>
<dl>
<dt>正中腭突（median palatine process）| 原始腭</dt>
<dd>第 6 周，由左、右内侧鼻突内侧面间充质增生，各自向原始口腔内长出的一个水平方向的小突起在中线融合形成。</dd>
<dt>外侧腭突（lateral palatine process）</dt>
<dd>第 6 周，左、右上颌突内侧面向原始口腔内长出的一对扁平突起。</dd>
</dl>
<p>正中腭突演化为腭前部的一小部分；
外侧腭突逐渐水平向中间生长，并在中线愈合，也称 <strong>继发腭</strong>，形成腭的大部分（硬腭、软腭、腭垂）。</p>
<p>在腭形成的同时，额鼻突形成鼻梁和鼻尖的部位的正中组织还向原始鼻腔内长出板状的
<strong>鼻中隔</strong>，它向下垂直生长，与腭在中线融合，将鼻腔一分为二。<br/>
同时，鼻腔外侧形成三个嵴形皱壁，分别形成上、中、下三个 <strong>鼻甲</strong>。</p>
<h2 id="四肢的发生">四肢的发生 <a class="markdownIt-Anchor" href="#四肢的发生">#</a></h2>
<dl>
<dt>上肢芽（anterior limb bud）、下肢芽（posterior limb bud）</dt>
<dd>人胚第四周末，胚体左、右外侧体壁上先后出现的两对小隆起，由深部的 <strong>中胚层</strong> 和表面的 <strong>外胚层</strong> 组成。</dd>
</dl>
<p>第 6 周时，肢芽的终末部分变扁，形成 <strong>手板</strong>（hand plate）和 <strong>足板</strong>（foot
plate）。<br/>
随后出现远端和近端两个收缩环，将上肢芽分为臂、前臂、手，将下肢芽分为大腿、小腿、足。<br/>
手板、足板最初呈扁平的桨板状，而后呈蹼状，第 7~8 周，蹼膜消失，手指和足趾形成。</p>
<h2 id="常见畸形">常见畸形 <a class="markdownIt-Anchor" href="#常见畸形">#</a></h2>
<dl>
<dt>唇裂（cleft lip）</dt>
<dd>最常见的先天性颜面畸形，好发于上唇，有时伴有腭裂，多因 <strong><mark>上颌突和同侧的内侧鼻突</mark></strong> 未融合所致。</dd>
<dt>腭裂（cleft palate）</dt>
<dd>可由 <strong>正中腭突与外侧腭突</strong> 未愈合或 <strong>左、右外侧腭突</strong> 未在中线愈合导致，前者引起
<strong>前腭裂</strong>（单侧或双侧，常伴有唇裂），后者引起的称 <strong>正中腭裂</strong> 或 <strong>后腭裂</strong>。</dd>
<dd>同时发生前腭裂和后腭裂者称为 <strong>全腭裂</strong>。</dd>
<dt>面斜裂（oblique facial cleft）</dt>
<dd>因 <strong>上颌突和同侧外侧鼻突</strong> 未融合所致的，位于上唇至下睑之间的裂隙，大多起自人中外侧边缘，绕过鼻翼外侧，止于内眦。</dd>
</dl>
<p><strong>肢体畸形</strong></p>
<ul>
<li>无肢畸形（肢体缺如）：无前臂、无手、无指等；</li>
<li>短肢畸形：四肢短小、海豹手等；</li>
<li>分化障碍：某块肌或肌群缺如、足内翻、多指、并指、骨畸形、关节发育不良等。</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
        <category>Medicine</category>
        <category>人类发育与遗传学</category>
        <category>组织学与胚胎学</category>
        <category>胚胎学</category>
      </categories>
      <tags>
        <tag>人类发育与遗传学</tag>
        <tag>组织学与胚胎学</tag>
        <tag>胚胎学</tag>
      </tags>
  </entry>
  <entry>
    <title>404</title>
    <url>/404.html</url>
    <content><![CDATA[
<div class="center">Over the mountains, mountains ...</div>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p class="center"><a href='https://zh.wikipedia.org/wiki/Aloha'>ALOHA!</a></p>
<p><strong>Who am I?</strong></p>
<img data-src="/images/aloha.gif" class="right" width="200">
<ul>
<li>CMU <s>(Carnegie Mellon University)</s> 在读 <em>医学牲</em></li>
<li>编程爱好者、（Neo）Vimmer</li>
</ul>
<p><strong>What am I doing?</strong></p>
<ul>
<li>我的博客（医学、计算机……）
<ul>
<li>博客地址：<span class="exturl" data-url="aHR0cHM6Ly9hbG9oYS5vcmcuY24=">https://aloha.org.cn<i class="fa fa-external-link-alt"></i></span></li>
<li>NeoVim 插件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fsb2hhaWEvdmltLWhleG93aWtp">https://github.com/alohaia/vim-hexowiki<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>我的 NeoVim 配置：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fsb2hhaWEvbnZpbWNmZw==">https://github.com/alohaia/nvimcfg<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><strong>What do I wanna do?</strong></p>
<ul>
<li><a href="/2021/04/12/%E8%87%AA%E5%88%B6%E4%BC%AA%E7%BB%88%E7%AB%AF/">自制伪终端</a> - Lua 配置，输入法支持</li>
<li>我爱数学 - 数学建模与应用、统计分析</li>
<li>计算机图形学 - <a href="/2021/04/17/OpenGL/">OpenGL</a>、Vulkan</li>
</ul>
<p><strong>How to contact me?</strong></p>
<img data-src="https://github-readme-stats.vercel.app/api?username=alohaia&show_icons=true&theme=tokyonight" class="right">
<ul>
<li>E-mail
<ul>
<li>Outlook: <span class="exturl" data-url="bWFpbHRvOmxpdS5xaWh1YW5Ab3V0bG9vay5jb20=">liu.qihuan@outlook.com<i class="fa fa-external-link-alt"></i></span></li>
<li>Gmail: <span class="exturl" data-url="bWFpbHRvOmVyaWNrc29ub3JsYW5kb3AxMTgxMUBnbWFpbC5jb20=">ericksonorlandop11811@gmail.com<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>BiliBili <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDM3ODU0Mjg4">@alohaia<i class="fa fa-external-link-alt"></i></span></li>
<li>Github <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fsb2hhaWE=">@alohaia<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>schedule</title>
    <url>/schedule/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/README.html</url>
    <content><![CDATA[<h1 id="pdfjs"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcGRmLmpz">PDF.js<i class="fa fa-external-link-alt"></i></span> for <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0">NexT<i class="fa fa-external-link-alt"></i></span> <a class="markdownIt-Anchor" href="#pdfjs">#</a></h1>
<h2 id="introduce">Introduce <a class="markdownIt-Anchor" href="#introduce">#</a></h2>
<p>This is a plugin that allows to preview PDF files in the blog pages.</p>
<p>If the browser supports embedded PDFs natively, NexT will create a <code>&lt;embed&gt;</code> tag and include the PDF file on your website. Otherwise it will create a <code>&lt;iframe&gt;</code> tag and uses PDF.js by @mozilla to render the pdf file.</p>
<p>Follow the guide below to install dependencies.</p>
<h2 id="installation">Installation <a class="markdownIt-Anchor" href="#installation">#</a></h2>
<h3 id="step-1-go-to-hexo-dir">Step 1 → Go to Hexo dir <a class="markdownIt-Anchor" href="#step-1-go-to-hexo-dir">#</a></h3>
<p>Change dir to <strong>Hexo</strong> directory. There must be <code>source</code>, <code>themes</code> and other directories:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-site</span><br><span class="line">$ ls</span><br><span class="line">_config.next.yml  db.json           package-lock.json scaffolds         themes</span><br><span class="line">_config.yml       node_modules      package.json      <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<h3 id="step-2-get-module">Step 2 → Get module <a class="markdownIt-Anchor" href="#step-2-get-module">#</a></h3>
<p>Install module to <code>source/lib</code> directory:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/next-theme/theme-next-pdf <span class="built_in">source</span>/lib/pdf</span><br></pre></td></tr></table></figure>
<h3 id="step-3-set-it-up">Step 3 → Set it up <a class="markdownIt-Anchor" href="#step-3-set-it-up">#</a></h3>
<p>Enable module in <strong>NexT</strong> <code>_config.next.yml</code> file:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PDF tag</span></span><br><span class="line"><span class="comment"># NexT will try to load pdf files natively, if failed, pdf.js will be used.</span></span><br><span class="line"><span class="comment"># So, you have to install the dependency of pdf.js if you want to use pdf tag and make it available to all browsers.</span></span><br><span class="line"><span class="comment"># See: https://github.com/next-theme/theme-next-pdf</span></span><br><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">500px</span></span><br></pre></td></tr></table></figure>
<h2 id="usage">Usage <a class="markdownIt-Anchor" href="#usage">#</a></h2>
<p>In order to embed PDF files in the article, you just need to create an <code>pdf</code> tag with the URL of your local PDF file, e.g.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% pdf /path/to/your/file.pdf %&#125;</span><br></pre></td></tr></table></figure>
<p>Notice: Do not use cross-origin PDF files, it might be blocked by the CORS policy.</p>
<p>Enjoy it!</p>
<h2 id="update">Update <a class="markdownIt-Anchor" href="#update">#</a></h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo-site/<span class="built_in">source</span>/lib/pdf</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/web/debugger.js</url>
    <content><![CDATA[/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";

// eslint-disable-next-line no-var
var FontInspector = (function FontInspectorClosure() {
  let fonts;
  let active = false;
  const fontAttribute = "data-font-name";
  function removeSelection() {
    const divs = document.querySelectorAll(`span[${fontAttribute}]`);
    for (const div of divs) {
      div.className = "";
    }
  }
  function resetSelection() {
    const divs = document.querySelectorAll(`span[${fontAttribute}]`);
    for (const div of divs) {
      div.className = "debuggerHideText";
    }
  }
  function selectFont(fontName, show) {
    const divs = document.querySelectorAll(
      `span[${fontAttribute}=${fontName}]`
    );
    for (const div of divs) {
      div.className = show ? "debuggerShowText" : "debuggerHideText";
    }
  }
  function textLayerClick(e) {
    if (
      !e.target.dataset.fontName ||
      e.target.tagName.toUpperCase() !== "SPAN"
    ) {
      return;
    }
    const fontName = e.target.dataset.fontName;
    const selects = document.getElementsByTagName("input");
    for (let i = 0; i < selects.length; ++i) {
      const select = selects[i];
      if (select.dataset.fontName !== fontName) {
        continue;
      }
      select.checked = !select.checked;
      selectFont(fontName, select.checked);
      select.scrollIntoView();
    }
  }
  return {
    // Properties/functions needed by PDFBug.
    id: "FontInspector",
    name: "Font Inspector",
    panel: null,
    manager: null,
    init: function init(pdfjsLib) {
      const panel = this.panel;
      const tmp = document.createElement("button");
      tmp.addEventListener("click", resetSelection);
      tmp.textContent = "Refresh";
      panel.appendChild(tmp);

      fonts = document.createElement("div");
      panel.appendChild(fonts);
    },
    cleanup: function cleanup() {
      fonts.textContent = "";
    },
    enabled: false,
    get active() {
      return active;
    },
    set active(value) {
      active = value;
      if (active) {
        document.body.addEventListener("click", textLayerClick, true);
        resetSelection();
      } else {
        document.body.removeEventListener("click", textLayerClick, true);
        removeSelection();
      }
    },
    // FontInspector specific functions.
    fontAdded: function fontAdded(fontObj, url) {
      function properties(obj, list) {
        const moreInfo = document.createElement("table");
        for (let i = 0; i < list.length; i++) {
          const tr = document.createElement("tr");
          const td1 = document.createElement("td");
          td1.textContent = list[i];
          tr.appendChild(td1);
          const td2 = document.createElement("td");
          td2.textContent = obj[list[i]].toString();
          tr.appendChild(td2);
          moreInfo.appendChild(tr);
        }
        return moreInfo;
      }
      const moreInfo = properties(fontObj, ["name", "type"]);
      const fontName = fontObj.loadedName;
      const font = document.createElement("div");
      const name = document.createElement("span");
      name.textContent = fontName;
      const download = document.createElement("a");
      if (url) {
        url = /url\(['"]?([^)"']+)/.exec(url);
        download.href = url[1];
      } else if (fontObj.data) {
        download.href = URL.createObjectURL(
          new Blob([fontObj.data], { type: fontObj.mimeType })
        );
      }
      download.textContent = "Download";
      const logIt = document.createElement("a");
      logIt.href = "";
      logIt.textContent = "Log";
      logIt.addEventListener("click", function (event) {
        event.preventDefault();
        console.log(fontObj);
      });
      const select = document.createElement("input");
      select.setAttribute("type", "checkbox");
      select.dataset.fontName = fontName;
      select.addEventListener("click", function () {
        selectFont(fontName, select.checked);
      });
      font.appendChild(select);
      font.appendChild(name);
      font.appendChild(document.createTextNode(" "));
      font.appendChild(download);
      font.appendChild(document.createTextNode(" "));
      font.appendChild(logIt);
      font.appendChild(moreInfo);
      fonts.appendChild(font);
      // Somewhat of a hack, should probably add a hook for when the text layer
      // is done rendering.
      setTimeout(() => {
        if (this.active) {
          resetSelection();
        }
      }, 2000);
    },
  };
})();

let opMap;

// Manages all the page steppers.
//
// eslint-disable-next-line no-var
var StepperManager = (function StepperManagerClosure() {
  let steppers = [];
  let stepperDiv = null;
  let stepperControls = null;
  let stepperChooser = null;
  let breakPoints = Object.create(null);
  return {
    // Properties/functions needed by PDFBug.
    id: "Stepper",
    name: "Stepper",
    panel: null,
    manager: null,
    init: function init(pdfjsLib) {
      const self = this;
      stepperControls = document.createElement("div");
      stepperChooser = document.createElement("select");
      stepperChooser.addEventListener("change", function (event) {
        self.selectStepper(this.value);
      });
      stepperControls.appendChild(stepperChooser);
      stepperDiv = document.createElement("div");
      this.panel.appendChild(stepperControls);
      this.panel.appendChild(stepperDiv);
      if (sessionStorage.getItem("pdfjsBreakPoints")) {
        breakPoints = JSON.parse(sessionStorage.getItem("pdfjsBreakPoints"));
      }

      opMap = Object.create(null);
      for (const key in pdfjsLib.OPS) {
        opMap[pdfjsLib.OPS[key]] = key;
      }
    },
    cleanup: function cleanup() {
      stepperChooser.textContent = "";
      stepperDiv.textContent = "";
      steppers = [];
    },
    enabled: false,
    active: false,
    // Stepper specific functions.
    create: function create(pageIndex) {
      const debug = document.createElement("div");
      debug.id = "stepper" + pageIndex;
      debug.hidden = true;
      debug.className = "stepper";
      stepperDiv.appendChild(debug);
      const b = document.createElement("option");
      b.textContent = "Page " + (pageIndex + 1);
      b.value = pageIndex;
      stepperChooser.appendChild(b);
      const initBreakPoints = breakPoints[pageIndex] || [];
      const stepper = new Stepper(debug, pageIndex, initBreakPoints);
      steppers.push(stepper);
      if (steppers.length === 1) {
        this.selectStepper(pageIndex, false);
      }
      return stepper;
    },
    selectStepper: function selectStepper(pageIndex, selectPanel) {
      let i;
      pageIndex = pageIndex | 0;
      if (selectPanel) {
        this.manager.selectPanel(this);
      }
      for (i = 0; i < steppers.length; ++i) {
        const stepper = steppers[i];
        stepper.panel.hidden = stepper.pageIndex !== pageIndex;
      }
      const options = stepperChooser.options;
      for (i = 0; i < options.length; ++i) {
        const option = options[i];
        option.selected = (option.value | 0) === pageIndex;
      }
    },
    saveBreakPoints: function saveBreakPoints(pageIndex, bps) {
      breakPoints[pageIndex] = bps;
      sessionStorage.setItem("pdfjsBreakPoints", JSON.stringify(breakPoints));
    },
  };
})();

// The stepper for each page's operatorList.
const Stepper = (function StepperClosure() {
  // Shorter way to create element and optionally set textContent.
  function c(tag, textContent) {
    const d = document.createElement(tag);
    if (textContent) {
      d.textContent = textContent;
    }
    return d;
  }

  function simplifyArgs(args) {
    if (typeof args === "string") {
      const MAX_STRING_LENGTH = 75;
      return args.length <= MAX_STRING_LENGTH
        ? args
        : args.substring(0, MAX_STRING_LENGTH) + "...";
    }
    if (typeof args !== "object" || args === null) {
      return args;
    }
    if ("length" in args) {
      // array
      const MAX_ITEMS = 10,
        simpleArgs = [];
      let i, ii;
      for (i = 0, ii = Math.min(MAX_ITEMS, args.length); i < ii; i++) {
        simpleArgs.push(simplifyArgs(args[i]));
      }
      if (i < args.length) {
        simpleArgs.push("...");
      }
      return simpleArgs;
    }
    const simpleObj = {};
    for (const key in args) {
      simpleObj[key] = simplifyArgs(args[key]);
    }
    return simpleObj;
  }

  // eslint-disable-next-line no-shadow
  class Stepper {
    constructor(panel, pageIndex, initialBreakPoints) {
      this.panel = panel;
      this.breakPoint = 0;
      this.nextBreakPoint = null;
      this.pageIndex = pageIndex;
      this.breakPoints = initialBreakPoints;
      this.currentIdx = -1;
      this.operatorListIdx = 0;
    }

    init(operatorList) {
      const panel = this.panel;
      const content = c("div", "c=continue, s=step");
      const table = c("table");
      content.appendChild(table);
      table.cellSpacing = 0;
      const headerRow = c("tr");
      table.appendChild(headerRow);
      headerRow.appendChild(c("th", "Break"));
      headerRow.appendChild(c("th", "Idx"));
      headerRow.appendChild(c("th", "fn"));
      headerRow.appendChild(c("th", "args"));
      panel.appendChild(content);
      this.table = table;
      this.updateOperatorList(operatorList);
    }

    updateOperatorList(operatorList) {
      const self = this;

      function cboxOnClick() {
        const x = +this.dataset.idx;
        if (this.checked) {
          self.breakPoints.push(x);
        } else {
          self.breakPoints.splice(self.breakPoints.indexOf(x), 1);
        }
        StepperManager.saveBreakPoints(self.pageIndex, self.breakPoints);
      }

      const MAX_OPERATORS_COUNT = 15000;
      if (this.operatorListIdx > MAX_OPERATORS_COUNT) {
        return;
      }

      const chunk = document.createDocumentFragment();
      const operatorsToDisplay = Math.min(
        MAX_OPERATORS_COUNT,
        operatorList.fnArray.length
      );
      for (let i = this.operatorListIdx; i < operatorsToDisplay; i++) {
        const line = c("tr");
        line.className = "line";
        line.dataset.idx = i;
        chunk.appendChild(line);
        const checked = this.breakPoints.includes(i);
        const args = operatorList.argsArray[i] || [];

        const breakCell = c("td");
        const cbox = c("input");
        cbox.type = "checkbox";
        cbox.className = "points";
        cbox.checked = checked;
        cbox.dataset.idx = i;
        cbox.onclick = cboxOnClick;

        breakCell.appendChild(cbox);
        line.appendChild(breakCell);
        line.appendChild(c("td", i.toString()));
        const fn = opMap[operatorList.fnArray[i]];
        let decArgs = args;
        if (fn === "showText") {
          const glyphs = args[0];
          const newArgs = [];
          let str = [];
          for (let j = 0; j < glyphs.length; j++) {
            const glyph = glyphs[j];
            if (typeof glyph === "object" && glyph !== null) {
              str.push(glyph.fontChar);
            } else {
              if (str.length > 0) {
                newArgs.push(str.join(""));
                str = [];
              }
              newArgs.push(glyph); // null or number
            }
          }
          if (str.length > 0) {
            newArgs.push(str.join(""));
          }
          decArgs = [newArgs];
        }
        line.appendChild(c("td", fn));
        line.appendChild(c("td", JSON.stringify(simplifyArgs(decArgs))));
      }
      if (operatorsToDisplay < operatorList.fnArray.length) {
        const lastCell = c("td", "...");
        lastCell.colspan = 4;
        chunk.appendChild(lastCell);
      }
      this.operatorListIdx = operatorList.fnArray.length;
      this.table.appendChild(chunk);
    }

    getNextBreakPoint() {
      this.breakPoints.sort(function (a, b) {
        return a - b;
      });
      for (let i = 0; i < this.breakPoints.length; i++) {
        if (this.breakPoints[i] > this.currentIdx) {
          return this.breakPoints[i];
        }
      }
      return null;
    }

    breakIt(idx, callback) {
      StepperManager.selectStepper(this.pageIndex, true);
      this.currentIdx = idx;

      const listener = evt => {
        switch (evt.keyCode) {
          case 83: // step
            document.removeEventListener("keydown", listener);
            this.nextBreakPoint = this.currentIdx + 1;
            this.goTo(-1);
            callback();
            break;
          case 67: // continue
            document.removeEventListener("keydown", listener);
            this.nextBreakPoint = this.getNextBreakPoint();
            this.goTo(-1);
            callback();
            break;
        }
      };
      document.addEventListener("keydown", listener);
      this.goTo(idx);
    }

    goTo(idx) {
      const allRows = this.panel.getElementsByClassName("line");
      for (let x = 0, xx = allRows.length; x < xx; ++x) {
        const row = allRows[x];
        if ((row.dataset.idx | 0) === idx) {
          row.style.backgroundColor = "rgb(251,250,207)";
          row.scrollIntoView();
        } else {
          row.style.backgroundColor = null;
        }
      }
    }
  }
  return Stepper;
})();

// eslint-disable-next-line no-var
var Stats = (function Stats() {
  let stats = [];
  function clear(node) {
    while (node.hasChildNodes()) {
      node.removeChild(node.lastChild);
    }
  }
  function getStatIndex(pageNumber) {
    for (let i = 0, ii = stats.length; i < ii; ++i) {
      if (stats[i].pageNumber === pageNumber) {
        return i;
      }
    }
    return false;
  }
  return {
    // Properties/functions needed by PDFBug.
    id: "Stats",
    name: "Stats",
    panel: null,
    manager: null,
    init(pdfjsLib) {},
    enabled: false,
    active: false,
    // Stats specific functions.
    add(pageNumber, stat) {
      if (!stat) {
        return;
      }
      const statsIndex = getStatIndex(pageNumber);
      if (statsIndex !== false) {
        const b = stats[statsIndex];
        this.panel.removeChild(b.div);
        stats.splice(statsIndex, 1);
      }
      const wrapper = document.createElement("div");
      wrapper.className = "stats";
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = "Page: " + pageNumber;
      const statsDiv = document.createElement("div");
      statsDiv.textContent = stat.toString();
      wrapper.appendChild(title);
      wrapper.appendChild(statsDiv);
      stats.push({ pageNumber, div: wrapper });
      stats.sort(function (a, b) {
        return a.pageNumber - b.pageNumber;
      });
      clear(this.panel);
      for (let i = 0, ii = stats.length; i < ii; ++i) {
        this.panel.appendChild(stats[i].div);
      }
    },
    cleanup() {
      stats = [];
      clear(this.panel);
    },
  };
})();

// Manages all the debugging tools.
window.PDFBug = (function PDFBugClosure() {
  const panelWidth = 300;
  const buttons = [];
  let activePanel = null;

  return {
    tools: [FontInspector, StepperManager, Stats],
    enable(ids) {
      const all = ids.length === 1 && ids[0] === "all";
      const tools = this.tools;
      for (let i = 0; i < tools.length; ++i) {
        const tool = tools[i];
        if (all || ids.includes(tool.id)) {
          tool.enabled = true;
        }
      }
      if (!all) {
        // Sort the tools by the order they are enabled.
        tools.sort(function (a, b) {
          let indexA = ids.indexOf(a.id);
          indexA = indexA < 0 ? tools.length : indexA;
          let indexB = ids.indexOf(b.id);
          indexB = indexB < 0 ? tools.length : indexB;
          return indexA - indexB;
        });
      }
    },
    init(pdfjsLib, container) {
      /*
       * Basic Layout:
       * PDFBug
       *  Controls
       *  Panels
       *    Panel
       *    Panel
       *    ...
       */
      const ui = document.createElement("div");
      ui.id = "PDFBug";

      const controls = document.createElement("div");
      controls.setAttribute("class", "controls");
      ui.appendChild(controls);

      const panels = document.createElement("div");
      panels.setAttribute("class", "panels");
      ui.appendChild(panels);

      container.appendChild(ui);
      container.style.right = panelWidth + "px";

      // Initialize all the debugging tools.
      const tools = this.tools;
      const self = this;
      for (let i = 0; i < tools.length; ++i) {
        const tool = tools[i];
        const panel = document.createElement("div");
        const panelButton = document.createElement("button");
        panelButton.textContent = tool.name;
        panelButton.addEventListener(
          "click",
          (function (selected) {
            return function (event) {
              event.preventDefault();
              self.selectPanel(selected);
            };
          })(i)
        );
        controls.appendChild(panelButton);
        panels.appendChild(panel);
        tool.panel = panel;
        tool.manager = this;
        if (tool.enabled) {
          tool.init(pdfjsLib);
        } else {
          panel.textContent =
            tool.name +
            " is disabled. To enable add " +
            ' "' +
            tool.id +
            '" to the pdfBug parameter ' +
            "and refresh (separate multiple by commas).";
        }
        buttons.push(panelButton);
      }
      this.selectPanel(0);
    },
    cleanup() {
      for (let i = 0, ii = this.tools.length; i < ii; i++) {
        if (this.tools[i].enabled) {
          this.tools[i].cleanup();
        }
      }
    },
    selectPanel(index) {
      if (typeof index !== "number") {
        index = this.tools.indexOf(index);
      }
      if (index === activePanel) {
        return;
      }
      activePanel = index;
      const tools = this.tools;
      for (let j = 0; j < tools.length; ++j) {
        const isActive = j === index;
        buttons[j].classList.toggle("active", isActive);
        tools[j].active = isActive;
        tools[j].panel.hidden = !isActive;
      }
    },
  };
})();
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/web/viewer.css</url>
    <content><![CDATA[/* Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.textLayer {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
  opacity: 0.2;
  line-height: 1;
}

.textLayer span,
.textLayer br {
  color: transparent;
  position: absolute;
  white-space: pre;
  cursor: text;
  transform-origin: 0% 0%;
}

.textLayer .highlight {
  position: relative;
  margin: -1px;
  padding: 1px;
  background-color: rgba(180, 0, 170, 1);
  border-radius: 4px;
}

.textLayer .highlight.begin {
  border-radius: 4px 0 0 4px;
}

.textLayer .highlight.end {
  border-radius: 0 4px 4px 0;
}

.textLayer .highlight.middle {
  border-radius: 0;
}

.textLayer .highlight.selected {
  background-color: rgba(0, 100, 0, 1);
}

.textLayer ::-moz-selection {
  background: rgba(0, 0, 255, 1);
}

.textLayer ::selection {
  background: rgba(0, 0, 255, 1);
}

.textLayer .endOfContent {
  display: block;
  position: absolute;
  left: 0;
  top: 100%;
  right: 0;
  bottom: 0;
  z-index: -1;
  cursor: default;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}

.textLayer .endOfContent.active {
  top: 0;
}


.annotationLayer section {
  position: absolute;
  text-align: initial;
}

.annotationLayer .linkAnnotation > a,
.annotationLayer .buttonWidgetAnnotation.pushButton > a {
  position: absolute;
  font-size: 1em;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.annotationLayer .linkAnnotation > a:hover,
.annotationLayer .buttonWidgetAnnotation.pushButton > a:hover {
  opacity: 0.2;
  background: rgba(255, 255, 0, 1);
  box-shadow: 0 2px 10px rgba(255, 255, 0, 1);
}

.annotationLayer .textAnnotation img {
  position: absolute;
  cursor: pointer;
}

.annotationLayer .textWidgetAnnotation input,
.annotationLayer .textWidgetAnnotation textarea,
.annotationLayer .choiceWidgetAnnotation select,
.annotationLayer .buttonWidgetAnnotation.checkBox input,
.annotationLayer .buttonWidgetAnnotation.radioButton input {
  background-color: rgba(0, 54, 255, 0.13);
  border: 1px solid transparent;
  box-sizing: border-box;
  font-size: 9px;
  height: 100%;
  margin: 0;
  padding: 0 3px;
  vertical-align: top;
  width: 100%;
}

.annotationLayer .choiceWidgetAnnotation select option {
  padding: 0;
}

.annotationLayer .buttonWidgetAnnotation.radioButton input {
  border-radius: 50%;
}

.annotationLayer .textWidgetAnnotation textarea {
  font: message-box;
  font-size: 9px;
  resize: none;
}

.annotationLayer .textWidgetAnnotation input[disabled],
.annotationLayer .textWidgetAnnotation textarea[disabled],
.annotationLayer .choiceWidgetAnnotation select[disabled],
.annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],
.annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] {
  background: none;
  border: 1px solid transparent;
  cursor: not-allowed;
}

.annotationLayer .textWidgetAnnotation input:hover,
.annotationLayer .textWidgetAnnotation textarea:hover,
.annotationLayer .choiceWidgetAnnotation select:hover,
.annotationLayer .buttonWidgetAnnotation.checkBox input:hover,
.annotationLayer .buttonWidgetAnnotation.radioButton input:hover {
  border: 1px solid rgba(0, 0, 0, 1);
}

.annotationLayer .textWidgetAnnotation input:focus,
.annotationLayer .textWidgetAnnotation textarea:focus,
.annotationLayer .choiceWidgetAnnotation select:focus {
  background: none;
  border: 1px solid transparent;
}

.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,
.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,
.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {
  background-color: rgba(0, 0, 0, 1);
  content: "";
  display: block;
  position: absolute;
}

.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,
.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {
  height: 80%;
  left: 45%;
  width: 1px;
}

.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before {
  transform: rotate(45deg);
}

.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after {
  transform: rotate(-45deg);
}

.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before {
  border-radius: 50%;
  height: 50%;
  left: 30%;
  top: 20%;
  width: 50%;
}

.annotationLayer .textWidgetAnnotation input.comb {
  font-family: monospace;
  padding-left: 2px;
  padding-right: 0;
}

.annotationLayer .textWidgetAnnotation input.comb:focus {
  /*
   * Letter spacing is placed on the right side of each character. Hence, the
   * letter spacing of the last character may be placed outside the visible
   * area, causing horizontal scrolling. We avoid this by extending the width
   * when the element has focus and revert this when it loses focus.
   */
  width: 115%;
}

.annotationLayer .buttonWidgetAnnotation.checkBox input,
.annotationLayer .buttonWidgetAnnotation.radioButton input {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  padding: 0;
}

.annotationLayer .popupWrapper {
  position: absolute;
  width: 20em;
}

.annotationLayer .popup {
  position: absolute;
  z-index: 200;
  max-width: 20em;
  background-color: rgba(255, 255, 153, 1);
  box-shadow: 0 2px 5px rgba(136, 136, 136, 1);
  border-radius: 2px;
  padding: 6px;
  margin-left: 5px;
  cursor: pointer;
  font: message-box;
  font-size: 9px;
  white-space: normal;
  word-wrap: break-word;
}

.annotationLayer .popup > * {
  font-size: 9px;
}

.annotationLayer .popup h1 {
  display: inline-block;
}

.annotationLayer .popup span {
  display: inline-block;
  margin-left: 5px;
}

.annotationLayer .popup p {
  border-top: 1px solid rgba(51, 51, 51, 1);
  margin-top: 2px;
  padding-top: 2px;
}

.annotationLayer .highlightAnnotation,
.annotationLayer .underlineAnnotation,
.annotationLayer .squigglyAnnotation,
.annotationLayer .strikeoutAnnotation,
.annotationLayer .freeTextAnnotation,
.annotationLayer .lineAnnotation svg line,
.annotationLayer .squareAnnotation svg rect,
.annotationLayer .circleAnnotation svg ellipse,
.annotationLayer .polylineAnnotation svg polyline,
.annotationLayer .polygonAnnotation svg polygon,
.annotationLayer .caretAnnotation,
.annotationLayer .inkAnnotation svg polyline,
.annotationLayer .stampAnnotation,
.annotationLayer .fileAttachmentAnnotation {
  cursor: pointer;
}


.xfaLayer {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 200;
  transform-origin: 0 0;
}

.xfaLayer * {
  color: inherit;
  font: inherit;
  -webkit-font-kerning: inherit;
          font-kerning: inherit;
  letter-spacing: inherit;
  text-align: inherit;
  text-decoration: inherit;
  vertical-align: inherit;
  box-sizing: border-box;
  background: transparent;
}

.xfaFont {
  color: black;
  font-weight: normal;
  -webkit-font-kerning: none;
          font-kerning: none;
  font-size: 10px;
  font-style: normal;
  letter-spacing: 0;
  text-decoration: none;
  vertical-align: 0;
}

.xfaDraw {
  z-index: 100;
}

.xfaExclgroup {
  z-index: 200;
}

.xfaField {
  z-index: 300;
}

.xfaRich {
  z-index: 300;
}

.xfaSubform {
  z-index: 200;
}

.xfaLabel {
  display: flex;
  flex-direction: row;
  align-items: center;
  width: 100%;
  height: 100%;
}

.xfaCaption {
  flex: 1 1 auto;
}

.xfaTextfield,
.xfaSelect {
  width: 100%;
  height: 100%;
  flex: 1 1 auto;
  border: none;
  resize: none;
}

.xfaLabel > input[type="checkbox"] {
  /* Use this trick to make the checkbox invisible but
       but still focusable. */
  position: absolute;
  left: -99999px;
}

.xfaLabel > input[type="checkbox"]:focus + .xfaCheckboxMark {
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
}

.xfaCheckboxMark {
  cursor: pointer;
  flex: 0 0 auto;
  border-style: solid;
  border-width: 2px;
  border-color: #8f8f9d;
  font-size: 10px;
  line-height: 10px;
  width: 10px;
  height: 10px;
  text-align: center;
  vertical-align: middle;
  display: flex;
  flex-direction: row;
  align-items: center;
}

.xfaCheckbox:checked + .xfaCheckboxMark::after {
  content: attr(mark);
}

.xfaButton {
  cursor: pointer;
  width: 100%;
  height: 100%;
  border: none;
  text-align: center;
}

.xfaButton:hover {
  background: Highlight;
}

.xfaRich {
  white-space: pre-wrap;
}

.xfaImage,
.xfaRich {
  width: 100%;
  height: 100%;
}

.xfaLrTb,
.xfaRlTb,
.xfaTb,
.xfaPosition {
  display: block;
}

.xfaPosition {
  position: relative;
}

.xfaArea {
  position: relative;
}

.xfaValignMiddle {
  display: flex;
  align-items: center;
}

.xfaLrTb > div {
  display: inline;
  float: left;
}

.xfaRlTb > div {
  display: inline;
  float: right;
}

.xfaTable {
  display: flex;
  flex-direction: column;
}

.xfaTable .xfaRow {
  display: flex;
  flex-direction: row;
  flex: 1 1 auto;
}

.xfaTable .xfaRow > div {
  flex: 1 1 auto;
}

.xfaTable .xfaRlRow {
  display: flex;
  flex-direction: row-reverse;
  flex: 1;
}

.xfaTable .xfaRlRow > div {
  flex: 1;
}

:root {
  --pdfViewer-padding-bottom: none;
  --page-margin: 1px auto -8px;
  --page-border: 9px solid transparent;
  --spreadHorizontalWrapped-margin-LR: -3.5px;
}

@media screen and (forced-colors: active) {
  :root {
    --pdfViewer-padding-bottom: 9px;
    --page-margin: 9px auto 0;
    --page-border: none;
    --spreadHorizontalWrapped-margin-LR: 4.5px;
  }
}

.pdfViewer {
  padding-bottom: var(--pdfViewer-padding-bottom);
}

.pdfViewer .canvasWrapper {
  overflow: hidden;
}

.pdfViewer .page {
  direction: ltr;
  width: 816px;
  height: 1056px;
  margin: var(--page-margin);
  position: relative;
  overflow: visible;
  border: var(--page-border);
  background-clip: content-box;
  -o-border-image: url(images/shadow.png) 9 9 repeat;
     border-image: url(images/shadow.png) 9 9 repeat;
  background-color: rgba(255, 255, 255, 1);
}

.pdfViewer.removePageBorders .page {
  margin: 0 auto 10px;
  border: none;
}

.pdfViewer.singlePageView {
  display: inline-block;
}

.pdfViewer.singlePageView .page {
  margin: 0;
  border: none;
}

.pdfViewer.scrollHorizontal,
.pdfViewer.scrollWrapped,
.spread {
  margin-left: 3.5px;
  margin-right: 3.5px;
  text-align: center;
}

.pdfViewer.scrollHorizontal,
.spread {
  white-space: nowrap;
}

.pdfViewer.removePageBorders,
.pdfViewer.scrollHorizontal .spread,
.pdfViewer.scrollWrapped .spread {
  margin-left: 0;
  margin-right: 0;
}

.spread .page,
.pdfViewer.scrollHorizontal .page,
.pdfViewer.scrollWrapped .page,
.pdfViewer.scrollHorizontal .spread,
.pdfViewer.scrollWrapped .spread {
  display: inline-block;
  vertical-align: middle;
}

.spread .page,
.pdfViewer.scrollHorizontal .page,
.pdfViewer.scrollWrapped .page {
  margin-left: var(--spreadHorizontalWrapped-margin-LR);
  margin-right: var(--spreadHorizontalWrapped-margin-LR);
}

.pdfViewer.removePageBorders .spread .page,
.pdfViewer.removePageBorders.scrollHorizontal .page,
.pdfViewer.removePageBorders.scrollWrapped .page {
  margin-left: 5px;
  margin-right: 5px;
}

.pdfViewer .page canvas {
  margin: 0;
  display: block;
}

.pdfViewer .page canvas[hidden] {
  display: none;
}

.pdfViewer .page .loadingIcon {
  position: absolute;
  display: block;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background: url("images/loading-icon.gif") center no-repeat;
}

.pdfPresentationMode .pdfViewer {
  margin-left: 0;
  margin-right: 0;
}

.pdfPresentationMode .pdfViewer .page,
.pdfPresentationMode .pdfViewer .spread {
  display: block;
}

.pdfPresentationMode .pdfViewer .page,
.pdfPresentationMode .pdfViewer.removePageBorders .page {
  margin-left: auto;
  margin-right: auto;
}

.pdfPresentationMode:-webkit-full-screen .pdfViewer .page {
  margin-bottom: 100%;
  border: 0;
}

.pdfPresentationMode:fullscreen .pdfViewer .page {
  margin-bottom: 100%;
  border: 0;
}

:root {
  --sidebar-width: 200px;
  --sidebar-transition-duration: 200ms;
  --sidebar-transition-timing-function: ease;
  --loadingBar-end-offset: 0;

  --toolbar-icon-opacity: 0.7;
  --doorhanger-icon-opacity: 0.9;

  --main-color: rgba(12, 12, 13, 1);
  --body-bg-color: rgba(237, 237, 240, 1);
  --errorWrapper-bg-color: rgba(255, 110, 110, 1);
  --progressBar-color: rgba(10, 132, 255, 1);
  --progressBar-indeterminate-bg-color: rgba(221, 221, 222, 1);
  --progressBar-indeterminate-blend-color: rgba(116, 177, 239, 1);
  --scrollbar-color: auto;
  --scrollbar-bg-color: auto;
  --toolbar-icon-bg-color: rgba(0, 0, 0, 1);
  --toolbar-icon-hover-bg-color: rgba(0, 0, 0, 1);

  --sidebar-narrow-bg-color: rgba(237, 237, 240, 0.9);
  --sidebar-toolbar-bg-color: rgba(245, 246, 247, 1);
  --toolbar-bg-color: rgba(249, 249, 250, 1);
  --toolbar-border-color: rgba(204, 204, 204, 1);
  --button-hover-color: rgba(221, 222, 223, 1);
  --toggled-btn-color: rgba(0, 0, 0, 1);
  --toggled-btn-bg-color: rgba(0, 0, 0, 0.3);
  --toggled-hover-active-btn-color: rgba(0, 0, 0, 0.4);
  --dropdown-btn-bg-color: rgba(215, 215, 219, 1);
  --separator-color: rgba(0, 0, 0, 0.3);
  --field-color: rgba(6, 6, 6, 1);
  --field-bg-color: rgba(255, 255, 255, 1);
  --field-border-color: rgba(187, 187, 188, 1);
  --findbar-nextprevious-btn-bg-color: rgba(227, 228, 230, 1);
  --treeitem-color: rgba(0, 0, 0, 0.8);
  --treeitem-hover-color: rgba(0, 0, 0, 0.9);
  --treeitem-selected-color: rgba(0, 0, 0, 0.9);
  --treeitem-selected-bg-color: rgba(0, 0, 0, 0.25);
  --sidebaritem-bg-color: rgba(0, 0, 0, 0.15);
  --doorhanger-bg-color: rgba(255, 255, 255, 1);
  --doorhanger-border-color: rgba(12, 12, 13, 0.2);
  --doorhanger-hover-color: rgba(12, 12, 13, 1);
  --doorhanger-hover-bg-color: rgba(237, 237, 237, 1);
  --doorhanger-separator-color: rgba(222, 222, 222, 1);
  --overlay-button-border: 0 none;
  --overlay-button-bg-color: rgba(12, 12, 13, 0.1);
  --overlay-button-hover-bg-color: rgba(12, 12, 13, 0.3);

  --loading-icon: url(images/loading.svg);
  --treeitem-expanded-icon: url(images/treeitem-expanded.svg);
  --treeitem-collapsed-icon: url(images/treeitem-collapsed.svg);
  --toolbarButton-menuArrow-icon: url(images/toolbarButton-menuArrow.svg);
  --toolbarButton-sidebarToggle-icon: url(images/toolbarButton-sidebarToggle.svg);
  --toolbarButton-secondaryToolbarToggle-icon: url(images/toolbarButton-secondaryToolbarToggle.svg);
  --toolbarButton-pageUp-icon: url(images/toolbarButton-pageUp.svg);
  --toolbarButton-pageDown-icon: url(images/toolbarButton-pageDown.svg);
  --toolbarButton-zoomOut-icon: url(images/toolbarButton-zoomOut.svg);
  --toolbarButton-zoomIn-icon: url(images/toolbarButton-zoomIn.svg);
  --toolbarButton-presentationMode-icon: url(images/toolbarButton-presentationMode.svg);
  --toolbarButton-print-icon: url(images/toolbarButton-print.svg);
  --toolbarButton-openFile-icon: url(images/toolbarButton-openFile.svg);
  --toolbarButton-download-icon: url(images/toolbarButton-download.svg);
  --toolbarButton-bookmark-icon: url(images/toolbarButton-bookmark.svg);
  --toolbarButton-viewThumbnail-icon: url(images/toolbarButton-viewThumbnail.svg);
  --toolbarButton-viewOutline-icon: url(images/toolbarButton-viewOutline.svg);
  --toolbarButton-viewAttachments-icon: url(images/toolbarButton-viewAttachments.svg);
  --toolbarButton-viewLayers-icon: url(images/toolbarButton-viewLayers.svg);
  --toolbarButton-currentOutlineItem-icon: url(images/toolbarButton-currentOutlineItem.svg);
  --toolbarButton-search-icon: url(images/toolbarButton-search.svg);
  --findbarButton-previous-icon: url(images/findbarButton-previous.svg);
  --findbarButton-next-icon: url(images/findbarButton-next.svg);
  --secondaryToolbarButton-firstPage-icon: url(images/secondaryToolbarButton-firstPage.svg);
  --secondaryToolbarButton-lastPage-icon: url(images/secondaryToolbarButton-lastPage.svg);
  --secondaryToolbarButton-rotateCcw-icon: url(images/secondaryToolbarButton-rotateCcw.svg);
  --secondaryToolbarButton-rotateCw-icon: url(images/secondaryToolbarButton-rotateCw.svg);
  --secondaryToolbarButton-selectTool-icon: url(images/secondaryToolbarButton-selectTool.svg);
  --secondaryToolbarButton-handTool-icon: url(images/secondaryToolbarButton-handTool.svg);
  --secondaryToolbarButton-scrollVertical-icon: url(images/secondaryToolbarButton-scrollVertical.svg);
  --secondaryToolbarButton-scrollHorizontal-icon: url(images/secondaryToolbarButton-scrollHorizontal.svg);
  --secondaryToolbarButton-scrollWrapped-icon: url(images/secondaryToolbarButton-scrollWrapped.svg);
  --secondaryToolbarButton-spreadNone-icon: url(images/secondaryToolbarButton-spreadNone.svg);
  --secondaryToolbarButton-spreadOdd-icon: url(images/secondaryToolbarButton-spreadOdd.svg);
  --secondaryToolbarButton-spreadEven-icon: url(images/secondaryToolbarButton-spreadEven.svg);
  --secondaryToolbarButton-documentProperties-icon: url(images/secondaryToolbarButton-documentProperties.svg);
}

@media (prefers-color-scheme: dark) {
  :root {
    --main-color: rgba(249, 249, 250, 1);
    --body-bg-color: rgba(42, 42, 46, 1);
    --errorWrapper-bg-color: rgba(169, 14, 14, 1);
    --progressBar-color: rgba(0, 96, 223, 1);
    --progressBar-indeterminate-bg-color: rgba(40, 40, 43, 1);
    --progressBar-indeterminate-blend-color: rgba(20, 68, 133, 1);
    --scrollbar-color: rgba(121, 121, 123, 1);
    --scrollbar-bg-color: rgba(35, 35, 39, 1);
    --toolbar-icon-bg-color: rgba(255, 255, 255, 1);
    --toolbar-icon-hover-bg-color: rgba(255, 255, 255, 1);

    --sidebar-narrow-bg-color: rgba(42, 42, 46, 0.9);
    --sidebar-toolbar-bg-color: rgba(50, 50, 52, 1);
    --toolbar-bg-color: rgba(56, 56, 61, 1);
    --toolbar-border-color: rgba(12, 12, 13, 1);
    --button-hover-color: rgba(102, 102, 103, 1);
    --toggled-btn-color: rgba(255, 255, 255, 1);
    --toggled-btn-bg-color: rgba(0, 0, 0, 0.3);
    --toggled-hover-active-btn-color: rgba(0, 0, 0, 0.4);
    --dropdown-btn-bg-color: rgba(74, 74, 79, 1);
    --separator-color: rgba(0, 0, 0, 0.3);
    --field-color: rgba(250, 250, 250, 1);
    --field-bg-color: rgba(64, 64, 68, 1);
    --field-border-color: rgba(115, 115, 115, 1);
    --findbar-nextprevious-btn-bg-color: rgba(89, 89, 89, 1);
    --treeitem-color: rgba(255, 255, 255, 0.8);
    --treeitem-hover-color: rgba(255, 255, 255, 0.9);
    --treeitem-selected-color: rgba(255, 255, 255, 0.9);
    --treeitem-selected-bg-color: rgba(255, 255, 255, 0.25);
    --sidebaritem-bg-color: rgba(255, 255, 255, 0.15);
    --doorhanger-bg-color: rgba(74, 74, 79, 1);
    --doorhanger-border-color: rgba(39, 39, 43, 1);
    --doorhanger-hover-color: rgba(249, 249, 250, 1);
    --doorhanger-hover-bg-color: rgba(93, 94, 98, 1);
    --doorhanger-separator-color: rgba(92, 92, 97, 1);
    --overlay-button-bg-color: rgba(92, 92, 97, 1);
    --overlay-button-hover-bg-color: rgba(115, 115, 115, 1);

    /* This image is used in <input> elements, which unfortunately means that
     * the `mask-image` approach used with all of the other images doesn't work
     * here; hence why we still have two versions of this particular image. */
    --loading-icon: url(images/loading-dark.svg);
  }
}

@media screen and (forced-colors: active) {
  :root {
    --main-color: ButtonText;
    --button-hover-color: Highlight;
    --doorhanger-hover-bg-color: Highlight;
    --toolbar-icon-opacity: 1;
    --toolbar-icon-bg-color: ButtonText;
    --toolbar-icon-hover-bg-color: ButtonFace;
    --toggled-btn-color: HighlightText;
    --toggled-btn-bg-color: LinkText;
    --doorhanger-hover-color: ButtonFace;
    --doorhanger-border-color-whcm: 1px solid ButtonText;
    --doorhanger-triangle-opacity-whcm: 0;
    --overlay-button-border: 1px solid Highlight;
    --overlay-button-hover-bg-color: Highlight;
    --overlay-button-hover-color: ButtonFace;
    --field-border-color: ButtonText;
  }
}

* {
  padding: 0;
  margin: 0;
}

html {
  height: 100%;
  width: 100%;
  /* Font size is needed to make the activity bar the correct size. */
  font-size: 10px;
}

body {
  height: 100%;
  width: 100%;
  background-color: var(--body-bg-color);
}

body,
input,
button,
select {
  font: message-box;
  outline: none;
  scrollbar-color: var(--scrollbar-color) var(--scrollbar-bg-color);
}

.hidden {
  display: none !important;
}
[hidden] {
  display: none !important;
}

.pdfViewer.enablePermissions .textLayer span {
  -webkit-user-select: none !important;
     -moz-user-select: none !important;
          user-select: none !important;
  cursor: not-allowed;
}

#viewerContainer.pdfPresentationMode:-webkit-full-screen {
  top: 0;
  border-top: 2px solid rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 1);
  width: 100%;
  height: 100%;
  overflow: hidden;
  cursor: none;
  -webkit-user-select: none;
          user-select: none;
}

#viewerContainer.pdfPresentationMode:fullscreen {
  top: 0;
  border-top: 2px solid rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 1);
  width: 100%;
  height: 100%;
  overflow: hidden;
  cursor: none;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}

.pdfPresentationMode:-webkit-full-screen a:not(.internalLink) {
  display: none;
}

.pdfPresentationMode:fullscreen a:not(.internalLink) {
  display: none;
}

.pdfPresentationMode:-webkit-full-screen .textLayer span {
  cursor: none;
}

.pdfPresentationMode:fullscreen .textLayer span {
  cursor: none;
}

.pdfPresentationMode.pdfPresentationModeControls > *,
.pdfPresentationMode.pdfPresentationModeControls .textLayer span {
  cursor: default;
}

#outerContainer {
  width: 100%;
  height: 100%;
  position: relative;
}

#sidebarContainer {
  position: absolute;
  top: 32px;
  bottom: 0;
  width: var(--sidebar-width);
  visibility: hidden;
  z-index: 100;
  border-top: 1px solid rgba(51, 51, 51, 1);
  transition-duration: var(--sidebar-transition-duration);
  transition-timing-function: var(--sidebar-transition-timing-function);
}
html[dir="ltr"] #sidebarContainer {
  transition-property: left;
  left: calc(0px - var(--sidebar-width));
  border-right: var(--doorhanger-border-color-whcm);
}
html[dir="rtl"] #sidebarContainer {
  transition-property: right;
  right: calc(0px - var(--sidebar-width));
  border-left: var(--doorhanger-border-color-whcm);
}

#outerContainer.sidebarResizing #sidebarContainer {
  /* Improve responsiveness and avoid visual glitches when the sidebar is resized. */
  transition-duration: 0s;
  /* Prevent e.g. the thumbnails being selected when the sidebar is resized. */
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}

#outerContainer.sidebarMoving #sidebarContainer,
#outerContainer.sidebarOpen #sidebarContainer {
  visibility: visible;
}
html[dir="ltr"] #outerContainer.sidebarOpen #sidebarContainer {
  left: 0;
}
html[dir="rtl"] #outerContainer.sidebarOpen #sidebarContainer {
  right: 0;
}

#mainContainer {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  min-width: 320px;
}

#sidebarContent {
  top: 32px;
  bottom: 0;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  position: absolute;
  width: 100%;
  background-color: rgba(0, 0, 0, 0.1);
}
html[dir="ltr"] #sidebarContent {
  left: 0;
  box-shadow: inset -1px 0 0 rgba(0, 0, 0, 0.25);
}
html[dir="rtl"] #sidebarContent {
  right: 0;
  box-shadow: inset 1px 0 0 rgba(0, 0, 0, 0.25);
}

#viewerContainer {
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  position: absolute;
  top: 32px;
  right: 0;
  bottom: 0;
  left: 0;
  outline: none;
}
#viewerContainer:not(.pdfPresentationMode) {
  transition-duration: var(--sidebar-transition-duration);
  transition-timing-function: var(--sidebar-transition-timing-function);
}

#outerContainer.sidebarResizing #viewerContainer {
  /* Improve responsiveness and avoid visual glitches when the sidebar is resized. */
  transition-duration: 0s;
}

html[dir="ltr"]
  #outerContainer.sidebarOpen
  #viewerContainer:not(.pdfPresentationMode) {
  transition-property: left;
  left: var(--sidebar-width);
}
html[dir="rtl"]
  #outerContainer.sidebarOpen
  #viewerContainer:not(.pdfPresentationMode) {
  transition-property: right;
  right: var(--sidebar-width);
}

.toolbar {
  position: relative;
  left: 0;
  right: 0;
  z-index: 9999;
  cursor: default;
}

#toolbarContainer {
  width: 100%;
}

#toolbarSidebar {
  width: 100%;
  height: 32px;
  background-color: var(--sidebar-toolbar-bg-color);
}
html[dir="ltr"] #toolbarSidebar {
  box-shadow: inset -1px 0 0 rgba(0, 0, 0, 0.25), 0 1px 0 rgba(0, 0, 0, 0.15),
    0 0 1px rgba(0, 0, 0, 0.1);
}
html[dir="rtl"] #toolbarSidebar {
  box-shadow: inset 1px 0 0 rgba(0, 0, 0, 0.25), 0 1px 0 rgba(0, 0, 0, 0.15),
    0 0 1px rgba(0, 0, 0, 0.1);
}

html[dir="ltr"] #toolbarSidebar .toolbarButton {
  margin-right: 2px !important;
}
html[dir="rtl"] #toolbarSidebar .toolbarButton {
  margin-left: 2px !important;
}

html[dir="ltr"] #toolbarSidebarRight .toolbarButton {
  margin-right: 3px !important;
}
html[dir="rtl"] #toolbarSidebarRight .toolbarButton {
  margin-left: 3px !important;
}

#sidebarResizer {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 6px;
  z-index: 200;
  cursor: ew-resize;
}
html[dir="ltr"] #sidebarResizer {
  right: -6px;
}
html[dir="rtl"] #sidebarResizer {
  left: -6px;
}

#toolbarContainer,
.findbar,
.secondaryToolbar {
  position: relative;
  height: 32px;
  background-color: var(--toolbar-bg-color);
  box-shadow: 0 1px 0 var(--toolbar-border-color);
}

#toolbarViewer {
  height: 32px;
}

#loadingBar {
  position: absolute;
  height: 4px;
  background-color: var(--body-bg-color);
  border-bottom: 1px solid var(--toolbar-border-color);

  transition-duration: var(--sidebar-transition-duration);
  transition-timing-function: var(--sidebar-transition-timing-function);
}
html[dir="ltr"] #loadingBar {
  transition-property: left;
  left: 0;
  right: var(--loadingBar-end-offset);
}
html[dir="rtl"] #loadingBar {
  transition-property: right;
  left: var(--loadingBar-end-offset);
  right: 0;
}

html[dir="ltr"] #outerContainer.sidebarOpen #loadingBar {
  left: var(--sidebar-width);
}
html[dir="rtl"] #outerContainer.sidebarOpen #loadingBar {
  right: var(--sidebar-width);
}

#outerContainer.sidebarResizing #loadingBar {
  /* Improve responsiveness and avoid visual glitches when the sidebar is resized. */
  transition-duration: 0s;
}

#loadingBar .progress {
  position: absolute;
  top: 0;
  left: 0;
  width: 0%;
  height: 100%;
  background-color: var(--progressBar-color);
  overflow: hidden;
  transition: width 200ms;
}

@-webkit-keyframes progressIndeterminate {
  0% {
    left: -142px;
  }
  100% {
    left: 0;
  }
}

@keyframes progressIndeterminate {
  0% {
    left: -142px;
  }
  100% {
    left: 0;
  }
}

#loadingBar .progress.indeterminate {
  background-color: var(--progressBar-indeterminate-bg-color);
  transition: none;
}

#loadingBar .progress.indeterminate .glimmer {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: calc(100% + 150px);
  background: repeating-linear-gradient(
    135deg,
    var(--progressBar-indeterminate-blend-color) 0,
    var(--progressBar-indeterminate-bg-color) 5px,
    var(--progressBar-indeterminate-bg-color) 45px,
    var(--progressBar-color) 55px,
    var(--progressBar-color) 95px,
    var(--progressBar-indeterminate-blend-color) 100px
  );
  -webkit-animation: progressIndeterminate 1s linear infinite;
          animation: progressIndeterminate 1s linear infinite;
}

.findbar,
.secondaryToolbar {
  top: 32px;
  position: absolute;
  z-index: 10000;
  height: auto;
  min-width: 16px;
  padding: 0 4px;
  margin: 4px 2px;
  color: rgba(217, 217, 217, 1);
  font-size: 12px;
  line-height: 14px;
  text-align: left;
  cursor: default;
}

.findbar {
  min-width: 300px;
  background-color: var(--toolbar-bg-color);
}
.findbar > div {
  height: 32px;
}
.findbar.wrapContainers > div {
  clear: both;
}
.findbar.wrapContainers > div#findbarMessageContainer {
  height: auto;
}
html[dir="ltr"] .findbar {
  left: 64px;
}
html[dir="rtl"] .findbar {
  right: 64px;
}

.findbar .splitToolbarButton {
  margin-top: 3px;
}
html[dir="ltr"] .findbar .splitToolbarButton {
  margin-left: 0;
  margin-right: 5px;
}
html[dir="rtl"] .findbar .splitToolbarButton {
  margin-left: 5px;
  margin-right: 0;
}

.findbar .splitToolbarButton > .toolbarButton {
  background-color: var(--findbar-nextprevious-btn-bg-color);
  border-radius: 0;
  height: 26px;
  border-top: 1px solid var(--field-border-color);
  border-bottom: 1px solid var(--field-border-color);
}

.findbar .splitToolbarButton > .toolbarButton::before {
  top: 5px;
}

.findbar .splitToolbarButton > .findNext {
  width: 29px;
}
html[dir="ltr"] .findbar .splitToolbarButton > .findNext {
  border-bottom-right-radius: 2px;
  border-top-right-radius: 2px;
  border-right: 1px solid var(--field-border-color);
}
html[dir="rtl"] .findbar .splitToolbarButton > .findNext {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
  border-left: 1px solid var(--field-border-color);
}

.findbar input[type="checkbox"] {
  pointer-events: none;
}

.findbar label {
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}

.findbar label:hover,
.findbar input:focus + label {
  color: var(--toggled-btn-color);
  background-color: var(--button-hover-color);
}

html[dir="ltr"] #findInput {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
html[dir="rtl"] #findInput {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}

.findbar .toolbarField[type="checkbox"]:checked + .toolbarLabel {
  background-color: var(--toggled-btn-bg-color) !important;
  color: var(--toggled-btn-color);
}

#findInput {
  width: 200px;
}
#findInput::-moz-placeholder {
  font-style: normal;
}
#findInput::placeholder {
  font-style: normal;
}
#findInput[data-status="pending"] {
  background-image: var(--loading-icon);
  background-repeat: no-repeat;
  background-position: 98%;
}
html[dir="rtl"] #findInput[data-status="pending"] {
  background-position: 3px;
}
#findInput[data-status="notFound"] {
  background-color: rgba(255, 102, 102, 1);
}

.secondaryToolbar {
  padding: 6px 0 10px;
  height: auto;
  z-index: 30000;
  background-color: var(--doorhanger-bg-color);
}
html[dir="ltr"] .secondaryToolbar {
  right: 4px;
}
html[dir="rtl"] .secondaryToolbar {
  left: 4px;
}

#secondaryToolbarButtonContainer {
  max-width: 220px;
  max-height: 400px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  margin-bottom: -4px;
}

#secondaryToolbarButtonContainer.hiddenScrollModeButtons > .scrollModeButtons,
#secondaryToolbarButtonContainer.hiddenSpreadModeButtons > .spreadModeButtons {
  display: none !important;
}

.doorHanger,
.doorHangerRight {
  border-radius: 2px;
  box-shadow: 0 1px 5px var(--doorhanger-border-color),
    0 0 0 1px var(--doorhanger-border-color);
  border: var(--doorhanger-border-color-whcm);
}
.doorHanger:after,
.doorHanger:before,
.doorHangerRight:after,
.doorHangerRight:before {
  bottom: 100%;
  border: solid rgba(0, 0, 0, 0);
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none;
  opacity: var(--doorhanger-triangle-opacity-whcm);
}
.doorHanger:after,
.doorHangerRight:after {
  border-width: 8px;
}
.doorHanger:after {
  border-bottom-color: var(--toolbar-bg-color);
}
.doorHangerRight:after {
  border-bottom-color: var(--doorhanger-bg-color);
}
.doorHanger:before,
.doorHangerRight:before {
  border-bottom-color: var(--doorhanger-border-color);
  border-width: 9px;
}

html[dir="ltr"] .doorHanger:after,
html[dir="rtl"] .doorHangerRight:after {
  left: 10px;
  margin-left: -8px;
}

html[dir="ltr"] .doorHanger:before,
html[dir="rtl"] .doorHangerRight:before {
  left: 10px;
  margin-left: -9px;
}

html[dir="rtl"] .doorHanger:after,
html[dir="ltr"] .doorHangerRight:after {
  right: 10px;
  margin-right: -8px;
}

html[dir="rtl"] .doorHanger:before,
html[dir="ltr"] .doorHangerRight:before {
  right: 10px;
  margin-right: -9px;
}

#findResultsCount {
  background-color: rgba(217, 217, 217, 1);
  color: rgba(82, 82, 82, 1);
  text-align: center;
  padding: 4px 5px;
  margin: 5px;
}

#findMsg {
  color: rgba(251, 0, 0, 1);
}
#findMsg:empty {
  display: none;
}

#toolbarViewerMiddle {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

html[dir="ltr"] #toolbarViewerLeft,
html[dir="rtl"] #toolbarViewerRight,
html[dir="ltr"] #toolbarSidebarLeft,
html[dir="rtl"] #toolbarSidebarRight {
  float: left;
}
html[dir="ltr"] #toolbarViewerRight,
html[dir="rtl"] #toolbarViewerLeft,
html[dir="ltr"] #toolbarSidebarRight,
html[dir="rtl"] #toolbarSidebarLeft {
  float: right;
}
html[dir="ltr"] #toolbarViewerLeft > *,
html[dir="ltr"] #toolbarViewerMiddle > *,
html[dir="ltr"] #toolbarViewerRight > *,
html[dir="ltr"] #toolbarSidebarLeft *,
html[dir="ltr"] #toolbarSidebarRight *,
html[dir="ltr"] .findbar * {
  position: relative;
  float: left;
}
html[dir="rtl"] #toolbarViewerLeft > *,
html[dir="rtl"] #toolbarViewerMiddle > *,
html[dir="rtl"] #toolbarViewerRight > *,
html[dir="rtl"] #toolbarSidebarLeft *,
html[dir="rtl"] #toolbarSidebarRight *,
html[dir="rtl"] .findbar * {
  position: relative;
  float: right;
}

.splitToolbarButton {
  margin: 2px 2px 0;
  display: inline-block;
}
html[dir="ltr"] .splitToolbarButton > .toolbarButton {
  float: left;
}
html[dir="rtl"] .splitToolbarButton > .toolbarButton {
  float: right;
}

.toolbarButton,
.secondaryToolbarButton,
.overlayButton {
  border: 0 none;
  background: none;
  width: 28px;
  height: 28px;
}

.overlayButton:hover,
.overlayButton:focus {
  background-color: var(--overlay-button-hover-bg-color);
}

.overlayButton:hover > span,
.overlayButton:focus > span {
  color: var(--overlay-button-hover-color);
}

.toolbarButton > span {
  display: inline-block;
  width: 0;
  height: 0;
  overflow: hidden;
}

.toolbarButton[disabled],
.secondaryToolbarButton[disabled],
.overlayButton[disabled] {
  opacity: 0.5;
}

.splitToolbarButton.toggled .toolbarButton {
  margin: 0;
}

.splitToolbarButton > .toolbarButton:hover,
.splitToolbarButton > .toolbarButton:focus,
.dropdownToolbarButton:hover,
.toolbarButton.textButton:hover,
.toolbarButton.textButton:focus {
  background-color: var(--button-hover-color);
  z-index: 199;
}
.splitToolbarButton > .toolbarButton {
  position: relative;
}
html[dir="ltr"] .splitToolbarButton > .toolbarButton:first-child,
html[dir="rtl"] .splitToolbarButton > .toolbarButton:last-child {
  margin: 0;
}
html[dir="ltr"] .splitToolbarButton > .toolbarButton:last-child,
html[dir="rtl"] .splitToolbarButton > .toolbarButton:first-child {
  margin: 0;
}
.splitToolbarButtonSeparator {
  padding: 10px 0;
  width: 1px;
  background-color: var(--separator-color);
  z-index: 99;
  display: inline-block;
  margin: 4px 0;
}

.findbar .splitToolbarButtonSeparator {
  background-color: var(--field-border-color);
  margin: 0;
  padding: 13px 0;
}

html[dir="ltr"] .splitToolbarButtonSeparator {
  float: left;
}
html[dir="rtl"] .splitToolbarButtonSeparator {
  float: right;
}

.toolbarButton,
.dropdownToolbarButton,
.secondaryToolbarButton,
.overlayButton {
  min-width: 16px;
  margin: 2px 1px;
  padding: 2px 6px 0;
  border: none;
  border-radius: 2px;
  color: var(--main-color);
  font-size: 12px;
  line-height: 14px;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  cursor: default;
  box-sizing: border-box;
}

html[dir="ltr"] #toolbarViewerLeft > .toolbarButton:first-child,
html[dir="rtl"] #toolbarViewerRight > .toolbarButton:last-child {
  margin-left: 2px;
}

html[dir="ltr"] #toolbarViewerRight > .toolbarButton:last-child,
html[dir="rtl"] #toolbarViewerLeft > .toolbarButton:first-child {
  margin-right: 2px;
}
.toolbarButton:hover,
.toolbarButton:focus {
  background-color: var(--button-hover-color);
}
.secondaryToolbarButton:hover,
.secondaryToolbarButton:focus {
  background-color: var(--doorhanger-hover-bg-color);
  color: var(--doorhanger-hover-color);
}

.toolbarButton.toggled,
.splitToolbarButton.toggled > .toolbarButton.toggled,
.secondaryToolbarButton.toggled {
  background-color: var(--toggled-btn-bg-color);
  color: var(--toggled-btn-color);
}

.secondaryToolbarButton.toggled::before {
  background-color: var(--toggled-btn-color);
}

.toolbarButton.toggled::before {
  background-color: var(--toggled-btn-color);
}

.toolbarButton.toggled:hover:active,
.splitToolbarButton.toggled > .toolbarButton.toggled:hover:active,
.secondaryToolbarButton.toggled:hover:active {
  background-color: var(--toggled-hover-active-btn-color);
}

.dropdownToolbarButton {
  width: 140px;
  padding: 0;
  overflow: hidden;
  background-color: var(--dropdown-btn-bg-color);
  margin-top: 2px !important;
}
.dropdownToolbarButton::after {
  top: 6px;
  pointer-events: none;

  -webkit-mask-image: var(--toolbarButton-menuArrow-icon);
  mask-image: var(--toolbarButton-menuArrow-icon);
}
html[dir="ltr"] .dropdownToolbarButton::after {
  right: 7px;
}
html[dir="rtl"] .dropdownToolbarButton::after {
  left: 7px;
}

.dropdownToolbarButton > select {
  width: 162px;
  height: 28px;
  font-size: 12px;
  color: var(--main-color);
  margin: 0;
  padding: 1px 0 2px;
  border: none;
  background-color: var(--dropdown-btn-bg-color);
}
html[dir="ltr"] .dropdownToolbarButton > select {
  padding-left: 4px;
}
html[dir="rtl"] .dropdownToolbarButton > select {
  padding-right: 4px;
}
.dropdownToolbarButton > select:hover,
.dropdownToolbarButton > select:focus {
  background-color: var(--button-hover-color);
  color: var(--toggled-btn-color);
}

.dropdownToolbarButton > select > option {
  background: var(--doorhanger-bg-color);
  color: var(--main-color);
}

#customScaleOption {
  display: none;
}

#pageWidthOption {
  border-bottom: 1px rgba(255, 255, 255, 0.5) solid;
}

.toolbarButtonSpacer {
  width: 30px;
  display: inline-block;
  height: 1px;
}

.toolbarButton::before,
.secondaryToolbarButton::before,
.dropdownToolbarButton::after,
.treeItemToggler::before {
  /* All matching images have a size of 16x16
   * All relevant containers have a size of 28x28 */
  position: absolute;
  display: inline-block;
  width: 16px;
  height: 16px;

  content: "";
  background-color: var(--toolbar-icon-bg-color);
  -webkit-mask-size: cover;
  mask-size: cover;
}

.dropdownToolbarButton:hover::after,
.dropdownToolbarButton:focus::after,
.dropdownToolbarButton:active::after {
  background-color: var(--toolbar-icon-hover-bg-color);
}

.toolbarButton::before {
  opacity: var(--toolbar-icon-opacity);
  top: 6px;
  left: 6px;
}

.toolbarButton:hover::before,
.toolbarButton:focus::before,
.secondaryToolbarButton:hover::before,
.secondaryToolbarButton:focus::before {
  background-color: var(--toolbar-icon-hover-bg-color);
}

.secondaryToolbarButton::before {
  opacity: var(--doorhanger-icon-opacity);
  top: 5px;
}
html[dir="ltr"] .secondaryToolbarButton::before {
  left: 12px;
}
html[dir="rtl"] .secondaryToolbarButton::before {
  right: 12px;
}

.toolbarButton#sidebarToggle::before {
  -webkit-mask-image: var(--toolbarButton-sidebarToggle-icon);
  mask-image: var(--toolbarButton-sidebarToggle-icon);
}
html[dir="rtl"] .toolbarButton#sidebarToggle::before {
  transform: scaleX(-1);
}

.toolbarButton#secondaryToolbarToggle::before {
  -webkit-mask-image: var(--toolbarButton-secondaryToolbarToggle-icon);
  mask-image: var(--toolbarButton-secondaryToolbarToggle-icon);
}
html[dir="rtl"] .toolbarButton#secondaryToolbarToggle::before {
  transform: scaleX(-1);
}

.toolbarButton.findPrevious::before {
  -webkit-mask-image: var(--findbarButton-previous-icon);
  mask-image: var(--findbarButton-previous-icon);
}

.toolbarButton.findNext::before {
  -webkit-mask-image: var(--findbarButton-next-icon);
  mask-image: var(--findbarButton-next-icon);
}

.toolbarButton.pageUp::before {
  -webkit-mask-image: var(--toolbarButton-pageUp-icon);
  mask-image: var(--toolbarButton-pageUp-icon);
}

.toolbarButton.pageDown::before {
  -webkit-mask-image: var(--toolbarButton-pageDown-icon);
  mask-image: var(--toolbarButton-pageDown-icon);
}

.toolbarButton.zoomOut::before {
  -webkit-mask-image: var(--toolbarButton-zoomOut-icon);
  mask-image: var(--toolbarButton-zoomOut-icon);
}

.toolbarButton.zoomIn::before {
  -webkit-mask-image: var(--toolbarButton-zoomIn-icon);
  mask-image: var(--toolbarButton-zoomIn-icon);
}

.toolbarButton.presentationMode::before,
.secondaryToolbarButton.presentationMode::before {
  -webkit-mask-image: var(--toolbarButton-presentationMode-icon);
  mask-image: var(--toolbarButton-presentationMode-icon);
}

.toolbarButton.print::before,
.secondaryToolbarButton.print::before {
  -webkit-mask-image: var(--toolbarButton-print-icon);
  mask-image: var(--toolbarButton-print-icon);
}

.toolbarButton.openFile::before,
.secondaryToolbarButton.openFile::before {
  -webkit-mask-image: var(--toolbarButton-openFile-icon);
  mask-image: var(--toolbarButton-openFile-icon);
}

.toolbarButton.download::before,
.secondaryToolbarButton.download::before {
  -webkit-mask-image: var(--toolbarButton-download-icon);
  mask-image: var(--toolbarButton-download-icon);
}

.secondaryToolbarButton.bookmark {
  padding-top: 6px;
  text-decoration: none;
}

.bookmark[href="#"] {
  opacity: 0.5;
  pointer-events: none;
}

.toolbarButton.bookmark::before,
.secondaryToolbarButton.bookmark::before {
  -webkit-mask-image: var(--toolbarButton-bookmark-icon);
  mask-image: var(--toolbarButton-bookmark-icon);
}

#viewThumbnail.toolbarButton::before {
  -webkit-mask-image: var(--toolbarButton-viewThumbnail-icon);
  mask-image: var(--toolbarButton-viewThumbnail-icon);
}

#viewOutline.toolbarButton::before {
  -webkit-mask-image: var(--toolbarButton-viewOutline-icon);
  mask-image: var(--toolbarButton-viewOutline-icon);
}
html[dir="rtl"] #viewOutline.toolbarButton::before {
  transform: scaleX(-1);
}

#viewAttachments.toolbarButton::before {
  -webkit-mask-image: var(--toolbarButton-viewAttachments-icon);
  mask-image: var(--toolbarButton-viewAttachments-icon);
}

#viewLayers.toolbarButton::before {
  -webkit-mask-image: var(--toolbarButton-viewLayers-icon);
  mask-image: var(--toolbarButton-viewLayers-icon);
}

#currentOutlineItem.toolbarButton::before {
  -webkit-mask-image: var(--toolbarButton-currentOutlineItem-icon);
  mask-image: var(--toolbarButton-currentOutlineItem-icon);
}
html[dir="rtl"] #currentOutlineItem.toolbarButton::before {
  transform: scaleX(-1);
}

#viewFind.toolbarButton::before {
  -webkit-mask-image: var(--toolbarButton-search-icon);
  mask-image: var(--toolbarButton-search-icon);
}

.toolbarButton.pdfSidebarNotification::after {
  position: absolute;
  display: inline-block;
  top: 1px;
  /* Create a filled circle, with a diameter of 9 pixels, using only CSS: */
  content: "";
  background-color: rgba(112, 219, 85, 1);
  height: 9px;
  width: 9px;
  border-radius: 50%;
}
html[dir="ltr"] .toolbarButton.pdfSidebarNotification::after {
  left: 17px;
}
html[dir="rtl"] .toolbarButton.pdfSidebarNotification::after {
  right: 17px;
}

.secondaryToolbarButton {
  position: relative;
  margin: 0;
  padding: 0 0 1px;
  height: auto;
  min-height: 26px;
  width: auto;
  min-width: 100%;
  white-space: normal;
  border-radius: 0;
  box-sizing: border-box;
}
html[dir="ltr"] .secondaryToolbarButton {
  padding-left: 36px;
  text-align: left;
}
html[dir="rtl"] .secondaryToolbarButton {
  padding-right: 36px;
  text-align: right;
}

html[dir="ltr"] .secondaryToolbarButton > span {
  padding-right: 4px;
}
html[dir="rtl"] .secondaryToolbarButton > span {
  padding-left: 4px;
}

.secondaryToolbarButton.firstPage::before {
  -webkit-mask-image: var(--secondaryToolbarButton-firstPage-icon);
  mask-image: var(--secondaryToolbarButton-firstPage-icon);
}

.secondaryToolbarButton.lastPage::before {
  -webkit-mask-image: var(--secondaryToolbarButton-lastPage-icon);
  mask-image: var(--secondaryToolbarButton-lastPage-icon);
}

.secondaryToolbarButton.rotateCcw::before {
  -webkit-mask-image: var(--secondaryToolbarButton-rotateCcw-icon);
  mask-image: var(--secondaryToolbarButton-rotateCcw-icon);
}

.secondaryToolbarButton.rotateCw::before {
  -webkit-mask-image: var(--secondaryToolbarButton-rotateCw-icon);
  mask-image: var(--secondaryToolbarButton-rotateCw-icon);
}

.secondaryToolbarButton.selectTool::before {
  -webkit-mask-image: var(--secondaryToolbarButton-selectTool-icon);
  mask-image: var(--secondaryToolbarButton-selectTool-icon);
}

.secondaryToolbarButton.handTool::before {
  -webkit-mask-image: var(--secondaryToolbarButton-handTool-icon);
  mask-image: var(--secondaryToolbarButton-handTool-icon);
}

.secondaryToolbarButton.scrollVertical::before {
  -webkit-mask-image: var(--secondaryToolbarButton-scrollVertical-icon);
  mask-image: var(--secondaryToolbarButton-scrollVertical-icon);
}

.secondaryToolbarButton.scrollHorizontal::before {
  -webkit-mask-image: var(--secondaryToolbarButton-scrollHorizontal-icon);
  mask-image: var(--secondaryToolbarButton-scrollHorizontal-icon);
}

.secondaryToolbarButton.scrollWrapped::before {
  -webkit-mask-image: var(--secondaryToolbarButton-scrollWrapped-icon);
  mask-image: var(--secondaryToolbarButton-scrollWrapped-icon);
}

.secondaryToolbarButton.spreadNone::before {
  -webkit-mask-image: var(--secondaryToolbarButton-spreadNone-icon);
  mask-image: var(--secondaryToolbarButton-spreadNone-icon);
}

.secondaryToolbarButton.spreadOdd::before {
  -webkit-mask-image: var(--secondaryToolbarButton-spreadOdd-icon);
  mask-image: var(--secondaryToolbarButton-spreadOdd-icon);
}

.secondaryToolbarButton.spreadEven::before {
  -webkit-mask-image: var(--secondaryToolbarButton-spreadEven-icon);
  mask-image: var(--secondaryToolbarButton-spreadEven-icon);
}

.secondaryToolbarButton.documentProperties::before {
  -webkit-mask-image: var(--secondaryToolbarButton-documentProperties-icon);
  mask-image: var(--secondaryToolbarButton-documentProperties-icon);
}

.verticalToolbarSeparator {
  display: block;
  padding: 11px 0;
  margin: 5px 2px;
  width: 1px;
  background-color: var(--separator-color);
}
html[dir="ltr"] .verticalToolbarSeparator {
  margin-left: 2px;
}
html[dir="rtl"] .verticalToolbarSeparator {
  margin-right: 2px;
}

.horizontalToolbarSeparator {
  display: block;
  margin: 6px 0 5px;
  height: 1px;
  width: 100%;
  border-top: 1px solid var(--doorhanger-separator-color);
}

.toolbarField {
  padding: 4px 7px;
  margin: 3px 0;
  border-radius: 2px;
  background-color: var(--field-bg-color);
  background-clip: padding-box;
  border-width: 1px;
  border-style: solid;
  border-color: var(--field-border-color);
  box-shadow: none;
  color: var(--field-color);
  font-size: 12px;
  line-height: 16px;
  outline-style: none;
}

.toolbarField[type="checkbox"] {
  opacity: 0;
  position: absolute !important;
  left: 0;
}

html[dir="ltr"] .toolbarField[type="checkbox"] {
  margin: 10px 0 3px 7px;
}

html[dir="rtl"] .toolbarField[type="checkbox"] {
  margin: 10px 7px 3px 0;
}

.toolbarField.pageNumber {
  -moz-appearance: textfield; /* hides the spinner in moz */
  min-width: 16px;
  text-align: right;
  width: 40px;
}

.toolbarField.pageNumber.visiblePageIsLoading {
  background-image: var(--loading-icon);
  background-repeat: no-repeat;
  background-position: 3px;
}

.toolbarField.pageNumber::-webkit-inner-spin-button,
.toolbarField.pageNumber::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.toolbarField:focus {
  border-color: #0a84ff;
}

.toolbarLabel {
  min-width: 16px;
  padding: 7px;
  margin: 2px;
  border-radius: 2px;
  color: var(--main-color);
  font-size: 12px;
  line-height: 14px;
  text-align: left;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  cursor: default;
}

html[dir="ltr"] #numPages.toolbarLabel {
  padding-left: 3px;
}
html[dir="rtl"] #numPages.toolbarLabel {
  padding-right: 3px;
}

#thumbnailView {
  position: absolute;
  width: calc(100% - 60px);
  top: 0;
  bottom: 0;
  padding: 10px 30px 0;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

#thumbnailView > a:active,
#thumbnailView > a:focus {
  outline: 0;
}

.thumbnail {
  margin: 0 10px 5px;
}
html[dir="ltr"] .thumbnail {
  float: left;
}
html[dir="rtl"] .thumbnail {
  float: right;
}

#thumbnailView > a:last-of-type > .thumbnail {
  margin-bottom: 10px;
}

#thumbnailView > a:last-of-type > .thumbnail:not([data-loaded]) {
  margin-bottom: 9px;
}

.thumbnail:not([data-loaded]) {
  border: 1px dashed rgba(132, 132, 132, 1);
  margin: -1px 9px 4px;
}

.thumbnailImage {
  border: 1px solid rgba(0, 0, 0, 0);
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.3);
  opacity: 0.8;
  z-index: 99;
  background-color: rgba(255, 255, 255, 1);
  background-clip: content-box;
}

.thumbnailSelectionRing {
  border-radius: 2px;
  padding: 7px;
}

a:focus > .thumbnail > .thumbnailSelectionRing > .thumbnailImage,
.thumbnail:hover > .thumbnailSelectionRing > .thumbnailImage {
  opacity: 0.9;
}

a:focus > .thumbnail > .thumbnailSelectionRing,
.thumbnail:hover > .thumbnailSelectionRing {
  background-color: var(--sidebaritem-bg-color);
  background-clip: padding-box;
  color: rgba(255, 255, 255, 0.9);
}

.thumbnail.selected > .thumbnailSelectionRing > .thumbnailImage {
  opacity: 1;
}

.thumbnail.selected > .thumbnailSelectionRing {
  background-color: var(--sidebaritem-bg-color);
  background-clip: padding-box;
  color: rgba(255, 255, 255, 1);
}

#outlineView,
#attachmentsView,
#layersView {
  position: absolute;
  width: calc(100% - 8px);
  top: 0;
  bottom: 0;
  padding: 4px 4px 0;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}

html[dir="ltr"] .treeWithDeepNesting > .treeItem,
html[dir="ltr"] .treeItem > .treeItems {
  margin-left: 20px;
}

html[dir="rtl"] .treeWithDeepNesting > .treeItem,
html[dir="rtl"] .treeItem > .treeItems {
  margin-right: 20px;
}

.treeItem > a {
  text-decoration: none;
  display: inline-block;
  min-width: 95%;
  /* Subtract the right padding (left, in RTL mode) of the container: */
  min-width: calc(100% - 4px);
  height: auto;
  margin-bottom: 1px;
  border-radius: 2px;
  color: var(--treeitem-color);
  font-size: 13px;
  line-height: 15px;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  white-space: normal;
  cursor: pointer;
}
html[dir="ltr"] .treeItem > a {
  padding: 2px 0 5px 4px;
}
html[dir="rtl"] .treeItem > a {
  padding: 2px 4px 5px 0;
}

#layersView .treeItem > a > * {
  cursor: pointer;
}
html[dir="ltr"] #layersView .treeItem > a > label {
  padding-left: 4px;
}
html[dir="rtl"] #layersView .treesItem > a > label {
  padding-right: 4px;
}

.treeItemToggler {
  position: relative;
  height: 0;
  width: 0;
  color: rgba(255, 255, 255, 0.5);
}
.treeItemToggler::before {
  -webkit-mask-image: var(--treeitem-expanded-icon);
  mask-image: var(--treeitem-expanded-icon);
}
.treeItemToggler.treeItemsHidden::before {
  -webkit-mask-image: var(--treeitem-collapsed-icon);
  mask-image: var(--treeitem-collapsed-icon);
}
html[dir="rtl"] .treeItemToggler.treeItemsHidden::before {
  transform: scaleX(-1);
}
.treeItemToggler.treeItemsHidden ~ .treeItems {
  display: none;
}
html[dir="ltr"] .treeItemToggler {
  float: left;
}
html[dir="rtl"] .treeItemToggler {
  float: right;
}
html[dir="ltr"] .treeItemToggler::before {
  right: 4px;
}
html[dir="rtl"] .treeItemToggler::before {
  left: 4px;
}

.treeItem.selected > a {
  background-color: var(--treeitem-selected-bg-color);
  color: var(--treeitem-selected-color);
}

.treeItemToggler:hover,
.treeItemToggler:hover + a,
.treeItemToggler:hover ~ .treeItems,
.treeItem > a:hover {
  background-color: var(--sidebaritem-bg-color);
  background-clip: padding-box;
  border-radius: 2px;
  color: var(--treeitem-hover-color);
}

/* TODO: file FF bug to support ::-moz-selection:window-inactive
   so we can override the opaque grey background when the window is inactive;
   see https://bugzilla.mozilla.org/show_bug.cgi?id=706209 */
::-moz-selection {
  background: rgba(0, 0, 255, 0.3);
}
::selection {
  background: rgba(0, 0, 255, 0.3);
}

#errorWrapper {
  background: none repeat scroll 0 0 var(--errorWrapper-bg-color);
  color: var(--main-color);
  left: 0;
  position: absolute;
  right: 0;
  z-index: 1000;
  padding: 3px 6px;
}

#errorMessageLeft {
  float: left;
}

#errorMessageRight {
  float: right;
}

#errorMoreInfo {
  background-color: var(--field-bg-color);
  color: var(--field-color);
  border: 1px solid var(--field-border-color);
  padding: 3px;
  margin: 3px;
  width: 98%;
}

.overlayButton {
  width: auto;
  margin: 3px 4px 2px !important;
  padding: 2px 11px;
  color: var(--main-color);
  background-color: var(--overlay-button-bg-color);
  border: var(--overlay-button-border) !important;
}

#overlayContainer {
  display: table;
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.2);
  z-index: 40000;
}
#overlayContainer > * {
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

#overlayContainer > .container {
  display: table-cell;
  vertical-align: middle;
  text-align: center;
}

#overlayContainer > .container > .dialog {
  display: inline-block;
  padding: 15px;
  border-spacing: 4px;
  color: var(--main-color);
  font-size: 12px;
  line-height: 14px;
  background-color: var(--doorhanger-bg-color);
  border: 1px solid rgba(0, 0, 0, 0.5);
  border-radius: 4px;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
}

.dialog > .row {
  display: table-row;
}

.dialog > .row > * {
  display: table-cell;
}

.dialog .toolbarField {
  margin: 5px 0;
}

.dialog .separator {
  display: block;
  margin: 4px 0;
  height: 1px;
  width: 100%;
  background-color: var(--separator-color);
}

.dialog .buttonRow {
  text-align: center;
  vertical-align: middle;
}

.dialog :link {
  color: rgba(255, 255, 255, 1);
}

#passwordOverlay > .dialog {
  text-align: center;
}
#passwordOverlay .toolbarField {
  width: 200px;
}

#documentPropertiesOverlay > .dialog {
  text-align: left;
}
#documentPropertiesOverlay .row > * {
  min-width: 100px;
}
html[dir="ltr"] #documentPropertiesOverlay .row > * {
  text-align: left;
}
html[dir="rtl"] #documentPropertiesOverlay .row > * {
  text-align: right;
}
#documentPropertiesOverlay .row > span {
  width: 125px;
  word-wrap: break-word;
}
#documentPropertiesOverlay .row > p {
  max-width: 225px;
  word-wrap: break-word;
}
#documentPropertiesOverlay .buttonRow {
  margin-top: 10px;
}

.clearBoth {
  clear: both;
}

.fileInput {
  background: rgba(255, 255, 255, 1);
  color: rgba(0, 0, 0, 1);
  margin-top: 5px;
  visibility: hidden;
  position: fixed;
  right: 0;
  top: 0;
}

#PDFBug {
  background: none repeat scroll 0 0 rgba(255, 255, 255, 1);
  border: 1px solid rgba(102, 102, 102, 1);
  position: fixed;
  top: 32px;
  right: 0;
  bottom: 0;
  font-size: 10px;
  padding: 0;
  width: 300px;
}
#PDFBug .controls {
  background: rgba(238, 238, 238, 1);
  border-bottom: 1px solid rgba(102, 102, 102, 1);
  padding: 3px;
}
#PDFBug .panels {
  bottom: 0;
  left: 0;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  position: absolute;
  right: 0;
  top: 27px;
}
#PDFBug .panels > div {
  padding: 5px;
}
#PDFBug button.active {
  font-weight: bold;
}
.debuggerShowText {
  background: none repeat scroll 0 0 rgba(255, 255, 0, 1);
  color: rgba(0, 0, 255, 1);
}
.debuggerHideText:hover {
  background: none repeat scroll 0 0 rgba(255, 255, 0, 1);
}
#PDFBug .stats {
  font-family: courier;
  font-size: 10px;
  white-space: pre;
}
#PDFBug .stats .title {
  font-weight: bold;
}
#PDFBug table {
  font-size: 10px;
}

#viewer.textLayer-visible .textLayer {
  opacity: 1;
}

#viewer.textLayer-visible .canvasWrapper {
  background-color: rgba(128, 255, 128, 1);
}

#viewer.textLayer-visible .canvasWrapper canvas {
  mix-blend-mode: screen;
}

#viewer.textLayer-visible .textLayer span {
  background-color: rgba(255, 255, 0, 0.1);
  color: rgba(0, 0, 0, 1);
  border: solid 1px rgba(255, 0, 0, 0.5);
  box-sizing: border-box;
}

#viewer.textLayer-hover .textLayer span:hover {
  background-color: rgba(255, 255, 255, 1);
  color: rgba(0, 0, 0, 1);
}

#viewer.textLayer-shadow .textLayer span {
  background-color: rgba(255, 255, 255, 0.6);
  color: rgba(0, 0, 0, 1);
}

.grab-to-pan-grab {
  cursor: url("images/grab.cur"), move !important;
  cursor: -webkit-grab !important;
  cursor: grab !important;
}
.grab-to-pan-grab
  *:not(input):not(textarea):not(button):not(select):not(:link) {
  cursor: inherit !important;
}
.grab-to-pan-grab:active,
.grab-to-pan-grabbing {
  cursor: url("images/grabbing.cur"), move !important;
  cursor: -webkit-grabbing !important;
  cursor: grabbing !important;
  position: fixed;
  background: rgba(0, 0, 0, 0);
  display: block;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
  z-index: 50000; /* should be higher than anything else in PDF.js! */
}

@page {
  margin: 0;
}

#printContainer {
  display: none;
}

@media print {
  /* General rules for printing. */
  body {
    background: rgba(0, 0, 0, 0) none;
  }

  /* Rules for browsers that don't support mozPrintCallback. */
  #sidebarContainer,
  #secondaryToolbar,
  .toolbar,
  #loadingBox,
  #errorWrapper,
  .textLayer {
    display: none;
  }
  #viewerContainer {
    overflow: visible;
  }

  #mainContainer,
  #viewerContainer,
  .page,
  .page canvas {
    position: static;
    padding: 0;
    margin: 0;
  }

  .page {
    float: left;
    display: none;
    border: none;
    box-shadow: none;
    background-clip: content-box;
    background-color: rgba(255, 255, 255, 1);
  }

  .page[data-loaded] {
    display: block;
  }

  .fileInput {
    display: none;
  }

  /* Rules for browsers that support PDF.js printing */
  body[data-pdfjsprinting] #outerContainer {
    display: none;
  }
  body[data-pdfjsprinting] #printContainer {
    display: block;
  }
  #printContainer {
    height: 100%;
  }
  /* wrapper around (scaled) print canvas elements */
  #printContainer > div {
    page-break-after: always;
    page-break-inside: avoid;

    /* The wrapper always cover the whole page. */
    height: 100%;
    width: 100%;

    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  #printContainer canvas,
  #printContainer img {
    /* The intrinsic canvas / image size will make sure that we fit the page. */
    max-width: 100%;
    max-height: 100%;

    direction: ltr;
    display: block;
  }
}

.visibleLargeView,
.visibleMediumView,
.visibleSmallView {
  display: none;
}

@media all and (max-width: 900px) {
  #toolbarViewerMiddle {
    display: table;
    margin: auto;
    left: auto;
    position: inherit;
    transform: none;
  }
}

@media all and (max-width: 840px) {
  #sidebarContainer {
    background-color: var(--sidebar-narrow-bg-color);
  }

  html[dir="ltr"] #outerContainer.sidebarOpen #viewerContainer {
    left: 0 !important;
  }
  html[dir="rtl"] #outerContainer.sidebarOpen #viewerContainer {
    right: 0 !important;
  }

  #outerContainer .hiddenLargeView,
  #outerContainer .hiddenMediumView {
    display: inherit;
  }
  #outerContainer .visibleLargeView,
  #outerContainer .visibleMediumView {
    display: none;
  }
}

@media all and (max-width: 770px) {
  #outerContainer .hiddenLargeView {
    display: none;
  }
  #outerContainer .visibleLargeView {
    display: inherit;
  }
}

@media all and (max-width: 700px) {
  #outerContainer .hiddenMediumView {
    display: none;
  }
  #outerContainer .visibleMediumView {
    display: inherit;
  }
}

@media all and (max-width: 640px) {
  .hiddenSmallView,
  .hiddenSmallView * {
    display: none;
  }
  .visibleSmallView {
    display: inherit;
  }
  .toolbarButtonSpacer {
    width: 0;
  }
  html[dir="ltr"] .findbar {
    left: 34px;
  }
  html[dir="rtl"] .findbar {
    right: 34px;
  }
}

@media all and (max-width: 535px) {
  #scaleSelectContainer {
    display: none;
  }
}
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/web/viewer.html</url>
    <content><![CDATA[<!DOCTYPE html>
<!--
Copyright 2012 Mozilla Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Adobe CMap resources are covered by their own copyright but the same license:

    Copyright 1990-2015 Adobe Systems Incorporated.

See https://github.com/adobe-type-tools/cmap-resources
-->
<html dir="ltr" mozdisallowselectionprint>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="google" content="notranslate">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>PDF.js viewer</title>


    <link rel="stylesheet" href="viewer.css">


<!-- This snippet is used in production (included from viewer.html) -->
<link rel="resource" type="application/l10n" href="locale/locale.properties">
<script src="../build/pdf.js"></script>


  <script src="viewer.js"></script>

  </head>

  <body tabindex="1">
    <div id="outerContainer">

      <div id="sidebarContainer">
        <div id="toolbarSidebar">
          <div id="toolbarSidebarLeft">
            <div class="splitToolbarButton toggled">
              <button id="viewThumbnail" class="toolbarButton toggled" title="Show Thumbnails" tabindex="2" data-l10n-id="thumbs">
                 <span data-l10n-id="thumbs_label">Thumbnails</span>
              </button>
              <button id="viewOutline" class="toolbarButton" title="Show Document Outline (double-click to expand/collapse all items)" tabindex="3" data-l10n-id="document_outline">
                 <span data-l10n-id="document_outline_label">Document Outline</span>
              </button>
              <button id="viewAttachments" class="toolbarButton" title="Show Attachments" tabindex="4" data-l10n-id="attachments">
                 <span data-l10n-id="attachments_label">Attachments</span>
              </button>
              <button id="viewLayers" class="toolbarButton" title="Show Layers (double-click to reset all layers to the default state)" tabindex="5" data-l10n-id="layers">
                 <span data-l10n-id="layers_label">Layers</span>
              </button>
            </div>
          </div>

          <div id="toolbarSidebarRight">
            <div id="outlineOptionsContainer" class="hidden">
              <div class="verticalToolbarSeparator"></div>

              <button id="currentOutlineItem" class="toolbarButton" disabled="disabled" title="Find Current Outline Item" tabindex="6" data-l10n-id="current_outline_item">
                <span data-l10n-id="current_outline_item_label">Current Outline Item</span>
              </button>
            </div>
          </div>
        </div>
        <div id="sidebarContent">
          <div id="thumbnailView">
          </div>
          <div id="outlineView" class="hidden">
          </div>
          <div id="attachmentsView" class="hidden">
          </div>
          <div id="layersView" class="hidden">
          </div>
        </div>
        <div id="sidebarResizer"></div>
      </div>  <!-- sidebarContainer -->

      <div id="mainContainer">
        <div class="findbar hidden doorHanger" id="findbar">
          <div id="findbarInputContainer">
            <input id="findInput" class="toolbarField" title="Find" placeholder="Find in document…" tabindex="91" data-l10n-id="find_input">
            <div class="splitToolbarButton">
              <button id="findPrevious" class="toolbarButton findPrevious" title="Find the previous occurrence of the phrase" tabindex="92" data-l10n-id="find_previous">
                <span data-l10n-id="find_previous_label">Previous</span>
              </button>
              <div class="splitToolbarButtonSeparator"></div>
              <button id="findNext" class="toolbarButton findNext" title="Find the next occurrence of the phrase" tabindex="93" data-l10n-id="find_next">
                <span data-l10n-id="find_next_label">Next</span>
              </button>
            </div>
          </div>

          <div id="findbarOptionsOneContainer">
            <input type="checkbox" id="findHighlightAll" class="toolbarField" tabindex="94">
            <label for="findHighlightAll" class="toolbarLabel" data-l10n-id="find_highlight">Highlight all</label>
            <input type="checkbox" id="findMatchCase" class="toolbarField" tabindex="95">
            <label for="findMatchCase" class="toolbarLabel" data-l10n-id="find_match_case_label">Match case</label>
          </div>
          <div id="findbarOptionsTwoContainer">
            <input type="checkbox" id="findEntireWord" class="toolbarField" tabindex="96">
            <label for="findEntireWord" class="toolbarLabel" data-l10n-id="find_entire_word_label">Whole words</label>
            <span id="findResultsCount" class="toolbarLabel hidden"></span>
          </div>

          <div id="findbarMessageContainer">
            <span id="findMsg" class="toolbarLabel"></span>
          </div>
        </div>  <!-- findbar -->

        <div id="secondaryToolbar" class="secondaryToolbar hidden doorHangerRight">
          <div id="secondaryToolbarButtonContainer">
            <button id="secondaryPresentationMode" class="secondaryToolbarButton presentationMode visibleLargeView" title="Switch to Presentation Mode" tabindex="51" data-l10n-id="presentation_mode">
              <span data-l10n-id="presentation_mode_label">Presentation Mode</span>
            </button>

            <button id="secondaryOpenFile" class="secondaryToolbarButton openFile visibleLargeView" title="Open File" tabindex="52" data-l10n-id="open_file">
              <span data-l10n-id="open_file_label">Open</span>
            </button>

            <button id="secondaryPrint" class="secondaryToolbarButton print visibleMediumView" title="Print" tabindex="53" data-l10n-id="print">
              <span data-l10n-id="print_label">Print</span>
            </button>

            <button id="secondaryDownload" class="secondaryToolbarButton download visibleMediumView" title="Download" tabindex="54" data-l10n-id="download">
              <span data-l10n-id="download_label">Download</span>
            </button>

            <a href="#" id="secondaryViewBookmark" class="secondaryToolbarButton bookmark visibleSmallView" title="Current view (copy or open in new window)" tabindex="55" data-l10n-id="bookmark">
              <span data-l10n-id="bookmark_label">Current View</span>
            </a>

            <div class="horizontalToolbarSeparator visibleLargeView"></div>

            <button id="firstPage" class="secondaryToolbarButton firstPage" title="Go to First Page" tabindex="56" data-l10n-id="first_page">
              <span data-l10n-id="first_page_label">Go to First Page</span>
            </button>
            <button id="lastPage" class="secondaryToolbarButton lastPage" title="Go to Last Page" tabindex="57" data-l10n-id="last_page">
              <span data-l10n-id="last_page_label">Go to Last Page</span>
            </button>

            <div class="horizontalToolbarSeparator"></div>

            <button id="pageRotateCw" class="secondaryToolbarButton rotateCw" title="Rotate Clockwise" tabindex="58" data-l10n-id="page_rotate_cw">
              <span data-l10n-id="page_rotate_cw_label">Rotate Clockwise</span>
            </button>
            <button id="pageRotateCcw" class="secondaryToolbarButton rotateCcw" title="Rotate Counterclockwise" tabindex="59" data-l10n-id="page_rotate_ccw">
              <span data-l10n-id="page_rotate_ccw_label">Rotate Counterclockwise</span>
            </button>

            <div class="horizontalToolbarSeparator"></div>

            <button id="cursorSelectTool" class="secondaryToolbarButton selectTool toggled" title="Enable Text Selection Tool" tabindex="60" data-l10n-id="cursor_text_select_tool">
              <span data-l10n-id="cursor_text_select_tool_label">Text Selection Tool</span>
            </button>
            <button id="cursorHandTool" class="secondaryToolbarButton handTool" title="Enable Hand Tool" tabindex="61" data-l10n-id="cursor_hand_tool">
              <span data-l10n-id="cursor_hand_tool_label">Hand Tool</span>
            </button>

            <div class="horizontalToolbarSeparator"></div>

            <button id="scrollVertical" class="secondaryToolbarButton scrollModeButtons scrollVertical toggled" title="Use Vertical Scrolling" tabindex="62" data-l10n-id="scroll_vertical">
              <span data-l10n-id="scroll_vertical_label">Vertical Scrolling</span>
            </button>
            <button id="scrollHorizontal" class="secondaryToolbarButton scrollModeButtons scrollHorizontal" title="Use Horizontal Scrolling" tabindex="63" data-l10n-id="scroll_horizontal">
              <span data-l10n-id="scroll_horizontal_label">Horizontal Scrolling</span>
            </button>
            <button id="scrollWrapped" class="secondaryToolbarButton scrollModeButtons scrollWrapped" title="Use Wrapped Scrolling" tabindex="64" data-l10n-id="scroll_wrapped">
              <span data-l10n-id="scroll_wrapped_label">Wrapped Scrolling</span>
            </button>

            <div class="horizontalToolbarSeparator scrollModeButtons"></div>

            <button id="spreadNone" class="secondaryToolbarButton spreadModeButtons spreadNone toggled" title="Do not join page spreads" tabindex="65" data-l10n-id="spread_none">
              <span data-l10n-id="spread_none_label">No Spreads</span>
            </button>
            <button id="spreadOdd" class="secondaryToolbarButton spreadModeButtons spreadOdd" title="Join page spreads starting with odd-numbered pages" tabindex="66" data-l10n-id="spread_odd">
              <span data-l10n-id="spread_odd_label">Odd Spreads</span>
            </button>
            <button id="spreadEven" class="secondaryToolbarButton spreadModeButtons spreadEven" title="Join page spreads starting with even-numbered pages" tabindex="67" data-l10n-id="spread_even">
              <span data-l10n-id="spread_even_label">Even Spreads</span>
            </button>

            <div class="horizontalToolbarSeparator spreadModeButtons"></div>

            <button id="documentProperties" class="secondaryToolbarButton documentProperties" title="Document Properties…" tabindex="68" data-l10n-id="document_properties">
              <span data-l10n-id="document_properties_label">Document Properties…</span>
            </button>
          </div>
        </div>  <!-- secondaryToolbar -->

        <div class="toolbar">
          <div id="toolbarContainer">
            <div id="toolbarViewer">
              <div id="toolbarViewerLeft">
                <button id="sidebarToggle" class="toolbarButton" title="Toggle Sidebar" tabindex="11" data-l10n-id="toggle_sidebar" aria-expanded="false" aria-controls="sidebarContainer">
                  <span data-l10n-id="toggle_sidebar_label">Toggle Sidebar</span>
                </button>
                <div class="toolbarButtonSpacer"></div>
                <button id="viewFind" class="toolbarButton" title="Find in Document" tabindex="12" data-l10n-id="findbar" aria-expanded="false" aria-controls="findbar">
                  <span data-l10n-id="findbar_label">Find</span>
                </button>
                <div class="splitToolbarButton hiddenSmallView">
                  <button class="toolbarButton pageUp" title="Previous Page" id="previous" tabindex="13" data-l10n-id="previous">
                    <span data-l10n-id="previous_label">Previous</span>
                  </button>
                  <div class="splitToolbarButtonSeparator"></div>
                  <button class="toolbarButton pageDown" title="Next Page" id="next" tabindex="14" data-l10n-id="next">
                    <span data-l10n-id="next_label">Next</span>
                  </button>
                </div>
                <input type="number" id="pageNumber" class="toolbarField pageNumber" title="Page" value="1" size="4" min="1" tabindex="15" data-l10n-id="page" autocomplete="off">
                <span id="numPages" class="toolbarLabel"></span>
              </div>
              <div id="toolbarViewerRight">
                <button id="presentationMode" class="toolbarButton presentationMode hiddenLargeView" title="Switch to Presentation Mode" tabindex="31" data-l10n-id="presentation_mode">
                  <span data-l10n-id="presentation_mode_label">Presentation Mode</span>
                </button>

                <button id="openFile" class="toolbarButton openFile hiddenLargeView" title="Open File" tabindex="32" data-l10n-id="open_file">
                  <span data-l10n-id="open_file_label">Open</span>
                </button>

                <button id="print" class="toolbarButton print hiddenMediumView" title="Print" tabindex="33" data-l10n-id="print">
                  <span data-l10n-id="print_label">Print</span>
                </button>

                <button id="download" class="toolbarButton download hiddenMediumView" title="Download" tabindex="34" data-l10n-id="download">
                  <span data-l10n-id="download_label">Download</span>
                </button>
                <a href="#" id="viewBookmark" class="toolbarButton bookmark hiddenSmallView" title="Current view (copy or open in new window)" tabindex="35" data-l10n-id="bookmark">
                  <span data-l10n-id="bookmark_label">Current View</span>
                </a>

                <div class="verticalToolbarSeparator hiddenSmallView"></div>

                <button id="secondaryToolbarToggle" class="toolbarButton" title="Tools" tabindex="36" data-l10n-id="tools" aria-expanded="false" aria-controls="secondaryToolbar">
                  <span data-l10n-id="tools_label">Tools</span>
                </button>
              </div>
              <div id="toolbarViewerMiddle">
                <div class="splitToolbarButton">
                  <button id="zoomOut" class="toolbarButton zoomOut" title="Zoom Out" tabindex="21" data-l10n-id="zoom_out">
                    <span data-l10n-id="zoom_out_label">Zoom Out</span>
                  </button>
                  <div class="splitToolbarButtonSeparator"></div>
                  <button id="zoomIn" class="toolbarButton zoomIn" title="Zoom In" tabindex="22" data-l10n-id="zoom_in">
                    <span data-l10n-id="zoom_in_label">Zoom In</span>
                   </button>
                </div>
                <span id="scaleSelectContainer" class="dropdownToolbarButton">
                  <select id="scaleSelect" title="Zoom" tabindex="23" data-l10n-id="zoom">
                    <option id="pageAutoOption" title="" value="auto" selected="selected" data-l10n-id="page_scale_auto">Automatic Zoom</option>
                    <option id="pageActualOption" title="" value="page-actual" data-l10n-id="page_scale_actual">Actual Size</option>
                    <option id="pageFitOption" title="" value="page-fit" data-l10n-id="page_scale_fit">Page Fit</option>
                    <option id="pageWidthOption" title="" value="page-width" data-l10n-id="page_scale_width">Page Width</option>
                    <option id="customScaleOption" title="" value="custom" disabled="disabled" hidden="true"></option>
                    <option title="" value="0.5" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 50 }'>50%</option>
                    <option title="" value="0.75" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 75 }'>75%</option>
                    <option title="" value="1" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 100 }'>100%</option>
                    <option title="" value="1.25" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 125 }'>125%</option>
                    <option title="" value="1.5" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 150 }'>150%</option>
                    <option title="" value="2" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 200 }'>200%</option>
                    <option title="" value="3" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 300 }'>300%</option>
                    <option title="" value="4" data-l10n-id="page_scale_percent" data-l10n-args='{ "scale": 400 }'>400%</option>
                  </select>
                </span>
              </div>
            </div>
            <div id="loadingBar">
              <div class="progress">
                <div class="glimmer">
                </div>
              </div>
            </div>
          </div>
        </div>

        <div id="viewerContainer" tabindex="0">
          <div id="viewer" class="pdfViewer"></div>
        </div>

        <div id="errorWrapper" hidden='true'>
          <div id="errorMessageLeft">
            <span id="errorMessage"></span>
            <button id="errorShowMore" data-l10n-id="error_more_info">
              More Information
            </button>
            <button id="errorShowLess" data-l10n-id="error_less_info" hidden='true'>
              Less Information
            </button>
          </div>
          <div id="errorMessageRight">
            <button id="errorClose" data-l10n-id="error_close">
              Close
            </button>
          </div>
          <div class="clearBoth"></div>
          <textarea id="errorMoreInfo" hidden='true' readonly="readonly"></textarea>
        </div>
      </div> <!-- mainContainer -->

      <div id="overlayContainer" class="hidden">
        <div id="passwordOverlay" class="container hidden">
          <div class="dialog">
            <div class="row">
              <p id="passwordText" data-l10n-id="password_label">Enter the password to open this PDF file:</p>
            </div>
            <div class="row">
              <input type="password" id="password" class="toolbarField">
            </div>
            <div class="buttonRow">
              <button id="passwordCancel" class="overlayButton"><span data-l10n-id="password_cancel">Cancel</span></button>
              <button id="passwordSubmit" class="overlayButton"><span data-l10n-id="password_ok">OK</span></button>
            </div>
          </div>
        </div>
        <div id="documentPropertiesOverlay" class="container hidden">
          <div class="dialog">
            <div class="row">
              <span data-l10n-id="document_properties_file_name">File name:</span> <p id="fileNameField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_file_size">File size:</span> <p id="fileSizeField">-</p>
            </div>
            <div class="separator"></div>
            <div class="row">
              <span data-l10n-id="document_properties_title">Title:</span> <p id="titleField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_author">Author:</span> <p id="authorField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_subject">Subject:</span> <p id="subjectField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_keywords">Keywords:</span> <p id="keywordsField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_creation_date">Creation Date:</span> <p id="creationDateField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_modification_date">Modification Date:</span> <p id="modificationDateField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_creator">Creator:</span> <p id="creatorField">-</p>
            </div>
            <div class="separator"></div>
            <div class="row">
              <span data-l10n-id="document_properties_producer">PDF Producer:</span> <p id="producerField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_version">PDF Version:</span> <p id="versionField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_page_count">Page Count:</span> <p id="pageCountField">-</p>
            </div>
            <div class="row">
              <span data-l10n-id="document_properties_page_size">Page Size:</span> <p id="pageSizeField">-</p>
            </div>
            <div class="separator"></div>
            <div class="row">
              <span data-l10n-id="document_properties_linearized">Fast Web View:</span> <p id="linearizedField">-</p>
            </div>
            <div class="buttonRow">
              <button id="documentPropertiesClose" class="overlayButton"><span data-l10n-id="document_properties_close">Close</span></button>
            </div>
          </div>
        </div>
        <div id="printServiceOverlay" class="container hidden">
          <div class="dialog">
            <div class="row">
              <span data-l10n-id="print_progress_message">Preparing document for printing…</span>
            </div>
            <div class="row">
              <progress value="0" max="100"></progress>
              <span data-l10n-id="print_progress_percent" data-l10n-args='{ "progress": 0 }' class="relative-progress">0%</span>
            </div>
            <div class="buttonRow">
              <button id="printCancel" class="overlayButton"><span data-l10n-id="print_progress_close">Cancel</span></button>
            </div>
          </div>
        </div>
      </div>  <!-- overlayContainer -->

    </div> <!-- outerContainer -->
    <div id="printContainer"></div>
  </body>
</html>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/build/pdf.js</url>
    <content><![CDATA[/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf", [], factory);
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf"] = factory();
	else
		root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addLinkAttributes = addLinkAttributes;
exports.deprecated = deprecated;
exports.getFilenameFromUrl = getFilenameFromUrl;
exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
exports.isDataScheme = isDataScheme;
exports.isFetchSupported = isFetchSupported;
exports.isPdfFile = isPdfFile;
exports.isValidFetchUrl = isValidFetchUrl;
exports.loadScript = loadScript;
exports.StatTimer = exports.RenderingCancelledException = exports.PDFDateString = exports.PageViewport = exports.LinkTarget = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.BaseCMapReaderFactory = exports.BaseCanvasFactory = void 0;

var _util = __w_pdfjs_require__(2);

const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
const SVG_NS = "http://www.w3.org/2000/svg";

class BaseCanvasFactory {
  constructor() {
    if (this.constructor === BaseCanvasFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
    }
  }

  create(width, height) {
    (0, _util.unreachable)("Abstract method `create` called.");
  }

  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }

  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }

}

exports.BaseCanvasFactory = BaseCanvasFactory;

class DOMCanvasFactory extends BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this._document = ownerDocument;
  }

  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    const canvas = this._document.createElement("canvas");

    const context = canvas.getContext("2d");
    canvas.width = width;
    canvas.height = height;
    return {
      canvas,
      context
    };
  }

}

exports.DOMCanvasFactory = DOMCanvasFactory;

class BaseCMapReaderFactory {
  constructor({
    baseUrl = null,
    isCompressed = false
  }) {
    if (this.constructor === BaseCMapReaderFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
    }

    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }

  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
    }

    if (!name) {
      throw new Error("CMap name must be specified.");
    }

    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
    return this._fetchData(url, compressionType).catch(reason => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }

  _fetchData(url, compressionType) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }

}

exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

class DOMCMapReaderFactory extends BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {
      return fetch(url).then(async response => {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        let cMapData;

        if (this.isCompressed) {
          cMapData = new Uint8Array(await response.arrayBuffer());
        } else {
          cMapData = (0, _util.stringToBytes)(await response.text());
        }

        return {
          cMapData,
          compressionType
        };
      });
    }

    return new Promise((resolve, reject) => {
      const request = new XMLHttpRequest();
      request.open("GET", url, true);

      if (this.isCompressed) {
        request.responseType = "arraybuffer";
      }

      request.onreadystatechange = () => {
        if (request.readyState !== XMLHttpRequest.DONE) {
          return;
        }

        if (request.status === 200 || request.status === 0) {
          let cMapData;

          if (this.isCompressed && request.response) {
            cMapData = new Uint8Array(request.response);
          } else if (!this.isCompressed && request.responseText) {
            cMapData = (0, _util.stringToBytes)(request.responseText);
          }

          if (cMapData) {
            resolve({
              cMapData,
              compressionType
            });
            return;
          }
        }

        reject(new Error(request.statusText));
      };

      request.send(null);
    });
  }

}

exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

class DOMSVGFactory {
  create(width, height) {
    (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
    const svg = document.createElementNS(SVG_NS, "svg:svg");
    svg.setAttribute("version", "1.1");
    svg.setAttribute("width", width + "px");
    svg.setAttribute("height", height + "px");
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", "0 0 " + width + " " + height);
    return svg;
  }

  createElement(type) {
    (0, _util.assert)(typeof type === "string", "Invalid SVG element type");
    return document.createElementNS(SVG_NS, type);
  }

}

exports.DOMSVGFactory = DOMSVGFactory;

class PageViewport {
  constructor({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;

    if (rotation < 0) {
      rotation += 360;
    }

    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;

      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;

      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;

      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;

      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }

    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }

    let offsetCanvasX, offsetCanvasY;
    let width, height;

    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }

    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }

  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  convertToViewportPoint(x, y) {
    return _util.Util.applyTransform([x, y], this.transform);
  }

  convertToViewportRectangle(rect) {
    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }

  convertToPdfPoint(x, y) {
    return _util.Util.applyInverseTransform([x, y], this.transform);
  }

}

exports.PageViewport = PageViewport;

class RenderingCancelledException extends _util.BaseException {
  constructor(msg, type) {
    super(msg);
    this.type = type;
  }

}

exports.RenderingCancelledException = RenderingCancelledException;
const LinkTarget = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
exports.LinkTarget = LinkTarget;

function addLinkAttributes(link, {
  url,
  target,
  rel,
  enabled = true
} = {}) {
  (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
  const urlNullRemoved = (0, _util.removeNullCharacters)(url);

  if (enabled) {
    link.href = link.title = urlNullRemoved;
  } else {
    link.href = "";
    link.title = `Disabled: ${urlNullRemoved}`;

    link.onclick = () => {
      return false;
    };
  }

  let targetStr = "";

  switch (target) {
    case LinkTarget.NONE:
      break;

    case LinkTarget.SELF:
      targetStr = "_self";
      break;

    case LinkTarget.BLANK:
      targetStr = "_blank";
      break;

    case LinkTarget.PARENT:
      targetStr = "_parent";
      break;

    case LinkTarget.TOP:
      targetStr = "_top";
      break;
  }

  link.target = targetStr;
  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
}

function isDataScheme(url) {
  const ii = url.length;
  let i = 0;

  while (i < ii && url[i].trim() === "") {
    i++;
  }

  return url.substring(i, i + 5).toLowerCase() === "data:";
}

function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}

function getFilenameFromUrl(url) {
  const anchor = url.indexOf("#");
  const query = url.indexOf("?");
  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
  return url.substring(url.lastIndexOf("/", end) + 1, end);
}

function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }

  if (isDataScheme(url)) {
    (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }

  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];

    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch (ex) {}
    }
  }

  return suggestedFilename || defaultFilename;
}

class StatTimer {
  constructor() {
    this.started = Object.create(null);
    this.times = [];
  }

  time(name) {
    if (name in this.started) {
      (0, _util.warn)(`Timer is already running for ${name}`);
    }

    this.started[name] = Date.now();
  }

  timeEnd(name) {
    if (!(name in this.started)) {
      (0, _util.warn)(`Timer has not been started for ${name}`);
    }

    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }

  toString() {
    const outBuf = [];
    let longest = 0;

    for (const time of this.times) {
      const name = time.name;

      if (name.length > longest) {
        longest = name.length;
      }
    }

    for (const time of this.times) {
      const duration = time.end - time.start;
      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`);
    }

    return outBuf.join("");
  }

}

exports.StatTimer = StatTimer;

function isFetchSupported() {
  return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
}

function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch (ex) {
    return false;
  }
}

function loadScript(src, removeScriptElement = false) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;

    script.onload = function (evt) {
      if (removeScriptElement) {
        script.remove();
      }

      resolve(evt);
    };

    script.onerror = function () {
      reject(new Error(`Cannot load script at: ${script.src}`));
    };

    (document.head || document.documentElement).appendChild(script);
  });
}

function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}

let pdfDateStringRegex;

class PDFDateString {
  static toDateObject(input) {
    if (!input || !(0, _util.isString)(input)) {
      return null;
    }

    if (!pdfDateStringRegex) {
      pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
    }

    const matches = pdfDateStringRegex.exec(input);

    if (!matches) {
      return null;
    }

    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }

    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }

}

exports.PDFDateString = PDFDateString;

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createObjectURL = createObjectURL;
exports.createPromiseCapability = createPromiseCapability;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.escapeString = escapeString;
exports.getModificationDate = getModificationDate;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isAscii = isAscii;
exports.isBool = isBool;
exports.isNum = isNum;
exports.isSameOrigin = isSameOrigin;
exports.isString = isString;
exports.objectFromMap = objectFromMap;
exports.objectSize = objectSize;
exports.removeNullCharacters = removeNullCharacters;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF16BEString = stringToUTF16BEString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
exports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;

__w_pdfjs_require__(3);

const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
const ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
const AnnotationStateModelType = {
  MARKED: "Marked",
  REVIEW: "Review"
};
exports.AnnotationStateModelType = AnnotationStateModelType;
const AnnotationMarkedState = {
  MARKED: "Marked",
  UNMARKED: "Unmarked"
};
exports.AnnotationMarkedState = AnnotationMarkedState;
const AnnotationReviewState = {
  ACCEPTED: "Accepted",
  REJECTED: "Rejected",
  CANCELLED: "Cancelled",
  COMPLETED: "Completed",
  NONE: "None"
};
exports.AnnotationReviewState = AnnotationReviewState;
const AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
const StreamType = {
  UNKNOWN: "UNKNOWN",
  FLATE: "FLATE",
  LZW: "LZW",
  DCT: "DCT",
  JPX: "JPX",
  JBIG: "JBIG",
  A85: "A85",
  AHX: "AHX",
  CCF: "CCF",
  RLX: "RLX"
};
exports.StreamType = StreamType;
const FontType = {
  UNKNOWN: "UNKNOWN",
  TYPE1: "TYPE1",
  TYPE1C: "TYPE1C",
  CIDFONTTYPE0: "CIDFONTTYPE0",
  CIDFONTTYPE0C: "CIDFONTTYPE0C",
  TRUETYPE: "TRUETYPE",
  CIDFONTTYPE2: "CIDFONTTYPE2",
  TYPE3: "TYPE3",
  OPENTYPE: "OPENTYPE",
  TYPE0: "TYPE0",
  MMTYPE1: "MMTYPE1"
};
exports.FontType = FontType;
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
exports.CMapCompressionType = CMapCompressionType;
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
const UNSUPPORTED_FEATURES = {
  unknown: "unknown",
  forms: "forms",
  javaScript: "javaScript",
  signatures: "signatures",
  smask: "smask",
  shadingPattern: "shadingPattern",
  font: "font",
  errorTilingPattern: "errorTilingPattern",
  errorExtGState: "errorExtGState",
  errorXObject: "errorXObject",
  errorFontLoadType3: "errorFontLoadType3",
  errorFontState: "errorFontState",
  errorFontMissing: "errorFontMissing",
  errorFontTranslate: "errorFontTranslate",
  errorColorSpace: "errorColorSpace",
  errorOperatorList: "errorOperatorList",
  errorFontToUnicode: "errorFontToUnicode",
  errorFontLoadNative: "errorFontLoadNative",
  errorFontBuildPath: "errorFontBuildPath",
  errorFontGetPath: "errorFontGetPath",
  errorMarkedContent: "errorMarkedContent"
};
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
let verbosity = VerbosityLevel.WARNINGS;

function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}

function getVerbosityLevel() {
  return verbosity;
}

function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function isSameOrigin(baseUrl, otherUrl) {
  let base;

  try {
    base = new URL(baseUrl);

    if (!base.origin || base.origin === "null") {
      return false;
    }
  } catch (e) {
    return false;
  }

  const other = new URL(otherUrl, base);
  return base.origin === other.origin;
}

function _isValidProtocol(url) {
  if (!url) {
    return false;
  }

  switch (url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;

    default:
      return false;
  }
}

function createValidAbsoluteUrl(url, baseUrl) {
  if (!url) {
    return null;
  }

  try {
    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}

  return null;
}

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}

const BaseException = function BaseExceptionClosure() {
  function BaseException(message) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }

    this.message = message;
    this.name = this.constructor.name;
  }

  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();

exports.BaseException = BaseException;

class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg);
    this.code = code;
  }

}

exports.PasswordException = PasswordException;

class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg);
    this.details = details;
  }

}

exports.UnknownErrorException = UnknownErrorException;

class InvalidPDFException extends BaseException {}

exports.InvalidPDFException = InvalidPDFException;

class MissingPDFException extends BaseException {}

exports.MissingPDFException = MissingPDFException;

class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg);
    this.status = status;
  }

}

exports.UnexpectedResponseException = UnexpectedResponseException;

class FormatError extends BaseException {}

exports.FormatError = FormatError;

class AbortException extends BaseException {}

exports.AbortException = AbortException;
const NullCharactersRegExp = /\x00/g;

function removeNullCharacters(str) {
  if (typeof str !== "string") {
    warn("The argument for removeNullCharacters must be a string.");
    return str;
  }

  return str.replace(NullCharactersRegExp, "");
}

function bytesToString(bytes) {
  assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;

  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }

  const strBuf = [];

  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }

  return strBuf.join("");
}

function stringToBytes(str) {
  assert(typeof str === "string", "Invalid argument for stringToBytes");
  const length = str.length;
  const bytes = new Uint8Array(length);

  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }

  return bytes;
}

function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }

  assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
  return arr.byteLength;
}

function arraysToBytes(arr) {
  const length = arr.length;

  if (length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }

  let resultLength = 0;

  for (let i = 0; i < length; i++) {
    resultLength += arrayByteLength(arr[i]);
  }

  let pos = 0;
  const data = new Uint8Array(resultLength);

  for (let i = 0; i < length; i++) {
    let item = arr[i];

    if (!(item instanceof Uint8Array)) {
      if (typeof item === "string") {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }

    const itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }

  return data;
}

function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}

function objectSize(obj) {
  return Object.keys(obj).length;
}

function objectFromMap(map) {
  const obj = Object.create(null);

  for (const [key, value] of map) {
    obj[key] = value;
  }

  return obj;
}

function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}

const IsLittleEndianCached = {
  get value() {
    return shadow(this, "value", isLittleEndian());
  }

};
exports.IsLittleEndianCached = IsLittleEndianCached;

function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch (e) {
    return false;
  }
}

const IsEvalSupportedCached = {
  get value() {
    return shadow(this, "value", isEvalSupported());
  }

};
exports.IsEvalSupportedCached = IsEvalSupportedCached;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }

  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }

  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }

  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }

  static getAxialAlignedBoundingBox(r, m) {
    const p1 = Util.applyTransform(r, m);
    const p2 = Util.applyTransform(r.slice(2, 4), m);
    const p3 = Util.applyTransform([r[0], r[3]], m);
    const p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }

  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }

  static apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  }

  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }

  static normalizeRect(rect) {
    const r = rect.slice(0);

    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }

    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }

    return r;
  }

  static intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
    const result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return null;
    }

    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return null;
    }

    return result;
  }

}

exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

function stringToPDFString(str) {
  const length = str.length,
        strBuf = [];

  if (str[0] === "\xFE" && str[1] === "\xFF") {
    for (let i = 2; i < length; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
    for (let i = 2; i < length; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
    }
  } else {
    for (let i = 0; i < length; ++i) {
      const code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }

  return strBuf.join("");
}

function escapeString(str) {
  return str.replace(/([()\\\n\r])/g, match => {
    if (match === "\n") {
      return "\\n";
    } else if (match === "\r") {
      return "\\r";
    }

    return `\\${match}`;
  });
}

function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}

function stringToUTF16BEString(str) {
  const buf = ["\xFE\xFF"];

  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push(String.fromCharCode(char >> 8 & 0xff));
    buf.push(String.fromCharCode(char & 0xff));
  }

  return buf.join("");
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}

function isBool(v) {
  return typeof v === "boolean";
}

function isNum(v) {
  return typeof v === "number";
}

function isString(v) {
  return typeof v === "string";
}

function isArrayBuffer(v) {
  return typeof v === "object" && v !== null && v.byteLength !== undefined;
}

function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0, ii = arr1.length; i < ii; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}

function getModificationDate(date = new Date()) {
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}

function createPromiseCapability() {
  const capability = Object.create(null);
  let isSettled = false;
  Object.defineProperty(capability, "settled", {
    get() {
      return isSettled;
    }

  });
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = function (data) {
      isSettled = true;
      resolve(data);
    };

    capability.reject = function (reason) {
      isSettled = true;
      reject(reason);
    };
  });
  return capability;
}

function createObjectURL(data, contentType = "", forceDataSchema = false) {
  if (URL.createObjectURL && !forceDataSchema) {
    return URL.createObjectURL(new Blob([data], {
      type: contentType
    }));
  }

  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let buffer = `data:${contentType};base64,`;

  for (let i = 0, ii = data.length; i < ii; i += 3) {
    const b1 = data[i] & 0xff;
    const b2 = data[i + 1] & 0xff;
    const b3 = data[i + 2] & 0xff;
    const d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
    const d4 = i + 2 < ii ? b3 & 0x3f : 64;
    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
  }

  return buffer;
}

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {



var _is_node = __w_pdfjs_require__(4);

;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNodeJS = void 0;
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getDocument = getDocument;
exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
exports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;

var _util = __w_pdfjs_require__(2);

var _display_utils = __w_pdfjs_require__(1);

var _font_loader = __w_pdfjs_require__(6);

var _node_utils = __w_pdfjs_require__(7);

var _annotation_storage = __w_pdfjs_require__(8);

var _api_compatibility = __w_pdfjs_require__(9);

var _canvas = __w_pdfjs_require__(10);

var _worker_options = __w_pdfjs_require__(12);

var _is_node = __w_pdfjs_require__(4);

var _message_handler = __w_pdfjs_require__(13);

var _metadata = __w_pdfjs_require__(14);

var _optional_content_config = __w_pdfjs_require__(15);

var _transport_stream = __w_pdfjs_require__(16);

const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
exports.DefaultCanvasFactory = DefaultCanvasFactory;
const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
let createPDFNetworkStream;

function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
  createPDFNetworkStream = pdfNetworkStreamFactory;
}

function getDocument(src) {
  const task = new PDFDocumentLoadingTask();
  let source;

  if (typeof src === "string" || src instanceof URL) {
    source = {
      url: src
    };
  } else if ((0, _util.isArrayBuffer)(src)) {
    source = {
      data: src
    };
  } else if (src instanceof PDFDataRangeTransport) {
    source = {
      range: src
    };
  } else {
    if (typeof src !== "object") {
      throw new Error("Invalid parameter in getDocument, " + "need either string, URL, Uint8Array, or parameter object.");
    }

    if (!src.url && !src.data && !src.range) {
      throw new Error("Invalid parameter object: need either .data, .range or .url");
    }

    source = src;
  }

  const params = Object.create(null);
  let rangeTransport = null,
      worker = null;

  for (const key in source) {
    const value = source[key];

    switch (key) {
      case "url":
        if (typeof window !== "undefined") {
          try {
            params[key] = new URL(value, window.location).href;
            continue;
          } catch (ex) {
            (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
          }
        } else if (typeof value === "string" || value instanceof URL) {
          params[key] = value.toString();
          continue;
        }

        throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");

      case "range":
        rangeTransport = value;
        continue;

      case "worker":
        worker = value;
        continue;

      case "data":
        if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
          params[key] = new Uint8Array(value);
        } else if (value instanceof Uint8Array) {
          break;
        } else if (typeof value === "string") {
          params[key] = (0, _util.stringToBytes)(value);
        } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
          params[key] = new Uint8Array(value);
        } else if ((0, _util.isArrayBuffer)(value)) {
          params[key] = new Uint8Array(value);
        } else {
          throw new Error("Invalid PDF binary data: either typed array, " + "string, or array-like object is expected in the data property.");
        }

        continue;
    }

    params[key] = value;
  }

  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
  params.ignoreErrors = params.stopAtErrors !== true;
  params.fontExtraProperties = params.fontExtraProperties === true;
  params.pdfBug = params.pdfBug === true;
  params.enableXfa = params.enableXfa === true;

  if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
    params.docBaseUrl = null;
  }

  if (!Number.isInteger(params.maxImageSize)) {
    params.maxImageSize = -1;
  }

  if (typeof params.isEvalSupported !== "boolean") {
    params.isEvalSupported = true;
  }

  if (typeof params.disableFontFace !== "boolean") {
    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
  }

  if (typeof params.ownerDocument === "undefined") {
    params.ownerDocument = globalThis.document;
  }

  if (typeof params.disableRange !== "boolean") {
    params.disableRange = false;
  }

  if (typeof params.disableStream !== "boolean") {
    params.disableStream = false;
  }

  if (typeof params.disableAutoFetch !== "boolean") {
    params.disableAutoFetch = false;
  }

  (0, _util.setVerbosityLevel)(params.verbosity);

  if (!worker) {
    const workerParams = {
      verbosity: params.verbosity,
      port: _worker_options.GlobalWorkerOptions.workerPort
    };
    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
    task._worker = worker;
  }

  const docId = task.docId;
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }

    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

    const networkStreamPromise = new Promise(function (resolve) {
      let networkStream;

      if (rangeTransport) {
        networkStream = new _transport_stream.PDFDataTransportStream({
          length: params.length,
          initialData: params.initialData,
          progressiveDone: params.progressiveDone,
          contentDispositionFilename: params.contentDispositionFilename,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        }, rangeTransport);
      } else if (!params.data) {
        networkStream = createPDFNetworkStream({
          url: params.url,
          length: params.length,
          httpHeaders: params.httpHeaders,
          withCredentials: params.withCredentials,
          rangeChunkSize: params.rangeChunkSize,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        });
      }

      resolve(networkStream);
    });
    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }

      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
      messageHandler.postMessageTransfers = worker.postMessageTransfers;
      const transport = new WorkerTransport(messageHandler, task, networkStream, params);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}

function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
  if (worker.destroyed) {
    return Promise.reject(new Error("Worker was destroyed"));
  }

  if (pdfDataRangeTransport) {
    source.length = pdfDataRangeTransport.length;
    source.initialData = pdfDataRangeTransport.initialData;
    source.progressiveDone = pdfDataRangeTransport.progressiveDone;
    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
  }

  return worker.messageHandler.sendWithPromise("GetDocRequest", {
    docId,
    apiVersion: '2.9.0',
    source: {
      data: source.data,
      url: source.url,
      password: source.password,
      disableAutoFetch: source.disableAutoFetch,
      rangeChunkSize: source.rangeChunkSize,
      length: source.length
    },
    maxImageSize: source.maxImageSize,
    disableFontFace: source.disableFontFace,
    postMessageTransfers: worker.postMessageTransfers,
    docBaseUrl: source.docBaseUrl,
    ignoreErrors: source.ignoreErrors,
    isEvalSupported: source.isEvalSupported,
    fontExtraProperties: source.fontExtraProperties,
    enableXfa: source.enableXfa
  }).then(function (workerId) {
    if (worker.destroyed) {
      throw new Error("Worker was destroyed");
    }

    return workerId;
  });
}

const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
  let nextDocumentId = 0;

  class PDFDocumentLoadingTask {
    constructor() {
      this._capability = (0, _util.createPromiseCapability)();
      this._transport = null;
      this._worker = null;
      this.docId = "d" + nextDocumentId++;
      this.destroyed = false;
      this.onPassword = null;
      this.onProgress = null;
      this.onUnsupportedFeature = null;
    }

    get promise() {
      return this._capability.promise;
    }

    destroy() {
      this.destroyed = true;
      const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
      return transportDestroyed.then(() => {
        this._transport = null;

        if (this._worker) {
          this._worker.destroy();

          this._worker = null;
        }
      });
    }

  }

  return PDFDocumentLoadingTask;
}();

class PDFDataRangeTransport {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this._readyCapability = (0, _util.createPromiseCapability)();
  }

  addRangeListener(listener) {
    this._rangeListeners.push(listener);
  }

  addProgressListener(listener) {
    this._progressListeners.push(listener);
  }

  addProgressiveReadListener(listener) {
    this._progressiveReadListeners.push(listener);
  }

  addProgressiveDoneListener(listener) {
    this._progressiveDoneListeners.push(listener);
  }

  onDataRange(begin, chunk) {
    for (const listener of this._rangeListeners) {
      listener(begin, chunk);
    }
  }

  onDataProgress(loaded, total) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressListeners) {
        listener(loaded, total);
      }
    });
  }

  onDataProgressiveRead(chunk) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveReadListeners) {
        listener(chunk);
      }
    });
  }

  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveDoneListeners) {
        listener();
      }
    });
  }

  transportReady() {
    this._readyCapability.resolve();
  }

  requestDataRange(begin, end) {
    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
  }

  abort() {}

}

exports.PDFDataRangeTransport = PDFDataRangeTransport;

class PDFDocumentProxy {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
  }

  get annotationStorage() {
    return this._transport.annotationStorage;
  }

  get numPages() {
    return this._pdfInfo.numPages;
  }

  get fingerprint() {
    return this._pdfInfo.fingerprint;
  }

  get isPureXfa() {
    return this._pdfInfo.isPureXfa;
  }

  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }

  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }

  getDestinations() {
    return this._transport.getDestinations();
  }

  getDestination(id) {
    return this._transport.getDestination(id);
  }

  getPageLabels() {
    return this._transport.getPageLabels();
  }

  getPageLayout() {
    return this._transport.getPageLayout();
  }

  getPageMode() {
    return this._transport.getPageMode();
  }

  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }

  getOpenAction() {
    return this._transport.getOpenAction();
  }

  getAttachments() {
    return this._transport.getAttachments();
  }

  getJavaScript() {
    return this._transport.getJavaScript();
  }

  getJSActions() {
    return this._transport.getDocJSActions();
  }

  getOutline() {
    return this._transport.getOutline();
  }

  getOptionalContentConfig() {
    return this._transport.getOptionalContentConfig();
  }

  getPermissions() {
    return this._transport.getPermissions();
  }

  getMetadata() {
    return this._transport.getMetadata();
  }

  getMarkInfo() {
    return this._transport.getMarkInfo();
  }

  getData() {
    return this._transport.getData();
  }

  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }

  getStats() {
    return this._transport.getStats();
  }

  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }

  destroy() {
    return this.loadingTask.destroy();
  }

  get loadingParams() {
    return this._transport.loadingParams;
  }

  get loadingTask() {
    return this._transport.loadingTask;
  }

  saveDocument() {
    if (arguments.length > 0) {
      (0, _display_utils.deprecated)("saveDocument no longer accepts any options.");
    }

    if (this._transport.annotationStorage.size <= 0) {
      (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
    }

    return this._transport.saveDocument();
  }

  getFieldObjects() {
    return this._transport.getFieldObjects();
  }

  hasJSActions() {
    return this._transport.hasJSActions();
  }

  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }

}

exports.PDFDocumentProxy = PDFDocumentProxy;

class PDFPageProxy {
  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._ownerDocument = ownerDocument;
    this._transport = transport;
    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this.cleanupAfterRender = false;
    this.pendingCleanup = false;
    this._intentStates = new Map();
    this.destroyed = false;
  }

  get pageNumber() {
    return this._pageIndex + 1;
  }

  get rotate() {
    return this._pageInfo.rotate;
  }

  get ref() {
    return this._pageInfo.ref;
  }

  get userUnit() {
    return this._pageInfo.userUnit;
  }

  get view() {
    return this._pageInfo.view;
  }

  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new _display_utils.PageViewport({
      viewBox: this.view,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  getAnnotations({
    intent = null
  } = {}) {
    if (!this._annotationsPromise || this._annotationsIntent !== intent) {
      this._annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
      this._annotationsIntent = intent;
    }

    return this._annotationsPromise;
  }

  getJSActions() {
    return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
  }

  getXfa() {
    return this._xfaPromise || (this._xfaPromise = this._transport.getPageXfa(this._pageIndex));
  }

  render({
    canvasContext,
    viewport,
    intent = "display",
    renderInteractiveForms = false,
    transform = null,
    imageLayer = null,
    canvasFactory = null,
    background = null,
    includeAnnotationStorage = false,
    optionalContentConfigPromise = null
  }) {
    var _intentState;

    if (arguments[0]?.annotationStorage !== undefined) {
      (0, _display_utils.deprecated)("render no longer accepts an `annotationStorage` option, " + "please use the `includeAnnotationStorage`-boolean instead.");
      includeAnnotationStorage || (includeAnnotationStorage = !!arguments[0].annotationStorage);
    }

    if (this._stats) {
      this._stats.time("Overall");
    }

    const renderingIntent = intent === "print" ? "print" : "display";
    this.pendingCleanup = false;

    if (!optionalContentConfigPromise) {
      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
    }

    let intentState = this._intentStates.get(renderingIntent);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(renderingIntent, intentState);
    }

    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }

    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
      ownerDocument: this._ownerDocument
    });
    const annotationStorage = includeAnnotationStorage ? this._transport.annotationStorage.serializable : null;

    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList({
        pageIndex: this._pageIndex,
        intent: renderingIntent,
        renderInteractiveForms: renderInteractiveForms === true,
        annotationStorage
      });
    }

    const complete = error => {
      intentState.renderTasks.delete(internalRenderTask);

      if (this.cleanupAfterRender || renderingIntent === "print") {
        this.pendingCleanup = true;
      }

      this._tryCleanup();

      if (error) {
        internalRenderTask.capability.reject(error);

        this._abortOperatorList({
          intentState,
          reason: error
        });
      } else {
        internalRenderTask.capability.resolve();
      }

      if (this._stats) {
        this._stats.timeEnd("Rendering");

        this._stats.timeEnd("Overall");
      }
    };

    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvasContext,
        viewport,
        transform,
        imageLayer,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: canvasFactoryInstance,
      useRequestAnimationFrame: renderingIntent !== "print",
      pdfBug: this._pdfBug
    });
    ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      if (this.pendingCleanup) {
        complete();
        return;
      }

      if (this._stats) {
        this._stats.time("Rendering");
      }

      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }

  getOperatorList() {
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }

    const renderingIntent = "oplist";

    let intentState = this._intentStates.get(renderingIntent);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(renderingIntent, intentState);
    }

    let opListTask;

    if (!intentState.opListReadCapability) {
      var _intentState2;

      opListTask = Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
      ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList({
        pageIndex: this._pageIndex,
        intent: renderingIntent
      });
    }

    return intentState.opListReadCapability.promise;
  }

  streamTextContent({
    normalizeWhitespace = false,
    disableCombineTextItems = false,
    includeMarkedContent = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      normalizeWhitespace: normalizeWhitespace === true,
      combineTextItems: disableCombineTextItems !== true,
      includeMarkedContent: includeMarkedContent === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,

      size(textContent) {
        return textContent.items.length;
      }

    });
  }

  getTextContent(params = {}) {
    const readableStream = this.streamTextContent(params);
    return new Promise(function (resolve, reject) {
      function pump() {
        reader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            resolve(textContent);
            return;
          }

          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }

      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: Object.create(null)
      };
      pump();
    });
  }

  getStructTree() {
    return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
  }

  _destroy() {
    this.destroyed = true;
    this._transport.pageCache[this._pageIndex] = null;
    const waitOn = [];

    for (const [intent, intentState] of this._intentStates) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });

      if (intent === "oplist") {
        continue;
      }

      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }

    this.objs.clear();
    this._annotationsPromise = null;
    this._jsActionsPromise = null;
    this._xfaPromise = null;
    this._structTreePromise = null;
    this.pendingCleanup = false;
    return Promise.all(waitOn);
  }

  cleanup(resetStats = false) {
    this.pendingCleanup = true;
    return this._tryCleanup(resetStats);
  }

  _tryCleanup(resetStats = false) {
    if (!this.pendingCleanup) {
      return false;
    }

    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }

    this._intentStates.clear();

    this.objs.clear();
    this._annotationsPromise = null;
    this._jsActionsPromise = null;
    this._xfaPromise = null;
    this._structTreePromise = null;

    if (resetStats && this._stats) {
      this._stats = new _display_utils.StatTimer();
    }

    this.pendingCleanup = false;
    return true;
  }

  _startRenderPage(transparency, intent) {
    const intentState = this._intentStates.get(intent);

    if (!intentState) {
      return;
    }

    if (this._stats) {
      this._stats.timeEnd("Page Request");
    }

    if (intentState.displayReadyCapability) {
      intentState.displayReadyCapability.resolve(transparency);
    }
  }

  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }

    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }

    if (operatorListChunk.lastChunk) {
      this._tryCleanup();
    }
  }

  _pumpOperatorList(args) {
    (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');

    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);

    const reader = readableStream.getReader();

    const intentState = this._intentStates.get(args.intent);

    intentState.streamReader = reader;

    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }

        if (this._transport.destroyed) {
          return;
        }

        this._renderPageChunk(value, intentState);

        pump();
      }, reason => {
        intentState.streamReader = null;

        if (this._transport.destroyed) {
          return;
        }

        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;

          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }

          this._tryCleanup();
        }

        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };

    pump();
  }

  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');

    if (!intentState.streamReader) {
      return;
    }

    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }

      if (reason instanceof _display_utils.RenderingCancelledException) {
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });

          intentState.streamReaderCancelTimeout = null;
        }, RENDERING_CANCELLED_TIMEOUT);
        return;
      }
    }

    intentState.streamReader.cancel(new _util.AbortException(reason?.message));
    intentState.streamReader = null;

    if (this._transport.destroyed) {
      return;
    }

    for (const [intent, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(intent);

        break;
      }
    }

    this.cleanup();
  }

  get stats() {
    return this._stats;
  }

}

exports.PDFPageProxy = PDFPageProxy;

class LoopbackPort {
  constructor() {
    this._listeners = [];
    this._deferred = Promise.resolve(undefined);
  }

  postMessage(obj, transfers) {
    function cloneValue(value) {
      if (typeof value !== "object" || value === null) {
        return value;
      }

      if (cloned.has(value)) {
        return cloned.get(value);
      }

      let buffer, result;

      if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
        if (transfers?.includes(buffer)) {
          result = new value.constructor(buffer, value.byteOffset, value.byteLength);
        } else {
          result = new value.constructor(value);
        }

        cloned.set(value, result);
        return result;
      }

      if (value instanceof Map) {
        result = new Map();
        cloned.set(value, result);

        for (const [key, val] of value) {
          result.set(key, cloneValue(val));
        }

        return result;
      }

      if (value instanceof Set) {
        result = new Set();
        cloned.set(value, result);

        for (const val of value) {
          result.add(cloneValue(val));
        }

        return result;
      }

      if (value instanceof URL) {
        throw new Error(`LoopbackPort.postMessage - cannot clone: ${value}`);
      }

      result = Array.isArray(value) ? [] : Object.create(null);
      cloned.set(value, result);

      for (const i in value) {
        let desc,
            p = value;

        while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
          p = Object.getPrototypeOf(p);
        }

        if (typeof desc.value === "undefined") {
          continue;
        }

        if (typeof desc.value === "function") {
          if (value.hasOwnProperty?.(i)) {
            throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);
          }

          continue;
        }

        result[i] = cloneValue(desc.value);
      }

      return result;
    }

    const cloned = new WeakMap();
    const event = {
      data: cloneValue(obj)
    };

    this._deferred.then(() => {
      for (const listener of this._listeners) {
        listener.call(this, event);
      }
    });
  }

  addEventListener(name, listener) {
    this._listeners.push(listener);
  }

  removeEventListener(name, listener) {
    const i = this._listeners.indexOf(listener);

    this._listeners.splice(i, 1);
  }

  terminate() {
    this._listeners.length = 0;
  }

}

exports.LoopbackPort = LoopbackPort;

const PDFWorker = function PDFWorkerClosure() {
  const pdfWorkerPorts = new WeakMap();
  let isWorkerDisabled = false;
  let fallbackWorkerSrc;
  let nextFakeWorkerId = 0;
  let fakeWorkerCapability;

  if (_is_node.isNodeJS && typeof require === "function") {
    isWorkerDisabled = true;
    fallbackWorkerSrc = "./pdf.worker.js";
  } else if (typeof document === "object" && "currentScript" in document) {
    const pdfjsFilePath = document.currentScript?.src;

    if (pdfjsFilePath) {
      fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
    }
  }

  function getWorkerSrc() {
    if (_worker_options.GlobalWorkerOptions.workerSrc) {
      return _worker_options.GlobalWorkerOptions.workerSrc;
    }

    if (typeof fallbackWorkerSrc !== "undefined") {
      if (!_is_node.isNodeJS) {
        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
      }

      return fallbackWorkerSrc;
    }

    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }

  function getMainThreadWorkerMessageHandler() {
    let mainWorkerMessageHandler;

    try {
      mainWorkerMessageHandler = globalThis.pdfjsWorker?.WorkerMessageHandler;
    } catch (ex) {}

    return mainWorkerMessageHandler || null;
  }

  function setupFakeWorkerGlobal() {
    if (fakeWorkerCapability) {
      return fakeWorkerCapability.promise;
    }

    fakeWorkerCapability = (0, _util.createPromiseCapability)();

    const loader = async function () {
      const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();

      if (mainWorkerMessageHandler) {
        return mainWorkerMessageHandler;
      }

      if (_is_node.isNodeJS && typeof require === "function") {
        const worker = eval("require")(getWorkerSrc());
        return worker.WorkerMessageHandler;
      }

      await (0, _display_utils.loadScript)(getWorkerSrc());
      return window.pdfjsWorker.WorkerMessageHandler;
    };

    loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
    return fakeWorkerCapability.promise;
  }

  function createCDNWrapper(url) {
    const wrapper = "importScripts('" + url + "');";
    return URL.createObjectURL(new Blob([wrapper]));
  }

  class PDFWorker {
    constructor({
      name = null,
      port = null,
      verbosity = (0, _util.getVerbosityLevel)()
    } = {}) {
      if (port && pdfWorkerPorts.has(port)) {
        throw new Error("Cannot use more than one PDFWorker per port");
      }

      this.name = name;
      this.destroyed = false;
      this.postMessageTransfers = true;
      this.verbosity = verbosity;
      this._readyCapability = (0, _util.createPromiseCapability)();
      this._port = null;
      this._webWorker = null;
      this._messageHandler = null;

      if (port) {
        pdfWorkerPorts.set(port, this);

        this._initializeFromPort(port);

        return;
      }

      this._initialize();
    }

    get promise() {
      return this._readyCapability.promise;
    }

    get port() {
      return this._port;
    }

    get messageHandler() {
      return this._messageHandler;
    }

    _initializeFromPort(port) {
      this._port = port;
      this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

      this._messageHandler.on("ready", function () {});

      this._readyCapability.resolve();
    }

    _initialize() {
      if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
        let workerSrc = getWorkerSrc();

        try {
          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
            workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
          }

          const worker = new Worker(workerSrc);
          const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

          const terminateEarly = () => {
            worker.removeEventListener("error", onWorkerError);
            messageHandler.destroy();
            worker.terminate();

            if (this.destroyed) {
              this._readyCapability.reject(new Error("Worker was destroyed"));
            } else {
              this._setupFakeWorker();
            }
          };

          const onWorkerError = () => {
            if (!this._webWorker) {
              terminateEarly();
            }
          };

          worker.addEventListener("error", onWorkerError);
          messageHandler.on("test", data => {
            worker.removeEventListener("error", onWorkerError);

            if (this.destroyed) {
              terminateEarly();
              return;
            }

            if (data) {
              this._messageHandler = messageHandler;
              this._port = worker;
              this._webWorker = worker;

              if (!data.supportTransfers) {
                this.postMessageTransfers = false;
              }

              this._readyCapability.resolve();

              messageHandler.send("configure", {
                verbosity: this.verbosity
              });
            } else {
              this._setupFakeWorker();

              messageHandler.destroy();
              worker.terminate();
            }
          });
          messageHandler.on("ready", data => {
            worker.removeEventListener("error", onWorkerError);

            if (this.destroyed) {
              terminateEarly();
              return;
            }

            try {
              sendTest();
            } catch (e) {
              this._setupFakeWorker();
            }
          });

          const sendTest = () => {
            const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);

            try {
              messageHandler.send("test", testObj, [testObj.buffer]);
            } catch (ex) {
              (0, _util.warn)("Cannot use postMessage transfers.");
              testObj[0] = 0;
              messageHandler.send("test", testObj);
            }
          };

          sendTest();
          return;
        } catch (e) {
          (0, _util.info)("The worker has been disabled.");
        }
      }

      this._setupFakeWorker();
    }

    _setupFakeWorker() {
      if (!isWorkerDisabled) {
        (0, _util.warn)("Setting up fake worker.");
        isWorkerDisabled = true;
      }

      setupFakeWorkerGlobal().then(WorkerMessageHandler => {
        if (this.destroyed) {
          this._readyCapability.reject(new Error("Worker was destroyed"));

          return;
        }

        const port = new LoopbackPort();
        this._port = port;
        const id = "fake" + nextFakeWorkerId++;
        const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
        WorkerMessageHandler.setup(workerHandler, port);
        const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
        this._messageHandler = messageHandler;

        this._readyCapability.resolve();

        messageHandler.send("configure", {
          verbosity: this.verbosity
        });
      }).catch(reason => {
        this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
      });
    }

    destroy() {
      this.destroyed = true;

      if (this._webWorker) {
        this._webWorker.terminate();

        this._webWorker = null;
      }

      pdfWorkerPorts.delete(this._port);
      this._port = null;

      if (this._messageHandler) {
        this._messageHandler.destroy();

        this._messageHandler = null;
      }
    }

    static fromPort(params) {
      if (!params || !params.port) {
        throw new Error("PDFWorker.fromPort - invalid method signature.");
      }

      if (pdfWorkerPorts.has(params.port)) {
        return pdfWorkerPorts.get(params.port);
      }

      return new PDFWorker(params);
    }

    static getWorkerSrc() {
      return getWorkerSrc();
    }

  }

  return PDFWorker;
}();

exports.PDFWorker = PDFWorker;

class WorkerTransport {
  constructor(messageHandler, loadingTask, networkStream, params) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new _font_loader.FontLoader({
      docId: loadingTask.docId,
      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
      ownerDocument: params.ownerDocument
    });
    this._params = params;
    this.CMapReaderFactory = new params.CMapReaderFactory({
      baseUrl: params.cMapUrl,
      isCompressed: params.cMapPacked
    });
    this.destroyed = false;
    this.destroyCapability = null;
    this._passwordCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.pageCache = [];
    this.pagePromises = [];
    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
    this.setupMessageHandler();
  }

  get annotationStorage() {
    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
  }

  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }

    this.destroyed = true;
    this.destroyCapability = (0, _util.createPromiseCapability)();

    if (this._passwordCapability) {
      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
    }

    const waitOn = [];

    for (const page of this.pageCache) {
      if (page) {
        waitOn.push(page._destroy());
      }
    }

    this.pageCache.length = 0;
    this.pagePromises.length = 0;

    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }

    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();
      this._hasJSActionsPromise = null;

      if (this._networkStream) {
        this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
      }

      if (this.messageHandler) {
        this.messageHandler.destroy();
        this.messageHandler = null;
      }

      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }

  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();

      this._fullReader.onProgress = evt => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };

      sink.onPull = () => {
        this._fullReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        this._fullReader.cancel(reason);

        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", data => {
      const headersCapability = (0, _util.createPromiseCapability)();
      const fullReader = this._fullReader;
      fullReader.headersReady.then(() => {
        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
          if (this._lastProgress && loadingTask.onProgress) {
            loadingTask.onProgress(this._lastProgress);
          }

          fullReader.onProgress = evt => {
            if (loadingTask.onProgress) {
              loadingTask.onProgress({
                loaded: evt.loaded,
                total: evt.total
              });
            }
          };
        }

        headersCapability.resolve({
          isStreamingSupported: fullReader.isStreamingSupported,
          isRangeSupported: fullReader.isRangeSupported,
          contentLength: fullReader.contentLength
        });
      }, headersCapability.reject);
      return headersCapability.promise;
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

      if (!rangeReader) {
        sink.close();
        return;
      }

      sink.onPull = () => {
        rangeReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        rangeReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;

      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", function (ex) {
      let reason;

      switch (ex.name) {
        case "PasswordException":
          reason = new _util.PasswordException(ex.message, ex.code);
          break;

        case "InvalidPDFException":
          reason = new _util.InvalidPDFException(ex.message);
          break;

        case "MissingPDFException":
          reason = new _util.MissingPDFException(ex.message);
          break;

        case "UnexpectedResponseException":
          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
          break;

        case "UnknownErrorException":
          reason = new _util.UnknownErrorException(ex.message, ex.details);
          break;
      }

      if (!(reason instanceof Error)) {
        const msg = "DocException - expected a valid Error.";
        (0, _util.warn)(msg);
      }

      loadingTask._capability.reject(reason);
    });
    messageHandler.on("PasswordRequest", exception => {
      this._passwordCapability = (0, _util.createPromiseCapability)();

      if (loadingTask.onPassword) {
        const updatePassword = password => {
          this._passwordCapability.resolve({
            password
          });
        };

        try {
          loadingTask.onPassword(updatePassword, exception.code);
        } catch (ex) {
          this._passwordCapability.reject(ex);
        }
      } else {
        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
      }

      return this._passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", data => {
      if (loadingTask.onProgress) {
        loadingTask.onProgress({
          loaded: data.length,
          total: data.length
        });
      }

      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", data => {
      if (this.destroyed) {
        return;
      }

      const page = this.pageCache[data.pageIndex];

      page._startRenderPage(data.transparency, data.intent);
    });
    messageHandler.on("commonobj", data => {
      if (this.destroyed) {
        return;
      }

      const [id, type, exportedData] = data;

      if (this.commonObjs.has(id)) {
        return;
      }

      switch (type) {
        case "Font":
          const params = this._params;

          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            (0, _util.warn)(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }

          let fontRegistry = null;

          if (params.pdfBug && globalThis.FontInspector?.enabled) {
            fontRegistry = {
              registerFont(font, url) {
                globalThis.FontInspector.fontAdded(font, url);
              }

            };
          }

          const font = new _font_loader.FontFaceObject(exportedData, {
            isEvalSupported: params.isEvalSupported,
            disableFontFace: params.disableFontFace,
            ignoreErrors: params.ignoreErrors,
            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
            fontRegistry
          });
          this.fontLoader.bind(font).catch(reason => {
            return messageHandler.sendWithPromise("FontFallback", {
              id
            });
          }).finally(() => {
            if (!params.fontExtraProperties && font.data) {
              font.data = null;
            }

            this.commonObjs.resolve(id, font);
          });
          break;

        case "FontPath":
        case "Image":
          this.commonObjs.resolve(id, exportedData);
          break;

        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
    });
    messageHandler.on("obj", data => {
      if (this.destroyed) {
        return undefined;
      }

      const [id, pageIndex, type, imageData] = data;
      const pageProxy = this.pageCache[pageIndex];

      if (pageProxy.objs.has(id)) {
        return undefined;
      }

      switch (type) {
        case "Image":
          pageProxy.objs.resolve(id, imageData);
          const MAX_IMAGE_SIZE_TO_STORE = 8000000;

          if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {
            pageProxy.cleanupAfterRender = true;
          }

          break;

        default:
          throw new Error(`Got unknown object type ${type}`);
      }

      return undefined;
    });
    messageHandler.on("DocProgress", data => {
      if (this.destroyed) {
        return;
      }

      if (loadingTask.onProgress) {
        loadingTask.onProgress({
          loaded: data.loaded,
          total: data.total
        });
      }
    });
    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
    messageHandler.on("FetchBuiltInCMap", (data, sink) => {
      if (this.destroyed) {
        sink.error(new Error("Worker was destroyed"));
        return;
      }

      let fetched = false;

      sink.onPull = () => {
        if (fetched) {
          sink.close();
          return;
        }

        fetched = true;
        this.CMapReaderFactory.fetch(data).then(function (builtInCMap) {
          sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
        }).catch(function (reason) {
          sink.error(reason);
        });
      };
    });
  }

  _onUnsupportedFeature({
    featureId
  }) {
    if (this.destroyed) {
      return;
    }

    if (this.loadingTask.onUnsupportedFeature) {
      this.loadingTask.onUnsupportedFeature(featureId);
    }
  }

  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }

  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request"));
    }

    const pageIndex = pageNumber - 1;

    if (pageIndex in this.pagePromises) {
      return this.pagePromises[pageIndex];
    }

    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then(pageInfo => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }

      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
      this.pageCache[pageIndex] = page;
      return page;
    });
    this.pagePromises[pageIndex] = promise;
    return promise;
  }

  getPageIndex(ref) {
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      ref
    }).catch(function (reason) {
      return Promise.reject(new Error(reason));
    });
  }

  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }

  saveDocument() {
    return this.messageHandler.sendWithPromise("SaveDocument", {
      numPages: this._numPages,
      annotationStorage: this.annotationStorage.serializable,
      filename: this._fullReader?.filename ?? null
    }).finally(() => {
      this.annotationStorage.resetModified();
    });
  }

  getFieldObjects() {
    return this.messageHandler.sendWithPromise("GetFieldObjects", null);
  }

  hasJSActions() {
    return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
  }

  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }

  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }

  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }

    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }

  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }

  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }

  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }

  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }

  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }

  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }

  getJavaScript() {
    return this.messageHandler.sendWithPromise("GetJavaScript", null);
  }

  getDocJSActions() {
    return this.messageHandler.sendWithPromise("GetDocJSActions", null);
  }

  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }

  getPageXfa(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageXfa", {
      pageIndex
    });
  }

  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }

  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }

  getOptionalContentConfig() {
    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
      return new _optional_content_config.OptionalContentConfig(results);
    });
  }

  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }

  getMetadata() {
    return this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
      return {
        info: results[0],
        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
        contentDispositionFilename: this._fullReader?.filename ?? null,
        contentLength: this._fullReader?.contentLength ?? null
      };
    });
  }

  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }

  getStats() {
    return this.messageHandler.sendWithPromise("GetStats", null);
  }

  async startCleanup(keepLoadedFonts = false) {
    await this.messageHandler.sendWithPromise("Cleanup", null);

    if (this.destroyed) {
      return;
    }

    for (let i = 0, ii = this.pageCache.length; i < ii; i++) {
      const page = this.pageCache[i];

      if (!page) {
        continue;
      }

      const cleanupSuccessful = page.cleanup();

      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);
      }
    }

    this.commonObjs.clear();

    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }

    this._hasJSActionsPromise = null;
  }

  get loadingParams() {
    const params = this._params;
    return (0, _util.shadow)(this, "loadingParams", {
      disableAutoFetch: params.disableAutoFetch,
      disableFontFace: params.disableFontFace
    });
  }

}

class PDFObjects {
  constructor() {
    this._objs = Object.create(null);
  }

  _ensureObj(objId) {
    if (this._objs[objId]) {
      return this._objs[objId];
    }

    return this._objs[objId] = {
      capability: (0, _util.createPromiseCapability)(),
      data: null,
      resolved: false
    };
  }

  get(objId, callback = null) {
    if (callback) {
      this._ensureObj(objId).capability.promise.then(callback);

      return null;
    }

    const obj = this._objs[objId];

    if (!obj || !obj.resolved) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }

    return obj.data;
  }

  has(objId) {
    const obj = this._objs[objId];
    return obj?.resolved || false;
  }

  resolve(objId, data) {
    const obj = this._ensureObj(objId);

    obj.resolved = true;
    obj.data = data;
    obj.capability.resolve(data);
  }

  clear() {
    this._objs = Object.create(null);
  }

}

class RenderTask {
  constructor(internalRenderTask) {
    this._internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }

  get promise() {
    return this._internalRenderTask.capability.promise;
  }

  cancel() {
    this._internalRenderTask.cancel();
  }

}

const InternalRenderTask = function InternalRenderTaskClosure() {
  const canvasInRendering = new WeakSet();

  class InternalRenderTask {
    constructor({
      callback,
      params,
      objs,
      commonObjs,
      operatorList,
      pageIndex,
      canvasFactory,
      useRequestAnimationFrame = false,
      pdfBug = false
    }) {
      this.callback = callback;
      this.params = params;
      this.objs = objs;
      this.commonObjs = commonObjs;
      this.operatorListIdx = null;
      this.operatorList = operatorList;
      this._pageIndex = pageIndex;
      this.canvasFactory = canvasFactory;
      this._pdfBug = pdfBug;
      this.running = false;
      this.graphicsReadyCallback = null;
      this.graphicsReady = false;
      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
      this.cancelled = false;
      this.capability = (0, _util.createPromiseCapability)();
      this.task = new RenderTask(this);
      this._cancelBound = this.cancel.bind(this);
      this._continueBound = this._continue.bind(this);
      this._scheduleNextBound = this._scheduleNext.bind(this);
      this._nextBound = this._next.bind(this);
      this._canvas = params.canvasContext.canvas;
    }

    get completed() {
      return this.capability.promise.catch(function () {});
    }

    initializeGraphics({
      transparency = false,
      optionalContentConfig
    }) {
      if (this.cancelled) {
        return;
      }

      if (this._canvas) {
        if (canvasInRendering.has(this._canvas)) {
          throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
        }

        canvasInRendering.add(this._canvas);
      }

      if (this._pdfBug && globalThis.StepperManager?.enabled) {
        this.stepper = globalThis.StepperManager.create(this._pageIndex);
        this.stepper.init(this.operatorList);
        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
      }

      const {
        canvasContext,
        viewport,
        transform,
        imageLayer,
        background
      } = this.params;
      this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig);
      this.gfx.beginDrawing({
        transform,
        viewport,
        transparency,
        background
      });
      this.operatorListIdx = 0;
      this.graphicsReady = true;

      if (this.graphicsReadyCallback) {
        this.graphicsReadyCallback();
      }
    }

    cancel(error = null) {
      this.running = false;
      this.cancelled = true;

      if (this.gfx) {
        this.gfx.endDrawing();
      }

      if (this._canvas) {
        canvasInRendering.delete(this._canvas);
      }

      this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
    }

    operatorListChanged() {
      if (!this.graphicsReady) {
        if (!this.graphicsReadyCallback) {
          this.graphicsReadyCallback = this._continueBound;
        }

        return;
      }

      if (this.stepper) {
        this.stepper.updateOperatorList(this.operatorList);
      }

      if (this.running) {
        return;
      }

      this._continue();
    }

    _continue() {
      this.running = true;

      if (this.cancelled) {
        return;
      }

      if (this.task.onContinue) {
        this.task.onContinue(this._scheduleNextBound);
      } else {
        this._scheduleNext();
      }
    }

    _scheduleNext() {
      if (this._useRequestAnimationFrame) {
        window.requestAnimationFrame(() => {
          this._nextBound().catch(this._cancelBound);
        });
      } else {
        Promise.resolve().then(this._nextBound).catch(this._cancelBound);
      }
    }

    async _next() {
      if (this.cancelled) {
        return;
      }

      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

      if (this.operatorListIdx === this.operatorList.argsArray.length) {
        this.running = false;

        if (this.operatorList.lastChunk) {
          this.gfx.endDrawing();

          if (this._canvas) {
            canvasInRendering.delete(this._canvas);
          }

          this.callback();
        }
      }
    }

  }

  return InternalRenderTask;
}();

const version = '2.9.0';
exports.version = version;
const build = '3538ef0';
exports.build = build;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontLoader = exports.FontFaceObject = void 0;

var _util = __w_pdfjs_require__(2);

class BaseFontLoader {
  constructor({
    docId,
    onUnsupportedFeature,
    ownerDocument = globalThis.document
  }) {
    if (this.constructor === BaseFontLoader) {
      (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
    }

    this.docId = docId;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this._document = ownerDocument;
    this.nativeFontFaces = [];
    this.styleElement = null;
  }

  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.push(nativeFontFace);

    this._document.fonts.add(nativeFontFace);
  }

  insertRule(rule) {
    let styleElement = this.styleElement;

    if (!styleElement) {
      styleElement = this.styleElement = this._document.createElement("style");
      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;

      this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
    }

    const styleSheet = styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }

  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }

    this.nativeFontFaces.length = 0;

    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }

  async bind(font) {
    if (font.attached || font.missingFile) {
      return;
    }

    font.attached = true;

    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();

      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);

        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          this._onUnsupportedFeature({
            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
          });

          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }

      return;
    }

    const rule = font.createFontFaceRule();

    if (rule) {
      this.insertRule(rule);

      if (this.isSyncFontLoadingSupported) {
        return;
      }

      await new Promise(resolve => {
        const request = this._queueLoadingCallback(resolve);

        this._prepareFontLoadEvent([rule], [font], request);
      });
    }
  }

  _queueLoadingCallback(callback) {
    (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
  }

  get isFontLoadingAPISupported() {
    return (0, _util.shadow)(this, "isFontLoadingAPISupported", !!this._document?.fonts);
  }

  get isSyncFontLoadingSupported() {
    (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
  }

  get _loadTestFont() {
    (0, _util.unreachable)("Abstract method `_loadTestFont`.");
  }

  _prepareFontLoadEvent(rules, fontsToLoad, request) {
    (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
  }

}

let FontLoader;
exports.FontLoader = FontLoader;
{
  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
    constructor(params) {
      super(params);
      this.loadingContext = {
        requests: [],
        nextRequestId: 0
      };
      this.loadTestFontId = 0;
    }

    get isSyncFontLoadingSupported() {
      let supported = false;

      if (typeof navigator === "undefined") {
        supported = true;
      } else {
        const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

        if (m?.[1] >= 14) {
          supported = true;
        }
      }

      return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
    }

    _queueLoadingCallback(callback) {
      function completeRequest() {
        (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
        request.done = true;

        while (context.requests.length > 0 && context.requests[0].done) {
          const otherRequest = context.requests.shift();
          setTimeout(otherRequest.callback, 0);
        }
      }

      const context = this.loadingContext;
      const request = {
        id: `pdfjs-font-loading-${context.nextRequestId++}`,
        done: false,
        complete: completeRequest,
        callback
      };
      context.requests.push(request);
      return request;
    }

    get _loadTestFont() {
      const getLoadTestFont = function () {
        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
      };

      return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
    }

    _prepareFontLoadEvent(rules, fonts, request) {
      function int32(data, offset) {
        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
      }

      function spliceString(s, offset, remove, insert) {
        const chunk1 = s.substring(0, offset);
        const chunk2 = s.substring(offset + remove);
        return chunk1 + insert + chunk2;
      }

      let i, ii;

      const canvas = this._document.createElement("canvas");

      canvas.width = 1;
      canvas.height = 1;
      const ctx = canvas.getContext("2d");
      let called = 0;

      function isFontReady(name, callback) {
        called++;

        if (called > 30) {
          (0, _util.warn)("Load test font never loaded.");
          callback();
          return;
        }

        ctx.font = "30px " + name;
        ctx.fillText(".", 0, 20);
        const imageData = ctx.getImageData(0, 0, 1, 1);

        if (imageData.data[3] > 0) {
          callback();
          return;
        }

        setTimeout(isFontReady.bind(null, name, callback));
      }

      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
      let data = this._loadTestFont;
      const COMMENT_OFFSET = 976;
      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
      const CFF_CHECKSUM_OFFSET = 16;
      const XXXX_VALUE = 0x58585858;
      let checksum = int32(data, CFF_CHECKSUM_OFFSET);

      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
      }

      if (i < loadTestFontId.length) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
      }

      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
      const url = `url(data:font/opentype;base64,${btoa(data)});`;
      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
      this.insertRule(rule);
      const names = [];

      for (i = 0, ii = fonts.length; i < ii; i++) {
        names.push(fonts[i].loadedName);
      }

      names.push(loadTestFontId);

      const div = this._document.createElement("div");

      div.style.visibility = "hidden";
      div.style.width = div.style.height = "10px";
      div.style.position = "absolute";
      div.style.top = div.style.left = "0px";

      for (i = 0, ii = names.length; i < ii; ++i) {
        const span = this._document.createElement("span");

        span.textContent = "Hi";
        span.style.fontFamily = names[i];
        div.appendChild(span);
      }

      this._document.body.appendChild(div);

      isFontReady(loadTestFontId, () => {
        this._document.body.removeChild(div);

        request.complete();
      });
    }

  };
}

class FontFaceObject {
  constructor(translatedData, {
    isEvalSupported = true,
    disableFontFace = false,
    ignoreErrors = false,
    onUnsupportedFeature,
    fontRegistry = null
  }) {
    this.compiledGlyphs = Object.create(null);

    for (const i in translatedData) {
      this[i] = translatedData[i];
    }

    this.isEvalSupported = isEvalSupported !== false;
    this.disableFontFace = disableFontFace === true;
    this.ignoreErrors = ignoreErrors === true;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this.fontRegistry = fontRegistry;
  }

  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    let nativeFontFace;

    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };

      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }

      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this);
    }

    return nativeFontFace;
  }

  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    const data = (0, _util.bytesToString)(this.data);
    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
    let rule;

    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;

      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }

      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this, url);
    }

    return rule;
  }

  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== undefined) {
      return this.compiledGlyphs[character];
    }

    let cmds, current;

    try {
      cmds = objs.get(this.loadedName + "_path_" + character);
    } catch (ex) {
      if (!this.ignoreErrors) {
        throw ex;
      }

      this._onUnsupportedFeature({
        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
      });

      (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
      return this.compiledGlyphs[character] = function (c, size) {};
    }

    if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {
      let args,
          js = "";

      for (let i = 0, ii = cmds.length; i < ii; i++) {
        current = cmds[i];

        if (current.args !== undefined) {
          args = current.args.join(",");
        } else {
          args = "";
        }

        js += "c." + current.cmd + "(" + args + ");\n";
      }

      return this.compiledGlyphs[character] = new Function("c", "size", js);
    }

    return this.compiledGlyphs[character] = function (c, size) {
      for (let i = 0, ii = cmds.length; i < ii; i++) {
        current = cmds[i];

        if (current.cmd === "scale") {
          current.args = [size, -size];
        }

        c[current.cmd].apply(c, current.args);
      }
    };
  }

}

exports.FontFaceObject = FontFaceObject;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;

var _display_utils = __w_pdfjs_require__(1);

var _is_node = __w_pdfjs_require__(4);

var _util = __w_pdfjs_require__(2);

let NodeCanvasFactory = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: NodeCanvasFactory");
  }

};
exports.NodeCanvasFactory = NodeCanvasFactory;
let NodeCMapReaderFactory = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory");
  }

};
exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

if (_is_node.isNodeJS) {
  exports.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils.BaseCanvasFactory {
    create(width, height) {
      if (width <= 0 || height <= 0) {
        throw new Error("Invalid canvas size");
      }

      const Canvas = require("canvas");

      const canvas = Canvas.createCanvas(width, height);
      return {
        canvas,
        context: canvas.getContext("2d")
      };
    }

  };
  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils.BaseCMapReaderFactory {
    _fetchData(url, compressionType) {
      return new Promise((resolve, reject) => {
        const fs = require("fs");

        fs.readFile(url, (error, data) => {
          if (error || !data) {
            reject(new Error(error));
            return;
          }

          resolve({
            cMapData: new Uint8Array(data),
            compressionType
          });
        });
      });
    }

  };
}

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationStorage = void 0;

var _util = __w_pdfjs_require__(2);

class AnnotationStorage {
  constructor() {
    this._storage = new Map();
    this._modified = false;
    this.onSetModified = null;
    this.onResetModified = null;
  }

  getValue(key, defaultValue) {
    const obj = this._storage.get(key);

    return obj !== undefined ? obj : defaultValue;
  }

  setValue(key, value) {
    const obj = this._storage.get(key);

    let modified = false;

    if (obj !== undefined) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      this._storage.set(key, value);

      modified = true;
    }

    if (modified) {
      this._setModified();
    }
  }

  getAll() {
    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
  }

  get size() {
    return this._storage.size;
  }

  _setModified() {
    if (!this._modified) {
      this._modified = true;

      if (typeof this.onSetModified === "function") {
        this.onSetModified();
      }
    }
  }

  resetModified() {
    if (this._modified) {
      this._modified = false;

      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }

  get serializable() {
    return this._storage.size > 0 ? this._storage : null;
  }

}

exports.AnnotationStorage = AnnotationStorage;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.apiCompatibilityParams = void 0;

var _is_node = __w_pdfjs_require__(4);

const compatibilityParams = Object.create(null);
{
  (function checkFontFace() {
    if (_is_node.isNodeJS) {
      compatibilityParams.disableFontFace = true;
    }
  })();
}
const apiCompatibilityParams = Object.freeze(compatibilityParams);
exports.apiCompatibilityParams = apiCompatibilityParams;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CanvasGraphics = void 0;

var _util = __w_pdfjs_require__(2);

var _pattern_helper = __w_pdfjs_require__(11);

const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const MAX_GROUP_SIZE = 4096;
const COMPILE_TYPE3_GLYPHS = true;
const MAX_SIZE_TO_COMPILE = 1000;
const FULL_CHUNK_HEIGHT = 16;
const LINEWIDTH_SCALE_FACTOR = 1.000001;

function addContextCurrentTransform(ctx) {
  if (ctx.mozCurrentTransform) {
    return;
  }

  ctx._originalSave = ctx.save;
  ctx._originalRestore = ctx.restore;
  ctx._originalRotate = ctx.rotate;
  ctx._originalScale = ctx.scale;
  ctx._originalTranslate = ctx.translate;
  ctx._originalTransform = ctx.transform;
  ctx._originalSetTransform = ctx.setTransform;
  ctx._originalResetTransform = ctx.resetTransform;
  ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
  ctx._transformStack = [];

  try {
    const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
    ctx._setLineWidth = desc.set;
    ctx._getLineWidth = desc.get;
    Object.defineProperty(ctx, "lineWidth", {
      set: function setLineWidth(width) {
        this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
      },
      get: function getLineWidth() {
        return this._getLineWidth();
      }
    });
  } catch (_) {}

  Object.defineProperty(ctx, "mozCurrentTransform", {
    get: function getCurrentTransform() {
      return this._transformMatrix;
    }
  });
  Object.defineProperty(ctx, "mozCurrentTransformInverse", {
    get: function getCurrentTransformInverse() {
      const [a, b, c, d, e, f] = this._transformMatrix;
      const ad_bc = a * d - b * c;
      const bc_ad = b * c - a * d;
      return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
    }
  });

  ctx.save = function ctxSave() {
    const old = this._transformMatrix;

    this._transformStack.push(old);

    this._transformMatrix = old.slice(0, 6);

    this._originalSave();
  };

  ctx.restore = function ctxRestore() {
    const prev = this._transformStack.pop();

    if (prev) {
      this._transformMatrix = prev;

      this._originalRestore();
    }
  };

  ctx.translate = function ctxTranslate(x, y) {
    const m = this._transformMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];

    this._originalTranslate(x, y);
  };

  ctx.scale = function ctxScale(x, y) {
    const m = this._transformMatrix;
    m[0] = m[0] * x;
    m[1] = m[1] * x;
    m[2] = m[2] * y;
    m[3] = m[3] * y;

    this._originalScale(x, y);
  };

  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
    const m = this._transformMatrix;
    this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

    ctx._originalTransform(a, b, c, d, e, f);
  };

  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
    this._transformMatrix = [a, b, c, d, e, f];

    ctx._originalSetTransform(a, b, c, d, e, f);
  };

  ctx.resetTransform = function ctxResetTransform() {
    this._transformMatrix = [1, 0, 0, 1, 0, 0];

    ctx._originalResetTransform();
  };

  ctx.rotate = function ctxRotate(angle) {
    const cosValue = Math.cos(angle);
    const sinValue = Math.sin(angle);
    const m = this._transformMatrix;
    this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

    this._originalRotate(angle);
  };
}

class CachedCanvases {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }

  getCanvas(id, width, height, trackTransform) {
    let canvasEntry;

    if (this.cache[id] !== undefined) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }

    if (trackTransform) {
      addContextCurrentTransform(canvasEntry.context);
    }

    return canvasEntry;
  }

  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }

}

function compileType3Glyph(imgData) {
  const POINT_TO_PROCESS_LIMIT = 1000;
  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  const width = imgData.width,
        height = imgData.height,
        width1 = width + 1;
  let i, ii, j, j0;
  const points = new Uint8Array(width1 * (height + 1));
  const lineSize = width + 7 & ~7,
        data0 = imgData.data;
  const data = new Uint8Array(lineSize * height);
  let pos = 0;

  for (i = 0, ii = data0.length; i < ii; i++) {
    const elem = data0[i];
    let mask = 128;

    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }

  let count = 0;
  pos = 0;

  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }

  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;

    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }

    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }

      pos++;
    }

    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }

    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }

  pos = lineSize * (height - 1);
  j0 = i * width1;

  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }

  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }

  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  const outlines = [];

  for (i = 0; count && i <= height; i++) {
    let p = i * width1;
    const end = p + width;

    while (p < end && !points[p]) {
      p++;
    }

    if (p === end) {
      continue;
    }

    const coords = [p % width1, i];
    const p0 = p;
    let type = points[p];

    do {
      const step = steps[type];

      do {
        p += step;
      } while (!points[p]);

      const pp = points[p];

      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }

      coords.push(p % width1);
      coords.push(p / width1 | 0);

      if (!points[p]) {
        --count;
      }
    } while (p0 !== p);

    outlines.push(coords);
    --i;
  }

  const drawOutline = function (c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.beginPath();

    for (let k = 0, kk = outlines.length; k < kk; k++) {
      const o = outlines[k];
      c.moveTo(o[0], o[1]);

      for (let l = 2, ll = o.length; l < ll; l += 2) {
        c.lineTo(o[l], o[l + 1]);
      }
    }

    c.fill();
    c.beginPath();
    c.restore();
  };

  return drawOutline;
}

class CanvasExtraState {
  constructor() {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = "#000000";
    this.strokeColor = "#000000";
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.resumeSMaskCtx = null;
    this.transferMaps = null;
  }

  clone() {
    return Object.create(this);
  }

  setCurrentPoint(x, y) {
    this.x = x;
    this.y = y;
  }

}

const CanvasGraphics = function CanvasGraphicsClosure() {
  const EXECUTION_TIME = 15;
  const EXECUTION_STEPS = 10;

  function putBinaryImageData(ctx, imgData, transferMaps = null) {
    if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
      ctx.putImageData(imgData, 0, 0);
      return;
    }

    const height = imgData.height,
          width = imgData.width;
    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    let srcPos = 0,
        destPos;
    const src = imgData.data;
    const dest = chunkImgData.data;
    let i, j, thisChunkHeight, elemsInThisChunk;
    let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

    if (transferMaps) {
      switch (transferMaps.length) {
        case 1:
          transferMapRed = transferMaps[0];
          transferMapGreen = transferMaps[0];
          transferMapBlue = transferMaps[0];
          transferMapGray = transferMaps[0];
          break;

        case 4:
          transferMapRed = transferMaps[0];
          transferMapGreen = transferMaps[1];
          transferMapBlue = transferMaps[2];
          transferMapGray = transferMaps[3];
          break;
      }
    }

    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
      const srcLength = src.byteLength;
      const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
      const dest32DataLength = dest32.length;
      const fullSrcDiff = width + 7 >> 3;
      let white = 0xffffffff;
      let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;

      if (transferMapGray) {
        if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
          [white, black] = [black, white];
        }
      }

      for (i = 0; i < totalChunks; i++) {
        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
        destPos = 0;

        for (j = 0; j < thisChunkHeight; j++) {
          const srcDiff = srcLength - srcPos;
          let k = 0;
          const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
          const kEndUnrolled = kEnd & ~7;
          let mask = 0;
          let srcByte = 0;

          for (; k < kEndUnrolled; k += 8) {
            srcByte = src[srcPos++];
            dest32[destPos++] = srcByte & 128 ? white : black;
            dest32[destPos++] = srcByte & 64 ? white : black;
            dest32[destPos++] = srcByte & 32 ? white : black;
            dest32[destPos++] = srcByte & 16 ? white : black;
            dest32[destPos++] = srcByte & 8 ? white : black;
            dest32[destPos++] = srcByte & 4 ? white : black;
            dest32[destPos++] = srcByte & 2 ? white : black;
            dest32[destPos++] = srcByte & 1 ? white : black;
          }

          for (; k < kEnd; k++) {
            if (mask === 0) {
              srcByte = src[srcPos++];
              mask = 128;
            }

            dest32[destPos++] = srcByte & mask ? white : black;
            mask >>= 1;
          }
        }

        while (destPos < dest32DataLength) {
          dest32[destPos++] = 0;
        }

        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
      j = 0;
      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

      for (i = 0; i < fullChunks; i++) {
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
        srcPos += elemsInThisChunk;

        if (hasTransferMaps) {
          for (let k = 0; k < elemsInThisChunk; k += 4) {
            if (transferMapRed) {
              dest[k + 0] = transferMapRed[dest[k + 0]];
            }

            if (transferMapGreen) {
              dest[k + 1] = transferMapGreen[dest[k + 1]];
            }

            if (transferMapBlue) {
              dest[k + 2] = transferMapBlue[dest[k + 2]];
            }
          }
        }

        ctx.putImageData(chunkImgData, 0, j);
        j += FULL_CHUNK_HEIGHT;
      }

      if (i < totalChunks) {
        elemsInThisChunk = width * partialChunkHeight * 4;
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

        if (hasTransferMaps) {
          for (let k = 0; k < elemsInThisChunk; k += 4) {
            if (transferMapRed) {
              dest[k + 0] = transferMapRed[dest[k + 0]];
            }

            if (transferMapGreen) {
              dest[k + 1] = transferMapGreen[dest[k + 1]];
            }

            if (transferMapBlue) {
              dest[k + 2] = transferMapBlue[dest[k + 2]];
            }
          }
        }

        ctx.putImageData(chunkImgData, 0, j);
      }
    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
      thisChunkHeight = FULL_CHUNK_HEIGHT;
      elemsInThisChunk = width * thisChunkHeight;

      for (i = 0; i < totalChunks; i++) {
        if (i >= fullChunks) {
          thisChunkHeight = partialChunkHeight;
          elemsInThisChunk = width * thisChunkHeight;
        }

        destPos = 0;

        for (j = elemsInThisChunk; j--;) {
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = 255;
        }

        if (hasTransferMaps) {
          for (let k = 0; k < destPos; k += 4) {
            if (transferMapRed) {
              dest[k + 0] = transferMapRed[dest[k + 0]];
            }

            if (transferMapGreen) {
              dest[k + 1] = transferMapGreen[dest[k + 1]];
            }

            if (transferMapBlue) {
              dest[k + 2] = transferMapBlue[dest[k + 2]];
            }
          }
        }

        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else {
      throw new Error(`bad image kind: ${imgData.kind}`);
    }
  }

  function putBinaryImageMask(ctx, imgData) {
    const height = imgData.height,
          width = imgData.width;
    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    let srcPos = 0;
    const src = imgData.data;
    const dest = chunkImgData.data;

    for (let i = 0; i < totalChunks; i++) {
      const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      let destPos = 3;

      for (let j = 0; j < thisChunkHeight; j++) {
        let elem,
            mask = 0;

        for (let k = 0; k < width; k++) {
          if (!mask) {
            elem = src[srcPos++];
            mask = 128;
          }

          dest[destPos] = elem & mask ? 0 : 255;
          destPos += 4;
          mask >>= 1;
        }
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  }

  function copyCtxState(sourceCtx, destCtx) {
    const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

    for (let i = 0, ii = properties.length; i < ii; i++) {
      const property = properties[i];

      if (sourceCtx[property] !== undefined) {
        destCtx[property] = sourceCtx[property];
      }
    }

    if (sourceCtx.setLineDash !== undefined) {
      destCtx.setLineDash(sourceCtx.getLineDash());
      destCtx.lineDashOffset = sourceCtx.lineDashOffset;
    }
  }

  function resetCtxToDefault(ctx) {
    ctx.strokeStyle = "#000000";
    ctx.fillStyle = "#000000";
    ctx.fillRule = "nonzero";
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 10;
    ctx.globalCompositeOperation = "source-over";
    ctx.font = "10px sans-serif";

    if (ctx.setLineDash !== undefined) {
      ctx.setLineDash([]);
      ctx.lineDashOffset = 0;
    }
  }

  function composeSMaskBackdrop(bytes, r0, g0, b0) {
    const length = bytes.length;

    for (let i = 3; i < length; i += 4) {
      const alpha = bytes[i];

      if (alpha === 0) {
        bytes[i - 3] = r0;
        bytes[i - 2] = g0;
        bytes[i - 1] = b0;
      } else if (alpha < 255) {
        const alpha_ = 255 - alpha;
        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
      }
    }
  }

  function composeSMaskAlpha(maskData, layerData, transferMap) {
    const length = maskData.length;
    const scale = 1 / 255;

    for (let i = 3; i < length; i += 4) {
      const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
      layerData[i] = layerData[i] * alpha * scale | 0;
    }
  }

  function composeSMaskLuminosity(maskData, layerData, transferMap) {
    const length = maskData.length;

    for (let i = 3; i < length; i += 4) {
      const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
    }
  }

  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
    const hasBackdrop = !!backdrop;
    const r0 = hasBackdrop ? backdrop[0] : 0;
    const g0 = hasBackdrop ? backdrop[1] : 0;
    const b0 = hasBackdrop ? backdrop[2] : 0;
    let composeFn;

    if (subtype === "Luminosity") {
      composeFn = composeSMaskLuminosity;
    } else {
      composeFn = composeSMaskAlpha;
    }

    const PIXELS_TO_PROCESS = 1048576;
    const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

    for (let row = 0; row < height; row += chunkSize) {
      const chunkHeight = Math.min(chunkSize, height - row);
      const maskData = maskCtx.getImageData(0, row, width, chunkHeight);
      const layerData = layerCtx.getImageData(0, row, width, chunkHeight);

      if (hasBackdrop) {
        composeSMaskBackdrop(maskData.data, r0, g0, b0);
      }

      composeFn(maskData.data, layerData.data, transferMap);
      maskCtx.putImageData(layerData, 0, row);
    }
  }

  function composeSMask(ctx, smask, layerCtx) {
    const mask = smask.canvas;
    const maskCtx = smask.context;
    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, smask.backdrop, smask.transferMap);
    ctx.drawImage(mask, 0, 0);
  }

  const LINE_CAP_STYLES = ["butt", "round", "square"];
  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
  const NORMAL_CLIP = {};
  const EO_CLIP = {};

  class CanvasGraphics {
    constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig) {
      this.ctx = canvasCtx;
      this.current = new CanvasExtraState();
      this.stateStack = [];
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.res = null;
      this.xobjs = null;
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.canvasFactory = canvasFactory;
      this.imageLayer = imageLayer;
      this.groupStack = [];
      this.processingType3 = null;
      this.baseTransform = null;
      this.baseTransformStack = [];
      this.groupLevel = 0;
      this.smaskStack = [];
      this.smaskCounter = 0;
      this.tempSMask = null;
      this.contentVisible = true;
      this.markedContentStack = [];
      this.optionalContentConfig = optionalContentConfig;
      this.cachedCanvases = new CachedCanvases(this.canvasFactory);

      if (canvasCtx) {
        addContextCurrentTransform(canvasCtx);
      }

      this._cachedGetSinglePixelWidth = null;
    }

    beginDrawing({
      transform,
      viewport,
      transparency = false,
      background = null
    }) {
      const width = this.ctx.canvas.width;
      const height = this.ctx.canvas.height;
      this.ctx.save();
      this.ctx.fillStyle = background || "rgb(255, 255, 255)";
      this.ctx.fillRect(0, 0, width, height);
      this.ctx.restore();

      if (transparency) {
        const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
        this.compositeCtx = this.ctx;
        this.transparentCanvas = transparentCanvas.canvas;
        this.ctx = transparentCanvas.context;
        this.ctx.save();
        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
      }

      this.ctx.save();
      resetCtxToDefault(this.ctx);

      if (transform) {
        this.ctx.transform.apply(this.ctx, transform);
      }

      this.ctx.transform.apply(this.ctx, viewport.transform);
      this.baseTransform = this.ctx.mozCurrentTransform.slice();
      this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);

      if (this.imageLayer) {
        this.imageLayer.beginLayout();
      }
    }

    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
      const argsArray = operatorList.argsArray;
      const fnArray = operatorList.fnArray;
      let i = executionStartIdx || 0;
      const argsArrayLen = argsArray.length;

      if (argsArrayLen === i) {
        return i;
      }

      const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
      const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
      let steps = 0;
      const commonObjs = this.commonObjs;
      const objs = this.objs;
      let fnId;

      while (true) {
        if (stepper !== undefined && i === stepper.nextBreakPoint) {
          stepper.breakIt(i, continueCallback);
          return i;
        }

        fnId = fnArray[i];

        if (fnId !== _util.OPS.dependency) {
          this[fnId].apply(this, argsArray[i]);
        } else {
          for (const depObjId of argsArray[i]) {
            const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

            if (!objsPool.has(depObjId)) {
              objsPool.get(depObjId, continueCallback);
              return i;
            }
          }
        }

        i++;

        if (i === argsArrayLen) {
          return i;
        }

        if (chunkOperations && ++steps > EXECUTION_STEPS) {
          if (Date.now() > endTime) {
            continueCallback();
            return i;
          }

          steps = 0;
        }
      }
    }

    endDrawing() {
      while (this.stateStack.length || this.current.activeSMask !== null) {
        this.restore();
      }

      this.ctx.restore();

      if (this.transparentCanvas) {
        this.ctx = this.compositeCtx;
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.drawImage(this.transparentCanvas, 0, 0);
        this.ctx.restore();
        this.transparentCanvas = null;
      }

      this.cachedCanvases.clear();

      if (this.imageLayer) {
        this.imageLayer.endLayout();
      }
    }

    setLineWidth(width) {
      this.current.lineWidth = width;
      this.ctx.lineWidth = width;
    }

    setLineCap(style) {
      this.ctx.lineCap = LINE_CAP_STYLES[style];
    }

    setLineJoin(style) {
      this.ctx.lineJoin = LINE_JOIN_STYLES[style];
    }

    setMiterLimit(limit) {
      this.ctx.miterLimit = limit;
    }

    setDash(dashArray, dashPhase) {
      const ctx = this.ctx;

      if (ctx.setLineDash !== undefined) {
        ctx.setLineDash(dashArray);
        ctx.lineDashOffset = dashPhase;
      }
    }

    setRenderingIntent(intent) {}

    setFlatness(flatness) {}

    setGState(states) {
      for (let i = 0, ii = states.length; i < ii; i++) {
        const state = states[i];
        const key = state[0];
        const value = state[1];

        switch (key) {
          case "LW":
            this.setLineWidth(value);
            break;

          case "LC":
            this.setLineCap(value);
            break;

          case "LJ":
            this.setLineJoin(value);
            break;

          case "ML":
            this.setMiterLimit(value);
            break;

          case "D":
            this.setDash(value[0], value[1]);
            break;

          case "RI":
            this.setRenderingIntent(value);
            break;

          case "FL":
            this.setFlatness(value);
            break;

          case "Font":
            this.setFont(value[0], value[1]);
            break;

          case "CA":
            this.current.strokeAlpha = state[1];
            break;

          case "ca":
            this.current.fillAlpha = state[1];
            this.ctx.globalAlpha = state[1];
            break;

          case "BM":
            this.ctx.globalCompositeOperation = value;
            break;

          case "SMask":
            if (this.current.activeSMask) {
              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                this.suspendSMaskGroup();
              } else {
                this.endSMaskGroup();
              }
            }

            this.current.activeSMask = value ? this.tempSMask : null;

            if (this.current.activeSMask) {
              this.beginSMaskGroup();
            }

            this.tempSMask = null;
            break;

          case "TR":
            this.current.transferMaps = value;
        }
      }
    }

    beginSMaskGroup() {
      const activeSMask = this.current.activeSMask;
      const drawnWidth = activeSMask.canvas.width;
      const drawnHeight = activeSMask.canvas.height;
      const cacheId = "smaskGroupAt" + this.groupLevel;
      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
      const currentCtx = this.ctx;
      const currentTransform = currentCtx.mozCurrentTransform;
      this.ctx.save();
      const groupCtx = scratchCanvas.context;
      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
      groupCtx.transform.apply(groupCtx, currentTransform);
      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
      copyCtxState(currentCtx, groupCtx);
      this.ctx = groupCtx;
      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
      this.groupStack.push(currentCtx);
      this.groupLevel++;
    }

    suspendSMaskGroup() {
      const groupCtx = this.ctx;
      this.groupLevel--;
      this.ctx = this.groupStack.pop();
      composeSMask(this.ctx, this.current.activeSMask, groupCtx);
      this.ctx.restore();
      this.ctx.save();
      copyCtxState(groupCtx, this.ctx);
      this.current.resumeSMaskCtx = groupCtx;

      const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

      this.ctx.transform.apply(this.ctx, deltaTransform);
      groupCtx.save();
      groupCtx.setTransform(1, 0, 0, 1, 0, 0);
      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
      groupCtx.restore();
    }

    resumeSMaskGroup() {
      const groupCtx = this.current.resumeSMaskCtx;
      const currentCtx = this.ctx;
      this.ctx = groupCtx;
      this.groupStack.push(currentCtx);
      this.groupLevel++;
    }

    endSMaskGroup() {
      const groupCtx = this.ctx;
      this.groupLevel--;
      this.ctx = this.groupStack.pop();
      composeSMask(this.ctx, this.current.activeSMask, groupCtx);
      this.ctx.restore();
      copyCtxState(groupCtx, this.ctx);

      const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

      this.ctx.transform.apply(this.ctx, deltaTransform);
    }

    save() {
      this.ctx.save();
      const old = this.current;
      this.stateStack.push(old);
      this.current = old.clone();
      this.current.resumeSMaskCtx = null;
    }

    restore() {
      if (this.current.resumeSMaskCtx) {
        this.resumeSMaskGroup();
      }

      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
        this.endSMaskGroup();
      }

      if (this.stateStack.length !== 0) {
        this.current = this.stateStack.pop();
        this.ctx.restore();
        this.pendingClip = null;
        this._cachedGetSinglePixelWidth = null;
      } else {
        this.current.activeSMask = null;
      }
    }

    transform(a, b, c, d, e, f) {
      this.ctx.transform(a, b, c, d, e, f);
      this._cachedGetSinglePixelWidth = null;
    }

    constructPath(ops, args) {
      const ctx = this.ctx;
      const current = this.current;
      let x = current.x,
          y = current.y;

      for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
        switch (ops[i] | 0) {
          case _util.OPS.rectangle:
            x = args[j++];
            y = args[j++];
            const width = args[j++];
            const height = args[j++];
            const xw = x + width;
            const yh = y + height;
            ctx.moveTo(x, y);

            if (width === 0 || height === 0) {
              ctx.lineTo(xw, yh);
            } else {
              ctx.lineTo(xw, y);
              ctx.lineTo(xw, yh);
              ctx.lineTo(x, yh);
            }

            ctx.closePath();
            break;

          case _util.OPS.moveTo:
            x = args[j++];
            y = args[j++];
            ctx.moveTo(x, y);
            break;

          case _util.OPS.lineTo:
            x = args[j++];
            y = args[j++];
            ctx.lineTo(x, y);
            break;

          case _util.OPS.curveTo:
            x = args[j + 4];
            y = args[j + 5];
            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
            j += 6;
            break;

          case _util.OPS.curveTo2:
            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
            x = args[j + 2];
            y = args[j + 3];
            j += 4;
            break;

          case _util.OPS.curveTo3:
            x = args[j + 2];
            y = args[j + 3];
            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
            j += 4;
            break;

          case _util.OPS.closePath:
            ctx.closePath();
            break;
        }
      }

      current.setCurrentPoint(x, y);
    }

    closePath() {
      this.ctx.closePath();
    }

    stroke(consumePath) {
      consumePath = typeof consumePath !== "undefined" ? consumePath : true;
      const ctx = this.ctx;
      const strokeColor = this.current.strokeColor;
      ctx.globalAlpha = this.current.strokeAlpha;

      if (this.contentVisible) {
        if (typeof strokeColor === "object" && strokeColor?.getPattern) {
          const lineWidth = this.getSinglePixelWidth();
          ctx.save();
          ctx.strokeStyle = strokeColor.getPattern(ctx, this);
          ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
          ctx.stroke();
          ctx.restore();
        } else {
          const lineWidth = this.getSinglePixelWidth();

          if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {
            ctx.save();
            ctx.resetTransform();
            ctx.lineWidth = Math.round(this._combinedScaleFactor);
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
            ctx.stroke();
          }
        }
      }

      if (consumePath) {
        this.consumePath();
      }

      ctx.globalAlpha = this.current.fillAlpha;
    }

    closeStroke() {
      this.closePath();
      this.stroke();
    }

    fill(consumePath) {
      consumePath = typeof consumePath !== "undefined" ? consumePath : true;
      const ctx = this.ctx;
      const fillColor = this.current.fillColor;
      const isPatternFill = this.current.patternFill;
      let needRestore = false;

      if (isPatternFill) {
        ctx.save();
        ctx.fillStyle = fillColor.getPattern(ctx, this);
        needRestore = true;
      }

      if (this.contentVisible) {
        if (this.pendingEOFill) {
          ctx.fill("evenodd");
          this.pendingEOFill = false;
        } else {
          ctx.fill();
        }
      }

      if (needRestore) {
        ctx.restore();
      }

      if (consumePath) {
        this.consumePath();
      }
    }

    eoFill() {
      this.pendingEOFill = true;
      this.fill();
    }

    fillStroke() {
      this.fill(false);
      this.stroke(false);
      this.consumePath();
    }

    eoFillStroke() {
      this.pendingEOFill = true;
      this.fillStroke();
    }

    closeFillStroke() {
      this.closePath();
      this.fillStroke();
    }

    closeEOFillStroke() {
      this.pendingEOFill = true;
      this.closePath();
      this.fillStroke();
    }

    endPath() {
      this.consumePath();
    }

    clip() {
      this.pendingClip = NORMAL_CLIP;
    }

    eoClip() {
      this.pendingClip = EO_CLIP;
    }

    beginText() {
      this.current.textMatrix = _util.IDENTITY_MATRIX;
      this.current.textMatrixScale = 1;
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    }

    endText() {
      const paths = this.pendingTextPaths;
      const ctx = this.ctx;

      if (paths === undefined) {
        ctx.beginPath();
        return;
      }

      ctx.save();
      ctx.beginPath();

      for (let i = 0; i < paths.length; i++) {
        const path = paths[i];
        ctx.setTransform.apply(ctx, path.transform);
        ctx.translate(path.x, path.y);
        path.addToPath(ctx, path.fontSize);
      }

      ctx.restore();
      ctx.clip();
      ctx.beginPath();
      delete this.pendingTextPaths;
    }

    setCharSpacing(spacing) {
      this.current.charSpacing = spacing;
    }

    setWordSpacing(spacing) {
      this.current.wordSpacing = spacing;
    }

    setHScale(scale) {
      this.current.textHScale = scale / 100;
    }

    setLeading(leading) {
      this.current.leading = -leading;
    }

    setFont(fontRefName, size) {
      const fontObj = this.commonObjs.get(fontRefName);
      const current = this.current;

      if (!fontObj) {
        throw new Error(`Can't find font for ${fontRefName}`);
      }

      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
        (0, _util.warn)("Invalid font matrix for font " + fontRefName);
      }

      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }

      this.current.font = fontObj;
      this.current.fontSize = size;

      if (fontObj.isType3Font) {
        return;
      }

      const name = fontObj.loadedName || "sans-serif";
      let bold = "normal";

      if (fontObj.black) {
        bold = "900";
      } else if (fontObj.bold) {
        bold = "bold";
      }

      const italic = fontObj.italic ? "italic" : "normal";
      const typeface = `"${name}", ${fontObj.fallbackName}`;
      let browserFontSize = size;

      if (size < MIN_FONT_SIZE) {
        browserFontSize = MIN_FONT_SIZE;
      } else if (size > MAX_FONT_SIZE) {
        browserFontSize = MAX_FONT_SIZE;
      }

      this.current.fontSizeScale = size / browserFontSize;
      this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
    }

    setTextRenderingMode(mode) {
      this.current.textRenderingMode = mode;
    }

    setTextRise(rise) {
      this.current.textRise = rise;
    }

    moveText(x, y) {
      this.current.x = this.current.lineX += x;
      this.current.y = this.current.lineY += y;
    }

    setLeadingMoveText(x, y) {
      this.setLeading(-y);
      this.moveText(x, y);
    }

    setTextMatrix(a, b, c, d, e, f) {
      this.current.textMatrix = [a, b, c, d, e, f];
      this.current.textMatrixScale = Math.hypot(a, b);
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    }

    nextLine() {
      this.moveText(0, this.current.leading);
    }

    paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
      const ctx = this.ctx;
      const current = this.current;
      const font = current.font;
      const textRenderingMode = current.textRenderingMode;
      const fontSize = current.fontSize / current.fontSizeScale;
      const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
      const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
      const patternFill = current.patternFill && !font.missingFile;
      let addToPath;

      if (font.disableFontFace || isAddToPathSet || patternFill) {
        addToPath = font.getPathGenerator(this.commonObjs, character);
      }

      if (font.disableFontFace || patternFill) {
        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath();
        addToPath(ctx, fontSize);

        if (patternTransform) {
          ctx.setTransform.apply(ctx, patternTransform);
        }

        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.fill();
        }

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          if (resetLineWidthToOne) {
            ctx.resetTransform();
            ctx.lineWidth = Math.round(this._combinedScaleFactor);
          }

          ctx.stroke();
        }

        ctx.restore();
      } else {
        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          ctx.fillText(character, x, y);
        }

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          if (resetLineWidthToOne) {
            ctx.save();
            ctx.moveTo(x, y);
            ctx.resetTransform();
            ctx.lineWidth = Math.round(this._combinedScaleFactor);
            ctx.strokeText(character, 0, 0);
            ctx.restore();
          } else {
            ctx.strokeText(character, x, y);
          }
        }
      }

      if (isAddToPathSet) {
        const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
        paths.push({
          transform: ctx.mozCurrentTransform,
          x,
          y,
          fontSize,
          addToPath
        });
      }
    }

    get isFontSubpixelAAEnabled() {
      const {
        context: ctx
      } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
      ctx.scale(1.5, 1);
      ctx.fillText("I", 0, 10);
      const data = ctx.getImageData(0, 0, 10, 10).data;
      let enabled = false;

      for (let i = 3; i < data.length; i += 4) {
        if (data[i] > 0 && data[i] < 255) {
          enabled = true;
          break;
        }
      }

      return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
    }

    showText(glyphs) {
      const current = this.current;
      const font = current.font;

      if (font.isType3Font) {
        return this.showType3Text(glyphs);
      }

      const fontSize = current.fontSize;

      if (fontSize === 0) {
        return undefined;
      }

      const ctx = this.ctx;
      const fontSizeScale = current.fontSizeScale;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const fontDirection = current.fontDirection;
      const textHScale = current.textHScale * fontDirection;
      const glyphsLength = glyphs.length;
      const vertical = font.vertical;
      const spacingDir = vertical ? 1 : -1;
      const defaultVMetrics = font.defaultVMetrics;
      const widthAdvanceScale = fontSize * current.fontMatrix[0];
      const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
      ctx.save();
      let patternTransform;

      if (current.patternFill) {
        ctx.save();
        const pattern = current.fillColor.getPattern(ctx, this);
        patternTransform = ctx.mozCurrentTransform;
        ctx.restore();
        ctx.fillStyle = pattern;
      }

      ctx.transform.apply(ctx, current.textMatrix);
      ctx.translate(current.x, current.y + current.textRise);

      if (fontDirection > 0) {
        ctx.scale(textHScale, -1);
      } else {
        ctx.scale(textHScale, 1);
      }

      let lineWidth = current.lineWidth;
      let resetLineWidthToOne = false;
      const scale = current.textMatrixScale;

      if (scale === 0 || lineWidth === 0) {
        const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          this._cachedGetSinglePixelWidth = null;
          lineWidth = this.getSinglePixelWidth();
          resetLineWidthToOne = lineWidth < 0;
        }
      } else {
        lineWidth /= scale;
      }

      if (fontSizeScale !== 1.0) {
        ctx.scale(fontSizeScale, fontSizeScale);
        lineWidth /= fontSizeScale;
      }

      ctx.lineWidth = lineWidth;
      let x = 0,
          i;

      for (i = 0; i < glyphsLength; ++i) {
        const glyph = glyphs[i];

        if ((0, _util.isNum)(glyph)) {
          x += spacingDir * glyph * fontSize / 1000;
          continue;
        }

        let restoreNeeded = false;
        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const character = glyph.fontChar;
        const accent = glyph.accent;
        let scaledX, scaledY;
        let width = glyph.width;

        if (vertical) {
          const vmetric = glyph.vmetric || defaultVMetrics;
          const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
          const vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }

        if (font.remeasure && width > 0) {
          const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
            const characterScaleX = width / measuredWidth;
            restoreNeeded = true;
            ctx.save();
            ctx.scale(characterScaleX, 1);
            scaledX /= characterScaleX;
          } else if (width !== measuredWidth) {
            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
          }
        }

        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
          if (simpleFillText && !accent) {
            ctx.fillText(character, scaledX, scaledY);
          } else {
            this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);

            if (accent) {
              const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
              const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
            }
          }
        }

        let charWidth;

        if (vertical) {
          charWidth = width * widthAdvanceScale - spacing * fontDirection;
        } else {
          charWidth = width * widthAdvanceScale + spacing * fontDirection;
        }

        x += charWidth;

        if (restoreNeeded) {
          ctx.restore();
        }
      }

      if (vertical) {
        current.y -= x;
      } else {
        current.x += x * textHScale;
      }

      ctx.restore();
      return undefined;
    }

    showType3Text(glyphs) {
      const ctx = this.ctx;
      const current = this.current;
      const font = current.font;
      const fontSize = current.fontSize;
      const fontDirection = current.fontDirection;
      const spacingDir = font.vertical ? 1 : -1;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const textHScale = current.textHScale * fontDirection;
      const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      const glyphsLength = glyphs.length;
      const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
      let i, glyph, width, spacingLength;

      if (isTextInvisible || fontSize === 0) {
        return;
      }

      this._cachedGetSinglePixelWidth = null;
      ctx.save();
      ctx.transform.apply(ctx, current.textMatrix);
      ctx.translate(current.x, current.y);
      ctx.scale(textHScale, fontDirection);

      for (i = 0; i < glyphsLength; ++i) {
        glyph = glyphs[i];

        if ((0, _util.isNum)(glyph)) {
          spacingLength = spacingDir * glyph * fontSize / 1000;
          this.ctx.translate(spacingLength, 0);
          current.x += spacingLength * textHScale;
          continue;
        }

        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const operatorList = font.charProcOperatorList[glyph.operatorListId];

        if (!operatorList) {
          (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
          continue;
        }

        if (this.contentVisible) {
          this.processingType3 = glyph;
          this.save();
          ctx.scale(fontSize, fontSize);
          ctx.transform.apply(ctx, fontMatrix);
          this.executeOperatorList(operatorList);
          this.restore();
        }

        const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

        width = transformed[0] * fontSize + spacing;
        ctx.translate(width, 0);
        current.x += width * textHScale;
      }

      ctx.restore();
      this.processingType3 = null;
    }

    setCharWidth(xWidth, yWidth) {}

    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
      this.ctx.rect(llx, lly, urx - llx, ury - lly);
      this.clip();
      this.endPath();
    }

    getColorN_Pattern(IR) {
      let pattern;

      if (IR[0] === "TilingPattern") {
        const color = IR[1];
        const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
        const canvasGraphicsFactory = {
          createCanvasGraphics: ctx => {
            return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
          }
        };
        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
      } else {
        pattern = (0, _pattern_helper.getShadingPattern)(IR);
      }

      return pattern;
    }

    setStrokeColorN() {
      this.current.strokeColor = this.getColorN_Pattern(arguments);
    }

    setFillColorN() {
      this.current.fillColor = this.getColorN_Pattern(arguments);
      this.current.patternFill = true;
    }

    setStrokeRGBColor(r, g, b) {
      const color = _util.Util.makeHexColor(r, g, b);

      this.ctx.strokeStyle = color;
      this.current.strokeColor = color;
    }

    setFillRGBColor(r, g, b) {
      const color = _util.Util.makeHexColor(r, g, b);

      this.ctx.fillStyle = color;
      this.current.fillColor = color;
      this.current.patternFill = false;
    }

    shadingFill(patternIR) {
      if (!this.contentVisible) {
        return;
      }

      const ctx = this.ctx;
      this.save();
      const pattern = (0, _pattern_helper.getShadingPattern)(patternIR);
      ctx.fillStyle = pattern.getPattern(ctx, this, true);
      const inv = ctx.mozCurrentTransformInverse;

      if (inv) {
        const canvas = ctx.canvas;
        const width = canvas.width;
        const height = canvas.height;

        const bl = _util.Util.applyTransform([0, 0], inv);

        const br = _util.Util.applyTransform([0, height], inv);

        const ul = _util.Util.applyTransform([width, 0], inv);

        const ur = _util.Util.applyTransform([width, height], inv);

        const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
        const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
        const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
        const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
      } else {
        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      }

      this.restore();
    }

    beginInlineImage() {
      (0, _util.unreachable)("Should not call beginInlineImage");
    }

    beginImageData() {
      (0, _util.unreachable)("Should not call beginImageData");
    }

    paintFormXObjectBegin(matrix, bbox) {
      if (!this.contentVisible) {
        return;
      }

      this.save();
      this.baseTransformStack.push(this.baseTransform);

      if (Array.isArray(matrix) && matrix.length === 6) {
        this.transform.apply(this, matrix);
      }

      this.baseTransform = this.ctx.mozCurrentTransform;

      if (bbox) {
        const width = bbox[2] - bbox[0];
        const height = bbox[3] - bbox[1];
        this.ctx.rect(bbox[0], bbox[1], width, height);
        this.clip();
        this.endPath();
      }
    }

    paintFormXObjectEnd() {
      if (!this.contentVisible) {
        return;
      }

      this.restore();
      this.baseTransform = this.baseTransformStack.pop();
    }

    beginGroup(group) {
      if (!this.contentVisible) {
        return;
      }

      this.save();
      const currentCtx = this.ctx;

      if (!group.isolated) {
        (0, _util.info)("TODO: Support non-isolated groups.");
      }

      if (group.knockout) {
        (0, _util.warn)("Knockout groups not supported.");
      }

      const currentTransform = currentCtx.mozCurrentTransform;

      if (group.matrix) {
        currentCtx.transform.apply(currentCtx, group.matrix);
      }

      if (!group.bbox) {
        throw new Error("Bounding box is required.");
      }

      let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

      const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
      const offsetX = Math.floor(bounds[0]);
      const offsetY = Math.floor(bounds[1]);
      let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
      let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
      let scaleX = 1,
          scaleY = 1;

      if (drawnWidth > MAX_GROUP_SIZE) {
        scaleX = drawnWidth / MAX_GROUP_SIZE;
        drawnWidth = MAX_GROUP_SIZE;
      }

      if (drawnHeight > MAX_GROUP_SIZE) {
        scaleY = drawnHeight / MAX_GROUP_SIZE;
        drawnHeight = MAX_GROUP_SIZE;
      }

      let cacheId = "groupAt" + this.groupLevel;

      if (group.smask) {
        cacheId += "_smask_" + this.smaskCounter++ % 2;
      }

      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
      const groupCtx = scratchCanvas.context;
      groupCtx.scale(1 / scaleX, 1 / scaleY);
      groupCtx.translate(-offsetX, -offsetY);
      groupCtx.transform.apply(groupCtx, currentTransform);

      if (group.smask) {
        this.smaskStack.push({
          canvas: scratchCanvas.canvas,
          context: groupCtx,
          offsetX,
          offsetY,
          scaleX,
          scaleY,
          subtype: group.smask.subtype,
          backdrop: group.smask.backdrop,
          transferMap: group.smask.transferMap || null,
          startTransformInverse: null
        });
      } else {
        currentCtx.setTransform(1, 0, 0, 1, 0, 0);
        currentCtx.translate(offsetX, offsetY);
        currentCtx.scale(scaleX, scaleY);
      }

      copyCtxState(currentCtx, groupCtx);
      this.ctx = groupCtx;
      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
      this.groupStack.push(currentCtx);
      this.groupLevel++;
      this.current.activeSMask = null;
    }

    endGroup(group) {
      if (!this.contentVisible) {
        return;
      }

      this.groupLevel--;
      const groupCtx = this.ctx;
      this.ctx = this.groupStack.pop();

      if (this.ctx.imageSmoothingEnabled !== undefined) {
        this.ctx.imageSmoothingEnabled = false;
      } else {
        this.ctx.mozImageSmoothingEnabled = false;
      }

      if (group.smask) {
        this.tempSMask = this.smaskStack.pop();
      } else {
        this.ctx.drawImage(groupCtx.canvas, 0, 0);
      }

      this.restore();
    }

    beginAnnotations() {
      this.save();

      if (this.baseTransform) {
        this.ctx.setTransform.apply(this.ctx, this.baseTransform);
      }
    }

    endAnnotations() {
      this.restore();
    }

    beginAnnotation(rect, transform, matrix) {
      this.save();
      resetCtxToDefault(this.ctx);
      this.current = new CanvasExtraState();

      if (Array.isArray(rect) && rect.length === 4) {
        const width = rect[2] - rect[0];
        const height = rect[3] - rect[1];
        this.ctx.rect(rect[0], rect[1], width, height);
        this.clip();
        this.endPath();
      }

      this.transform.apply(this, transform);
      this.transform.apply(this, matrix);
    }

    endAnnotation() {
      this.restore();
    }

    paintImageMaskXObject(img) {
      if (!this.contentVisible) {
        return;
      }

      const ctx = this.ctx;
      const width = img.width,
            height = img.height;
      const fillColor = this.current.fillColor;
      const isPatternFill = this.current.patternFill;
      const glyph = this.processingType3;

      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
          glyph.compiled = compileType3Glyph({
            data: img.data,
            width,
            height
          });
        } else {
          glyph.compiled = null;
        }
      }

      if (glyph?.compiled) {
        glyph.compiled(ctx);
        return;
      }

      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      this.paintInlineImageXObject(maskCanvas.canvas);
    }

    paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
      if (!this.contentVisible) {
        return;
      }

      const width = imgData.width;
      const height = imgData.height;
      const fillColor = this.current.fillColor;
      const isPatternFill = this.current.patternFill;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      putBinaryImageMask(maskCtx, imgData);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      const ctx = this.ctx;

      for (let i = 0, ii = positions.length; i < ii; i += 2) {
        ctx.save();
        ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);
        ctx.scale(1, -1);
        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
        ctx.restore();
      }
    }

    paintImageMaskXObjectGroup(images) {
      if (!this.contentVisible) {
        return;
      }

      const ctx = this.ctx;
      const fillColor = this.current.fillColor;
      const isPatternFill = this.current.patternFill;

      for (let i = 0, ii = images.length; i < ii; i++) {
        const image = images[i];
        const width = image.width,
              height = image.height;
        const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
        const maskCtx = maskCanvas.context;
        maskCtx.save();
        putBinaryImageMask(maskCtx, image);
        maskCtx.globalCompositeOperation = "source-in";
        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
        maskCtx.fillRect(0, 0, width, height);
        maskCtx.restore();
        ctx.save();
        ctx.transform.apply(ctx, image.transform);
        ctx.scale(1, -1);
        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
        ctx.restore();
      }
    }

    paintImageXObject(objId) {
      if (!this.contentVisible) {
        return;
      }

      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)("Dependent image isn't ready yet");
        return;
      }

      this.paintInlineImageXObject(imgData);
    }

    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
      if (!this.contentVisible) {
        return;
      }

      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)("Dependent image isn't ready yet");
        return;
      }

      const width = imgData.width;
      const height = imgData.height;
      const map = [];

      for (let i = 0, ii = positions.length; i < ii; i += 2) {
        map.push({
          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
          x: 0,
          y: 0,
          w: width,
          h: height
        });
      }

      this.paintInlineImageXObjectGroup(imgData, map);
    }

    paintInlineImageXObject(imgData) {
      if (!this.contentVisible) {
        return;
      }

      const width = imgData.width;
      const height = imgData.height;
      const ctx = this.ctx;
      this.save();
      ctx.scale(1 / width, -1 / height);
      const currentTransform = ctx.mozCurrentTransformInverse;
      let widthScale = Math.max(Math.hypot(currentTransform[0], currentTransform[1]), 1);
      let heightScale = Math.max(Math.hypot(currentTransform[2], currentTransform[3]), 1);
      let imgToPaint, tmpCanvas, tmpCtx;

      if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
        imgToPaint = imgData;
      } else {
        tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
        tmpCtx = tmpCanvas.context;
        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
        imgToPaint = tmpCanvas.canvas;
      }

      let paintWidth = width,
          paintHeight = height;
      let tmpCanvasId = "prescale1";

      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
        let newWidth = paintWidth,
            newHeight = paintHeight;

        if (widthScale > 2 && paintWidth > 1) {
          newWidth = Math.ceil(paintWidth / 2);
          widthScale /= paintWidth / newWidth;
        }

        if (heightScale > 2 && paintHeight > 1) {
          newHeight = Math.ceil(paintHeight / 2);
          heightScale /= paintHeight / newHeight;
        }

        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
        tmpCtx = tmpCanvas.context;
        tmpCtx.clearRect(0, 0, newWidth, newHeight);
        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
        imgToPaint = tmpCanvas.canvas;
        paintWidth = newWidth;
        paintHeight = newHeight;
        tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
      }

      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);

      if (this.imageLayer) {
        const position = this.getCanvasPosition(0, -height);
        this.imageLayer.appendImage({
          imgData,
          left: position[0],
          top: position[1],
          width: width / currentTransform[0],
          height: height / currentTransform[3]
        });
      }

      this.restore();
    }

    paintInlineImageXObjectGroup(imgData, map) {
      if (!this.contentVisible) {
        return;
      }

      const ctx = this.ctx;
      const w = imgData.width;
      const h = imgData.height;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

      for (let i = 0, ii = map.length; i < ii; i++) {
        const entry = map[i];
        ctx.save();
        ctx.transform.apply(ctx, entry.transform);
        ctx.scale(1, -1);
        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

        if (this.imageLayer) {
          const position = this.getCanvasPosition(entry.x, entry.y);
          this.imageLayer.appendImage({
            imgData,
            left: position[0],
            top: position[1],
            width: w,
            height: h
          });
        }

        ctx.restore();
      }
    }

    paintSolidColorImageMask() {
      if (!this.contentVisible) {
        return;
      }

      this.ctx.fillRect(0, 0, 1, 1);
    }

    markPoint(tag) {}

    markPointProps(tag, properties) {}

    beginMarkedContent(tag) {
      this.markedContentStack.push({
        visible: true
      });
    }

    beginMarkedContentProps(tag, properties) {
      if (tag === "OC") {
        this.markedContentStack.push({
          visible: this.optionalContentConfig.isVisible(properties)
        });
      } else {
        this.markedContentStack.push({
          visible: true
        });
      }

      this.contentVisible = this.isContentVisible();
    }

    endMarkedContent() {
      this.markedContentStack.pop();
      this.contentVisible = this.isContentVisible();
    }

    beginCompat() {}

    endCompat() {}

    consumePath() {
      const ctx = this.ctx;

      if (this.pendingClip) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip("evenodd");
        } else {
          ctx.clip();
        }

        this.pendingClip = null;
      }

      ctx.beginPath();
    }

    getSinglePixelWidth() {
      if (this._cachedGetSinglePixelWidth === null) {
        const m = this.ctx.mozCurrentTransform;
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const sqNorm1 = m[0] ** 2 + m[2] ** 2;
        const sqNorm2 = m[1] ** 2 + m[3] ** 2;
        const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;

        if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
          this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
        } else if (absDet > Number.EPSILON) {
          this._cachedGetSinglePixelWidth = pixelHeight;
        } else {
          this._cachedGetSinglePixelWidth = 1;
        }
      }

      return this._cachedGetSinglePixelWidth;
    }

    getCanvasPosition(x, y) {
      const transform = this.ctx.mozCurrentTransform;
      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
    }

    isContentVisible() {
      for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
        if (!this.markedContentStack[i].visible) {
          return false;
        }
      }

      return true;
    }

  }

  for (const op in _util.OPS) {
    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
  }

  return CanvasGraphics;
}();

exports.CanvasGraphics = CanvasGraphics;

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getShadingPattern = getShadingPattern;
exports.TilingPattern = void 0;

var _util = __w_pdfjs_require__(2);

let svgElement;

function createMatrix(matrix) {
  if (typeof DOMMatrix !== "undefined") {
    return new DOMMatrix(matrix);
  }

  if (!svgElement) {
    svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  }

  return svgElement.createSVGMatrix(matrix);
}

function applyBoundingBox(ctx, bbox) {
  if (!bbox || typeof Path2D === "undefined") {
    return;
  }

  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}

class BaseShadingPattern {
  constructor() {
    if (this.constructor === BaseShadingPattern) {
      (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
    }
  }

  getPattern() {
    (0, _util.unreachable)("Abstract method `getPattern` called.");
  }

}

class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this._matrix = IR[8];
  }

  getPattern(ctx, owner, shadingFill) {
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", ctx.canvas.width, ctx.canvas.height, true);
    const tmpCtx = tmpCanvas.context;
    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
    tmpCtx.beginPath();
    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);

    if (!shadingFill) {
      tmpCtx.setTransform.apply(tmpCtx, owner.baseTransform);

      if (this._matrix) {
        tmpCtx.transform.apply(tmpCtx, this._matrix);
      }
    } else {
      tmpCtx.setTransform.apply(tmpCtx, ctx.mozCurrentTransform);
    }

    applyBoundingBox(tmpCtx, this._bbox);
    let grad;

    if (this._type === "axial") {
      grad = tmpCtx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = tmpCtx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }

    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }

    tmpCtx.fillStyle = grad;
    tmpCtx.fill();
    const pattern = ctx.createPattern(tmpCanvas.canvas, "repeat");
    pattern.setTransform(createMatrix(ctx.mozCurrentTransformInverse));
    return pattern;
  }

}

function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords,
        colors = context.colors;
  const bytes = data.data,
        rowSize = data.width * 4;
  let tmp;

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

  if (y1 >= y3) {
    return;
  }

  const c1r = colors[c1],
        c1g = colors[c1 + 1],
        c1b = colors[c1 + 2];
  const c2r = colors[c2],
        c2g = colors[c2 + 1],
        c2b = colors[c2 + 2];
  const c3r = colors[c3],
        c3g = colors[c3 + 1],
        c3b = colors[c3 + 2];
  const minY = Math.round(y1),
        maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;

  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      let k;

      if (y < y1) {
        k = 0;
      } else if (y1 === y2) {
        k = 1;
      } else {
        k = (y1 - y) / (y1 - y2);
      }

      xa = x1 - (x1 - x2) * k;
      car = c1r - (c1r - c2r) * k;
      cag = c1g - (c1g - c2g) * k;
      cab = c1b - (c1b - c2b) * k;
    } else {
      let k;

      if (y > y3) {
        k = 1;
      } else if (y2 === y3) {
        k = 0;
      } else {
        k = (y2 - y) / (y2 - y3);
      }

      xa = x2 - (x2 - x3) * k;
      car = c2r - (c2r - c3r) * k;
      cag = c2g - (c2g - c3g) * k;
      cab = c2b - (c2b - c3b) * k;
    }

    let k;

    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }

    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;

    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);

      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }

      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}

function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;

  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;

      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;

        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }

      break;

    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }

      break;

    default:
      throw new Error("illegal figure");
  }
}

class MeshShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._matrix = IR[6];
    this._bbox = IR[7];
    this._background = IR[8];
  }

  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3000;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);

    if (backgroundColor) {
      const bytes = data.data;

      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }

    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }

    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }

  getPattern(ctx, owner, shadingFill) {
    applyBoundingBox(ctx, this._bbox);
    let scale;

    if (shadingFill) {
      scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
    } else {
      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

      if (this._matrix) {
        const matrixScale = _util.Util.singularValueDecompose2dScale(this._matrix);

        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
      }
    }

    const temporaryPatternCanvas = this._createMeshCanvas(scale, shadingFill ? null : this._background, owner.cachedCanvases);

    if (!shadingFill) {
      ctx.setTransform.apply(ctx, owner.baseTransform);

      if (this._matrix) {
        ctx.transform.apply(ctx, this._matrix);
      }
    }

    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }

}

class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }

}

function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);

    case "Mesh":
      return new MeshShadingPattern(IR);

    case "Dummy":
      return new DummyShadingPattern();
  }

  throw new Error(`Unknown IR type: ${IR[0]}`);
}

const PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};

class TilingPattern {
  static get MAX_PATTERN_SIZE() {
    return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
  }

  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }

  createPatternCanvas(owner) {
    const operatorList = this.operatorList;
    const bbox = this.bbox;
    const xstep = this.xstep;
    const ystep = this.ystep;
    const paintType = this.paintType;
    const tilingType = this.tilingType;
    const color = this.color;
    const canvasGraphicsFactory = this.canvasGraphicsFactory;
    (0, _util.info)("TilingType: " + tilingType);
    const x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3];

    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
    this.clipBbox(graphics, bbox, x0, y0, x1, y1);
    graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale
    };
  }

  getSizeAndScale(step, realOutputSize, scale) {
    step = Math.abs(step);
    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);

    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }

    return {
      scale,
      size
    };
  }

  clipBbox(graphics, bbox, x0, y0, x1, y1) {
    if (Array.isArray(bbox) && bbox.length === 4) {
      const bboxWidth = x1 - x0;
      const bboxHeight = y1 - y0;
      graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
      graphics.clip();
      graphics.endPath();
    }
  }

  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx,
          current = graphics.current;

    switch (paintType) {
      case PaintType.COLORED:
        const ctx = this.ctx;
        context.fillStyle = ctx.fillStyle;
        context.strokeStyle = ctx.strokeStyle;
        current.fillColor = ctx.fillStyle;
        current.strokeColor = ctx.strokeStyle;
        break;

      case PaintType.UNCOLORED:
        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

        context.fillStyle = cssColor;
        context.strokeStyle = cssColor;
        current.fillColor = cssColor;
        current.strokeColor = cssColor;
        break;

      default:
        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
    }
  }

  getPattern(ctx, owner, shadingFill) {
    ctx = this.ctx;
    let matrix = ctx.mozCurrentTransformInverse;

    if (!shadingFill) {
      matrix = _util.Util.transform(matrix, owner.baseTransform);

      if (this.matrix) {
        matrix = _util.Util.transform(matrix, this.matrix);
      }
    }

    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = createMatrix(matrix);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
    pattern.setTransform(domMatrix);
    return pattern;
  }

}

exports.TilingPattern = TilingPattern;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlobalWorkerOptions = void 0;
const GlobalWorkerOptions = Object.create(null);
exports.GlobalWorkerOptions = GlobalWorkerOptions;
GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;

var _util = __w_pdfjs_require__(2);

const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};

function wrapReason(reason) {
  if (typeof reason !== "object" || reason === null) {
    return reason;
  }

  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);

    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);

    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);

    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);

    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}

class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.postMessageTransfers = true;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);

    this._onComObjOnMessage = event => {
      const data = event.data;

      if (data.targetName !== this.sourceName) {
        return;
      }

      if (data.stream) {
        this._processStreamMessage(data);

        return;
      }

      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];

        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }

        delete this.callbackCapabilities[callbackId];

        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }

        return;
      }

      const action = this.actionHandler[data.action];

      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }

      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }

      if (data.streamId) {
        this._createStreamSink(data);

        return;
      }

      action(data.data);
    };

    comObj.addEventListener("message", this._onComObjOnMessage);
  }

  on(actionName, handler) {
    const ah = this.actionHandler;

    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }

    ah[actionName] = handler;
  }

  send(actionName, data, transfers) {
    this._postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }

  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = (0, _util.createPromiseCapability)();
    this.callbackCapabilities[callbackId] = capability;

    try {
      this._postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }

    return capability.promise;
  }

  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++;
    const sourceName = this.sourceName;
    const targetName = this.targetName;
    const comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };

        this._postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);

        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }

  _createStreamSink(data) {
    const self = this;
    const action = this.actionHandler[data.action];
    const streamId = data.streamId;
    const sourceName = this.sourceName;
    const targetName = data.sourceName;
    const comObj = this.comObj;
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }

        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;

        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = (0, _util.createPromiseCapability)();
          this.ready = this.sinkCapability.promise;
        }

        self._postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },

      close() {
        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },

      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },

      sinkCapability: (0, _util.createPromiseCapability)(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }

  _processStreamMessage(data) {
    const streamId = data.streamId;
    const sourceName = this.sourceName;
    const targetName = data.sourceName;
    const comObj = this.comObj;

    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].startCall.resolve();
        } else {
          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].pullCall.resolve();
        } else {
          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL:
        if (!this.streamSinks[streamId]) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }

        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
          this.streamSinks[streamId].sinkCapability.resolve();
        }

        this.streamSinks[streamId].desiredSize = data.desiredSize;
        const {
          onPull
        } = this.streamSinks[data.streamId];
        new Promise(function (resolve) {
          resolve(onPull && onPull());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;

      case StreamKind.ENQUEUE:
        (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller");

        if (this.streamControllers[streamId].isClosed) {
          break;
        }

        this.streamControllers[streamId].controller.enqueue(data.chunk);
        break;

      case StreamKind.CLOSE:
        (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller");

        if (this.streamControllers[streamId].isClosed) {
          break;
        }

        this.streamControllers[streamId].isClosed = true;
        this.streamControllers[streamId].controller.close();

        this._deleteStreamController(streamId);

        break;

      case StreamKind.ERROR:
        (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller");
        this.streamControllers[streamId].controller.error(wrapReason(data.reason));

        this._deleteStreamController(streamId);

        break;

      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].cancelCall.resolve();
        } else {
          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
        }

        this._deleteStreamController(streamId);

        break;

      case StreamKind.CANCEL:
        if (!this.streamSinks[streamId]) {
          break;
        }

        const {
          onCancel
        } = this.streamSinks[data.streamId];
        new Promise(function (resolve) {
          resolve(onCancel && onCancel(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
        this.streamSinks[streamId].isCancelled = true;
        delete this.streamSinks[streamId];
        break;

      default:
        throw new Error("Unexpected stream case");
    }
  }

  async _deleteStreamController(streamId) {
    await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {
      return capability && capability.promise;
    }));
    delete this.streamControllers[streamId];
  }

  _postMessage(message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }

  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }

}

exports.MessageHandler = MessageHandler;

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Metadata = void 0;

var _util = __w_pdfjs_require__(2);

class Metadata {
  constructor({
    parsedData,
    rawData
  }) {
    this._metadataMap = parsedData;
    this._data = rawData;
  }

  getRaw() {
    return this._data;
  }

  get(name) {
    return this._metadataMap.get(name) ?? null;
  }

  getAll() {
    return (0, _util.objectFromMap)(this._metadataMap);
  }

  has(name) {
    return this._metadataMap.has(name);
  }

}

exports.Metadata = Metadata;

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionalContentConfig = void 0;

var _util = __w_pdfjs_require__(2);

class OptionalContentGroup {
  constructor(name, intent) {
    this.visible = true;
    this.name = name;
    this.intent = intent;
  }

}

class OptionalContentConfig {
  constructor(data) {
    this.name = null;
    this.creator = null;
    this._order = null;
    this._groups = new Map();

    if (data === null) {
      return;
    }

    this.name = data.name;
    this.creator = data.creator;
    this._order = data.order;

    for (const group of data.groups) {
      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
    }

    if (data.baseState === "OFF") {
      for (const group of this._groups) {
        group.visible = false;
      }
    }

    for (const on of data.on) {
      this._groups.get(on).visible = true;
    }

    for (const off of data.off) {
      this._groups.get(off).visible = false;
    }
  }

  _evaluateVisibilityExpression(array) {
    const length = array.length;

    if (length < 2) {
      return true;
    }

    const operator = array[0];

    for (let i = 1; i < length; i++) {
      const element = array[i];
      let state;

      if (Array.isArray(element)) {
        state = this._evaluateVisibilityExpression(element);
      } else if (this._groups.has(element)) {
        state = this._groups.get(element).visible;
      } else {
        (0, _util.warn)(`Optional content group not found: ${element}`);
        return true;
      }

      switch (operator) {
        case "And":
          if (!state) {
            return false;
          }

          break;

        case "Or":
          if (state) {
            return true;
          }

          break;

        case "Not":
          return !state;

        default:
          return true;
      }
    }

    return operator === "And";
  }

  isVisible(group) {
    if (group.type === "OCG") {
      if (!this._groups.has(group.id)) {
        (0, _util.warn)(`Optional content group not found: ${group.id}`);
        return true;
      }

      return this._groups.get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return this._evaluateVisibilityExpression(group.expression);
      }

      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (this._groups.get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!this._groups.get(id).visible) {
            return false;
          }
        }

        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!this._groups.get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (this._groups.get(id).visible) {
            return false;
          }
        }

        return true;
      }

      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
      return true;
    }

    (0, _util.warn)(`Unknown group type ${group.type}.`);
    return true;
  }

  setVisibility(id, visible = true) {
    if (!this._groups.has(id)) {
      (0, _util.warn)(`Optional content group not found: ${id}`);
      return;
    }

    this._groups.get(id).visible = !!visible;
  }

  getOrder() {
    if (!this._groups.size) {
      return null;
    }

    if (this._order) {
      return this._order.slice();
    }

    return Array.from(this._groups.keys());
  }

  getGroups() {
    return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;
  }

  getGroup(id) {
    return this._groups.get(id) || null;
  }

}

exports.OptionalContentConfig = OptionalContentConfig;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDataTransportStream = void 0;

var _util = __w_pdfjs_require__(2);

var _display_utils = __w_pdfjs_require__(1);

class PDFDataTransportStream {
  constructor(params, pdfDataRangeTransport) {
    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    this._queuedChunks = [];
    this._progressiveDone = params.progressiveDone || false;
    this._contentDispositionFilename = params.contentDispositionFilename || null;
    const initialData = params.initialData;

    if (initialData?.length > 0) {
      const buffer = new Uint8Array(initialData).buffer;

      this._queuedChunks.push(buffer);
    }

    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !params.disableStream;
    this._isRangeSupported = !params.disableRange;
    this._contentLength = params.length;
    this._fullRequestReader = null;
    this._rangeReaders = [];

    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });

    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
      this._onReceiveData({
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });

    this._pdfDataRangeTransport.transportReady();
  }

  _onReceiveData(args) {
    const buffer = new Uint8Array(args.chunk).buffer;

    if (args.begin === undefined) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function (rangeReader) {
        if (rangeReader._begin !== args.begin) {
          return false;
        }

        rangeReader._enqueue(buffer);

        return true;
      });

      (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  _onProgress(evt) {
    if (evt.total === undefined) {
      const firstReader = this._rangeReaders[0];

      if (firstReader?.onProgress) {
        firstReader.onProgress({
          loaded: evt.loaded
        });
      }
    } else {
      const fullReader = this._fullRequestReader;

      if (fullReader?.onProgress) {
        fullReader.onProgress({
          loaded: evt.loaded,
          total: evt.total
        });
      }
    }
  }

  _onProgressiveDone() {
    if (this._fullRequestReader) {
      this._fullRequestReader.progressiveDone();
    }

    this._progressiveDone = true;
  }

  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);

    this._pdfDataRangeTransport.requestDataRange(begin, end);

    this._rangeReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }

    this._pdfDataRangeTransport.abort();
  }

}

exports.PDFDataTransportStream = PDFDataTransportStream;

class PDFDataTransportStreamReader {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;

    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }

    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }

    this._loaded += chunk.byteLength;
  }

  get headersReady() {
    return this._headersReady;
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }

  get contentLength() {
    return this._stream._contentLength;
  }

  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  progressiveDone() {
    if (this._done) {
      return;
    }

    this._done = true;
  }

}

class PDFDataTransportStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();

      requestsCapability.resolve({
        value: chunk,
        done: false
      });

      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      }

      this._requests.length = 0;
    }

    this._done = true;

    this._stream._removeRangeReader(this);
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._stream._removeRangeReader(this);
  }

}

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationLayer = void 0;

var _display_utils = __w_pdfjs_require__(1);

var _util = __w_pdfjs_require__(2);

var _annotation_storage = __w_pdfjs_require__(8);

var _scripting_utils = __w_pdfjs_require__(18);

class AnnotationElementFactory {
  static create(parameters) {
    const subtype = parameters.data.annotationType;

    switch (subtype) {
      case _util.AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);

      case _util.AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);

      case _util.AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;

        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);

          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }

            return new PushButtonWidgetAnnotationElement(parameters);

          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
        }

        return new WidgetAnnotationElement(parameters);

      case _util.AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);

      case _util.AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);

      case _util.AnnotationType.LINE:
        return new LineAnnotationElement(parameters);

      case _util.AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);

      case _util.AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);

      case _util.AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);

      case _util.AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);

      case _util.AnnotationType.INK:
        return new InkAnnotationElement(parameters);

      case _util.AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);

      case _util.AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);

      case _util.AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);

      case _util.AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);

      case _util.AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);

      case _util.AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);

      case _util.AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);

      default:
        return new AnnotationElement(parameters);
    }
  }

}

class AnnotationElement {
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.page = parameters.page;
    this.viewport = parameters.viewport;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderInteractiveForms = parameters.renderInteractiveForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._mouseState = parameters.mouseState;

    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }

    if (createQuadrilaterals) {
      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
    }
  }

  _createContainer(ignoreBorder = false) {
    const data = this.data,
          page = this.page,
          viewport = this.viewport;
    const container = document.createElement("section");
    let width = data.rect[2] - data.rect[0];
    let height = data.rect[3] - data.rect[1];
    container.setAttribute("data-annotation-id", data.id);

    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

    container.style.transform = `matrix(${viewport.transform.join(",")})`;
    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;

    if (!ignoreBorder && data.borderStyle.width > 0) {
      container.style.borderWidth = `${data.borderStyle.width}px`;

      if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
        width = width - 2 * data.borderStyle.width;
        height = height - 2 * data.borderStyle.width;
      }

      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;

      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `${horizontalRadius}px / ${verticalRadius}px`;
        container.style.borderRadius = radius;
      }

      switch (data.borderStyle.style) {
        case _util.AnnotationBorderStyleType.SOLID:
          container.style.borderStyle = "solid";
          break;

        case _util.AnnotationBorderStyleType.DASHED:
          container.style.borderStyle = "dashed";
          break;

        case _util.AnnotationBorderStyleType.BEVELED:
          (0, _util.warn)("Unimplemented border style: beveled");
          break;

        case _util.AnnotationBorderStyleType.INSET:
          (0, _util.warn)("Unimplemented border style: inset");
          break;

        case _util.AnnotationBorderStyleType.UNDERLINE:
          container.style.borderBottomStyle = "solid";
          break;

        default:
          break;
      }

      if (data.color) {
        container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
      } else {
        container.style.borderWidth = 0;
      }
    }

    container.style.left = `${rect[0]}px`;
    container.style.top = `${rect[1]}px`;
    container.style.width = `${width}px`;
    container.style.height = `${height}px`;
    return container;
  }

  _createQuadrilaterals(ignoreBorder = false) {
    if (!this.data.quadPoints) {
      return null;
    }

    const quadrilaterals = [];
    const savedRect = this.data.rect;

    for (const quadPoint of this.data.quadPoints) {
      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
      quadrilaterals.push(this._createContainer(ignoreBorder));
    }

    this.data.rect = savedRect;
    return quadrilaterals;
  }

  _createPopup(trigger, data) {
    let container = this.container;

    if (this.quadrilaterals) {
      trigger = trigger || this.quadrilaterals;
      container = this.quadrilaterals[0];
    }

    if (!trigger) {
      trigger = document.createElement("div");
      trigger.style.height = container.style.height;
      trigger.style.width = container.style.width;
      container.appendChild(trigger);
    }

    const popupElement = new PopupElement({
      container,
      trigger,
      color: data.color,
      title: data.title,
      modificationDate: data.modificationDate,
      contents: data.contents,
      hideWrapper: true
    });
    const popup = popupElement.render();
    popup.style.left = container.style.width;
    container.appendChild(popup);
  }

  _renderQuadrilaterals(className) {
    for (const quadrilateral of this.quadrilaterals) {
      quadrilateral.className = className;
    }

    return this.quadrilaterals;
  }

  render() {
    (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
  }

}

class LinkAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
    super(parameters, {
      isRenderable,
      createQuadrilaterals: true
    });
  }

  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");

    if (data.url) {
      (0, _display_utils.addLinkAttributes)(link, {
        url: data.url,
        target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,
        rel: linkService.externalLinkRel,
        enabled: linkService.externalLinkEnabled
      });
    } else if (data.action) {
      this._bindNamedAction(link, data.action);
    } else if (data.dest) {
      this._bindLink(link, data.dest);
    } else if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
      this._bindJSAction(link, data);
    } else {
      this._bindLink(link, "");
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
        const linkElement = index === 0 ? link : link.cloneNode();
        quadrilateral.appendChild(linkElement);
        return quadrilateral;
      });
    }

    this.container.className = "linkAnnotation";
    this.container.appendChild(link);
    return this.container;
  }

  _bindLink(link, destination) {
    link.href = this.linkService.getDestinationHash(destination);

    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }

      return false;
    };

    if (destination || destination === "") {
      link.className = "internalLink";
    }
  }

  _bindNamedAction(link, action) {
    link.href = this.linkService.getAnchorUrl("");

    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };

    link.className = "internalLink";
  }

  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);

      if (!jsName) {
        continue;
      }

      link[jsName] = () => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }

    link.className = "internalLink";
  }

}

class TextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    this.container.className = "textAnnotation";
    const image = document.createElement("img");
    image.style.height = this.container.style.height;
    image.style.width = this.container.style.width;
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.alt = "[ Annotation]";
    image.dataset.l10nId = "text_annotation_type";
    image.dataset.l10nArgs = JSON.stringify({
      type: this.data.name
    });

    if (!this.data.hasPopup) {
      this._createPopup(image, this.data);
    }

    this.container.appendChild(image);
    return this.container;
  }

}

class WidgetAnnotationElement extends AnnotationElement {
  render() {
    if (this.data.alternativeText) {
      this.container.title = this.data.alternativeText;
    }

    return this.container;
  }

  _getKeyModifier(event) {
    return navigator.platform.includes("Win") && event.ctrlKey || navigator.platform.includes("Mac") && event.metaKey;
  }

  _setEventListener(element, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: event.target.checked
          }
        });
      });
    }
  }

  _setEventListeners(element, names, getter) {
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || this.data.actions?.[eventName]) {
        this._setEventListener(element, baseName, eventName, getter);
      }
    }
  }

  _dispatchEventFromSandbox(actions, jsEvent) {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
    };

    const commonActions = {
      display: event => {
        const hidden = event.detail.display % 2 === 1;
        event.target.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden,
          print: event.detail.display === 0 || event.detail.display === 3
        });
      },
      print: event => {
        this.annotationStorage.setValue(this.data.id, {
          print: event.detail.print
        });
      },
      hidden: event => {
        event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden: event.detail.hidden
        });
      },
      focus: event => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: event => {
        event.target.title = event.detail.userName;
      },
      readonly: event => {
        if (event.detail.readonly) {
          event.target.setAttribute("readonly", "");
        } else {
          event.target.removeAttribute("readonly");
        }
      },
      required: event => {
        if (event.detail.required) {
          event.target.setAttribute("required", "");
        } else {
          event.target.removeAttribute("required");
        }
      },
      bgColor: event => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: event => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: event => {
        setColor("fgColor", "color", event);
      },
      textColor: event => {
        setColor("textColor", "color", event);
      },
      borderColor: event => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: event => {
        setColor("strokeColor", "borderColor", event);
      }
    };

    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];

      if (action) {
        action(jsEvent);
      }
    }
  }

}

class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }

  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;

    for (const element of document.getElementsByName(base.name)) {
      if (element !== base) {
        element[key] = value;
        const data = Object.create(null);
        data[keyInStorage] = value;
        storage.setValue(element.getAttribute("id"), data);
      }
    }
  }

  render() {
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.className = "textWidgetAnnotation";
    let element = null;

    if (this.renderInteractiveForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue,
        valueAsString: this.data.fieldValue
      });
      const textContent = storedData.valueAsString || storedData.value || "";
      const elementData = {
        userValue: null,
        formattedValue: null,
        beforeInputSelectionRange: null,
        beforeInputValue: null
      };

      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = textContent;
      } else {
        element = document.createElement("input");
        element.type = "text";
        element.setAttribute("value", textContent);
      }

      elementData.userValue = textContent;
      element.setAttribute("id", id);
      element.addEventListener("input", event => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
      });

      let blurListener = event => {
        if (elementData.formattedValue) {
          event.target.value = elementData.formattedValue;
        }

        event.target.scrollLeft = 0;
        elementData.beforeInputSelectionRange = null;
      };

      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", event => {
          if (elementData.userValue) {
            event.target.value = elementData.userValue;
          }
        });
        element.addEventListener("updatefromsandbox", jsEvent => {
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value || "";
              storage.setValue(id, {
                value: elementData.userValue.toString()
              });

              if (!elementData.formattedValue) {
                event.target.value = elementData.userValue;
              }
            },

            valueAsString(event) {
              elementData.formattedValue = event.detail.valueAsString || "";

              if (event.target !== document.activeElement) {
                event.target.value = elementData.formattedValue;
              }

              storage.setValue(id, {
                formattedValue: elementData.formattedValue
              });
            },

            selRange(event) {
              const [selStart, selEnd] = event.detail.selRange;

              if (selStart >= 0 && selEnd < event.target.value.length) {
                event.target.setSelectionRange(selStart, selEnd);
              }
            }

          };

          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", event => {
          elementData.beforeInputValue = event.target.value;
          let commitKey = -1;

          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter") {
            commitKey = 2;
          } else if (event.key === "Tab") {
            commitKey = 3;
          }

          if (commitKey === -1) {
            return;
          }

          elementData.userValue = event.target.value;
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value: event.target.value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", event => {
          if (this._mouseState.isDown) {
            elementData.userValue = event.target.value;
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value: event.target.value,
                willCommit: true,
                commitKey: 1,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }

          _blurListener(event);
        });
        element.addEventListener("mousedown", event => {
          elementData.beforeInputValue = event.target.value;
          elementData.beforeInputSelectionRange = null;
        });
        element.addEventListener("keyup", event => {
          if (event.target.selectionStart === event.target.selectionEnd) {
            elementData.beforeInputSelectionRange = null;
          }
        });
        element.addEventListener("select", event => {
          elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
        });

        if (this.data.actions?.Keystroke) {
          element.addEventListener("input", event => {
            let selStart = -1;
            let selEnd = -1;

            if (elementData.beforeInputSelectionRange) {
              [selStart, selEnd] = elementData.beforeInputSelectionRange;
            }

            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value: elementData.beforeInputValue,
                change: event.data,
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }

        this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
      }

      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }

      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;

      if (this.data.maxLen !== null) {
        element.maxLength = this.data.maxLen;
      }

      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / this.data.maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
    }

    this._setTextStyle(element);

    this.container.appendChild(element);
    return this.container;
  }

  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontSize,
      fontColor
    } = this.data.defaultAppearanceData;
    const style = element.style;

    if (fontSize) {
      style.fontSize = `${fontSize}px`;
    }

    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }

}

class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderInteractiveForms
    });
  }

  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue && (data.exportValue && data.exportValue === data.fieldValue || !data.exportValue && data.fieldValue !== "Off")
    }).value;

    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }

    this.container.className = "buttonWidgetAnnotation checkBox";
    const element = document.createElement("input");
    element.disabled = data.readOnly;
    element.type = "checkbox";
    element.name = this.data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.setAttribute("id", id);
    element.addEventListener("change", function (event) {
      const name = event.target.name;

      for (const checkbox of document.getElementsByName(name)) {
        if (checkbox !== event.target) {
          checkbox.checked = false;
          storage.setValue(checkbox.parentNode.getAttribute("data-annotation-id"), {
            value: false
          });
        }
      }

      storage.setValue(id, {
        value: event.target.checked
      });
    });

    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this.container.appendChild(element);
    return this.container;
  }

}

class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderInteractiveForms
    });
  }

  render() {
    this.container.className = "buttonWidgetAnnotation radioButton";
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;

    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }

    const element = document.createElement("input");
    element.disabled = data.readOnly;
    element.type = "radio";
    element.name = data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.setAttribute("id", id);
    element.addEventListener("change", function (event) {
      const {
        target
      } = event;

      for (const radio of document.getElementsByName(target.name)) {
        if (radio !== target) {
          storage.setValue(radio.getAttribute("id"), {
            value: false
          });
        }
      }

      storage.setValue(id, {
        value: target.checked
      });
    });

    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            const checked = pdfButtonValue === event.detail.value;

            for (const radio of document.getElementsByName(event.target.name)) {
              const radioId = radio.getAttribute("id");
              radio.checked = radioId === id && checked;
              storage.setValue(radioId, {
                value: radio.checked
              });
            }
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this.container.appendChild(element);
    return this.container;
  }

}

class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  render() {
    const container = super.render();
    container.className = "buttonWidgetAnnotation pushButton";

    if (this.data.alternativeText) {
      container.title = this.data.alternativeText;
    }

    return container;
  }

}

class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderInteractiveForms
    });
  }

  render() {
    this.container.className = "choiceWidgetAnnotation";
    const storage = this.annotationStorage;
    const id = this.data.id;
    storage.getValue(id, {
      value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined
    });
    const selectElement = document.createElement("select");
    selectElement.disabled = this.data.readOnly;
    selectElement.name = this.data.fieldName;
    selectElement.setAttribute("id", id);

    if (!this.data.combo) {
      selectElement.size = this.data.options.length;

      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }

    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;

      if (this.data.fieldValue.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
      }

      selectElement.appendChild(optionElement);
    }

    const getValue = (event, isExport) => {
      const name = isExport ? "value" : "textContent";
      const options = event.target.options;

      if (!event.target.multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }

      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
    };

    const getItems = event => {
      const options = event.target.options;
      return Array.prototype.map.call(options, option => {
        return {
          displayValue: option.textContent,
          exportValue: option.value
        };
      });
    };

    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            const options = selectElement.options;
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);
            Array.prototype.forEach.call(options, option => {
              option.selected = values.has(option.value);
            });
            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          multipleSelection(event) {
            selectElement.multiple = true;
          },

          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);

            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, option => option.selected);

              if (i === -1) {
                options[0].selected = true;
              }
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            storage.setValue(id, {
              value: null,
              items: []
            });
          },

          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            selectElement.insertBefore(optionElement, selectElement.children[index]);
            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          items(event) {
            const {
              items
            } = event.detail;

            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.appendChild(optionElement);
            }

            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          indices(event) {
            const indices = new Set(event.detail.indices);
            const options = event.target.options;
            Array.prototype.forEach.call(options, (option, i) => {
              option.selected = indices.has(i);
            });
            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          editable(event) {
            event.target.disabled = !event.detail.editable;
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", event => {
        const exportValue = getValue(event, true);
        const value = getValue(event, false);
        storage.setValue(id, {
          value: exportValue
        });
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value,
            changeEx: exportValue,
            willCommit: true,
            commitKey: 1,
            keyDown: false
          }
        });
      });

      this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], event => event.target.checked);
    } else {
      selectElement.addEventListener("input", function (event) {
        storage.setValue(id, {
          value: getValue(event)
        });
      });
    }

    this.container.appendChild(selectElement);
    return this.container;
  }

}

class PopupAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
    this.container.className = "popupAnnotation";

    if (IGNORE_TYPES.includes(this.data.parentType)) {
      return this.container;
    }

    const selector = `[data-annotation-id="${this.data.parentId}"]`;
    const parentElements = this.layer.querySelectorAll(selector);

    if (parentElements.length === 0) {
      return this.container;
    }

    const popup = new PopupElement({
      container: this.container,
      trigger: Array.from(parentElements),
      color: this.data.color,
      title: this.data.title,
      modificationDate: this.data.modificationDate,
      contents: this.data.contents
    });
    const page = this.page;

    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
    const popupTop = rect[1];
    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;
    this.container.style.left = `${popupLeft}px`;
    this.container.style.top = `${popupTop}px`;
    this.container.appendChild(popup.render());
    return this.container;
  }

}

class PopupElement {
  constructor(parameters) {
    this.container = parameters.container;
    this.trigger = parameters.trigger;
    this.color = parameters.color;
    this.title = parameters.title;
    this.modificationDate = parameters.modificationDate;
    this.contents = parameters.contents;
    this.hideWrapper = parameters.hideWrapper || false;
    this.pinned = false;
  }

  render() {
    const BACKGROUND_ENLIGHT = 0.7;
    const wrapper = document.createElement("div");
    wrapper.className = "popupWrapper";
    this.hideElement = this.hideWrapper ? wrapper : this.container;
    this.hideElement.hidden = true;
    const popup = document.createElement("div");
    popup.className = "popup";
    const color = this.color;

    if (color) {
      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
    }

    const title = document.createElement("h1");
    title.textContent = this.title;
    popup.appendChild(title);

    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

    if (dateObject) {
      const modificationDate = document.createElement("span");
      modificationDate.textContent = "1622354702136, ";
      modificationDate.dataset.l10nId = "annotation_date_string";
      modificationDate.dataset.l10nArgs = JSON.stringify({
        date: dateObject.toLocaleDateString(),
        time: dateObject.toLocaleTimeString()
      });
      popup.appendChild(modificationDate);
    }

    const contents = this._formatContents(this.contents);

    popup.appendChild(contents);

    if (!Array.isArray(this.trigger)) {
      this.trigger = [this.trigger];
    }

    for (const element of this.trigger) {
      element.addEventListener("click", this._toggle.bind(this));
      element.addEventListener("mouseover", this._show.bind(this, false));
      element.addEventListener("mouseout", this._hide.bind(this, false));
    }

    popup.addEventListener("click", this._hide.bind(this, true));
    wrapper.appendChild(popup);
    return wrapper;
  }

  _formatContents(contents) {
    const p = document.createElement("p");
    const lines = contents.split(/(?:\r\n?|\n)/);

    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.appendChild(document.createTextNode(line));

      if (i < ii - 1) {
        p.appendChild(document.createElement("br"));
      }
    }

    return p;
  }

  _toggle() {
    if (this.pinned) {
      this._hide(true);
    } else {
      this._show(true);
    }
  }

  _show(pin = false) {
    if (pin) {
      this.pinned = true;
    }

    if (this.hideElement.hidden) {
      this.hideElement.hidden = false;
      this.container.style.zIndex += 1;
    }
  }

  _hide(unpin = true) {
    if (unpin) {
      this.pinned = false;
    }

    if (!this.hideElement.hidden && !this.pinned) {
      this.hideElement.hidden = true;
      this.container.style.zIndex -= 1;
    }
  }

}

class FreeTextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "freeTextAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class LineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "lineAnnotation";
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    const line = this.svgFactory.createElement("svg:line");
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    svg.appendChild(line);
    this.container.append(svg);

    this._createPopup(line, data);

    return this.container;
  }

}

class SquareAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "squareAnnotation";
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    const borderWidth = data.borderStyle.width;
    const square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "none");
    svg.appendChild(square);
    this.container.append(svg);

    this._createPopup(square, data);

    return this.container;
  }

}

class CircleAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "circleAnnotation";
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    const borderWidth = data.borderStyle.width;
    const circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "none");
    svg.appendChild(circle);
    this.container.append(svg);

    this._createPopup(circle, data);

    return this.container;
  }

}

class PolylineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);
    let points = [];

    for (const coordinate of data.vertices) {
      const x = coordinate.x - data.rect[0];
      const y = data.rect[3] - coordinate.y;
      points.push(x + "," + y);
    }

    points = points.join(" ");
    const polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "none");
    svg.appendChild(polyline);
    this.container.append(svg);

    this._createPopup(polyline, data);

    return this.container;
  }

}

class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }

}

class CaretAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "caretAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class InkAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const width = data.rect[2] - data.rect[0];
    const height = data.rect[3] - data.rect[1];
    const svg = this.svgFactory.create(width, height);

    for (const inkList of data.inkLists) {
      let points = [];

      for (const coordinate of inkList) {
        const x = coordinate.x - data.rect[0];
        const y = data.rect[3] - coordinate.y;
        points.push(`${x},${y}`);
      }

      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "none");

      this._createPopup(polyline, data);

      svg.appendChild(polyline);
    }

    this.container.append(svg);
    return this.container;
  }

}

class HighlightAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("highlightAnnotation");
    }

    this.container.className = "highlightAnnotation";
    return this.container;
  }

}

class UnderlineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("underlineAnnotation");
    }

    this.container.className = "underlineAnnotation";
    return this.container;
  }

}

class SquigglyAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("squigglyAnnotation");
    }

    this.container.className = "squigglyAnnotation";
    return this.container;
  }

}

class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("strikeoutAnnotation");
    }

    this.container.className = "strikeoutAnnotation";
    return this.container;
  }

}

class StampAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "stampAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class FileAttachmentAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
    const {
      filename,
      content
    } = this.data.file;
    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
    this.content = content;
    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      id: (0, _util.stringToPDFString)(filename),
      filename,
      content
    });
  }

  render() {
    this.container.className = "fileAttachmentAnnotation";
    const trigger = document.createElement("div");
    trigger.style.height = this.container.style.height;
    trigger.style.width = this.container.style.width;
    trigger.addEventListener("dblclick", this._download.bind(this));

    if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
      this._createPopup(trigger, this.data);
    }

    this.container.appendChild(trigger);
    return this.container;
  }

  _download() {
    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
  }

}

class AnnotationLayer {
  static render(parameters) {
    const sortedAnnotations = [],
          popupAnnotations = [];

    for (const data of parameters.annotations) {
      if (!data) {
        continue;
      }

      if (data.annotationType === _util.AnnotationType.POPUP) {
        popupAnnotations.push(data);
        continue;
      }

      sortedAnnotations.push(data);
    }

    if (popupAnnotations.length) {
      sortedAnnotations.push(...popupAnnotations);
    }

    for (const data of sortedAnnotations) {
      const element = AnnotationElementFactory.create({
        data,
        layer: parameters.div,
        page: parameters.page,
        viewport: parameters.viewport,
        linkService: parameters.linkService,
        downloadManager: parameters.downloadManager,
        imageResourcesPath: parameters.imageResourcesPath || "",
        renderInteractiveForms: parameters.renderInteractiveForms !== false,
        svgFactory: new _display_utils.DOMSVGFactory(),
        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
        enableScripting: parameters.enableScripting,
        hasJSActions: parameters.hasJSActions,
        mouseState: parameters.mouseState || {
          isDown: false
        }
      });

      if (element.isRenderable) {
        const rendered = element.render();

        if (data.hidden) {
          rendered.style.visibility = "hidden";
        }

        if (Array.isArray(rendered)) {
          for (const renderedElement of rendered) {
            parameters.div.appendChild(renderedElement);
          }
        } else {
          if (element instanceof PopupAnnotationElement) {
            parameters.div.prepend(rendered);
          } else {
            parameters.div.appendChild(rendered);
          }
        }
      }
    }
  }

  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;

    for (const data of parameters.annotations) {
      const elements = parameters.div.querySelectorAll(`[data-annotation-id="${data.id}"]`);

      if (elements) {
        for (const element of elements) {
          element.style.transform = transform;
        }
      }
    }

    parameters.div.hidden = false;
  }

}

exports.AnnotationLayer = AnnotationLayer;

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorConverters = void 0;

function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}

class ColorConverters {
  static CMYK_G([c, y, m, k]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }

  static G_CMYK([g]) {
    return ["CMYK", 0, 0, 0, 1 - g];
  }

  static G_RGB([g]) {
    return ["RGB", g, g, g];
  }

  static G_HTML([g]) {
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }

  static RGB_G([r, g, b]) {
    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
  }

  static RGB_HTML([r, g, b]) {
    const R = makeColorComp(r);
    const G = makeColorComp(g);
    const B = makeColorComp(b);
    return `#${R}${G}${B}`;
  }

  static T_HTML() {
    return "#00000000";
  }

  static CMYK_RGB([c, y, m, k]) {
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }

  static CMYK_HTML(components) {
    return this.RGB_HTML(this.CMYK_RGB(components));
  }

  static RGB_CMYK([r, g, b]) {
    const c = 1 - r;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }

}

exports.ColorConverters = ColorConverters;

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.renderTextLayer = renderTextLayer;

var _util = __w_pdfjs_require__(2);

const MAX_TEXT_DIVS_TO_RENDER = 100000;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
const ascentCache = new Map();
const AllWhitespaceRegexp = /^\s+$/g;

function getAscent(fontFamily, ctx) {
  const cachedAscent = ascentCache.get(fontFamily);

  if (cachedAscent) {
    return cachedAscent;
  }

  ctx.save();
  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
  const metrics = ctx.measureText("");
  let ascent = metrics.fontBoundingBoxAscent;
  let descent = Math.abs(metrics.fontBoundingBoxDescent);

  if (ascent) {
    ctx.restore();
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ctx.strokeStyle = "red";
  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("g", 0, 0);
  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  descent = 0;

  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
    if (pixels[i] > 0) {
      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  ascent = 0;

  for (let i = 0, ii = pixels.length; i < ii; i += 4) {
    if (pixels[i] > 0) {
      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.restore();

  if (ascent) {
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
  return DEFAULT_FONT_ASCENT;
}

function appendText(task, geom, styles, ctx) {
  const textDiv = document.createElement("span");
  const textDivProperties = {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    originalTransform: null,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    scale: 1
  };

  task._textDivs.push(textDiv);

  const tx = _util.Util.transform(task._viewport.transform, geom.transform);

  let angle = Math.atan2(tx[1], tx[0]);
  const style = styles[geom.fontName];

  if (style.vertical) {
    angle += Math.PI / 2;
  }

  const fontHeight = Math.hypot(tx[2], tx[3]);
  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
  let left, top;

  if (angle === 0) {
    left = tx[4];
    top = tx[5] - fontAscent;
  } else {
    left = tx[4] + fontAscent * Math.sin(angle);
    top = tx[5] - fontAscent * Math.cos(angle);
  }

  textDiv.style.left = `${left}px`;
  textDiv.style.top = `${top}px`;
  textDiv.style.fontSize = `${fontHeight}px`;
  textDiv.style.fontFamily = style.fontFamily;
  textDiv.setAttribute("role", "presentation");
  textDiv.textContent = geom.str;
  textDiv.dir = geom.dir;

  if (task._fontInspectorEnabled) {
    textDiv.dataset.fontName = geom.fontName;
  }

  if (angle !== 0) {
    textDivProperties.angle = angle * (180 / Math.PI);
  }

  let shouldScaleText = false;

  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
    shouldScaleText = true;
  } else if (geom.transform[0] !== geom.transform[3]) {
    const absScaleX = Math.abs(geom.transform[0]),
          absScaleY = Math.abs(geom.transform[3]);

    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
      shouldScaleText = true;
    }
  }

  if (shouldScaleText) {
    if (style.vertical) {
      textDivProperties.canvasWidth = geom.height * task._viewport.scale;
    } else {
      textDivProperties.canvasWidth = geom.width * task._viewport.scale;
    }
  }

  task._textDivProperties.set(textDiv, textDivProperties);

  if (task._textContentStream) {
    task._layoutText(textDiv);
  }

  if (task._enhanceTextSelection && textDivProperties.hasText) {
    let angleCos = 1,
        angleSin = 0;

    if (angle !== 0) {
      angleCos = Math.cos(angle);
      angleSin = Math.sin(angle);
    }

    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
    const divHeight = fontHeight;
    let m, b;

    if (angle !== 0) {
      m = [angleCos, angleSin, -angleSin, angleCos, left, top];
      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
    } else {
      b = [left, top, left + divWidth, top + divHeight];
    }

    task._bounds.push({
      left: b[0],
      top: b[1],
      right: b[2],
      bottom: b[3],
      div: textDiv,
      size: [divWidth, divHeight],
      m
    });
  }
}

function render(task) {
  if (task._canceled) {
    return;
  }

  const textDivs = task._textDivs;
  const capability = task._capability;
  const textDivsLength = textDivs.length;

  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
    task._renderingDone = true;
    capability.resolve();
    return;
  }

  if (!task._textContentStream) {
    for (let i = 0; i < textDivsLength; i++) {
      task._layoutText(textDivs[i]);
    }
  }

  task._renderingDone = true;
  capability.resolve();
}

function findPositiveMin(ts, offset, count) {
  let result = 0;

  for (let i = 0; i < count; i++) {
    const t = ts[offset++];

    if (t > 0) {
      result = result ? Math.min(t, result) : t;
    }
  }

  return result;
}

function expand(task) {
  const bounds = task._bounds;
  const viewport = task._viewport;
  const expanded = expandBounds(viewport.width, viewport.height, bounds);

  for (let i = 0; i < expanded.length; i++) {
    const div = bounds[i].div;

    const divProperties = task._textDivProperties.get(div);

    if (divProperties.angle === 0) {
      divProperties.paddingLeft = bounds[i].left - expanded[i].left;
      divProperties.paddingTop = bounds[i].top - expanded[i].top;
      divProperties.paddingRight = expanded[i].right - bounds[i].right;
      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

      task._textDivProperties.set(div, divProperties);

      continue;
    }

    const e = expanded[i],
          b = bounds[i];
    const m = b.m,
          c = m[0],
          s = m[1];
    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
    const ts = new Float64Array(64);

    for (let j = 0, jj = points.length; j < jj; j++) {
      const t = _util.Util.applyTransform(points[j], m);

      ts[j + 0] = c && (e.left - t[0]) / c;
      ts[j + 4] = s && (e.top - t[1]) / s;
      ts[j + 8] = c && (e.right - t[0]) / c;
      ts[j + 12] = s && (e.bottom - t[1]) / s;
      ts[j + 16] = s && (e.left - t[0]) / -s;
      ts[j + 20] = c && (e.top - t[1]) / c;
      ts[j + 24] = s && (e.right - t[0]) / -s;
      ts[j + 28] = c && (e.bottom - t[1]) / c;
      ts[j + 32] = c && (e.left - t[0]) / -c;
      ts[j + 36] = s && (e.top - t[1]) / -s;
      ts[j + 40] = c && (e.right - t[0]) / -c;
      ts[j + 44] = s && (e.bottom - t[1]) / -s;
      ts[j + 48] = s && (e.left - t[0]) / s;
      ts[j + 52] = c && (e.top - t[1]) / -c;
      ts[j + 56] = s && (e.right - t[0]) / s;
      ts[j + 60] = c && (e.bottom - t[1]) / -c;
    }

    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

    task._textDivProperties.set(div, divProperties);
  }
}

function expandBounds(width, height, boxes) {
  const bounds = boxes.map(function (box, i) {
    return {
      x1: box.left,
      y1: box.top,
      x2: box.right,
      y2: box.bottom,
      index: i,
      x1New: undefined,
      x2New: undefined
    };
  });
  expandBoundsLTR(width, bounds);
  const expanded = new Array(boxes.length);

  for (const b of bounds) {
    const i = b.index;
    expanded[i] = {
      left: b.x1New,
      top: 0,
      right: b.x2New,
      bottom: 0
    };
  }

  boxes.map(function (box, i) {
    const e = expanded[i],
          b = bounds[i];
    b.x1 = box.top;
    b.y1 = width - e.right;
    b.x2 = box.bottom;
    b.y2 = width - e.left;
    b.index = i;
    b.x1New = undefined;
    b.x2New = undefined;
  });
  expandBoundsLTR(height, bounds);

  for (const b of bounds) {
    const i = b.index;
    expanded[i].top = b.x1New;
    expanded[i].bottom = b.x2New;
  }

  return expanded;
}

function expandBoundsLTR(width, bounds) {
  bounds.sort(function (a, b) {
    return a.x1 - b.x1 || a.index - b.index;
  });
  const fakeBoundary = {
    x1: -Infinity,
    y1: -Infinity,
    x2: 0,
    y2: Infinity,
    index: -1,
    x1New: 0,
    x2New: 0
  };
  const horizon = [{
    start: -Infinity,
    end: Infinity,
    boundary: fakeBoundary
  }];

  for (const boundary of bounds) {
    let i = 0;

    while (i < horizon.length && horizon[i].end <= boundary.y1) {
      i++;
    }

    let j = horizon.length - 1;

    while (j >= 0 && horizon[j].start >= boundary.y2) {
      j--;
    }

    let horizonPart, affectedBoundary;
    let q,
        k,
        maxXNew = -Infinity;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      let xNew;

      if (affectedBoundary.x2 > boundary.x1) {
        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
      } else if (affectedBoundary.x2New === undefined) {
        xNew = (affectedBoundary.x2 + boundary.x1) / 2;
      } else {
        xNew = affectedBoundary.x2New;
      }

      if (xNew > maxXNew) {
        maxXNew = xNew;
      }
    }

    boundary.x1New = maxXNew;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New === undefined) {
        if (affectedBoundary.x2 > boundary.x1) {
          if (affectedBoundary.index > boundary.index) {
            affectedBoundary.x2New = affectedBoundary.x2;
          }
        } else {
          affectedBoundary.x2New = maxXNew;
        }
      } else if (affectedBoundary.x2New > maxXNew) {
        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
      }
    }

    const changedHorizon = [];
    let lastBoundary = null;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

      if (lastBoundary === useBoundary) {
        changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
      } else {
        changedHorizon.push({
          start: horizonPart.start,
          end: horizonPart.end,
          boundary: useBoundary
        });
        lastBoundary = useBoundary;
      }
    }

    if (horizon[i].start < boundary.y1) {
      changedHorizon[0].start = boundary.y1;
      changedHorizon.unshift({
        start: horizon[i].start,
        end: boundary.y1,
        boundary: horizon[i].boundary
      });
    }

    if (boundary.y2 < horizon[j].end) {
      changedHorizon[changedHorizon.length - 1].end = boundary.y2;
      changedHorizon.push({
        start: boundary.y2,
        end: horizon[j].end,
        boundary: horizon[j].boundary
      });
    }

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New !== undefined) {
        continue;
      }

      let used = false;

      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = 0; !used && k < changedHorizon.length; k++) {
        used = changedHorizon[k].boundary === affectedBoundary;
      }

      if (!used) {
        affectedBoundary.x2New = maxXNew;
      }
    }

    Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
  }

  for (const horizonPart of horizon) {
    const affectedBoundary = horizonPart.boundary;

    if (affectedBoundary.x2New === undefined) {
      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
    }
  }
}

class TextLayerRenderTask {
  constructor({
    textContent,
    textContentStream,
    container,
    viewport,
    textDivs,
    textContentItemsStr,
    enhanceTextSelection
  }) {
    this._textContent = textContent;
    this._textContentStream = textContentStream;
    this._container = container;
    this._document = container.ownerDocument;
    this._viewport = viewport;
    this._textDivs = textDivs || [];
    this._textContentItemsStr = textContentItemsStr || [];
    this._enhanceTextSelection = !!enhanceTextSelection;
    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
    this._reader = null;
    this._layoutTextLastFontSize = null;
    this._layoutTextLastFontFamily = null;
    this._layoutTextCtx = null;
    this._textDivProperties = new WeakMap();
    this._renderingDone = false;
    this._canceled = false;
    this._capability = (0, _util.createPromiseCapability)();
    this._renderTimer = null;
    this._bounds = [];

    this._capability.promise.finally(() => {
      if (this._layoutTextCtx) {
        this._layoutTextCtx.canvas.width = 0;
        this._layoutTextCtx.canvas.height = 0;
        this._layoutTextCtx = null;
      }
    }).catch(() => {});
  }

  get promise() {
    return this._capability.promise;
  }

  cancel() {
    this._canceled = true;

    if (this._reader) {
      this._reader.cancel(new _util.AbortException("TextLayer task cancelled."));

      this._reader = null;
    }

    if (this._renderTimer !== null) {
      clearTimeout(this._renderTimer);
      this._renderTimer = null;
    }

    this._capability.reject(new Error("TextLayer task cancelled."));
  }

  _processItems(items, styleCache) {
    for (let i = 0, len = items.length; i < len; i++) {
      if (items[i].str === undefined) {
        if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
          const parent = this._container;
          this._container = document.createElement("span");

          this._container.classList.add("markedContent");

          if (items[i].id !== null) {
            this._container.setAttribute("id", `${items[i].id}`);
          }

          parent.appendChild(this._container);
        } else if (items[i].type === "endMarkedContent") {
          this._container = this._container.parentNode;
        }

        continue;
      }

      this._textContentItemsStr.push(items[i].str);

      appendText(this, items[i], styleCache, this._layoutTextCtx);
    }
  }

  _layoutText(textDiv) {
    const textDivProperties = this._textDivProperties.get(textDiv);

    let transform = "";

    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
      const {
        fontSize,
        fontFamily
      } = textDiv.style;

      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
        this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
        this._layoutTextLastFontSize = fontSize;
        this._layoutTextLastFontFamily = fontFamily;
      }

      const {
        width
      } = this._layoutTextCtx.measureText(textDiv.textContent);

      if (width > 0) {
        textDivProperties.scale = textDivProperties.canvasWidth / width;
        transform = `scaleX(${textDivProperties.scale})`;
      }
    }

    if (textDivProperties.angle !== 0) {
      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
    }

    if (transform.length > 0) {
      if (this._enhanceTextSelection) {
        textDivProperties.originalTransform = transform;
      }

      textDiv.style.transform = transform;
    }

    if (textDivProperties.hasText) {
      this._container.appendChild(textDiv);
    }

    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");

      this._container.appendChild(br);
    }
  }

  _render(timeout = 0) {
    const capability = (0, _util.createPromiseCapability)();
    let styleCache = Object.create(null);

    const canvas = this._document.createElement("canvas");

    canvas.height = canvas.width = DEFAULT_FONT_SIZE;
    canvas.mozOpaque = true;
    this._layoutTextCtx = canvas.getContext("2d", {
      alpha: false
    });

    if (this._textContent) {
      const textItems = this._textContent.items;
      const textStyles = this._textContent.styles;

      this._processItems(textItems, textStyles);

      capability.resolve();
    } else if (this._textContentStream) {
      const pump = () => {
        this._reader.read().then(({
          value,
          done
        }) => {
          if (done) {
            capability.resolve();
            return;
          }

          Object.assign(styleCache, value.styles);

          this._processItems(value.items, styleCache);

          pump();
        }, capability.reject);
      };

      this._reader = this._textContentStream.getReader();
      pump();
    } else {
      throw new Error('Neither "textContent" nor "textContentStream"' + " parameters specified.");
    }

    capability.promise.then(() => {
      styleCache = null;

      if (!timeout) {
        render(this);
      } else {
        this._renderTimer = setTimeout(() => {
          render(this);
          this._renderTimer = null;
        }, timeout);
      }
    }, this._capability.reject);
  }

  expandTextDivs(expandDivs = false) {
    if (!this._enhanceTextSelection || !this._renderingDone) {
      return;
    }

    if (this._bounds !== null) {
      expand(this);
      this._bounds = null;
    }

    const transformBuf = [],
          paddingBuf = [];

    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
      const div = this._textDivs[i];

      const divProps = this._textDivProperties.get(div);

      if (!divProps.hasText) {
        continue;
      }

      if (expandDivs) {
        transformBuf.length = 0;
        paddingBuf.length = 0;

        if (divProps.originalTransform) {
          transformBuf.push(divProps.originalTransform);
        }

        if (divProps.paddingTop > 0) {
          paddingBuf.push(`${divProps.paddingTop}px`);
          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingRight > 0) {
          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingBottom > 0) {
          paddingBuf.push(`${divProps.paddingBottom}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingLeft > 0) {
          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
        } else {
          paddingBuf.push(0);
        }

        div.style.padding = paddingBuf.join(" ");

        if (transformBuf.length) {
          div.style.transform = transformBuf.join(" ");
        }
      } else {
        div.style.padding = null;
        div.style.transform = divProps.originalTransform;
      }
    }
  }

}

function renderTextLayer(renderParameters) {
  const task = new TextLayerRenderTask({
    textContent: renderParameters.textContent,
    textContentStream: renderParameters.textContentStream,
    container: renderParameters.container,
    viewport: renderParameters.viewport,
    textDivs: renderParameters.textDivs,
    textContentItemsStr: renderParameters.textContentItemsStr,
    enhanceTextSelection: renderParameters.enhanceTextSelection
  });

  task._render(renderParameters.timeout);

  return task;
}

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SVGGraphics = void 0;

var _util = __w_pdfjs_require__(2);

var _display_utils = __w_pdfjs_require__(1);

var _is_node = __w_pdfjs_require__(4);

let SVGGraphics = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: SVGGraphics");
  }

};
exports.SVGGraphics = SVGGraphics;
{
  const SVG_DEFAULTS = {
    fontStyle: "normal",
    fontWeight: "normal",
    fillColor: "#000000"
  };
  const XML_NS = "http://www.w3.org/XML/1998/namespace";
  const XLINK_NS = "http://www.w3.org/1999/xlink";
  const LINE_CAP_STYLES = ["butt", "round", "square"];
  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];

  const convertImgDataToPng = function () {
    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
    const CHUNK_WRAPPER_SIZE = 12;
    const crcTable = new Int32Array(256);

    for (let i = 0; i < 256; i++) {
      let c = i;

      for (let h = 0; h < 8; h++) {
        if (c & 1) {
          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
        } else {
          c = c >> 1 & 0x7fffffff;
        }
      }

      crcTable[i] = c;
    }

    function crc32(data, start, end) {
      let crc = -1;

      for (let i = start; i < end; i++) {
        const a = (crc ^ data[i]) & 0xff;
        const b = crcTable[a];
        crc = crc >>> 8 ^ b;
      }

      return crc ^ -1;
    }

    function writePngChunk(type, body, data, offset) {
      let p = offset;
      const len = body.length;
      data[p] = len >> 24 & 0xff;
      data[p + 1] = len >> 16 & 0xff;
      data[p + 2] = len >> 8 & 0xff;
      data[p + 3] = len & 0xff;
      p += 4;
      data[p] = type.charCodeAt(0) & 0xff;
      data[p + 1] = type.charCodeAt(1) & 0xff;
      data[p + 2] = type.charCodeAt(2) & 0xff;
      data[p + 3] = type.charCodeAt(3) & 0xff;
      p += 4;
      data.set(body, p);
      p += body.length;
      const crc = crc32(data, offset + 4, p);
      data[p] = crc >> 24 & 0xff;
      data[p + 1] = crc >> 16 & 0xff;
      data[p + 2] = crc >> 8 & 0xff;
      data[p + 3] = crc & 0xff;
    }

    function adler32(data, start, end) {
      let a = 1;
      let b = 0;

      for (let i = start; i < end; ++i) {
        a = (a + (data[i] & 0xff)) % 65521;
        b = (b + a) % 65521;
      }

      return b << 16 | a;
    }

    function deflateSync(literals) {
      if (!_is_node.isNodeJS) {
        return deflateSyncUncompressed(literals);
      }

      try {
        let input;

        if (parseInt(process.versions.node) >= 8) {
          input = literals;
        } else {
          input = Buffer.from(literals);
        }

        const output = require("zlib").deflateSync(input, {
          level: 9
        });

        return output instanceof Uint8Array ? output : new Uint8Array(output);
      } catch (e) {
        (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
      }

      return deflateSyncUncompressed(literals);
    }

    function deflateSyncUncompressed(literals) {
      let len = literals.length;
      const maxBlockLength = 0xffff;
      const deflateBlocks = Math.ceil(len / maxBlockLength);
      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
      let pi = 0;
      idat[pi++] = 0x78;
      idat[pi++] = 0x9c;
      let pos = 0;

      while (len > maxBlockLength) {
        idat[pi++] = 0x00;
        idat[pi++] = 0xff;
        idat[pi++] = 0xff;
        idat[pi++] = 0x00;
        idat[pi++] = 0x00;
        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
        pi += maxBlockLength;
        pos += maxBlockLength;
        len -= maxBlockLength;
      }

      idat[pi++] = 0x01;
      idat[pi++] = len & 0xff;
      idat[pi++] = len >> 8 & 0xff;
      idat[pi++] = ~len & 0xffff & 0xff;
      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
      idat.set(literals.subarray(pos), pi);
      pi += literals.length - pos;
      const adler = adler32(literals, 0, literals.length);
      idat[pi++] = adler >> 24 & 0xff;
      idat[pi++] = adler >> 16 & 0xff;
      idat[pi++] = adler >> 8 & 0xff;
      idat[pi++] = adler & 0xff;
      return idat;
    }

    function encode(imgData, kind, forceDataSchema, isMask) {
      const width = imgData.width;
      const height = imgData.height;
      let bitDepth, colorType, lineSize;
      const bytes = imgData.data;

      switch (kind) {
        case _util.ImageKind.GRAYSCALE_1BPP:
          colorType = 0;
          bitDepth = 1;
          lineSize = width + 7 >> 3;
          break;

        case _util.ImageKind.RGB_24BPP:
          colorType = 2;
          bitDepth = 8;
          lineSize = width * 3;
          break;

        case _util.ImageKind.RGBA_32BPP:
          colorType = 6;
          bitDepth = 8;
          lineSize = width * 4;
          break;

        default:
          throw new Error("invalid format");
      }

      const literals = new Uint8Array((1 + lineSize) * height);
      let offsetLiterals = 0,
          offsetBytes = 0;

      for (let y = 0; y < height; ++y) {
        literals[offsetLiterals++] = 0;
        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
        offsetBytes += lineSize;
        offsetLiterals += lineSize;
      }

      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
        offsetLiterals = 0;

        for (let y = 0; y < height; y++) {
          offsetLiterals++;

          for (let i = 0; i < lineSize; i++) {
            literals[offsetLiterals++] ^= 0xff;
          }
        }
      }

      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
      const idat = deflateSync(literals);
      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
      const data = new Uint8Array(pngLength);
      let offset = 0;
      data.set(PNG_HEADER, offset);
      offset += PNG_HEADER.length;
      writePngChunk("IHDR", ihdr, data, offset);
      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
      writePngChunk("IDATA", idat, data, offset);
      offset += CHUNK_WRAPPER_SIZE + idat.length;
      writePngChunk("IEND", new Uint8Array(0), data, offset);
      return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
    }

    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
      return encode(imgData, kind, forceDataSchema, isMask);
    };
  }();

  class SVGExtraState {
    constructor() {
      this.fontSizeScale = 1;
      this.fontWeight = SVG_DEFAULTS.fontWeight;
      this.fontSize = 0;
      this.textMatrix = _util.IDENTITY_MATRIX;
      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
      this.leading = 0;
      this.textRenderingMode = _util.TextRenderingMode.FILL;
      this.textMatrixScale = 1;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRise = 0;
      this.fillColor = SVG_DEFAULTS.fillColor;
      this.strokeColor = "#000000";
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.lineJoin = "";
      this.lineCap = "";
      this.miterLimit = 0;
      this.dashArray = [];
      this.dashPhase = 0;
      this.dependencies = [];
      this.activeClipUrl = null;
      this.clipGroup = null;
      this.maskId = "";
    }

    clone() {
      return Object.create(this);
    }

    setCurrentPoint(x, y) {
      this.x = x;
      this.y = y;
    }

  }

  function opListToTree(opList) {
    let opTree = [];
    const tmp = [];

    for (const opListElement of opList) {
      if (opListElement.fn === "save") {
        opTree.push({
          fnId: 92,
          fn: "group",
          items: []
        });
        tmp.push(opTree);
        opTree = opTree[opTree.length - 1].items;
        continue;
      }

      if (opListElement.fn === "restore") {
        opTree = tmp.pop();
      } else {
        opTree.push(opListElement);
      }
    }

    return opTree;
  }

  function pf(value) {
    if (Number.isInteger(value)) {
      return value.toString();
    }

    const s = value.toFixed(10);
    let i = s.length - 1;

    if (s[i] !== "0") {
      return s;
    }

    do {
      i--;
    } while (s[i] === "0");

    return s.substring(0, s[i] === "." ? i : i + 1);
  }

  function pm(m) {
    if (m[4] === 0 && m[5] === 0) {
      if (m[1] === 0 && m[2] === 0) {
        if (m[0] === 1 && m[3] === 1) {
          return "";
        }

        return `scale(${pf(m[0])} ${pf(m[3])})`;
      }

      if (m[0] === m[3] && m[1] === -m[2]) {
        const a = Math.acos(m[0]) * 180 / Math.PI;
        return `rotate(${pf(a)})`;
      }
    } else {
      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
        return `translate(${pf(m[4])} ${pf(m[5])})`;
      }
    }

    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
  }

  let clipCount = 0;
  let maskCount = 0;
  let shadingCount = 0;
  exports.SVGGraphics = SVGGraphics = class {
    constructor(commonObjs, objs, forceDataSchema = false) {
      this.svgFactory = new _display_utils.DOMSVGFactory();
      this.current = new SVGExtraState();
      this.transformMatrix = _util.IDENTITY_MATRIX;
      this.transformStack = [];
      this.extraStack = [];
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.embedFonts = false;
      this.embeddedFonts = Object.create(null);
      this.cssStyle = null;
      this.forceDataSchema = !!forceDataSchema;
      this._operatorIdMapping = [];

      for (const op in _util.OPS) {
        this._operatorIdMapping[_util.OPS[op]] = op;
      }
    }

    save() {
      this.transformStack.push(this.transformMatrix);
      const old = this.current;
      this.extraStack.push(old);
      this.current = old.clone();
    }

    restore() {
      this.transformMatrix = this.transformStack.pop();
      this.current = this.extraStack.pop();
      this.pendingClip = null;
      this.tgrp = null;
    }

    group(items) {
      this.save();
      this.executeOpTree(items);
      this.restore();
    }

    loadDependencies(operatorList) {
      const fnArray = operatorList.fnArray;
      const argsArray = operatorList.argsArray;

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        if (fnArray[i] !== _util.OPS.dependency) {
          continue;
        }

        for (const obj of argsArray[i]) {
          const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
          const promise = new Promise(resolve => {
            objsPool.get(obj, resolve);
          });
          this.current.dependencies.push(promise);
        }
      }

      return Promise.all(this.current.dependencies);
    }

    transform(a, b, c, d, e, f) {
      const transformMatrix = [a, b, c, d, e, f];
      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
      this.tgrp = null;
    }

    getSVG(operatorList, viewport) {
      this.viewport = viewport;

      const svgElement = this._initialize(viewport);

      return this.loadDependencies(operatorList).then(() => {
        this.transformMatrix = _util.IDENTITY_MATRIX;
        this.executeOpTree(this.convertOpList(operatorList));
        return svgElement;
      });
    }

    convertOpList(operatorList) {
      const operatorIdMapping = this._operatorIdMapping;
      const argsArray = operatorList.argsArray;
      const fnArray = operatorList.fnArray;
      const opList = [];

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        const fnId = fnArray[i];
        opList.push({
          fnId,
          fn: operatorIdMapping[fnId],
          args: argsArray[i]
        });
      }

      return opListToTree(opList);
    }

    executeOpTree(opTree) {
      for (const opTreeElement of opTree) {
        const fn = opTreeElement.fn;
        const fnId = opTreeElement.fnId;
        const args = opTreeElement.args;

        switch (fnId | 0) {
          case _util.OPS.beginText:
            this.beginText();
            break;

          case _util.OPS.dependency:
            break;

          case _util.OPS.setLeading:
            this.setLeading(args);
            break;

          case _util.OPS.setLeadingMoveText:
            this.setLeadingMoveText(args[0], args[1]);
            break;

          case _util.OPS.setFont:
            this.setFont(args);
            break;

          case _util.OPS.showText:
            this.showText(args[0]);
            break;

          case _util.OPS.showSpacedText:
            this.showText(args[0]);
            break;

          case _util.OPS.endText:
            this.endText();
            break;

          case _util.OPS.moveText:
            this.moveText(args[0], args[1]);
            break;

          case _util.OPS.setCharSpacing:
            this.setCharSpacing(args[0]);
            break;

          case _util.OPS.setWordSpacing:
            this.setWordSpacing(args[0]);
            break;

          case _util.OPS.setHScale:
            this.setHScale(args[0]);
            break;

          case _util.OPS.setTextMatrix:
            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.setTextRise:
            this.setTextRise(args[0]);
            break;

          case _util.OPS.setTextRenderingMode:
            this.setTextRenderingMode(args[0]);
            break;

          case _util.OPS.setLineWidth:
            this.setLineWidth(args[0]);
            break;

          case _util.OPS.setLineJoin:
            this.setLineJoin(args[0]);
            break;

          case _util.OPS.setLineCap:
            this.setLineCap(args[0]);
            break;

          case _util.OPS.setMiterLimit:
            this.setMiterLimit(args[0]);
            break;

          case _util.OPS.setFillRGBColor:
            this.setFillRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeRGBColor:
            this.setStrokeRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeColorN:
            this.setStrokeColorN(args);
            break;

          case _util.OPS.setFillColorN:
            this.setFillColorN(args);
            break;

          case _util.OPS.shadingFill:
            this.shadingFill(args[0]);
            break;

          case _util.OPS.setDash:
            this.setDash(args[0], args[1]);
            break;

          case _util.OPS.setRenderingIntent:
            this.setRenderingIntent(args[0]);
            break;

          case _util.OPS.setFlatness:
            this.setFlatness(args[0]);
            break;

          case _util.OPS.setGState:
            this.setGState(args[0]);
            break;

          case _util.OPS.fill:
            this.fill();
            break;

          case _util.OPS.eoFill:
            this.eoFill();
            break;

          case _util.OPS.stroke:
            this.stroke();
            break;

          case _util.OPS.fillStroke:
            this.fillStroke();
            break;

          case _util.OPS.eoFillStroke:
            this.eoFillStroke();
            break;

          case _util.OPS.clip:
            this.clip("nonzero");
            break;

          case _util.OPS.eoClip:
            this.clip("evenodd");
            break;

          case _util.OPS.paintSolidColorImageMask:
            this.paintSolidColorImageMask();
            break;

          case _util.OPS.paintImageXObject:
            this.paintImageXObject(args[0]);
            break;

          case _util.OPS.paintInlineImageXObject:
            this.paintInlineImageXObject(args[0]);
            break;

          case _util.OPS.paintImageMaskXObject:
            this.paintImageMaskXObject(args[0]);
            break;

          case _util.OPS.paintFormXObjectBegin:
            this.paintFormXObjectBegin(args[0], args[1]);
            break;

          case _util.OPS.paintFormXObjectEnd:
            this.paintFormXObjectEnd();
            break;

          case _util.OPS.closePath:
            this.closePath();
            break;

          case _util.OPS.closeStroke:
            this.closeStroke();
            break;

          case _util.OPS.closeFillStroke:
            this.closeFillStroke();
            break;

          case _util.OPS.closeEOFillStroke:
            this.closeEOFillStroke();
            break;

          case _util.OPS.nextLine:
            this.nextLine();
            break;

          case _util.OPS.transform:
            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.constructPath:
            this.constructPath(args[0], args[1]);
            break;

          case _util.OPS.endPath:
            this.endPath();
            break;

          case 92:
            this.group(opTreeElement.items);
            break;

          default:
            (0, _util.warn)(`Unimplemented operator ${fn}`);
            break;
        }
      }
    }

    setWordSpacing(wordSpacing) {
      this.current.wordSpacing = wordSpacing;
    }

    setCharSpacing(charSpacing) {
      this.current.charSpacing = charSpacing;
    }

    nextLine() {
      this.moveText(0, this.current.leading);
    }

    setTextMatrix(a, b, c, d, e, f) {
      const current = this.current;
      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
      current.textMatrixScale = Math.hypot(a, b);
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtElement.appendChild(current.tspan);
    }

    beginText() {
      const current = this.current;
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.textMatrix = _util.IDENTITY_MATRIX;
      current.lineMatrix = _util.IDENTITY_MATRIX;
      current.textMatrixScale = 1;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtgrp = this.svgFactory.createElement("svg:g");
      current.xcoords = [];
      current.ycoords = [];
    }

    moveText(x, y) {
      const current = this.current;
      current.x = current.lineX += x;
      current.y = current.lineY += y;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
    }

    showText(glyphs) {
      const current = this.current;
      const font = current.font;
      const fontSize = current.fontSize;

      if (fontSize === 0) {
        return;
      }

      const fontSizeScale = current.fontSizeScale;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const fontDirection = current.fontDirection;
      const textHScale = current.textHScale * fontDirection;
      const vertical = font.vertical;
      const spacingDir = vertical ? 1 : -1;
      const defaultVMetrics = font.defaultVMetrics;
      const widthAdvanceScale = fontSize * current.fontMatrix[0];
      let x = 0;

      for (const glyph of glyphs) {
        if (glyph === null) {
          x += fontDirection * wordSpacing;
          continue;
        } else if ((0, _util.isNum)(glyph)) {
          x += spacingDir * glyph * fontSize / 1000;
          continue;
        }

        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const character = glyph.fontChar;
        let scaledX, scaledY;
        let width = glyph.width;

        if (vertical) {
          let vx;
          const vmetric = glyph.vmetric || defaultVMetrics;
          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
          vx = -vx * widthAdvanceScale;
          const vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }

        if (glyph.isInFont || font.missingFile) {
          current.xcoords.push(current.x + scaledX);

          if (vertical) {
            current.ycoords.push(-current.y + scaledY);
          }

          current.tspan.textContent += character;
        } else {}

        let charWidth;

        if (vertical) {
          charWidth = width * widthAdvanceScale - spacing * fontDirection;
        } else {
          charWidth = width * widthAdvanceScale + spacing * fontDirection;
        }

        x += charWidth;
      }

      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

      if (vertical) {
        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
      } else {
        current.tspan.setAttributeNS(null, "y", pf(-current.y));
      }

      if (vertical) {
        current.y -= x;
      } else {
        current.x += x * textHScale;
      }

      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);

      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
      }

      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
      }

      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
          current.tspan.setAttributeNS(null, "fill", current.fillColor);
        }

        if (current.fillAlpha < 1) {
          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        }
      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
        current.tspan.setAttributeNS(null, "fill", "transparent");
      } else {
        current.tspan.setAttributeNS(null, "fill", "none");
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        const lineWidthScale = 1 / (current.textMatrixScale || 1);

        this._setStrokeAttributes(current.tspan, lineWidthScale);
      }

      let textMatrix = current.textMatrix;

      if (current.textRise !== 0) {
        textMatrix = textMatrix.slice();
        textMatrix[5] += current.textRise;
      }

      current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
      current.txtElement.appendChild(current.tspan);
      current.txtgrp.appendChild(current.txtElement);

      this._ensureTransformGroup().appendChild(current.txtElement);
    }

    setLeadingMoveText(x, y) {
      this.setLeading(-y);
      this.moveText(x, y);
    }

    addFontStyle(fontObj) {
      if (!fontObj.data) {
        throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
      }

      if (!this.cssStyle) {
        this.cssStyle = this.svgFactory.createElement("svg:style");
        this.cssStyle.setAttributeNS(null, "type", "text/css");
        this.defs.appendChild(this.cssStyle);
      }

      const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
      this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
    }

    setFont(details) {
      const current = this.current;
      const fontObj = this.commonObjs.get(details[0]);
      let size = details[1];
      current.font = fontObj;

      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
        this.addFontStyle(fontObj);
        this.embeddedFonts[fontObj.loadedName] = fontObj;
      }

      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      let bold = "normal";

      if (fontObj.black) {
        bold = "900";
      } else if (fontObj.bold) {
        bold = "bold";
      }

      const italic = fontObj.italic ? "italic" : "normal";

      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }

      current.fontSize = size;
      current.fontFamily = fontObj.loadedName;
      current.fontWeight = bold;
      current.fontStyle = italic;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.xcoords = [];
      current.ycoords = [];
    }

    endText() {
      const current = this.current;

      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
        current.element = current.txtElement;
        this.clip("nonzero");
        this.endPath();
      }
    }

    setLineWidth(width) {
      if (width > 0) {
        this.current.lineWidth = width;
      }
    }

    setLineCap(style) {
      this.current.lineCap = LINE_CAP_STYLES[style];
    }

    setLineJoin(style) {
      this.current.lineJoin = LINE_JOIN_STYLES[style];
    }

    setMiterLimit(limit) {
      this.current.miterLimit = limit;
    }

    setStrokeAlpha(strokeAlpha) {
      this.current.strokeAlpha = strokeAlpha;
    }

    setStrokeRGBColor(r, g, b) {
      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
    }

    setFillAlpha(fillAlpha) {
      this.current.fillAlpha = fillAlpha;
    }

    setFillRGBColor(r, g, b) {
      this.current.fillColor = _util.Util.makeHexColor(r, g, b);
      this.current.tspan = this.svgFactory.createElement("svg:tspan");
      this.current.xcoords = [];
      this.current.ycoords = [];
    }

    setStrokeColorN(args) {
      this.current.strokeColor = this._makeColorN_Pattern(args);
    }

    setFillColorN(args) {
      this.current.fillColor = this._makeColorN_Pattern(args);
    }

    shadingFill(args) {
      const width = this.viewport.width;
      const height = this.viewport.height;

      const inv = _util.Util.inverseTransform(this.transformMatrix);

      const bl = _util.Util.applyTransform([0, 0], inv);

      const br = _util.Util.applyTransform([0, height], inv);

      const ul = _util.Util.applyTransform([width, 0], inv);

      const ur = _util.Util.applyTransform([width, height], inv);

      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", x0);
      rect.setAttributeNS(null, "y", y0);
      rect.setAttributeNS(null, "width", x1 - x0);
      rect.setAttributeNS(null, "height", y1 - y0);
      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

      if (this.current.fillAlpha < 1) {
        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
      }

      this._ensureTransformGroup().appendChild(rect);
    }

    _makeColorN_Pattern(args) {
      if (args[0] === "TilingPattern") {
        return this._makeTilingPattern(args);
      }

      return this._makeShadingPattern(args);
    }

    _makeTilingPattern(args) {
      const color = args[1];
      const operatorList = args[2];
      const matrix = args[3] || _util.IDENTITY_MATRIX;
      const [x0, y0, x1, y1] = args[4];
      const xstep = args[5];
      const ystep = args[6];
      const paintType = args[7];
      const tilingId = `shading${shadingCount++}`;

      const [tx0, ty0] = _util.Util.applyTransform([x0, y0], matrix);

      const [tx1, ty1] = _util.Util.applyTransform([x1, y1], matrix);

      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);

      const txstep = xstep * xscale;
      const tystep = ystep * yscale;
      const tiling = this.svgFactory.createElement("svg:pattern");
      tiling.setAttributeNS(null, "id", tilingId);
      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
      tiling.setAttributeNS(null, "width", txstep);
      tiling.setAttributeNS(null, "height", tystep);
      tiling.setAttributeNS(null, "x", `${tx0}`);
      tiling.setAttributeNS(null, "y", `${ty0}`);
      const svg = this.svg;
      const transformMatrix = this.transformMatrix;
      const fillColor = this.current.fillColor;
      const strokeColor = this.current.strokeColor;
      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
      this.svg = bbox;
      this.transformMatrix = matrix;

      if (paintType === 2) {
        const cssColor = _util.Util.makeHexColor(...color);

        this.current.fillColor = cssColor;
        this.current.strokeColor = cssColor;
      }

      this.executeOpTree(this.convertOpList(operatorList));
      this.svg = svg;
      this.transformMatrix = transformMatrix;
      this.current.fillColor = fillColor;
      this.current.strokeColor = strokeColor;
      tiling.appendChild(bbox.childNodes[0]);
      this.defs.appendChild(tiling);
      return `url(#${tilingId})`;
    }

    _makeShadingPattern(args) {
      switch (args[0]) {
        case "RadialAxial":
          const shadingId = `shading${shadingCount++}`;
          const colorStops = args[3];
          let gradient;

          switch (args[1]) {
            case "axial":
              const point0 = args[4];
              const point1 = args[5];
              gradient = this.svgFactory.createElement("svg:linearGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "x1", point0[0]);
              gradient.setAttributeNS(null, "y1", point0[1]);
              gradient.setAttributeNS(null, "x2", point1[0]);
              gradient.setAttributeNS(null, "y2", point1[1]);
              break;

            case "radial":
              const focalPoint = args[4];
              const circlePoint = args[5];
              const focalRadius = args[6];
              const circleRadius = args[7];
              gradient = this.svgFactory.createElement("svg:radialGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "cx", circlePoint[0]);
              gradient.setAttributeNS(null, "cy", circlePoint[1]);
              gradient.setAttributeNS(null, "r", circleRadius);
              gradient.setAttributeNS(null, "fx", focalPoint[0]);
              gradient.setAttributeNS(null, "fy", focalPoint[1]);
              gradient.setAttributeNS(null, "fr", focalRadius);
              break;

            default:
              throw new Error(`Unknown RadialAxial type: ${args[1]}`);
          }

          for (const colorStop of colorStops) {
            const stop = this.svgFactory.createElement("svg:stop");
            stop.setAttributeNS(null, "offset", colorStop[0]);
            stop.setAttributeNS(null, "stop-color", colorStop[1]);
            gradient.appendChild(stop);
          }

          this.defs.appendChild(gradient);
          return `url(#${shadingId})`;

        case "Mesh":
          (0, _util.warn)("Unimplemented pattern Mesh");
          return null;

        case "Dummy":
          return "hotpink";

        default:
          throw new Error(`Unknown IR type: ${args[0]}`);
      }
    }

    setDash(dashArray, dashPhase) {
      this.current.dashArray = dashArray;
      this.current.dashPhase = dashPhase;
    }

    constructPath(ops, args) {
      const current = this.current;
      let x = current.x,
          y = current.y;
      let d = [];
      let j = 0;

      for (const op of ops) {
        switch (op | 0) {
          case _util.OPS.rectangle:
            x = args[j++];
            y = args[j++];
            const width = args[j++];
            const height = args[j++];
            const xw = x + width;
            const yh = y + height;
            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
            break;

          case _util.OPS.moveTo:
            x = args[j++];
            y = args[j++];
            d.push("M", pf(x), pf(y));
            break;

          case _util.OPS.lineTo:
            x = args[j++];
            y = args[j++];
            d.push("L", pf(x), pf(y));
            break;

          case _util.OPS.curveTo:
            x = args[j + 4];
            y = args[j + 5];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
            j += 6;
            break;

          case _util.OPS.curveTo2:
            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
            x = args[j + 2];
            y = args[j + 3];
            j += 4;
            break;

          case _util.OPS.curveTo3:
            x = args[j + 2];
            y = args[j + 3];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
            j += 4;
            break;

          case _util.OPS.closePath:
            d.push("Z");
            break;
        }
      }

      d = d.join(" ");

      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
        d = current.path.getAttributeNS(null, "d") + d;
      } else {
        current.path = this.svgFactory.createElement("svg:path");

        this._ensureTransformGroup().appendChild(current.path);
      }

      current.path.setAttributeNS(null, "d", d);
      current.path.setAttributeNS(null, "fill", "none");
      current.element = current.path;
      current.setCurrentPoint(x, y);
    }

    endPath() {
      const current = this.current;
      current.path = null;

      if (!this.pendingClip) {
        return;
      }

      if (!current.element) {
        this.pendingClip = null;
        return;
      }

      const clipId = `clippath${clipCount++}`;
      const clipPath = this.svgFactory.createElement("svg:clipPath");
      clipPath.setAttributeNS(null, "id", clipId);
      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
      const clipElement = current.element.cloneNode(true);

      if (this.pendingClip === "evenodd") {
        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
      } else {
        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
      }

      this.pendingClip = null;
      clipPath.appendChild(clipElement);
      this.defs.appendChild(clipPath);

      if (current.activeClipUrl) {
        current.clipGroup = null;

        for (const prev of this.extraStack) {
          prev.clipGroup = null;
        }

        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
      }

      current.activeClipUrl = `url(#${clipId})`;
      this.tgrp = null;
    }

    clip(type) {
      this.pendingClip = type;
    }

    closePath() {
      const current = this.current;

      if (current.path) {
        const d = `${current.path.getAttributeNS(null, "d")}Z`;
        current.path.setAttributeNS(null, "d", d);
      }
    }

    setLeading(leading) {
      this.current.leading = -leading;
    }

    setTextRise(textRise) {
      this.current.textRise = textRise;
    }

    setTextRenderingMode(textRenderingMode) {
      this.current.textRenderingMode = textRenderingMode;
    }

    setHScale(scale) {
      this.current.textHScale = scale / 100;
    }

    setRenderingIntent(intent) {}

    setFlatness(flatness) {}

    setGState(states) {
      for (const [key, value] of states) {
        switch (key) {
          case "LW":
            this.setLineWidth(value);
            break;

          case "LC":
            this.setLineCap(value);
            break;

          case "LJ":
            this.setLineJoin(value);
            break;

          case "ML":
            this.setMiterLimit(value);
            break;

          case "D":
            this.setDash(value[0], value[1]);
            break;

          case "RI":
            this.setRenderingIntent(value);
            break;

          case "FL":
            this.setFlatness(value);
            break;

          case "Font":
            this.setFont(value);
            break;

          case "CA":
            this.setStrokeAlpha(value);
            break;

          case "ca":
            this.setFillAlpha(value);
            break;

          default:
            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
            break;
        }
      }
    }

    fill() {
      const current = this.current;

      if (current.element) {
        current.element.setAttributeNS(null, "fill", current.fillColor);
        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        this.endPath();
      }
    }

    stroke() {
      const current = this.current;

      if (current.element) {
        this._setStrokeAttributes(current.element);

        current.element.setAttributeNS(null, "fill", "none");
        this.endPath();
      }
    }

    _setStrokeAttributes(element, lineWidthScale = 1) {
      const current = this.current;
      let dashArray = current.dashArray;

      if (lineWidthScale !== 1 && dashArray.length > 0) {
        dashArray = dashArray.map(function (value) {
          return lineWidthScale * value;
        });
      }

      element.setAttributeNS(null, "stroke", current.strokeColor);
      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
    }

    eoFill() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fill();
    }

    fillStroke() {
      this.stroke();
      this.fill();
    }

    eoFillStroke() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fillStroke();
    }

    closeStroke() {
      this.closePath();
      this.stroke();
    }

    closeFillStroke() {
      this.closePath();
      this.fillStroke();
    }

    closeEOFillStroke() {
      this.closePath();
      this.eoFillStroke();
    }

    paintSolidColorImageMask() {
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", "1px");
      rect.setAttributeNS(null, "height", "1px");
      rect.setAttributeNS(null, "fill", this.current.fillColor);

      this._ensureTransformGroup().appendChild(rect);
    }

    paintImageXObject(objId) {
      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
        return;
      }

      this.paintInlineImageXObject(imgData);
    }

    paintInlineImageXObject(imgData, mask) {
      const width = imgData.width;
      const height = imgData.height;
      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
      const cliprect = this.svgFactory.createElement("svg:rect");
      cliprect.setAttributeNS(null, "x", "0");
      cliprect.setAttributeNS(null, "y", "0");
      cliprect.setAttributeNS(null, "width", pf(width));
      cliprect.setAttributeNS(null, "height", pf(height));
      this.current.element = cliprect;
      this.clip("nonzero");
      const imgEl = this.svgFactory.createElement("svg:image");
      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
      imgEl.setAttributeNS(null, "x", "0");
      imgEl.setAttributeNS(null, "y", pf(-height));
      imgEl.setAttributeNS(null, "width", pf(width) + "px");
      imgEl.setAttributeNS(null, "height", pf(height) + "px");
      imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);

      if (mask) {
        mask.appendChild(imgEl);
      } else {
        this._ensureTransformGroup().appendChild(imgEl);
      }
    }

    paintImageMaskXObject(imgData) {
      const current = this.current;
      const width = imgData.width;
      const height = imgData.height;
      const fillColor = current.fillColor;
      current.maskId = `mask${maskCount++}`;
      const mask = this.svgFactory.createElement("svg:mask");
      mask.setAttributeNS(null, "id", current.maskId);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", pf(width));
      rect.setAttributeNS(null, "height", pf(height));
      rect.setAttributeNS(null, "fill", fillColor);
      rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
      this.defs.appendChild(mask);

      this._ensureTransformGroup().appendChild(rect);

      this.paintInlineImageXObject(imgData, mask);
    }

    paintFormXObjectBegin(matrix, bbox) {
      if (Array.isArray(matrix) && matrix.length === 6) {
        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      }

      if (bbox) {
        const width = bbox[2] - bbox[0];
        const height = bbox[3] - bbox[1];
        const cliprect = this.svgFactory.createElement("svg:rect");
        cliprect.setAttributeNS(null, "x", bbox[0]);
        cliprect.setAttributeNS(null, "y", bbox[1]);
        cliprect.setAttributeNS(null, "width", pf(width));
        cliprect.setAttributeNS(null, "height", pf(height));
        this.current.element = cliprect;
        this.clip("nonzero");
        this.endPath();
      }
    }

    paintFormXObjectEnd() {}

    _initialize(viewport) {
      const svg = this.svgFactory.create(viewport.width, viewport.height);
      const definitions = this.svgFactory.createElement("svg:defs");
      svg.appendChild(definitions);
      this.defs = definitions;
      const rootGroup = this.svgFactory.createElement("svg:g");
      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
      svg.appendChild(rootGroup);
      this.svg = rootGroup;
      return svg;
    }

    _ensureClipGroup() {
      if (!this.current.clipGroup) {
        const clipGroup = this.svgFactory.createElement("svg:g");
        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
        this.svg.appendChild(clipGroup);
        this.current.clipGroup = clipGroup;
      }

      return this.current.clipGroup;
    }

    _ensureTransformGroup() {
      if (!this.tgrp) {
        this.tgrp = this.svgFactory.createElement("svg:g");
        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

        if (this.current.activeClipUrl) {
          this._ensureClipGroup().appendChild(this.tgrp);
        } else {
          this.svg.appendChild(this.tgrp);
        }
      }

      return this.tgrp;
    }

  };
}

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaLayer = void 0;

class XfaLayer {
  static setAttributes(html, attrs) {
    for (const [key, value] of Object.entries(attrs)) {
      if (value === null || value === undefined) {
        continue;
      }

      if (key !== "style") {
        html.setAttribute(key, value);
      } else {
        Object.assign(html.style, value);
      }
    }
  }

  static render(parameters) {
    const root = parameters.xfa;
    const rootHtml = document.createElement(root.name);

    if (root.attributes) {
      XfaLayer.setAttributes(rootHtml, root.attributes);
    }

    const stack = [[root, -1, rootHtml]];
    const rootDiv = parameters.div;
    rootDiv.appendChild(rootHtml);
    const coeffs = parameters.viewport.transform.join(",");
    rootDiv.style.transform = `matrix(${coeffs})`;
    rootDiv.setAttribute("class", "xfaLayer xfaFont");

    while (stack.length > 0) {
      const [parent, i, html] = stack[stack.length - 1];

      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }

      const child = parent.children[++stack[stack.length - 1][1]];

      if (child === null) {
        continue;
      }

      const {
        name
      } = child;

      if (name === "#text") {
        html.appendChild(document.createTextNode(child.value));
        continue;
      }

      const childHtml = document.createElement(name);
      html.appendChild(childHtml);

      if (child.attributes) {
        XfaLayer.setAttributes(childHtml, child.attributes);
      }

      if (child.children && child.children.length > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        childHtml.appendChild(document.createTextNode(child.value));
      }
    }
  }

  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }

}

exports.XfaLayer = XfaLayer;

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNodeStream = void 0;

var _util = __w_pdfjs_require__(2);

var _network_utils = __w_pdfjs_require__(23);

;

const fs = require("fs");

const http = require("http");

const https = require("https");

const url = require("url");

const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

function parseUrl(sourceUrl) {
  const parsedUrl = url.parse(sourceUrl);

  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
    return parsedUrl;
  }

  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse(`file:///${sourceUrl}`);
  }

  if (!parsedUrl.host) {
    parsedUrl.protocol = "file:";
  }

  return parsedUrl;
}

class PDFNodeStream {
  constructor(source) {
    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
    this.isFsUrl = this.url.protocol === "file:";
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

    this._rangeRequestReaders.push(rangeReader);

    return rangeReader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNodeStream = PDFNodeStream;

class BaseFullReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._headersCapability = (0, _util.createPromiseCapability)();
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new _util.AbortException("streaming is disabled"));
    }

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

class BaseRangeReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

function createRequestOptions(parsedUrl, headers) {
  return {
    protocol: parsedUrl.protocol,
    auth: parsedUrl.auth,
    host: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    method: "GET",
    headers
  };
}

class PDFNodeStreamFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._headersCapability.resolve();

      this._setReadableStream(response);

      const getResponseHeader = name => {
        return this._readableStream.headers[name.toLowerCase()];
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;

      this._headersCapability.reject(reason);
    });

    this._request.end();
  }

}

class PDFNodeStreamRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    this._httpHeaders = {};

    for (const property in stream.httpHeaders) {
      const value = stream.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      this._httpHeaders[property] = value;
    }

    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        return;
      }

      this._setReadableStream(response);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;
    });

    this._request.end();
  }

}

class PDFNodeStreamFsFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    fs.lstat(path, (error, stat) => {
      if (error) {
        if (error.code === "ENOENT") {
          error = new _util.MissingPDFException(`Missing PDF "${path}".`);
        }

        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._contentLength = stat.size;

      this._setReadableStream(fs.createReadStream(path));

      this._headersCapability.resolve();
    });
  }

}

class PDFNodeStreamFsRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    this._setReadableStream(fs.createReadStream(path, {
      start,
      end: end - 1
    }));
  }

}

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createResponseStatusError = createResponseStatusError;
exports.extractFilenameFromHeader = extractFilenameFromHeader;
exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
exports.validateResponseStatus = validateResponseStatus;

var _util = __w_pdfjs_require__(2);

var _content_disposition = __w_pdfjs_require__(24);

var _display_utils = __w_pdfjs_require__(1);

function validateRangeRequestCapabilities({
  getResponseHeader,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: undefined
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);

  if (!Number.isInteger(length)) {
    return returnValues;
  }

  returnValues.suggestedLength = length;

  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }

  if (disableRange || !isHttp) {
    return returnValues;
  }

  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }

  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";

  if (contentEncoding !== "identity") {
    return returnValues;
  }

  returnValues.allowRangeRequests = true;
  return returnValues;
}

function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");

  if (contentDisposition) {
    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch (ex) {}
    }

    if ((0, _display_utils.isPdfFile)(filename)) {
      return filename;
    }
  }

  return null;
}

function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new _util.MissingPDFException('Missing PDF "' + url + '".');
  }

  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}

function validateResponseStatus(status) {
  return status === 200 || status === 206;
}

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

var _util = __w_pdfjs_require__(2);

function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  tmp = rfc2231getparam(contentDisposition);

  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }

  tmp = toParamRegExp("filename", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
  }

  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }

      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = (0, _util.stringToBytes)(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch (e) {
        if (/^utf-?8$/i.test(encoding)) {
          try {
            value = decodeURIComponent(escape(value));
            needsEncodingFixup = false;
          } catch (err) {}
        }
      }
    }

    return value;
  }

  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);

      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }

    return value;
  }

  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);

      if (n in matches) {
        if (n === 0) {
          break;
        }

        continue;
      }

      matches[n] = [quot, part];
    }

    const parts = [];

    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }

      let [quot, part] = matches[n];
      part = rfc2616unquote(part);

      if (quot) {
        part = unescape(part);

        if (n === 0) {
          part = rfc5987decode(part);
        }
      }

      parts.push(part);
    }

    return parts.join("");
  }

  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');

      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');

        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }

        parts[i] = parts[i].replace(/\\(.)/g, "$1");
      }

      value = parts.join('"');
    }

    return value;
  }

  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");

    if (encodingend === -1) {
      return extvalue;
    }

    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }

  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }

    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replace(/_/g, " ");
        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }

      try {
        text = atob(text);
      } catch (e) {}

      return textdecode(charset, text);
    });
  }

  return "";
}

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNetworkStream = void 0;

var _util = __w_pdfjs_require__(2);

var _network_utils = __w_pdfjs_require__(23);

;
const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;

function getArrayBuffer(xhr) {
  const data = xhr.response;

  if (typeof data !== "string") {
    return data;
  }

  const array = (0, _util.stringToBytes)(data);
  return array.buffer;
}

class NetworkManager {
  constructor(url, args) {
    this.url = url;
    args = args || {};
    this.isHttp = /^https?:/i.test(url);
    this.httpHeaders = this.isHttp && args.httpHeaders || {};
    this.withCredentials = args.withCredentials || false;

    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
      return new XMLHttpRequest();
    };

    this.currXhrId = 0;
    this.pendingRequests = Object.create(null);
  }

  requestRange(begin, end, listeners) {
    const args = {
      begin,
      end
    };

    for (const prop in listeners) {
      args[prop] = listeners[prop];
    }

    return this.request(args);
  }

  requestFull(listeners) {
    return this.request(listeners);
  }

  request(args) {
    const xhr = this.getXhr();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;

    for (const property in this.httpHeaders) {
      const value = this.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      xhr.setRequestHeader(property, value);
    }

    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }

    xhr.responseType = "arraybuffer";

    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }

    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }

  onProgress(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    if (pendingRequest.onProgress) {
      pendingRequest.onProgress(evt);
    }
  }

  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    const xhr = pendingRequest.xhr;

    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }

    if (xhr.readyState !== 4) {
      return;
    }

    if (!(xhrId in this.pendingRequests)) {
      return;
    }

    delete this.pendingRequests[xhrId];

    if (xhr.status === 0 && this.isHttp) {
      if (pendingRequest.onError) {
        pendingRequest.onError(xhr.status);
      }

      return;
    }

    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      if (pendingRequest.onError) {
        pendingRequest.onError(xhr.status);
      }

      return;
    }

    const chunk = getArrayBuffer(xhr);

    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      pendingRequest.onDone({
        begin: parseInt(matches[1], 10),
        chunk
      });
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else if (pendingRequest.onError) {
      pendingRequest.onError(xhr.status);
    }
  }

  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }

  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }

  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }

}

class PDFNetworkStream {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source.url, {
      httpHeaders: source.httpHeaders,
      withCredentials: source.withCredentials
    });
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNetworkStream = PDFNetworkStream;

class PDFNetworkStreamFullRequestReader {
  constructor(manager, source) {
    this._manager = manager;
    const args = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = source.url;
    this._fullRequestId = manager.requestFull(args);
    this._headersReceivedCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = undefined;
    this._filename = null;
    this.onProgress = null;
  }

  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;

    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

    const getResponseHeader = name => {
      return fullRequestXhr.getResponseHeader(name);
    };

    const {
      allowRangeRequests,
      suggestedLength
    } = (0, _network_utils.validateRangeRequestCapabilities)({
      getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });

    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }

    this._contentLength = suggestedLength || this._contentLength;
    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }

    this._headersReceivedCapability.resolve();
  }

  _onDone(args) {
    if (args) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();

        requestCapability.resolve({
          value: args.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(args.chunk);
      }
    }

    this._done = true;

    if (this._cachedChunks.length > 0) {
      return;
    }

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  _onError(status) {
    const url = this._url;
    const exception = (0, _network_utils.createResponseStatusError)(status, url);
    this._storedError = exception;

    this._headersReceivedCapability.reject(exception);

    for (const requestCapability of this._requests) {
      requestCapability.reject(exception);
    }

    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }

  _onProgress(data) {
    if (this.onProgress) {
      this.onProgress({
        loaded: data.loaded,
        total: data.lengthComputable ? data.total : this._contentLength
      });
    }
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  get contentLength() {
    return this._contentLength;
  }

  get headersReady() {
    return this._headersReceivedCapability.promise;
  }

  async read() {
    if (this._storedError) {
      throw this._storedError;
    }

    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    this._headersReceivedCapability.reject(reason);

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }

    this._fullRequestReader = null;
  }

}

class PDFNetworkStreamRangeRequestReader {
  constructor(manager, begin, end) {
    this._manager = manager;
    const args = {
      onDone: this._onDone.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._requestId = manager.requestRange(begin, end, args);
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this.onProgress = null;
    this.onClosed = null;
  }

  _close() {
    if (this.onClosed) {
      this.onClosed(this);
    }
  }

  _onDone(data) {
    const chunk = data.chunk;

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }

    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._close();
  }

  _onProgress(evt) {
    if (!this.isStreamingSupported && this.onProgress) {
      this.onProgress({
        loaded: evt.loaded
      });
    }
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }

    this._close();
  }

}

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFFetchStream = void 0;

var _util = __w_pdfjs_require__(2);

var _network_utils = __w_pdfjs_require__(23);

;

function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController?.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}

function createHeaders(httpHeaders) {
  const headers = new Headers();

  for (const property in httpHeaders) {
    const value = httpHeaders[property];

    if (typeof value === "undefined") {
      continue;
    }

    headers.append(property, value);
  }

  return headers;
}

class PDFFetchStream {
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFFetchStreamRangeReader(this, begin, end);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFFetchStream = PDFFetchStream;

class PDFFetchStreamReader {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    if (typeof AbortController !== "undefined") {
      this._abortController = new AbortController();
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = createHeaders(this._stream.httpHeaders);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._reader = response.body.getReader();

      this._headersCapability.resolve();

      const getResponseHeader = name => {
        return response.headers.get(name);
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new _util.AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    if (this._abortController) {
      this._abortController.abort();
    }
  }

}

class PDFFetchStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._isStreamingSupported = !source.disableStream;

    if (typeof AbortController !== "undefined") {
      this._abortController = new AbortController();
    }

    this._headers = createHeaders(this._stream.httpHeaders);

    this._headers.append("Range", `bytes=${begin}-${end - 1}`);

    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._readCapability.resolve();

      this._reader = response.body.getReader();
    }).catch(reason => {
      if (reason?.name === "AbortError") {
        return;
      }

      throw reason;
    });
    this.onProgress = null;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    if (this._abortController) {
      this._abortController.abort();
    }
  }

}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "addLinkAttributes", ({
  enumerable: true,
  get: function () {
    return _display_utils.addLinkAttributes;
  }
}));
Object.defineProperty(exports, "getFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getPdfFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getPdfFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "isPdfFile", ({
  enumerable: true,
  get: function () {
    return _display_utils.isPdfFile;
  }
}));
Object.defineProperty(exports, "LinkTarget", ({
  enumerable: true,
  get: function () {
    return _display_utils.LinkTarget;
  }
}));
Object.defineProperty(exports, "loadScript", ({
  enumerable: true,
  get: function () {
    return _display_utils.loadScript;
  }
}));
Object.defineProperty(exports, "PDFDateString", ({
  enumerable: true,
  get: function () {
    return _display_utils.PDFDateString;
  }
}));
Object.defineProperty(exports, "RenderingCancelledException", ({
  enumerable: true,
  get: function () {
    return _display_utils.RenderingCancelledException;
  }
}));
Object.defineProperty(exports, "build", ({
  enumerable: true,
  get: function () {
    return _api.build;
  }
}));
Object.defineProperty(exports, "getDocument", ({
  enumerable: true,
  get: function () {
    return _api.getDocument;
  }
}));
Object.defineProperty(exports, "LoopbackPort", ({
  enumerable: true,
  get: function () {
    return _api.LoopbackPort;
  }
}));
Object.defineProperty(exports, "PDFDataRangeTransport", ({
  enumerable: true,
  get: function () {
    return _api.PDFDataRangeTransport;
  }
}));
Object.defineProperty(exports, "PDFWorker", ({
  enumerable: true,
  get: function () {
    return _api.PDFWorker;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _api.version;
  }
}));
Object.defineProperty(exports, "CMapCompressionType", ({
  enumerable: true,
  get: function () {
    return _util.CMapCompressionType;
  }
}));
Object.defineProperty(exports, "createObjectURL", ({
  enumerable: true,
  get: function () {
    return _util.createObjectURL;
  }
}));
Object.defineProperty(exports, "createPromiseCapability", ({
  enumerable: true,
  get: function () {
    return _util.createPromiseCapability;
  }
}));
Object.defineProperty(exports, "createValidAbsoluteUrl", ({
  enumerable: true,
  get: function () {
    return _util.createValidAbsoluteUrl;
  }
}));
Object.defineProperty(exports, "InvalidPDFException", ({
  enumerable: true,
  get: function () {
    return _util.InvalidPDFException;
  }
}));
Object.defineProperty(exports, "MissingPDFException", ({
  enumerable: true,
  get: function () {
    return _util.MissingPDFException;
  }
}));
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function () {
    return _util.OPS;
  }
}));
Object.defineProperty(exports, "PasswordResponses", ({
  enumerable: true,
  get: function () {
    return _util.PasswordResponses;
  }
}));
Object.defineProperty(exports, "PermissionFlag", ({
  enumerable: true,
  get: function () {
    return _util.PermissionFlag;
  }
}));
Object.defineProperty(exports, "removeNullCharacters", ({
  enumerable: true,
  get: function () {
    return _util.removeNullCharacters;
  }
}));
Object.defineProperty(exports, "shadow", ({
  enumerable: true,
  get: function () {
    return _util.shadow;
  }
}));
Object.defineProperty(exports, "UnexpectedResponseException", ({
  enumerable: true,
  get: function () {
    return _util.UnexpectedResponseException;
  }
}));
Object.defineProperty(exports, "UNSUPPORTED_FEATURES", ({
  enumerable: true,
  get: function () {
    return _util.UNSUPPORTED_FEATURES;
  }
}));
Object.defineProperty(exports, "Util", ({
  enumerable: true,
  get: function () {
    return _util.Util;
  }
}));
Object.defineProperty(exports, "VerbosityLevel", ({
  enumerable: true,
  get: function () {
    return _util.VerbosityLevel;
  }
}));
Object.defineProperty(exports, "AnnotationLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_layer.AnnotationLayer;
  }
}));
Object.defineProperty(exports, "apiCompatibilityParams", ({
  enumerable: true,
  get: function () {
    return _api_compatibility.apiCompatibilityParams;
  }
}));
Object.defineProperty(exports, "GlobalWorkerOptions", ({
  enumerable: true,
  get: function () {
    return _worker_options.GlobalWorkerOptions;
  }
}));
Object.defineProperty(exports, "renderTextLayer", ({
  enumerable: true,
  get: function () {
    return _text_layer.renderTextLayer;
  }
}));
Object.defineProperty(exports, "SVGGraphics", ({
  enumerable: true,
  get: function () {
    return _svg.SVGGraphics;
  }
}));
Object.defineProperty(exports, "XfaLayer", ({
  enumerable: true,
  get: function () {
    return _xfa_layer.XfaLayer;
  }
}));

var _display_utils = __w_pdfjs_require__(1);

var _api = __w_pdfjs_require__(5);

var _util = __w_pdfjs_require__(2);

var _annotation_layer = __w_pdfjs_require__(17);

var _api_compatibility = __w_pdfjs_require__(9);

var _worker_options = __w_pdfjs_require__(12);

var _text_layer = __w_pdfjs_require__(19);

var _svg = __w_pdfjs_require__(20);

var _xfa_layer = __w_pdfjs_require__(21);

const pdfjsVersion = '2.9.0';
const pdfjsBuild = '3538ef0';
{
  const {
    isNodeJS
  } = __w_pdfjs_require__(4);

  if (isNodeJS) {
    const PDFNodeStream = __w_pdfjs_require__(22).PDFNodeStream;

    (0, _api.setPDFNetworkStreamFactory)(params => {
      return new PDFNodeStream(params);
    });
  } else {
    const PDFNetworkStream = __w_pdfjs_require__(25).PDFNetworkStream;

    let PDFFetchStream;

    if ((0, _display_utils.isFetchSupported)()) {
      PDFFetchStream = __w_pdfjs_require__(26).PDFFetchStream;
    }

    (0, _api.setPDFNetworkStreamFactory)(params => {
      if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {
        return new PDFFetchStream(params);
      }

      return new PDFNetworkStream(params);
    });
  }
}
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.js.map]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/web/viewer.js</url>
    <content><![CDATA[/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionKind = exports.AppOptions = void 0;

var _viewer_compatibility = __webpack_require__(2);

const OptionKind = {
  VIEWER: 0x02,
  API: 0x04,
  WORKER: 0x08,
  PREFERENCE: 0x80
};
exports.OptionKind = OptionKind;
const defaultOptions = {
  cursorToolOnLoad: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  defaultUrl: {
    value: "compressed.tracemonkey-pldi-09.pdf",
    kind: OptionKind.VIEWER
  },
  defaultZoomValue: {
    value: "",
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  disableHistory: {
    value: false,
    kind: OptionKind.VIEWER
  },
  disablePageLabels: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enablePermissions: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enablePrintAutoRotate: {
    value: true,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enableScripting: {
    value: true,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  externalLinkRel: {
    value: "noopener noreferrer nofollow",
    kind: OptionKind.VIEWER
  },
  externalLinkTarget: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  historyUpdateUrl: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  ignoreDestinationZoom: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  imageResourcesPath: {
    value: "./images/",
    kind: OptionKind.VIEWER
  },
  maxCanvasPixels: {
    value: 16777216,
    compatibility: _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels,
    kind: OptionKind.VIEWER
  },
  pdfBugEnabled: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  printResolution: {
    value: 150,
    kind: OptionKind.VIEWER
  },
  renderer: {
    value: "canvas",
    kind: OptionKind.VIEWER
  },
  renderInteractiveForms: {
    value: true,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  sidebarViewOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  scrollModeOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  spreadModeOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  textLayerMode: {
    value: 1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  useOnlyCssZoom: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  viewerCssTheme: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  viewOnLoad: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  cMapPacked: {
    value: true,
    kind: OptionKind.API
  },
  cMapUrl: {
    value: "../web/cmaps/",
    kind: OptionKind.API
  },
  disableAutoFetch: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableFontFace: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableRange: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableStream: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  docBaseUrl: {
    value: "",
    kind: OptionKind.API
  },
  enableXfa: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  fontExtraProperties: {
    value: false,
    kind: OptionKind.API
  },
  isEvalSupported: {
    value: true,
    kind: OptionKind.API
  },
  maxImageSize: {
    value: -1,
    kind: OptionKind.API
  },
  pdfBug: {
    value: false,
    kind: OptionKind.API
  },
  verbosity: {
    value: 1,
    kind: OptionKind.API
  },
  workerPort: {
    value: null,
    kind: OptionKind.WORKER
  },
  workerSrc: {
    value: "../build/pdf.worker.js",
    kind: OptionKind.WORKER
  }
};
{
  defaultOptions.disablePreferences = {
    value: false,
    kind: OptionKind.VIEWER
  };
  defaultOptions.locale = {
    value: typeof navigator !== "undefined" ? navigator.language : "en-US",
    kind: OptionKind.VIEWER
  };
  defaultOptions.sandboxBundleSrc = {
    value: "../build/pdf.sandbox.js",
    kind: OptionKind.VIEWER
  };
  defaultOptions.renderer.kind += OptionKind.PREFERENCE;
}
const userOptions = Object.create(null);

class AppOptions {
  constructor() {
    throw new Error("Cannot initialize AppOptions.");
  }

  static get(name) {
    const userOption = userOptions[name];

    if (userOption !== undefined) {
      return userOption;
    }

    const defaultOption = defaultOptions[name];

    if (defaultOption !== undefined) {
      return defaultOption.compatibility ?? defaultOption.value;
    }

    return undefined;
  }

  static getAll(kind = null) {
    const options = Object.create(null);

    for (const name in defaultOptions) {
      const defaultOption = defaultOptions[name];

      if (kind) {
        if ((kind & defaultOption.kind) === 0) {
          continue;
        }

        if (kind === OptionKind.PREFERENCE) {
          const value = defaultOption.value,
                valueType = typeof value;

          if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
            options[name] = value;
            continue;
          }

          throw new Error(`Invalid type for preference: ${name}`);
        }
      }

      const userOption = userOptions[name];
      options[name] = userOption !== undefined ? userOption : defaultOption.compatibility ?? defaultOption.value;
    }

    return options;
  }

  static set(name, value) {
    userOptions[name] = value;
  }

  static setAll(options) {
    for (const name in options) {
      userOptions[name] = options[name];
    }
  }

  static remove(name) {
    delete userOptions[name];
  }

}

exports.AppOptions = AppOptions;

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.viewerCompatibilityParams = void 0;
const compatibilityParams = Object.create(null);
{
  const userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
  const platform = typeof navigator !== "undefined" && navigator.platform || "";
  const maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1;
  const isAndroid = /Android/.test(userAgent);
  const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
  const isIOSChrome = /CriOS/.test(userAgent);

  (function checkOnBlobSupport() {
    if (isIOSChrome) {
      compatibilityParams.disableCreateObjectURL = true;
    }
  })();

  (function checkCanvasSizeLimitation() {
    if (isIOS || isAndroid) {
      compatibilityParams.maxCanvasPixels = 5242880;
    }
  })();
}
const viewerCompatibilityParams = Object.freeze(compatibilityParams);
exports.viewerCompatibilityParams = viewerCompatibilityParams;

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFViewerApplication = exports.PDFPrintServiceFactory = exports.DefaultExternalServices = void 0;

var _ui_utils = __webpack_require__(4);

var _app_options = __webpack_require__(1);

var _pdfjsLib = __webpack_require__(5);

var _pdf_cursor_tools = __webpack_require__(6);

var _pdf_rendering_queue = __webpack_require__(8);

var _overlay_manager = __webpack_require__(9);

var _password_prompt = __webpack_require__(10);

var _pdf_attachment_viewer = __webpack_require__(11);

var _pdf_document_properties = __webpack_require__(13);

var _pdf_find_bar = __webpack_require__(14);

var _pdf_find_controller = __webpack_require__(15);

var _pdf_history = __webpack_require__(17);

var _pdf_layer_viewer = __webpack_require__(18);

var _pdf_link_service = __webpack_require__(19);

var _pdf_outline_viewer = __webpack_require__(20);

var _pdf_presentation_mode = __webpack_require__(21);

var _pdf_scripting_manager = __webpack_require__(22);

var _pdf_sidebar = __webpack_require__(23);

var _pdf_sidebar_resizer = __webpack_require__(24);

var _pdf_thumbnail_viewer = __webpack_require__(25);

var _pdf_viewer = __webpack_require__(27);

var _secondary_toolbar = __webpack_require__(35);

var _toolbar = __webpack_require__(37);

var _viewer_compatibility = __webpack_require__(2);

var _view_history = __webpack_require__(38);

const DEFAULT_SCALE_DELTA = 1.1;
const DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000;
const FORCE_PAGES_LOADED_TIMEOUT = 10000;
const WHEEL_ZOOM_DISABLED_TIMEOUT = 1000;
const ENABLE_PERMISSIONS_CLASS = "enablePermissions";
const ViewOnLoad = {
  UNKNOWN: -1,
  PREVIOUS: 0,
  INITIAL: 1
};
const ViewerCssTheme = {
  AUTOMATIC: 0,
  LIGHT: 1,
  DARK: 2
};
const KNOWN_VERSIONS = ["1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "1.9", "2.0", "2.1", "2.2", "2.3"];
const KNOWN_GENERATORS = ["acrobat distiller", "acrobat pdfwriter", "adobe livecycle", "adobe pdf library", "adobe photoshop", "ghostscript", "tcpdf", "cairo", "dvipdfm", "dvips", "pdftex", "pdfkit", "itext", "prince", "quarkxpress", "mac os x", "microsoft", "openoffice", "oracle", "luradocument", "pdf-xchange", "antenna house", "aspose.cells", "fpdf"];

class DefaultExternalServices {
  constructor() {
    throw new Error("Cannot initialize DefaultExternalServices.");
  }

  static updateFindControlState(data) {}

  static updateFindMatchesCount(data) {}

  static initPassiveLoading(callbacks) {}

  static async fallback(data) {}

  static reportTelemetry(data) {}

  static createDownloadManager(options) {
    throw new Error("Not implemented: createDownloadManager");
  }

  static createPreferences() {
    throw new Error("Not implemented: createPreferences");
  }

  static createL10n(options) {
    throw new Error("Not implemented: createL10n");
  }

  static createScripting(options) {
    throw new Error("Not implemented: createScripting");
  }

  static get supportsIntegratedFind() {
    return (0, _pdfjsLib.shadow)(this, "supportsIntegratedFind", false);
  }

  static get supportsDocumentFonts() {
    return (0, _pdfjsLib.shadow)(this, "supportsDocumentFonts", true);
  }

  static get supportedMouseWheelZoomModifierKeys() {
    return (0, _pdfjsLib.shadow)(this, "supportedMouseWheelZoomModifierKeys", {
      ctrlKey: true,
      metaKey: true
    });
  }

  static get isInAutomation() {
    return (0, _pdfjsLib.shadow)(this, "isInAutomation", false);
  }

}

exports.DefaultExternalServices = DefaultExternalServices;
const PDFViewerApplication = {
  initialBookmark: document.location.hash.substring(1),
  _initializedCapability: (0, _pdfjsLib.createPromiseCapability)(),
  _fellback: false,
  appConfig: null,
  pdfDocument: null,
  pdfLoadingTask: null,
  printService: null,
  pdfViewer: null,
  pdfThumbnailViewer: null,
  pdfRenderingQueue: null,
  pdfPresentationMode: null,
  pdfDocumentProperties: null,
  pdfLinkService: null,
  pdfHistory: null,
  pdfSidebar: null,
  pdfSidebarResizer: null,
  pdfOutlineViewer: null,
  pdfAttachmentViewer: null,
  pdfLayerViewer: null,
  pdfCursorTools: null,
  pdfScriptingManager: null,
  store: null,
  downloadManager: null,
  overlayManager: null,
  preferences: null,
  toolbar: null,
  secondaryToolbar: null,
  eventBus: null,
  l10n: null,
  isInitialViewSet: false,
  downloadComplete: false,
  isViewerEmbedded: window.parent !== window,
  url: "",
  baseUrl: "",
  externalServices: DefaultExternalServices,
  _boundEvents: Object.create(null),
  documentInfo: null,
  metadata: null,
  _contentDispositionFilename: null,
  _contentLength: null,
  _saveInProgress: false,
  _wheelUnusedTicks: 0,
  _idleCallbacks: new Set(),

  async initialize(appConfig) {
    this.preferences = this.externalServices.createPreferences();
    this.appConfig = appConfig;
    await this._readPreferences();
    await this._parseHashParameters();

    this._forceCssTheme();

    await this._initializeL10n();

    if (this.isViewerEmbedded && _app_options.AppOptions.get("externalLinkTarget") === _pdfjsLib.LinkTarget.NONE) {
      _app_options.AppOptions.set("externalLinkTarget", _pdfjsLib.LinkTarget.TOP);
    }

    await this._initializeViewerComponents();
    this.bindEvents();
    this.bindWindowEvents();
    const appContainer = appConfig.appContainer || document.documentElement;
    this.l10n.translate(appContainer).then(() => {
      this.eventBus.dispatch("localized", {
        source: this
      });
    });

    this._initializedCapability.resolve();
  },

  async _readPreferences() {
    if (_app_options.AppOptions.get("disablePreferences")) {
      return;
    }

    try {
      _app_options.AppOptions.setAll(await this.preferences.getAll());
    } catch (reason) {
      console.error(`_readPreferences: "${reason?.message}".`);
    }
  },

  async _parseHashParameters() {
    if (!_app_options.AppOptions.get("pdfBugEnabled")) {
      return undefined;
    }

    const hash = document.location.hash.substring(1);

    if (!hash) {
      return undefined;
    }

    const hashParams = (0, _ui_utils.parseQueryString)(hash),
          waitOn = [];

    if ("disableworker" in hashParams && hashParams.disableworker === "true") {
      waitOn.push(loadFakeWorker());
    }

    if ("disablerange" in hashParams) {
      _app_options.AppOptions.set("disableRange", hashParams.disablerange === "true");
    }

    if ("disablestream" in hashParams) {
      _app_options.AppOptions.set("disableStream", hashParams.disablestream === "true");
    }

    if ("disableautofetch" in hashParams) {
      _app_options.AppOptions.set("disableAutoFetch", hashParams.disableautofetch === "true");
    }

    if ("disablefontface" in hashParams) {
      _app_options.AppOptions.set("disableFontFace", hashParams.disablefontface === "true");
    }

    if ("disablehistory" in hashParams) {
      _app_options.AppOptions.set("disableHistory", hashParams.disablehistory === "true");
    }

    if ("verbosity" in hashParams) {
      _app_options.AppOptions.set("verbosity", hashParams.verbosity | 0);
    }

    if ("textlayer" in hashParams) {
      switch (hashParams.textlayer) {
        case "off":
          _app_options.AppOptions.set("textLayerMode", _ui_utils.TextLayerMode.DISABLE);

          break;

        case "visible":
        case "shadow":
        case "hover":
          const viewer = this.appConfig.viewerContainer;
          viewer.classList.add("textLayer-" + hashParams.textlayer);
          break;
      }
    }

    if ("pdfbug" in hashParams) {
      _app_options.AppOptions.set("pdfBug", true);

      _app_options.AppOptions.set("fontExtraProperties", true);

      const enabled = hashParams.pdfbug.split(",");
      waitOn.push(loadAndEnablePDFBug(enabled));
    }

    if ("locale" in hashParams) {
      _app_options.AppOptions.set("locale", hashParams.locale);
    }

    if (waitOn.length === 0) {
      return undefined;
    }

    return Promise.all(waitOn).catch(reason => {
      console.error(`_parseHashParameters: "${reason.message}".`);
    });
  },

  async _initializeL10n() {
    this.l10n = this.externalServices.createL10n({
      locale: _app_options.AppOptions.get("locale")
    });
    const dir = await this.l10n.getDirection();
    document.getElementsByTagName("html")[0].dir = dir;
  },

  _forceCssTheme() {
    const cssTheme = _app_options.AppOptions.get("viewerCssTheme");

    if (cssTheme === ViewerCssTheme.AUTOMATIC || !Object.values(ViewerCssTheme).includes(cssTheme)) {
      return;
    }

    try {
      const styleSheet = document.styleSheets[0];
      const cssRules = styleSheet?.cssRules || [];
      const mediaMatcher = "prefers-color-scheme";
      const mediaRule = `(${mediaMatcher}: dark)`;
      const mediaRegex = new RegExp(`^@media \\(${mediaMatcher}: dark\\) {\\n\\s*([\\w\\s-.,:;/\\\\{}()]+)\\n}$`);

      for (let i = 0, ii = cssRules.length; i < ii; i++) {
        const rule = cssRules[i];

        if (rule instanceof CSSMediaRule && rule.media?.[0] === mediaRule) {
          if (cssTheme === ViewerCssTheme.LIGHT) {
            styleSheet.deleteRule(i);
            return;
          }

          const darkRules = mediaRegex.exec(rule.cssText);

          if (darkRules?.[1]) {
            styleSheet.deleteRule(i);
            styleSheet.insertRule(darkRules[1], i);
          }

          return;
        }
      }
    } catch (reason) {
      console.error(`_forceCssTheme: "${reason?.message}".`);
    }
  },

  async _initializeViewerComponents() {
    const appConfig = this.appConfig;
    const eventBus = appConfig.eventBus || new _ui_utils.EventBus({
      isInAutomation: this.externalServices.isInAutomation
    });
    this.eventBus = eventBus;
    this.overlayManager = new _overlay_manager.OverlayManager();
    const pdfRenderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
    pdfRenderingQueue.onIdle = this._cleanup.bind(this);
    this.pdfRenderingQueue = pdfRenderingQueue;
    const pdfLinkService = new _pdf_link_service.PDFLinkService({
      eventBus,
      externalLinkTarget: _app_options.AppOptions.get("externalLinkTarget"),
      externalLinkRel: _app_options.AppOptions.get("externalLinkRel"),
      ignoreDestinationZoom: _app_options.AppOptions.get("ignoreDestinationZoom")
    });
    this.pdfLinkService = pdfLinkService;
    const downloadManager = this.externalServices.createDownloadManager();
    this.downloadManager = downloadManager;
    const findController = new _pdf_find_controller.PDFFindController({
      linkService: pdfLinkService,
      eventBus
    });
    this.findController = findController;
    const pdfScriptingManager = new _pdf_scripting_manager.PDFScriptingManager({
      eventBus,
      sandboxBundleSrc: _app_options.AppOptions.get("sandboxBundleSrc"),
      scriptingFactory: this.externalServices,
      docPropertiesLookup: this._scriptingDocProperties.bind(this)
    });
    this.pdfScriptingManager = pdfScriptingManager;
    const container = appConfig.mainContainer;
    const viewer = appConfig.viewerContainer;
    this.pdfViewer = new _pdf_viewer.PDFViewer({
      container,
      viewer,
      eventBus,
      renderingQueue: pdfRenderingQueue,
      linkService: pdfLinkService,
      downloadManager,
      findController,
      scriptingManager: pdfScriptingManager,
      renderer: _app_options.AppOptions.get("renderer"),
      l10n: this.l10n,
      textLayerMode: _app_options.AppOptions.get("textLayerMode"),
      imageResourcesPath: _app_options.AppOptions.get("imageResourcesPath"),
      renderInteractiveForms: _app_options.AppOptions.get("renderInteractiveForms"),
      enablePrintAutoRotate: _app_options.AppOptions.get("enablePrintAutoRotate"),
      useOnlyCssZoom: _app_options.AppOptions.get("useOnlyCssZoom"),
      maxCanvasPixels: _app_options.AppOptions.get("maxCanvasPixels"),
      enableScripting: _app_options.AppOptions.get("enableScripting")
    });
    pdfRenderingQueue.setViewer(this.pdfViewer);
    pdfLinkService.setViewer(this.pdfViewer);
    pdfScriptingManager.setViewer(this.pdfViewer);
    this.pdfThumbnailViewer = new _pdf_thumbnail_viewer.PDFThumbnailViewer({
      container: appConfig.sidebar.thumbnailView,
      eventBus,
      renderingQueue: pdfRenderingQueue,
      linkService: pdfLinkService,
      l10n: this.l10n
    });
    pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);
    this.pdfHistory = new _pdf_history.PDFHistory({
      linkService: pdfLinkService,
      eventBus
    });
    pdfLinkService.setHistory(this.pdfHistory);

    if (!this.supportsIntegratedFind) {
      this.findBar = new _pdf_find_bar.PDFFindBar(appConfig.findBar, eventBus, this.l10n);
    }

    this.pdfDocumentProperties = new _pdf_document_properties.PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n);
    this.pdfCursorTools = new _pdf_cursor_tools.PDFCursorTools({
      container,
      eventBus,
      cursorToolOnLoad: _app_options.AppOptions.get("cursorToolOnLoad")
    });
    this.toolbar = new _toolbar.Toolbar(appConfig.toolbar, eventBus, this.l10n);
    this.secondaryToolbar = new _secondary_toolbar.SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

    if (this.supportsFullscreen) {
      this.pdfPresentationMode = new _pdf_presentation_mode.PDFPresentationMode({
        container,
        pdfViewer: this.pdfViewer,
        eventBus
      });
    }

    this.passwordPrompt = new _password_prompt.PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n, this.isViewerEmbedded);
    this.pdfOutlineViewer = new _pdf_outline_viewer.PDFOutlineViewer({
      container: appConfig.sidebar.outlineView,
      eventBus,
      linkService: pdfLinkService
    });
    this.pdfAttachmentViewer = new _pdf_attachment_viewer.PDFAttachmentViewer({
      container: appConfig.sidebar.attachmentsView,
      eventBus,
      downloadManager
    });
    this.pdfLayerViewer = new _pdf_layer_viewer.PDFLayerViewer({
      container: appConfig.sidebar.layersView,
      eventBus,
      l10n: this.l10n
    });
    this.pdfSidebar = new _pdf_sidebar.PDFSidebar({
      elements: appConfig.sidebar,
      pdfViewer: this.pdfViewer,
      pdfThumbnailViewer: this.pdfThumbnailViewer,
      eventBus,
      l10n: this.l10n
    });
    this.pdfSidebar.onToggled = this.forceRendering.bind(this);
    this.pdfSidebarResizer = new _pdf_sidebar_resizer.PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);
  },

  run(config) {
    this.initialize(config).then(webViewerInitialized);
  },

  get initialized() {
    return this._initializedCapability.settled;
  },

  get initializedPromise() {
    return this._initializedCapability.promise;
  },

  zoomIn(ticks) {
    if (this.pdfViewer.isInPresentationMode) {
      return;
    }

    let newScale = this.pdfViewer.currentScale;

    do {
      newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);
      newScale = Math.ceil(newScale * 10) / 10;
      newScale = Math.min(_ui_utils.MAX_SCALE, newScale);
    } while (--ticks > 0 && newScale < _ui_utils.MAX_SCALE);

    this.pdfViewer.currentScaleValue = newScale;
  },

  zoomOut(ticks) {
    if (this.pdfViewer.isInPresentationMode) {
      return;
    }

    let newScale = this.pdfViewer.currentScale;

    do {
      newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);
      newScale = Math.floor(newScale * 10) / 10;
      newScale = Math.max(_ui_utils.MIN_SCALE, newScale);
    } while (--ticks > 0 && newScale > _ui_utils.MIN_SCALE);

    this.pdfViewer.currentScaleValue = newScale;
  },

  zoomReset() {
    if (this.pdfViewer.isInPresentationMode) {
      return;
    }

    this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
  },

  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  },

  get page() {
    return this.pdfViewer.currentPageNumber;
  },

  set page(val) {
    this.pdfViewer.currentPageNumber = val;
  },

  get supportsPrinting() {
    return PDFPrintServiceFactory.instance.supportsPrinting;
  },

  get supportsFullscreen() {
    const doc = document.documentElement;
    let support = !!(doc.requestFullscreen || doc.mozRequestFullScreen || doc.webkitRequestFullScreen);

    if (document.fullscreenEnabled === false || document.mozFullScreenEnabled === false || document.webkitFullscreenEnabled === false) {
      support = false;
    }

    return (0, _pdfjsLib.shadow)(this, "supportsFullscreen", support);
  },

  get supportsIntegratedFind() {
    return this.externalServices.supportsIntegratedFind;
  },

  get supportsDocumentFonts() {
    return this.externalServices.supportsDocumentFonts;
  },

  get loadingBar() {
    const bar = new _ui_utils.ProgressBar("#loadingBar");
    return (0, _pdfjsLib.shadow)(this, "loadingBar", bar);
  },

  get supportedMouseWheelZoomModifierKeys() {
    return this.externalServices.supportedMouseWheelZoomModifierKeys;
  },

  initPassiveLoading() {
    throw new Error("Not implemented: initPassiveLoading");
  },

  setTitleUsingUrl(url = "") {
    this.url = url;
    this.baseUrl = url.split("#")[0];
    let title = (0, _pdfjsLib.getPdfFilenameFromUrl)(url, "");

    if (!title) {
      try {
        title = decodeURIComponent((0, _pdfjsLib.getFilenameFromUrl)(url)) || url;
      } catch (ex) {
        title = url;
      }
    }

    this.setTitle(title);
  },

  setTitle(title) {
    if (this.isViewerEmbedded) {
      return;
    }

    document.title = title;
  },

  get _docFilename() {
    return this._contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(this.url);
  },

  _cancelIdleCallbacks() {
    if (!this._idleCallbacks.size) {
      return;
    }

    for (const callback of this._idleCallbacks) {
      window.cancelIdleCallback(callback);
    }

    this._idleCallbacks.clear();
  },

  async close() {
    this._unblockDocumentLoadEvent();

    const {
      container
    } = this.appConfig.errorWrapper;
    container.hidden = true;

    if (!this.pdfLoadingTask) {
      return;
    }

    if (this.pdfDocument?.annotationStorage.size > 0 && this._annotationStorageModified) {
      try {
        await this.save({
          sourceEventType: "save"
        });
      } catch (reason) {}
    }

    const promises = [];
    promises.push(this.pdfLoadingTask.destroy());
    this.pdfLoadingTask = null;

    if (this.pdfDocument) {
      this.pdfDocument = null;
      this.pdfThumbnailViewer.setDocument(null);
      this.pdfViewer.setDocument(null);
      this.pdfLinkService.setDocument(null);
      this.pdfDocumentProperties.setDocument(null);
    }

    webViewerResetPermissions();
    this._fellback = false;
    this.store = null;
    this.isInitialViewSet = false;
    this.downloadComplete = false;
    this.url = "";
    this.baseUrl = "";
    this.documentInfo = null;
    this.metadata = null;
    this._contentDispositionFilename = null;
    this._contentLength = null;
    this._saveInProgress = false;

    this._cancelIdleCallbacks();

    promises.push(this.pdfScriptingManager.destroyPromise);
    this.pdfSidebar.reset();
    this.pdfOutlineViewer.reset();
    this.pdfAttachmentViewer.reset();
    this.pdfLayerViewer.reset();

    if (this.pdfHistory) {
      this.pdfHistory.reset();
    }

    if (this.findBar) {
      this.findBar.reset();
    }

    this.toolbar.reset();
    this.secondaryToolbar.reset();

    if (typeof PDFBug !== "undefined") {
      PDFBug.cleanup();
    }

    await Promise.all(promises);
  },

  async open(file, args) {
    if (this.pdfLoadingTask) {
      await this.close();
    }

    const workerParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.WORKER);

    for (const key in workerParameters) {
      _pdfjsLib.GlobalWorkerOptions[key] = workerParameters[key];
    }

    const parameters = Object.create(null);

    if (typeof file === "string") {
      this.setTitleUsingUrl(file);
      parameters.url = file;
    } else if (file && "byteLength" in file) {
      parameters.data = file;
    } else if (file.url && file.originalUrl) {
      this.setTitleUsingUrl(file.originalUrl);
      parameters.url = file.url;
    }

    const apiParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.API);

    for (const key in apiParameters) {
      let value = apiParameters[key];

      if (key === "docBaseUrl" && !value) {}

      parameters[key] = value;
    }

    if (args) {
      for (const key in args) {
        parameters[key] = args[key];
      }
    }

    const loadingTask = (0, _pdfjsLib.getDocument)(parameters);
    this.pdfLoadingTask = loadingTask;

    loadingTask.onPassword = (updateCallback, reason) => {
      this.pdfLinkService.externalLinkEnabled = false;
      this.passwordPrompt.setUpdateCallback(updateCallback, reason);
      this.passwordPrompt.open();
    };

    loadingTask.onProgress = ({
      loaded,
      total
    }) => {
      this.progress(loaded / total);
    };

    loadingTask.onUnsupportedFeature = this.fallback.bind(this);
    return loadingTask.promise.then(pdfDocument => {
      this.load(pdfDocument);
    }, exception => {
      if (loadingTask !== this.pdfLoadingTask) {
        return undefined;
      }

      let key = "loading_error";

      if (exception instanceof _pdfjsLib.InvalidPDFException) {
        key = "invalid_file_error";
      } else if (exception instanceof _pdfjsLib.MissingPDFException) {
        key = "missing_file_error";
      } else if (exception instanceof _pdfjsLib.UnexpectedResponseException) {
        key = "unexpected_response_error";
      }

      return this.l10n.get(key).then(msg => {
        this._documentError(msg, {
          message: exception?.message
        });

        throw exception;
      });
    });
  },

  _ensureDownloadComplete() {
    if (this.pdfDocument && this.downloadComplete) {
      return;
    }

    throw new Error("PDF document not downloaded.");
  },

  async download({
    sourceEventType = "download"
  } = {}) {
    const url = this.baseUrl,
          filename = this._docFilename;

    try {
      this._ensureDownloadComplete();

      const data = await this.pdfDocument.getData();
      const blob = new Blob([data], {
        type: "application/pdf"
      });
      await this.downloadManager.download(blob, url, filename, sourceEventType);
    } catch (reason) {
      await this.downloadManager.downloadUrl(url, filename);
    }
  },

  async save({
    sourceEventType = "download"
  } = {}) {
    if (this._saveInProgress) {
      return;
    }

    this._saveInProgress = true;
    await this.pdfScriptingManager.dispatchWillSave();
    const url = this.baseUrl,
          filename = this._docFilename;

    try {
      this._ensureDownloadComplete();

      const data = await this.pdfDocument.saveDocument();
      const blob = new Blob([data], {
        type: "application/pdf"
      });
      await this.downloadManager.download(blob, url, filename, sourceEventType);
    } catch (reason) {
      await this.download({
        sourceEventType
      });
    } finally {
      await this.pdfScriptingManager.dispatchDidSave();
      this._saveInProgress = false;
    }
  },

  downloadOrSave(options) {
    if (this.pdfDocument?.annotationStorage.size > 0) {
      this.save(options);
    } else {
      this.download(options);
    }
  },

  fallback(featureId) {
    this.externalServices.reportTelemetry({
      type: "unsupportedFeature",
      featureId
    });

    if (this._fellback) {
      return;
    }

    this._fellback = true;
    this.externalServices.fallback({
      featureId,
      url: this.baseUrl
    }).then(download => {
      if (!download) {
        return;
      }

      this.download({
        sourceEventType: "download"
      });
    });
  },

  _documentError(message, moreInfo = null) {
    this._unblockDocumentLoadEvent();

    this._otherError(message, moreInfo);
  },

  _otherError(message, moreInfo = null) {
    const moreInfoText = [this.l10n.get("error_version_info", {
      version: _pdfjsLib.version || "?",
      build: _pdfjsLib.build || "?"
    })];

    if (moreInfo) {
      moreInfoText.push(this.l10n.get("error_message", {
        message: moreInfo.message
      }));

      if (moreInfo.stack) {
        moreInfoText.push(this.l10n.get("error_stack", {
          stack: moreInfo.stack
        }));
      } else {
        if (moreInfo.filename) {
          moreInfoText.push(this.l10n.get("error_file", {
            file: moreInfo.filename
          }));
        }

        if (moreInfo.lineNumber) {
          moreInfoText.push(this.l10n.get("error_line", {
            line: moreInfo.lineNumber
          }));
        }
      }
    }

    const errorWrapperConfig = this.appConfig.errorWrapper;
    const errorWrapper = errorWrapperConfig.container;
    errorWrapper.hidden = false;
    const errorMessage = errorWrapperConfig.errorMessage;
    errorMessage.textContent = message;
    const closeButton = errorWrapperConfig.closeButton;

    closeButton.onclick = function () {
      errorWrapper.hidden = true;
    };

    const errorMoreInfo = errorWrapperConfig.errorMoreInfo;
    const moreInfoButton = errorWrapperConfig.moreInfoButton;
    const lessInfoButton = errorWrapperConfig.lessInfoButton;

    moreInfoButton.onclick = function () {
      errorMoreInfo.hidden = false;
      moreInfoButton.hidden = true;
      lessInfoButton.hidden = false;
      errorMoreInfo.style.height = errorMoreInfo.scrollHeight + "px";
    };

    lessInfoButton.onclick = function () {
      errorMoreInfo.hidden = true;
      moreInfoButton.hidden = false;
      lessInfoButton.hidden = true;
    };

    moreInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
    lessInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
    closeButton.oncontextmenu = _ui_utils.noContextMenuHandler;
    moreInfoButton.hidden = false;
    lessInfoButton.hidden = true;
    Promise.all(moreInfoText).then(parts => {
      errorMoreInfo.value = parts.join("\n");
    });
  },

  progress(level) {
    if (this.downloadComplete) {
      return;
    }

    const percent = Math.round(level * 100);

    if (percent > this.loadingBar.percent || isNaN(percent)) {
      this.loadingBar.percent = percent;
      const disableAutoFetch = this.pdfDocument ? this.pdfDocument.loadingParams.disableAutoFetch : _app_options.AppOptions.get("disableAutoFetch");

      if (disableAutoFetch && percent) {
        if (this.disableAutoFetchLoadingBarTimeout) {
          clearTimeout(this.disableAutoFetchLoadingBarTimeout);
          this.disableAutoFetchLoadingBarTimeout = null;
        }

        this.loadingBar.show();
        this.disableAutoFetchLoadingBarTimeout = setTimeout(() => {
          this.loadingBar.hide();
          this.disableAutoFetchLoadingBarTimeout = null;
        }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);
      }
    }
  },

  load(pdfDocument) {
    this.pdfDocument = pdfDocument;
    pdfDocument.getDownloadInfo().then(({
      length
    }) => {
      this._contentLength = length;
      this.downloadComplete = true;
      this.loadingBar.hide();
      firstPagePromise.then(() => {
        this.eventBus.dispatch("documentloaded", {
          source: this
        });
      });
    });
    const pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {});
    const pageModePromise = pdfDocument.getPageMode().catch(function () {});
    const openActionPromise = pdfDocument.getOpenAction().catch(function () {});
    this.toolbar.setPagesCount(pdfDocument.numPages, false);
    this.secondaryToolbar.setPagesCount(pdfDocument.numPages);
    let baseDocumentUrl;
    baseDocumentUrl = null;
    this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);
    this.pdfDocumentProperties.setDocument(pdfDocument, this.url);
    const pdfViewer = this.pdfViewer;
    pdfViewer.setDocument(pdfDocument);
    const {
      firstPagePromise,
      onePageRendered,
      pagesPromise
    } = pdfViewer;
    const pdfThumbnailViewer = this.pdfThumbnailViewer;
    pdfThumbnailViewer.setDocument(pdfDocument);
    const storedPromise = (this.store = new _view_history.ViewHistory(pdfDocument.fingerprint)).getMultiple({
      page: null,
      zoom: _ui_utils.DEFAULT_SCALE_VALUE,
      scrollLeft: "0",
      scrollTop: "0",
      rotation: null,
      sidebarView: _ui_utils.SidebarView.UNKNOWN,
      scrollMode: _ui_utils.ScrollMode.UNKNOWN,
      spreadMode: _ui_utils.SpreadMode.UNKNOWN
    }).catch(() => {
      return Object.create(null);
    });
    firstPagePromise.then(pdfPage => {
      this.loadingBar.setWidth(this.appConfig.viewerContainer);

      this._initializeAnnotationStorageCallbacks(pdfDocument);

      Promise.all([_ui_utils.animationStarted, storedPromise, pageLayoutPromise, pageModePromise, openActionPromise]).then(async ([timeStamp, stored, pageLayout, pageMode, openAction]) => {
        const viewOnLoad = _app_options.AppOptions.get("viewOnLoad");

        this._initializePdfHistory({
          fingerprint: pdfDocument.fingerprint,
          viewOnLoad,
          initialDest: openAction?.dest
        });

        const initialBookmark = this.initialBookmark;

        const zoom = _app_options.AppOptions.get("defaultZoomValue");

        let hash = zoom ? `zoom=${zoom}` : null;
        let rotation = null;

        let sidebarView = _app_options.AppOptions.get("sidebarViewOnLoad");

        let scrollMode = _app_options.AppOptions.get("scrollModeOnLoad");

        let spreadMode = _app_options.AppOptions.get("spreadModeOnLoad");

        if (stored.page && viewOnLoad !== ViewOnLoad.INITIAL) {
          hash = `page=${stored.page}&zoom=${zoom || stored.zoom},` + `${stored.scrollLeft},${stored.scrollTop}`;
          rotation = parseInt(stored.rotation, 10);

          if (sidebarView === _ui_utils.SidebarView.UNKNOWN) {
            sidebarView = stored.sidebarView | 0;
          }

          if (scrollMode === _ui_utils.ScrollMode.UNKNOWN) {
            scrollMode = stored.scrollMode | 0;
          }

          if (spreadMode === _ui_utils.SpreadMode.UNKNOWN) {
            spreadMode = stored.spreadMode | 0;
          }
        }

        if (pageMode && sidebarView === _ui_utils.SidebarView.UNKNOWN) {
          sidebarView = (0, _ui_utils.apiPageModeToSidebarView)(pageMode);
        }

        if (pageLayout && spreadMode === _ui_utils.SpreadMode.UNKNOWN) {
          spreadMode = (0, _ui_utils.apiPageLayoutToSpreadMode)(pageLayout);
        }

        this.setInitialView(hash, {
          rotation,
          sidebarView,
          scrollMode,
          spreadMode
        });
        this.eventBus.dispatch("documentinit", {
          source: this
        });

        if (!this.isViewerEmbedded) {
          pdfViewer.focus();
        }

        this._initializePermissions(pdfDocument);

        await Promise.race([pagesPromise, new Promise(resolve => {
          setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT);
        })]);

        if (!initialBookmark && !hash) {
          return;
        }

        if (pdfViewer.hasEqualPageSizes) {
          return;
        }

        this.initialBookmark = initialBookmark;
        pdfViewer.currentScaleValue = pdfViewer.currentScaleValue;
        this.setInitialView(hash);
      }).catch(() => {
        this.setInitialView();
      }).then(function () {
        pdfViewer.update();
      });
    });
    pagesPromise.then(() => {
      this._unblockDocumentLoadEvent();

      this._initializeAutoPrint(pdfDocument, openActionPromise);
    });
    onePageRendered.then(() => {
      pdfDocument.getOutline().then(outline => {
        if (pdfDocument !== this.pdfDocument) {
          return;
        }

        this.pdfOutlineViewer.render({
          outline,
          pdfDocument
        });
      });
      pdfDocument.getAttachments().then(attachments => {
        if (pdfDocument !== this.pdfDocument) {
          return;
        }

        this.pdfAttachmentViewer.render({
          attachments
        });
      });
      pdfViewer.optionalContentConfigPromise.then(optionalContentConfig => {
        if (pdfDocument !== this.pdfDocument) {
          return;
        }

        this.pdfLayerViewer.render({
          optionalContentConfig,
          pdfDocument
        });
      });

      if ("requestIdleCallback" in window) {
        const callback = window.requestIdleCallback(() => {
          this._collectTelemetry(pdfDocument);

          this._idleCallbacks.delete(callback);
        }, {
          timeout: 1000
        });

        this._idleCallbacks.add(callback);
      }
    });

    this._initializePageLabels(pdfDocument);

    this._initializeMetadata(pdfDocument);
  },

  async _scriptingDocProperties(pdfDocument) {
    if (!this.documentInfo) {
      await new Promise(resolve => {
        this.eventBus._on("metadataloaded", resolve, {
          once: true
        });
      });

      if (pdfDocument !== this.pdfDocument) {
        return null;
      }
    }

    if (!this._contentLength) {
      await new Promise(resolve => {
        this.eventBus._on("documentloaded", resolve, {
          once: true
        });
      });

      if (pdfDocument !== this.pdfDocument) {
        return null;
      }
    }

    return { ...this.documentInfo,
      baseURL: this.baseUrl,
      filesize: this._contentLength,
      filename: this._docFilename,
      metadata: this.metadata?.getRaw(),
      authors: this.metadata?.get("dc:creator"),
      numPages: this.pagesCount,
      URL: this.url
    };
  },

  async _collectTelemetry(pdfDocument) {
    const markInfo = await this.pdfDocument.getMarkInfo();

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    const tagged = markInfo?.Marked || false;
    this.externalServices.reportTelemetry({
      type: "tagged",
      tagged
    });
  },

  async _initializeAutoPrint(pdfDocument, openActionPromise) {
    const [openAction, javaScript] = await Promise.all([openActionPromise, !this.pdfViewer.enableScripting ? pdfDocument.getJavaScript() : null]);

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    let triggerAutoPrint = false;

    if (openAction?.action === "Print") {
      triggerAutoPrint = true;
    }

    if (javaScript) {
      javaScript.some(js => {
        if (!js) {
          return false;
        }

        console.warn("Warning: JavaScript support is not enabled");
        this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.javaScript);
        return true;
      });

      if (!triggerAutoPrint) {
        for (const js of javaScript) {
          if (js && _ui_utils.AutoPrintRegExp.test(js)) {
            triggerAutoPrint = true;
            break;
          }
        }
      }
    }

    if (triggerAutoPrint) {
      this.triggerPrinting();
    }
  },

  async _initializeMetadata(pdfDocument) {
    const {
      info,
      metadata,
      contentDispositionFilename,
      contentLength
    } = await pdfDocument.getMetadata();

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    this.documentInfo = info;
    this.metadata = metadata;
    this._contentDispositionFilename ?? (this._contentDispositionFilename = contentDispositionFilename);
    this._contentLength ?? (this._contentLength = contentLength);
    console.log(`PDF ${pdfDocument.fingerprint} [${info.PDFFormatVersion} ` + `${(info.Producer || "-").trim()} / ${(info.Creator || "-").trim()}] ` + `(PDF.js: ${_pdfjsLib.version || "-"})`);
    let pdfTitle = info?.Title;
    const metadataTitle = metadata?.get("dc:title");

    if (metadataTitle) {
      if (metadataTitle !== "Untitled" && !/[\uFFF0-\uFFFF]/g.test(metadataTitle)) {
        pdfTitle = metadataTitle;
      }
    }

    if (pdfTitle) {
      this.setTitle(`${pdfTitle} - ${contentDispositionFilename || document.title}`);
    } else if (contentDispositionFilename) {
      this.setTitle(contentDispositionFilename);
    }

    if (info.IsXFAPresent && !info.IsAcroFormPresent && !pdfDocument.isPureXfa) {
      console.warn("Warning: XFA is not enabled");
      this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.forms);
    } else if ((info.IsAcroFormPresent || info.IsXFAPresent) && !this.pdfViewer.renderInteractiveForms) {
      console.warn("Warning: Interactive form support is not enabled");
      this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.forms);
    }

    if (info.IsSignaturesPresent) {
      console.warn("Warning: Digital signatures validation is not supported");
      this.fallback(_pdfjsLib.UNSUPPORTED_FEATURES.signatures);
    }

    let versionId = "other";

    if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {
      versionId = `v${info.PDFFormatVersion.replace(".", "_")}`;
    }

    let generatorId = "other";

    if (info.Producer) {
      const producer = info.Producer.toLowerCase();
      KNOWN_GENERATORS.some(function (generator) {
        if (!producer.includes(generator)) {
          return false;
        }

        generatorId = generator.replace(/[ .-]/g, "_");
        return true;
      });
    }

    let formType = null;

    if (info.IsXFAPresent) {
      formType = "xfa";
    } else if (info.IsAcroFormPresent) {
      formType = "acroform";
    }

    this.externalServices.reportTelemetry({
      type: "documentInfo",
      version: versionId,
      generator: generatorId,
      formType
    });
    this.eventBus.dispatch("metadataloaded", {
      source: this
    });
  },

  async _initializePageLabels(pdfDocument) {
    const labels = await pdfDocument.getPageLabels();

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    if (!labels || _app_options.AppOptions.get("disablePageLabels")) {
      return;
    }

    const numLabels = labels.length;

    if (numLabels !== this.pagesCount) {
      console.error("The number of Page Labels does not match the number of pages in the document.");
      return;
    }

    let i = 0;

    while (i < numLabels && labels[i] === (i + 1).toString()) {
      i++;
    }

    if (i === numLabels) {
      return;
    }

    const {
      pdfViewer,
      pdfThumbnailViewer,
      toolbar
    } = this;
    pdfViewer.setPageLabels(labels);
    pdfThumbnailViewer.setPageLabels(labels);
    toolbar.setPagesCount(numLabels, true);
    toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
  },

  _initializePdfHistory({
    fingerprint,
    viewOnLoad,
    initialDest = null
  }) {
    if (this.isViewerEmbedded || _app_options.AppOptions.get("disableHistory")) {
      return;
    }

    this.pdfHistory.initialize({
      fingerprint,
      resetHistory: viewOnLoad === ViewOnLoad.INITIAL,
      updateUrl: _app_options.AppOptions.get("historyUpdateUrl")
    });

    if (this.pdfHistory.initialBookmark) {
      this.initialBookmark = this.pdfHistory.initialBookmark;
      this.initialRotation = this.pdfHistory.initialRotation;
    }

    if (initialDest && !this.initialBookmark && viewOnLoad === ViewOnLoad.UNKNOWN) {
      this.initialBookmark = JSON.stringify(initialDest);
      this.pdfHistory.push({
        explicitDest: initialDest,
        pageNumber: null
      });
    }
  },

  async _initializePermissions(pdfDocument) {
    const permissions = await pdfDocument.getPermissions();

    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    if (!permissions || !_app_options.AppOptions.get("enablePermissions")) {
      return;
    }

    if (!permissions.includes(_pdfjsLib.PermissionFlag.COPY)) {
      this.appConfig.viewerContainer.classList.add(ENABLE_PERMISSIONS_CLASS);
    }
  },

  _initializeAnnotationStorageCallbacks(pdfDocument) {
    if (pdfDocument !== this.pdfDocument) {
      return;
    }

    const {
      annotationStorage
    } = pdfDocument;

    annotationStorage.onSetModified = () => {
      window.addEventListener("beforeunload", beforeUnload);
      this._annotationStorageModified = true;
    };

    annotationStorage.onResetModified = () => {
      window.removeEventListener("beforeunload", beforeUnload);
      delete this._annotationStorageModified;
    };
  },

  setInitialView(storedHash, {
    rotation,
    sidebarView,
    scrollMode,
    spreadMode
  } = {}) {
    const setRotation = angle => {
      if ((0, _ui_utils.isValidRotation)(angle)) {
        this.pdfViewer.pagesRotation = angle;
      }
    };

    const setViewerModes = (scroll, spread) => {
      if ((0, _ui_utils.isValidScrollMode)(scroll)) {
        this.pdfViewer.scrollMode = scroll;
      }

      if ((0, _ui_utils.isValidSpreadMode)(spread)) {
        this.pdfViewer.spreadMode = spread;
      }
    };

    this.isInitialViewSet = true;
    this.pdfSidebar.setInitialView(sidebarView);
    setViewerModes(scrollMode, spreadMode);

    if (this.initialBookmark) {
      setRotation(this.initialRotation);
      delete this.initialRotation;
      this.pdfLinkService.setHash(this.initialBookmark);
      this.initialBookmark = null;
    } else if (storedHash) {
      setRotation(rotation);
      this.pdfLinkService.setHash(storedHash);
    }

    this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel);
    this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);

    if (!this.pdfViewer.currentScaleValue) {
      this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
    }
  },

  _cleanup() {
    if (!this.pdfDocument) {
      return;
    }

    this.pdfViewer.cleanup();
    this.pdfThumbnailViewer.cleanup();
    this.pdfDocument.cleanup(this.pdfViewer.renderer === _ui_utils.RendererType.SVG);
  },

  forceRendering() {
    this.pdfRenderingQueue.printing = !!this.printService;
    this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;
    this.pdfRenderingQueue.renderHighestPriority();
  },

  beforePrint() {
    this.pdfScriptingManager.dispatchWillPrint();

    if (this.printService) {
      return;
    }

    if (!this.supportsPrinting) {
      this.l10n.get("printing_not_supported").then(msg => {
        this._otherError(msg);
      });
      return;
    }

    if (!this.pdfViewer.pageViewsReady) {
      this.l10n.get("printing_not_ready").then(msg => {
        window.alert(msg);
      });
      return;
    }

    const pagesOverview = this.pdfViewer.getPagesOverview();
    const printContainer = this.appConfig.printContainer;

    const printResolution = _app_options.AppOptions.get("printResolution");

    const optionalContentConfigPromise = this.pdfViewer.optionalContentConfigPromise;
    const printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, this.l10n);
    this.printService = printService;
    this.forceRendering();
    printService.layout();
    this.externalServices.reportTelemetry({
      type: "print"
    });
  },

  afterPrint() {
    this.pdfScriptingManager.dispatchDidPrint();

    if (this.printService) {
      this.printService.destroy();
      this.printService = null;

      if (this.pdfDocument) {
        this.pdfDocument.annotationStorage.resetModified();
      }
    }

    this.forceRendering();
  },

  rotatePages(delta) {
    this.pdfViewer.pagesRotation += delta;
  },

  requestPresentationMode() {
    if (!this.pdfPresentationMode) {
      return;
    }

    this.pdfPresentationMode.request();
  },

  triggerPrinting() {
    if (!this.supportsPrinting) {
      return;
    }

    window.print();
  },

  bindEvents() {
    const {
      eventBus,
      _boundEvents
    } = this;
    _boundEvents.beforePrint = this.beforePrint.bind(this);
    _boundEvents.afterPrint = this.afterPrint.bind(this);

    eventBus._on("resize", webViewerResize);

    eventBus._on("hashchange", webViewerHashchange);

    eventBus._on("beforeprint", _boundEvents.beforePrint);

    eventBus._on("afterprint", _boundEvents.afterPrint);

    eventBus._on("pagerendered", webViewerPageRendered);

    eventBus._on("updateviewarea", webViewerUpdateViewarea);

    eventBus._on("pagechanging", webViewerPageChanging);

    eventBus._on("scalechanging", webViewerScaleChanging);

    eventBus._on("rotationchanging", webViewerRotationChanging);

    eventBus._on("sidebarviewchanged", webViewerSidebarViewChanged);

    eventBus._on("pagemode", webViewerPageMode);

    eventBus._on("namedaction", webViewerNamedAction);

    eventBus._on("presentationmodechanged", webViewerPresentationModeChanged);

    eventBus._on("presentationmode", webViewerPresentationMode);

    eventBus._on("print", webViewerPrint);

    eventBus._on("download", webViewerDownload);

    eventBus._on("save", webViewerSave);

    eventBus._on("firstpage", webViewerFirstPage);

    eventBus._on("lastpage", webViewerLastPage);

    eventBus._on("nextpage", webViewerNextPage);

    eventBus._on("previouspage", webViewerPreviousPage);

    eventBus._on("zoomin", webViewerZoomIn);

    eventBus._on("zoomout", webViewerZoomOut);

    eventBus._on("zoomreset", webViewerZoomReset);

    eventBus._on("pagenumberchanged", webViewerPageNumberChanged);

    eventBus._on("scalechanged", webViewerScaleChanged);

    eventBus._on("rotatecw", webViewerRotateCw);

    eventBus._on("rotateccw", webViewerRotateCcw);

    eventBus._on("optionalcontentconfig", webViewerOptionalContentConfig);

    eventBus._on("switchscrollmode", webViewerSwitchScrollMode);

    eventBus._on("scrollmodechanged", webViewerScrollModeChanged);

    eventBus._on("switchspreadmode", webViewerSwitchSpreadMode);

    eventBus._on("spreadmodechanged", webViewerSpreadModeChanged);

    eventBus._on("documentproperties", webViewerDocumentProperties);

    eventBus._on("find", webViewerFind);

    eventBus._on("findfromurlhash", webViewerFindFromUrlHash);

    eventBus._on("updatefindmatchescount", webViewerUpdateFindMatchesCount);

    eventBus._on("updatefindcontrolstate", webViewerUpdateFindControlState);

    if (_app_options.AppOptions.get("pdfBug")) {
      _boundEvents.reportPageStatsPDFBug = reportPageStatsPDFBug;

      eventBus._on("pagerendered", _boundEvents.reportPageStatsPDFBug);

      eventBus._on("pagechanging", _boundEvents.reportPageStatsPDFBug);
    }

    eventBus._on("fileinputchange", webViewerFileInputChange);

    eventBus._on("openfile", webViewerOpenFile);
  },

  bindWindowEvents() {
    const {
      eventBus,
      _boundEvents
    } = this;

    _boundEvents.windowResize = () => {
      eventBus.dispatch("resize", {
        source: window
      });
    };

    _boundEvents.windowHashChange = () => {
      eventBus.dispatch("hashchange", {
        source: window,
        hash: document.location.hash.substring(1)
      });
    };

    _boundEvents.windowBeforePrint = () => {
      eventBus.dispatch("beforeprint", {
        source: window
      });
    };

    _boundEvents.windowAfterPrint = () => {
      eventBus.dispatch("afterprint", {
        source: window
      });
    };

    _boundEvents.windowUpdateFromSandbox = event => {
      eventBus.dispatch("updatefromsandbox", {
        source: window,
        detail: event.detail
      });
    };

    window.addEventListener("visibilitychange", webViewerVisibilityChange);
    window.addEventListener("wheel", webViewerWheel, {
      passive: false
    });
    window.addEventListener("touchstart", webViewerTouchStart, {
      passive: false
    });
    window.addEventListener("click", webViewerClick);
    window.addEventListener("keydown", webViewerKeyDown);
    window.addEventListener("resize", _boundEvents.windowResize);
    window.addEventListener("hashchange", _boundEvents.windowHashChange);
    window.addEventListener("beforeprint", _boundEvents.windowBeforePrint);
    window.addEventListener("afterprint", _boundEvents.windowAfterPrint);
    window.addEventListener("updatefromsandbox", _boundEvents.windowUpdateFromSandbox);
  },

  unbindEvents() {
    const {
      eventBus,
      _boundEvents
    } = this;

    eventBus._off("resize", webViewerResize);

    eventBus._off("hashchange", webViewerHashchange);

    eventBus._off("beforeprint", _boundEvents.beforePrint);

    eventBus._off("afterprint", _boundEvents.afterPrint);

    eventBus._off("pagerendered", webViewerPageRendered);

    eventBus._off("updateviewarea", webViewerUpdateViewarea);

    eventBus._off("pagechanging", webViewerPageChanging);

    eventBus._off("scalechanging", webViewerScaleChanging);

    eventBus._off("rotationchanging", webViewerRotationChanging);

    eventBus._off("sidebarviewchanged", webViewerSidebarViewChanged);

    eventBus._off("pagemode", webViewerPageMode);

    eventBus._off("namedaction", webViewerNamedAction);

    eventBus._off("presentationmodechanged", webViewerPresentationModeChanged);

    eventBus._off("presentationmode", webViewerPresentationMode);

    eventBus._off("print", webViewerPrint);

    eventBus._off("download", webViewerDownload);

    eventBus._off("save", webViewerSave);

    eventBus._off("firstpage", webViewerFirstPage);

    eventBus._off("lastpage", webViewerLastPage);

    eventBus._off("nextpage", webViewerNextPage);

    eventBus._off("previouspage", webViewerPreviousPage);

    eventBus._off("zoomin", webViewerZoomIn);

    eventBus._off("zoomout", webViewerZoomOut);

    eventBus._off("zoomreset", webViewerZoomReset);

    eventBus._off("pagenumberchanged", webViewerPageNumberChanged);

    eventBus._off("scalechanged", webViewerScaleChanged);

    eventBus._off("rotatecw", webViewerRotateCw);

    eventBus._off("rotateccw", webViewerRotateCcw);

    eventBus._off("optionalcontentconfig", webViewerOptionalContentConfig);

    eventBus._off("switchscrollmode", webViewerSwitchScrollMode);

    eventBus._off("scrollmodechanged", webViewerScrollModeChanged);

    eventBus._off("switchspreadmode", webViewerSwitchSpreadMode);

    eventBus._off("spreadmodechanged", webViewerSpreadModeChanged);

    eventBus._off("documentproperties", webViewerDocumentProperties);

    eventBus._off("find", webViewerFind);

    eventBus._off("findfromurlhash", webViewerFindFromUrlHash);

    eventBus._off("updatefindmatchescount", webViewerUpdateFindMatchesCount);

    eventBus._off("updatefindcontrolstate", webViewerUpdateFindControlState);

    if (_boundEvents.reportPageStatsPDFBug) {
      eventBus._off("pagerendered", _boundEvents.reportPageStatsPDFBug);

      eventBus._off("pagechanging", _boundEvents.reportPageStatsPDFBug);

      _boundEvents.reportPageStatsPDFBug = null;
    }

    eventBus._off("fileinputchange", webViewerFileInputChange);

    eventBus._off("openfile", webViewerOpenFile);

    _boundEvents.beforePrint = null;
    _boundEvents.afterPrint = null;
  },

  unbindWindowEvents() {
    const {
      _boundEvents
    } = this;
    window.removeEventListener("visibilitychange", webViewerVisibilityChange);
    window.removeEventListener("wheel", webViewerWheel, {
      passive: false
    });
    window.removeEventListener("touchstart", webViewerTouchStart, {
      passive: false
    });
    window.removeEventListener("click", webViewerClick);
    window.removeEventListener("keydown", webViewerKeyDown);
    window.removeEventListener("resize", _boundEvents.windowResize);
    window.removeEventListener("hashchange", _boundEvents.windowHashChange);
    window.removeEventListener("beforeprint", _boundEvents.windowBeforePrint);
    window.removeEventListener("afterprint", _boundEvents.windowAfterPrint);
    window.removeEventListener("updatefromsandbox", _boundEvents.windowUpdateFromSandbox);
    _boundEvents.windowResize = null;
    _boundEvents.windowHashChange = null;
    _boundEvents.windowBeforePrint = null;
    _boundEvents.windowAfterPrint = null;
    _boundEvents.windowUpdateFromSandbox = null;
  },

  accumulateWheelTicks(ticks) {
    if (this._wheelUnusedTicks > 0 && ticks < 0 || this._wheelUnusedTicks < 0 && ticks > 0) {
      this._wheelUnusedTicks = 0;
    }

    this._wheelUnusedTicks += ticks;
    const wholeTicks = Math.sign(this._wheelUnusedTicks) * Math.floor(Math.abs(this._wheelUnusedTicks));
    this._wheelUnusedTicks -= wholeTicks;
    return wholeTicks;
  },

  _unblockDocumentLoadEvent() {
    if (document.blockUnblockOnload) {
      document.blockUnblockOnload(false);
    }

    this._unblockDocumentLoadEvent = () => {};
  },

  get scriptingReady() {
    return this.pdfScriptingManager.ready;
  }

};
exports.PDFViewerApplication = PDFViewerApplication;
let validateFileURL;
{
  const HOSTED_VIEWER_ORIGINS = ["null", "http://mozilla.github.io", "https://mozilla.github.io"];

  validateFileURL = function (file) {
    if (file === undefined) {
      return;
    }

    try {
      const viewerOrigin = new URL(window.location.href).origin || "null";

      if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) {
        return;
      }

      const {
        origin,
        protocol
      } = new URL(file, window.location.href);

      if (origin !== viewerOrigin && protocol !== "blob:") {
        throw new Error("file origin does not match viewer's");
      }
    } catch (ex) {
      PDFViewerApplication.l10n.get("loading_error").then(msg => {
        PDFViewerApplication._documentError(msg, {
          message: ex?.message
        });
      });
      throw ex;
    }
  };
}

async function loadFakeWorker() {
  if (!_pdfjsLib.GlobalWorkerOptions.workerSrc) {
    _pdfjsLib.GlobalWorkerOptions.workerSrc = _app_options.AppOptions.get("workerSrc");
  }

  return (0, _pdfjsLib.loadScript)(_pdfjsLib.PDFWorker.getWorkerSrc());
}

function loadAndEnablePDFBug(enabledTabs) {
  const appConfig = PDFViewerApplication.appConfig;
  return (0, _pdfjsLib.loadScript)(appConfig.debuggerScriptPath).then(function () {
    PDFBug.enable(enabledTabs);
    PDFBug.init({
      OPS: _pdfjsLib.OPS
    }, appConfig.mainContainer);
  });
}

function reportPageStatsPDFBug({
  pageNumber
}) {
  if (typeof Stats === "undefined" || !Stats.enabled) {
    return;
  }

  const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1);
  const pageStats = pageView?.pdfPage?.stats;

  if (!pageStats) {
    return;
  }

  Stats.add(pageNumber, pageStats);
}

function webViewerInitialized() {
  const appConfig = PDFViewerApplication.appConfig;
  let file;
  const queryString = document.location.search.substring(1);
  const params = (0, _ui_utils.parseQueryString)(queryString);
  file = "file" in params ? params.file : _app_options.AppOptions.get("defaultUrl");
  validateFileURL(file);
  const fileInput = document.createElement("input");
  fileInput.id = appConfig.openFileInputName;
  fileInput.className = "fileInput";
  fileInput.setAttribute("type", "file");
  fileInput.oncontextmenu = _ui_utils.noContextMenuHandler;
  document.body.appendChild(fileInput);

  if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
    appConfig.toolbar.openFile.hidden = true;
    appConfig.secondaryToolbar.openFileButton.hidden = true;
  } else {
    fileInput.value = null;
  }

  fileInput.addEventListener("change", function (evt) {
    const files = evt.target.files;

    if (!files || files.length === 0) {
      return;
    }

    PDFViewerApplication.eventBus.dispatch("fileinputchange", {
      source: this,
      fileInput: evt.target
    });
  });
  appConfig.mainContainer.addEventListener("dragover", function (evt) {
    evt.preventDefault();
    evt.dataTransfer.dropEffect = "move";
  });
  appConfig.mainContainer.addEventListener("drop", function (evt) {
    evt.preventDefault();
    const files = evt.dataTransfer.files;

    if (!files || files.length === 0) {
      return;
    }

    PDFViewerApplication.eventBus.dispatch("fileinputchange", {
      source: this,
      fileInput: evt.dataTransfer
    });
  });

  if (!PDFViewerApplication.supportsDocumentFonts) {
    _app_options.AppOptions.set("disableFontFace", true);

    PDFViewerApplication.l10n.get("web_fonts_disabled").then(msg => {
      console.warn(msg);
    });
  }

  if (!PDFViewerApplication.supportsPrinting) {
    appConfig.toolbar.print.classList.add("hidden");
    appConfig.secondaryToolbar.printButton.classList.add("hidden");
  }

  if (!PDFViewerApplication.supportsFullscreen) {
    appConfig.toolbar.presentationModeButton.classList.add("hidden");
    appConfig.secondaryToolbar.presentationModeButton.classList.add("hidden");
  }

  if (PDFViewerApplication.supportsIntegratedFind) {
    appConfig.toolbar.viewFind.classList.add("hidden");
  }

  appConfig.mainContainer.addEventListener("transitionend", function (evt) {
    if (evt.target === this) {
      PDFViewerApplication.eventBus.dispatch("resize", {
        source: this
      });
    }
  }, true);

  try {
    webViewerOpenFileViaURL(file);
  } catch (reason) {
    PDFViewerApplication.l10n.get("loading_error").then(msg => {
      PDFViewerApplication._documentError(msg, reason);
    });
  }
}

function webViewerOpenFileViaURL(file) {
  if (file) {
    PDFViewerApplication.open(file);
  }
}

function webViewerResetPermissions() {
  const {
    appConfig
  } = PDFViewerApplication;

  if (!appConfig) {
    return;
  }

  appConfig.viewerContainer.classList.remove(ENABLE_PERMISSIONS_CLASS);
}

function webViewerPageRendered({
  pageNumber,
  timestamp,
  error
}) {
  if (pageNumber === PDFViewerApplication.page) {
    PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);
  }

  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
    const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1);
    const thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageNumber - 1);

    if (pageView && thumbnailView) {
      thumbnailView.setImage(pageView);
    }
  }

  if (error) {
    PDFViewerApplication.l10n.get("rendering_error").then(msg => {
      PDFViewerApplication._otherError(msg, error);
    });
  }

  PDFViewerApplication.externalServices.reportTelemetry({
    type: "pageInfo",
    timestamp
  });
  PDFViewerApplication.pdfDocument.getStats().then(function (stats) {
    PDFViewerApplication.externalServices.reportTelemetry({
      type: "documentStats",
      stats
    });
  });
}

function webViewerPageMode({
  mode
}) {
  let view;

  switch (mode) {
    case "thumbs":
      view = _ui_utils.SidebarView.THUMBS;
      break;

    case "bookmarks":
    case "outline":
      view = _ui_utils.SidebarView.OUTLINE;
      break;

    case "attachments":
      view = _ui_utils.SidebarView.ATTACHMENTS;
      break;

    case "layers":
      view = _ui_utils.SidebarView.LAYERS;
      break;

    case "none":
      view = _ui_utils.SidebarView.NONE;
      break;

    default:
      console.error('Invalid "pagemode" hash parameter: ' + mode);
      return;
  }

  PDFViewerApplication.pdfSidebar.switchView(view, true);
}

function webViewerNamedAction(evt) {
  switch (evt.action) {
    case "GoToPage":
      PDFViewerApplication.appConfig.toolbar.pageNumber.select();
      break;

    case "Find":
      if (!PDFViewerApplication.supportsIntegratedFind) {
        PDFViewerApplication.findBar.toggle();
      }

      break;

    case "Print":
      PDFViewerApplication.triggerPrinting();
      break;

    case "SaveAs":
      webViewerSave();
      break;
  }
}

function webViewerPresentationModeChanged(evt) {
  PDFViewerApplication.pdfViewer.presentationModeState = evt.state;
}

function webViewerSidebarViewChanged(evt) {
  PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;
  const store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.set("sidebarView", evt.view).catch(function () {});
  }
}

function webViewerUpdateViewarea(evt) {
  const location = evt.location,
        store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.setMultiple({
      page: location.pageNumber,
      zoom: location.scale,
      scrollLeft: location.left,
      scrollTop: location.top,
      rotation: location.rotation
    }).catch(function () {});
  }

  const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams);
  PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;
  PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href;
  const currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1);
  const loading = currentPage?.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED;
  PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);
}

function webViewerScrollModeChanged(evt) {
  const store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.set("scrollMode", evt.mode).catch(function () {});
  }
}

function webViewerSpreadModeChanged(evt) {
  const store = PDFViewerApplication.store;

  if (store && PDFViewerApplication.isInitialViewSet) {
    store.set("spreadMode", evt.mode).catch(function () {});
  }
}

function webViewerResize() {
  const {
    pdfDocument,
    pdfViewer
  } = PDFViewerApplication;

  if (!pdfDocument) {
    return;
  }

  const currentScaleValue = pdfViewer.currentScaleValue;

  if (currentScaleValue === "auto" || currentScaleValue === "page-fit" || currentScaleValue === "page-width") {
    pdfViewer.currentScaleValue = currentScaleValue;
  }

  pdfViewer.update();
}

function webViewerHashchange(evt) {
  const hash = evt.hash;

  if (!hash) {
    return;
  }

  if (!PDFViewerApplication.isInitialViewSet) {
    PDFViewerApplication.initialBookmark = hash;
  } else if (!PDFViewerApplication.pdfHistory.popStateInProgress) {
    PDFViewerApplication.pdfLinkService.setHash(hash);
  }
}

let webViewerFileInputChange, webViewerOpenFile;
{
  webViewerFileInputChange = function (evt) {
    if (PDFViewerApplication.pdfViewer?.isInPresentationMode) {
      return;
    }

    const file = evt.fileInput.files[0];

    if (!_viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL) {
      let url = URL.createObjectURL(file);

      if (file.name) {
        url = {
          url,
          originalUrl: file.name
        };
      }

      PDFViewerApplication.open(url);
    } else {
      PDFViewerApplication.setTitleUsingUrl(file.name);
      const fileReader = new FileReader();

      fileReader.onload = function webViewerChangeFileReaderOnload(event) {
        const buffer = event.target.result;
        PDFViewerApplication.open(new Uint8Array(buffer));
      };

      fileReader.readAsArrayBuffer(file);
    }

    const appConfig = PDFViewerApplication.appConfig;
    appConfig.toolbar.viewBookmark.hidden = true;
    appConfig.secondaryToolbar.viewBookmarkButton.hidden = true;
    appConfig.toolbar.download.hidden = true;
    appConfig.secondaryToolbar.downloadButton.hidden = true;
  };

  webViewerOpenFile = function (evt) {
    const openFileInputName = PDFViewerApplication.appConfig.openFileInputName;
    document.getElementById(openFileInputName).click();
  };
}

function webViewerPresentationMode() {
  PDFViewerApplication.requestPresentationMode();
}

function webViewerPrint() {
  PDFViewerApplication.triggerPrinting();
}

function webViewerDownload() {
  PDFViewerApplication.downloadOrSave({
    sourceEventType: "download"
  });
}

function webViewerSave() {
  PDFViewerApplication.downloadOrSave({
    sourceEventType: "save"
  });
}

function webViewerFirstPage() {
  if (PDFViewerApplication.pdfDocument) {
    PDFViewerApplication.page = 1;
  }
}

function webViewerLastPage() {
  if (PDFViewerApplication.pdfDocument) {
    PDFViewerApplication.page = PDFViewerApplication.pagesCount;
  }
}

function webViewerNextPage() {
  PDFViewerApplication.pdfViewer.nextPage();
}

function webViewerPreviousPage() {
  PDFViewerApplication.pdfViewer.previousPage();
}

function webViewerZoomIn() {
  PDFViewerApplication.zoomIn();
}

function webViewerZoomOut() {
  PDFViewerApplication.zoomOut();
}

function webViewerZoomReset() {
  PDFViewerApplication.zoomReset();
}

function webViewerPageNumberChanged(evt) {
  const pdfViewer = PDFViewerApplication.pdfViewer;

  if (evt.value !== "") {
    PDFViewerApplication.pdfLinkService.goToPage(evt.value);
  }

  if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) {
    PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
  }
}

function webViewerScaleChanged(evt) {
  PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;
}

function webViewerRotateCw() {
  PDFViewerApplication.rotatePages(90);
}

function webViewerRotateCcw() {
  PDFViewerApplication.rotatePages(-90);
}

function webViewerOptionalContentConfig(evt) {
  PDFViewerApplication.pdfViewer.optionalContentConfigPromise = evt.promise;
}

function webViewerSwitchScrollMode(evt) {
  PDFViewerApplication.pdfViewer.scrollMode = evt.mode;
}

function webViewerSwitchSpreadMode(evt) {
  PDFViewerApplication.pdfViewer.spreadMode = evt.mode;
}

function webViewerDocumentProperties() {
  PDFViewerApplication.pdfDocumentProperties.open();
}

function webViewerFind(evt) {
  PDFViewerApplication.findController.executeCommand("find" + evt.type, {
    query: evt.query,
    phraseSearch: evt.phraseSearch,
    caseSensitive: evt.caseSensitive,
    entireWord: evt.entireWord,
    highlightAll: evt.highlightAll,
    findPrevious: evt.findPrevious
  });
}

function webViewerFindFromUrlHash(evt) {
  PDFViewerApplication.findController.executeCommand("find", {
    query: evt.query,
    phraseSearch: evt.phraseSearch,
    caseSensitive: false,
    entireWord: false,
    highlightAll: true,
    findPrevious: false
  });
}

function webViewerUpdateFindMatchesCount({
  matchesCount
}) {
  if (PDFViewerApplication.supportsIntegratedFind) {
    PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount);
  } else {
    PDFViewerApplication.findBar.updateResultsCount(matchesCount);
  }
}

function webViewerUpdateFindControlState({
  state,
  previous,
  matchesCount,
  rawQuery
}) {
  if (PDFViewerApplication.supportsIntegratedFind) {
    PDFViewerApplication.externalServices.updateFindControlState({
      result: state,
      findPrevious: previous,
      matchesCount,
      rawQuery
    });
  } else {
    PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount);
  }
}

function webViewerScaleChanging(evt) {
  PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);
  PDFViewerApplication.pdfViewer.update();
}

function webViewerRotationChanging(evt) {
  PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;
  PDFViewerApplication.forceRendering();
  PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;
}

function webViewerPageChanging({
  pageNumber,
  pageLabel
}) {
  PDFViewerApplication.toolbar.setPageNumber(pageNumber, pageLabel);
  PDFViewerApplication.secondaryToolbar.setPageNumber(pageNumber);

  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
    PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(pageNumber);
  }
}

function webViewerVisibilityChange(evt) {
  if (document.visibilityState === "visible") {
    setZoomDisabledTimeout();
  }
}

let zoomDisabledTimeout = null;

function setZoomDisabledTimeout() {
  if (zoomDisabledTimeout) {
    clearTimeout(zoomDisabledTimeout);
  }

  zoomDisabledTimeout = setTimeout(function () {
    zoomDisabledTimeout = null;
  }, WHEEL_ZOOM_DISABLED_TIMEOUT);
}

function webViewerWheel(evt) {
  const {
    pdfViewer,
    supportedMouseWheelZoomModifierKeys
  } = PDFViewerApplication;

  if (pdfViewer.isInPresentationMode) {
    return;
  }

  if (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey) {
    evt.preventDefault();

    if (zoomDisabledTimeout || document.visibilityState === "hidden") {
      return;
    }

    const previousScale = pdfViewer.currentScale;
    const delta = (0, _ui_utils.normalizeWheelEventDirection)(evt);
    let ticks = 0;

    if (evt.deltaMode === WheelEvent.DOM_DELTA_LINE || evt.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
      if (Math.abs(delta) >= 1) {
        ticks = Math.sign(delta);
      } else {
        ticks = PDFViewerApplication.accumulateWheelTicks(delta);
      }
    } else {
      const PIXELS_PER_LINE_SCALE = 30;
      ticks = PDFViewerApplication.accumulateWheelTicks(delta / PIXELS_PER_LINE_SCALE);
    }

    if (ticks < 0) {
      PDFViewerApplication.zoomOut(-ticks);
    } else if (ticks > 0) {
      PDFViewerApplication.zoomIn(ticks);
    }

    const currentScale = pdfViewer.currentScale;

    if (previousScale !== currentScale) {
      const scaleCorrectionFactor = currentScale / previousScale - 1;
      const rect = pdfViewer.container.getBoundingClientRect();
      const dx = evt.clientX - rect.left;
      const dy = evt.clientY - rect.top;
      pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;
      pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;
    }
  } else {
    setZoomDisabledTimeout();
  }
}

function webViewerTouchStart(evt) {
  if (evt.touches.length > 1) {
    evt.preventDefault();
  }
}

function webViewerClick(evt) {
  if (!PDFViewerApplication.secondaryToolbar.isOpen) {
    return;
  }

  const appConfig = PDFViewerApplication.appConfig;

  if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar.toggleButton) {
    PDFViewerApplication.secondaryToolbar.close();
  }
}

function webViewerKeyDown(evt) {
  if (PDFViewerApplication.overlayManager.active) {
    return;
  }

  let handled = false,
      ensureViewerFocused = false;
  const cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0);
  const pdfViewer = PDFViewerApplication.pdfViewer;
  const isViewerInPresentationMode = pdfViewer?.isInPresentationMode;

  if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {
    switch (evt.keyCode) {
      case 70:
        if (!PDFViewerApplication.supportsIntegratedFind && !evt.shiftKey) {
          PDFViewerApplication.findBar.open();
          handled = true;
        }

        break;

      case 71:
        if (!PDFViewerApplication.supportsIntegratedFind) {
          const findState = PDFViewerApplication.findController.state;

          if (findState) {
            PDFViewerApplication.findController.executeCommand("findagain", {
              query: findState.query,
              phraseSearch: findState.phraseSearch,
              caseSensitive: findState.caseSensitive,
              entireWord: findState.entireWord,
              highlightAll: findState.highlightAll,
              findPrevious: cmd === 5 || cmd === 12
            });
          }

          handled = true;
        }

        break;

      case 61:
      case 107:
      case 187:
      case 171:
        if (!isViewerInPresentationMode) {
          PDFViewerApplication.zoomIn();
        }

        handled = true;
        break;

      case 173:
      case 109:
      case 189:
        if (!isViewerInPresentationMode) {
          PDFViewerApplication.zoomOut();
        }

        handled = true;
        break;

      case 48:
      case 96:
        if (!isViewerInPresentationMode) {
          setTimeout(function () {
            PDFViewerApplication.zoomReset();
          });
          handled = false;
        }

        break;

      case 38:
        if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
          PDFViewerApplication.page = 1;
          handled = true;
          ensureViewerFocused = true;
        }

        break;

      case 40:
        if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
          PDFViewerApplication.page = PDFViewerApplication.pagesCount;
          handled = true;
          ensureViewerFocused = true;
        }

        break;
    }
  }

  const {
    eventBus
  } = PDFViewerApplication;

  if (cmd === 1 || cmd === 8) {
    switch (evt.keyCode) {
      case 83:
        eventBus.dispatch("download", {
          source: window
        });
        handled = true;
        break;

      case 79:
        {
          eventBus.dispatch("openfile", {
            source: window
          });
          handled = true;
        }
        break;
    }
  }

  if (cmd === 3 || cmd === 10) {
    switch (evt.keyCode) {
      case 80:
        PDFViewerApplication.requestPresentationMode();
        handled = true;
        break;

      case 71:
        PDFViewerApplication.appConfig.toolbar.pageNumber.select();
        handled = true;
        break;
    }
  }

  if (handled) {
    if (ensureViewerFocused && !isViewerInPresentationMode) {
      pdfViewer.focus();
    }

    evt.preventDefault();
    return;
  }

  const curElement = (0, _ui_utils.getActiveOrFocusedElement)();
  const curElementTagName = curElement?.tagName.toUpperCase();

  if (curElementTagName === "INPUT" || curElementTagName === "TEXTAREA" || curElementTagName === "SELECT" || curElement?.isContentEditable) {
    if (evt.keyCode !== 27) {
      return;
    }
  }

  if (cmd === 0) {
    let turnPage = 0,
        turnOnlyIfPageFit = false;

    switch (evt.keyCode) {
      case 38:
      case 33:
        if (pdfViewer.isVerticalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

        turnPage = -1;
        break;

      case 8:
        if (!isViewerInPresentationMode) {
          turnOnlyIfPageFit = true;
        }

        turnPage = -1;
        break;

      case 37:
        if (pdfViewer.isHorizontalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

      case 75:
      case 80:
        turnPage = -1;
        break;

      case 27:
        if (PDFViewerApplication.secondaryToolbar.isOpen) {
          PDFViewerApplication.secondaryToolbar.close();
          handled = true;
        }

        if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened) {
          PDFViewerApplication.findBar.close();
          handled = true;
        }

        break;

      case 40:
      case 34:
        if (pdfViewer.isVerticalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

        turnPage = 1;
        break;

      case 13:
      case 32:
        if (!isViewerInPresentationMode) {
          turnOnlyIfPageFit = true;
        }

        turnPage = 1;
        break;

      case 39:
        if (pdfViewer.isHorizontalScrollbarEnabled) {
          turnOnlyIfPageFit = true;
        }

      case 74:
      case 78:
        turnPage = 1;
        break;

      case 36:
        if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
          PDFViewerApplication.page = 1;
          handled = true;
          ensureViewerFocused = true;
        }

        break;

      case 35:
        if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
          PDFViewerApplication.page = PDFViewerApplication.pagesCount;
          handled = true;
          ensureViewerFocused = true;
        }

        break;

      case 83:
        PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.SELECT);
        break;

      case 72:
        PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.HAND);
        break;

      case 82:
        PDFViewerApplication.rotatePages(90);
        break;

      case 115:
        PDFViewerApplication.pdfSidebar.toggle();
        break;
    }

    if (turnPage !== 0 && (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === "page-fit")) {
      if (turnPage > 0) {
        pdfViewer.nextPage();
      } else {
        pdfViewer.previousPage();
      }

      handled = true;
    }
  }

  if (cmd === 4) {
    switch (evt.keyCode) {
      case 13:
      case 32:
        if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== "page-fit") {
          break;
        }

        if (PDFViewerApplication.page > 1) {
          PDFViewerApplication.page--;
        }

        handled = true;
        break;

      case 82:
        PDFViewerApplication.rotatePages(-90);
        break;
    }
  }

  if (!handled && !isViewerInPresentationMode) {
    if (evt.keyCode >= 33 && evt.keyCode <= 40 || evt.keyCode === 32 && curElementTagName !== "BUTTON") {
      ensureViewerFocused = true;
    }
  }

  if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {
    pdfViewer.focus();
  }

  if (handled) {
    evt.preventDefault();
  }
}

function beforeUnload(evt) {
  evt.preventDefault();
  evt.returnValue = "";
  return false;
}

const PDFPrintServiceFactory = {
  instance: {
    supportsPrinting: false,

    createPrintService() {
      throw new Error("Not implemented: createPrintService");
    }

  }
};
exports.PDFPrintServiceFactory = PDFPrintServiceFactory;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.apiPageLayoutToSpreadMode = apiPageLayoutToSpreadMode;
exports.apiPageModeToSidebarView = apiPageModeToSidebarView;
exports.approximateFraction = approximateFraction;
exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
exports.binarySearchFirstItem = binarySearchFirstItem;
exports.getActiveOrFocusedElement = getActiveOrFocusedElement;
exports.getOutputScale = getOutputScale;
exports.getPageSizeInches = getPageSizeInches;
exports.getVisibleElements = getVisibleElements;
exports.isPortraitOrientation = isPortraitOrientation;
exports.isValidRotation = isValidRotation;
exports.isValidScrollMode = isValidScrollMode;
exports.isValidSpreadMode = isValidSpreadMode;
exports.moveToEndOfArray = moveToEndOfArray;
exports.noContextMenuHandler = noContextMenuHandler;
exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
exports.normalizeWheelEventDirection = normalizeWheelEventDirection;
exports.parseQueryString = parseQueryString;
exports.roundToDivide = roundToDivide;
exports.scrollIntoView = scrollIntoView;
exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
exports.watchScroll = watchScroll;
exports.WaitOnType = exports.VERTICAL_PADDING = exports.UNKNOWN_SCALE = exports.TextLayerMode = exports.SpreadMode = exports.SidebarView = exports.ScrollMode = exports.SCROLLBAR_PADDING = exports.RendererType = exports.ProgressBar = exports.PresentationModeState = exports.MIN_SCALE = exports.MAX_SCALE = exports.MAX_AUTO_SCALE = exports.EventBus = exports.DEFAULT_SCALE_VALUE = exports.DEFAULT_SCALE = exports.CSS_UNITS = exports.AutoPrintRegExp = exports.animationStarted = void 0;
const CSS_UNITS = 96.0 / 72.0;
exports.CSS_UNITS = CSS_UNITS;
const DEFAULT_SCALE_VALUE = "auto";
exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
const DEFAULT_SCALE = 1.0;
exports.DEFAULT_SCALE = DEFAULT_SCALE;
const MIN_SCALE = 0.1;
exports.MIN_SCALE = MIN_SCALE;
const MAX_SCALE = 10.0;
exports.MAX_SCALE = MAX_SCALE;
const UNKNOWN_SCALE = 0;
exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
const MAX_AUTO_SCALE = 1.25;
exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
const SCROLLBAR_PADDING = 40;
exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
const VERTICAL_PADDING = 5;
exports.VERTICAL_PADDING = VERTICAL_PADDING;
const LOADINGBAR_END_OFFSET_VAR = "--loadingBar-end-offset";
const PresentationModeState = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
};
exports.PresentationModeState = PresentationModeState;
const SidebarView = {
  UNKNOWN: -1,
  NONE: 0,
  THUMBS: 1,
  OUTLINE: 2,
  ATTACHMENTS: 3,
  LAYERS: 4
};
exports.SidebarView = SidebarView;
const RendererType = {
  CANVAS: "canvas",
  SVG: "svg"
};
exports.RendererType = RendererType;
const TextLayerMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_ENHANCE: 2
};
exports.TextLayerMode = TextLayerMode;
const ScrollMode = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2
};
exports.ScrollMode = ScrollMode;
const SpreadMode = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
exports.SpreadMode = SpreadMode;
const AutoPrintRegExp = /\bprint\s*\(/;
exports.AutoPrintRegExp = AutoPrintRegExp;

function getOutputScale(ctx) {
  const devicePixelRatio = window.devicePixelRatio || 1;
  const backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
  const pixelRatio = devicePixelRatio / backingStoreRatio;
  return {
    sx: pixelRatio,
    sy: pixelRatio,
    scaled: pixelRatio !== 1
  };
}

function scrollIntoView(element, spot, skipOverflowHiddenElements = false) {
  let parent = element.offsetParent;

  if (!parent) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }

  let offsetY = element.offsetTop + element.clientTop;
  let offsetX = element.offsetLeft + element.clientLeft;

  while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === "hidden") {
    if (parent.dataset._scaleY) {
      offsetY /= parent.dataset._scaleY;
      offsetX /= parent.dataset._scaleX;
    }

    offsetY += parent.offsetTop;
    offsetX += parent.offsetLeft;
    parent = parent.offsetParent;

    if (!parent) {
      return;
    }
  }

  if (spot) {
    if (spot.top !== undefined) {
      offsetY += spot.top;
    }

    if (spot.left !== undefined) {
      offsetX += spot.left;
      parent.scrollLeft = offsetX;
    }
  }

  parent.scrollTop = offsetY;
}

function watchScroll(viewAreaElement, callback) {
  const debounceScroll = function (evt) {
    if (rAF) {
      return;
    }

    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
      rAF = null;
      const currentX = viewAreaElement.scrollLeft;
      const lastX = state.lastX;

      if (currentX !== lastX) {
        state.right = currentX > lastX;
      }

      state.lastX = currentX;
      const currentY = viewAreaElement.scrollTop;
      const lastY = state.lastY;

      if (currentY !== lastY) {
        state.down = currentY > lastY;
      }

      state.lastY = currentY;
      callback(state);
    });
  };

  const state = {
    right: true,
    down: true,
    lastX: viewAreaElement.scrollLeft,
    lastY: viewAreaElement.scrollTop,
    _eventHandler: debounceScroll
  };
  let rAF = null;
  viewAreaElement.addEventListener("scroll", debounceScroll, true);
  return state;
}

function parseQueryString(query) {
  const parts = query.split("&");
  const params = Object.create(null);

  for (let i = 0, ii = parts.length; i < ii; ++i) {
    const param = parts[i].split("=");
    const key = param[0].toLowerCase();
    const value = param.length > 1 ? param[1] : null;
    params[decodeURIComponent(key)] = decodeURIComponent(value);
  }

  return params;
}

function binarySearchFirstItem(items, condition) {
  let minIndex = 0;
  let maxIndex = items.length - 1;

  if (maxIndex < 0 || !condition(items[maxIndex])) {
    return items.length;
  }

  if (condition(items[minIndex])) {
    return minIndex;
  }

  while (minIndex < maxIndex) {
    const currentIndex = minIndex + maxIndex >> 1;
    const currentItem = items[currentIndex];

    if (condition(currentItem)) {
      maxIndex = currentIndex;
    } else {
      minIndex = currentIndex + 1;
    }
  }

  return minIndex;
}

function approximateFraction(x) {
  if (Math.floor(x) === x) {
    return [x, 1];
  }

  const xinv = 1 / x;
  const limit = 8;

  if (xinv > limit) {
    return [1, limit];
  } else if (Math.floor(xinv) === xinv) {
    return [1, xinv];
  }

  const x_ = x > 1 ? xinv : x;
  let a = 0,
      b = 1,
      c = 1,
      d = 1;

  while (true) {
    const p = a + c,
          q = b + d;

    if (q > limit) {
      break;
    }

    if (x_ <= p / q) {
      c = p;
      d = q;
    } else {
      a = p;
      b = q;
    }
  }

  let result;

  if (x_ - a / b < c / d - x_) {
    result = x_ === x ? [a, b] : [b, a];
  } else {
    result = x_ === x ? [c, d] : [d, c];
  }

  return result;
}

function roundToDivide(x, div) {
  const r = x % div;
  return r === 0 ? x : Math.round(x - r + div);
}

function getPageSizeInches({
  view,
  userUnit,
  rotate
}) {
  const [x1, y1, x2, y2] = view;
  const changeOrientation = rotate % 180 !== 0;
  const width = (x2 - x1) / 72 * userUnit;
  const height = (y2 - y1) / 72 * userUnit;
  return {
    width: changeOrientation ? height : width,
    height: changeOrientation ? width : height
  };
}

function backtrackBeforeAllVisibleElements(index, views, top) {
  if (index < 2) {
    return index;
  }

  let elt = views[index].div;
  let pageTop = elt.offsetTop + elt.clientTop;

  if (pageTop >= top) {
    elt = views[index - 1].div;
    pageTop = elt.offsetTop + elt.clientTop;
  }

  for (let i = index - 2; i >= 0; --i) {
    elt = views[i].div;

    if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
      break;
    }

    index = i;
  }

  return index;
}

function getVisibleElements({
  scrollEl,
  views,
  sortByVisibility = false,
  horizontal = false,
  rtl = false
}) {
  const top = scrollEl.scrollTop,
        bottom = top + scrollEl.clientHeight;
  const left = scrollEl.scrollLeft,
        right = left + scrollEl.clientWidth;

  function isElementBottomAfterViewTop(view) {
    const element = view.div;
    const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
    return elementBottom > top;
  }

  function isElementNextAfterViewHorizontally(view) {
    const element = view.div;
    const elementLeft = element.offsetLeft + element.clientLeft;
    const elementRight = elementLeft + element.clientWidth;
    return rtl ? elementLeft < right : elementRight > left;
  }

  const visible = [],
        numViews = views.length;
  let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);

  if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
    firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
  }

  let lastEdge = horizontal ? right : -1;

  for (let i = firstVisibleElementInd; i < numViews; i++) {
    const view = views[i],
          element = view.div;
    const currentWidth = element.offsetLeft + element.clientLeft;
    const currentHeight = element.offsetTop + element.clientTop;
    const viewWidth = element.clientWidth,
          viewHeight = element.clientHeight;
    const viewRight = currentWidth + viewWidth;
    const viewBottom = currentHeight + viewHeight;

    if (lastEdge === -1) {
      if (viewBottom >= bottom) {
        lastEdge = viewBottom;
      }
    } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
      break;
    }

    if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
      continue;
    }

    const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
    const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
    const fractionHeight = (viewHeight - hiddenHeight) / viewHeight,
          fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
    const percent = fractionHeight * fractionWidth * 100 | 0;
    visible.push({
      id: view.id,
      x: currentWidth,
      y: currentHeight,
      view,
      percent,
      widthPercent: fractionWidth * 100 | 0
    });
  }

  const first = visible[0],
        last = visible[visible.length - 1];

  if (sortByVisibility) {
    visible.sort(function (a, b) {
      const pc = a.percent - b.percent;

      if (Math.abs(pc) > 0.001) {
        return -pc;
      }

      return a.id - b.id;
    });
  }

  return {
    first,
    last,
    views: visible
  };
}

function noContextMenuHandler(evt) {
  evt.preventDefault();
}

function normalizeWheelEventDirection(evt) {
  let delta = Math.hypot(evt.deltaX, evt.deltaY);
  const angle = Math.atan2(evt.deltaY, evt.deltaX);

  if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
    delta = -delta;
  }

  return delta;
}

function normalizeWheelEventDelta(evt) {
  let delta = normalizeWheelEventDirection(evt);
  const MOUSE_DOM_DELTA_PIXEL_MODE = 0;
  const MOUSE_DOM_DELTA_LINE_MODE = 1;
  const MOUSE_PIXELS_PER_LINE = 30;
  const MOUSE_LINES_PER_PAGE = 30;

  if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
    delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
  } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
    delta /= MOUSE_LINES_PER_PAGE;
  }

  return delta;
}

function isValidRotation(angle) {
  return Number.isInteger(angle) && angle % 90 === 0;
}

function isValidScrollMode(mode) {
  return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
}

function isValidSpreadMode(mode) {
  return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
}

function isPortraitOrientation(size) {
  return size.width <= size.height;
}

const WaitOnType = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
exports.WaitOnType = WaitOnType;

function waitOnEventOrTimeout({
  target,
  name,
  delay = 0
}) {
  return new Promise(function (resolve, reject) {
    if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
      throw new Error("waitOnEventOrTimeout - invalid parameters.");
    }

    function handler(type) {
      if (target instanceof EventBus) {
        target._off(name, eventHandler);
      } else {
        target.removeEventListener(name, eventHandler);
      }

      if (timeout) {
        clearTimeout(timeout);
      }

      resolve(type);
    }

    const eventHandler = handler.bind(null, WaitOnType.EVENT);

    if (target instanceof EventBus) {
      target._on(name, eventHandler);
    } else {
      target.addEventListener(name, eventHandler);
    }

    const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
    const timeout = setTimeout(timeoutHandler, delay);
  });
}

const animationStarted = new Promise(function (resolve) {
  window.requestAnimationFrame(resolve);
});
exports.animationStarted = animationStarted;

function dispatchDOMEvent(eventName, args = null) {
  throw new Error("Not implemented: dispatchDOMEvent");
}

class EventBus {
  constructor(options) {
    this._listeners = Object.create(null);
  }

  on(eventName, listener, options = null) {
    this._on(eventName, listener, {
      external: true,
      once: options?.once
    });
  }

  off(eventName, listener, options = null) {
    this._off(eventName, listener, {
      external: true,
      once: options?.once
    });
  }

  dispatch(eventName) {
    const eventListeners = this._listeners[eventName];

    if (!eventListeners || eventListeners.length === 0) {
      return;
    }

    const args = Array.prototype.slice.call(arguments, 1);
    let externalListeners;

    for (const {
      listener,
      external,
      once
    } of eventListeners.slice(0)) {
      if (once) {
        this._off(eventName, listener);
      }

      if (external) {
        (externalListeners || (externalListeners = [])).push(listener);
        continue;
      }

      listener.apply(null, args);
    }

    if (externalListeners) {
      for (const listener of externalListeners) {
        listener.apply(null, args);
      }

      externalListeners = null;
    }
  }

  _on(eventName, listener, options = null) {
    var _this$_listeners;

    const eventListeners = (_this$_listeners = this._listeners)[eventName] || (_this$_listeners[eventName] = []);
    eventListeners.push({
      listener,
      external: options?.external === true,
      once: options?.once === true
    });
  }

  _off(eventName, listener, options = null) {
    const eventListeners = this._listeners[eventName];

    if (!eventListeners) {
      return;
    }

    for (let i = 0, ii = eventListeners.length; i < ii; i++) {
      if (eventListeners[i].listener === listener) {
        eventListeners.splice(i, 1);
        return;
      }
    }
  }

}

exports.EventBus = EventBus;

function clamp(v, min, max) {
  return Math.min(Math.max(v, min), max);
}

class ProgressBar {
  constructor(id, {
    height,
    width,
    units
  } = {}) {
    this.visible = true;
    this.div = document.querySelector(id + " .progress");
    this.bar = this.div.parentNode;
    this.height = height || 100;
    this.width = width || 100;
    this.units = units || "%";
    this.div.style.height = this.height + this.units;
    this.percent = 0;
  }

  _updateBar() {
    if (this._indeterminate) {
      this.div.classList.add("indeterminate");
      this.div.style.width = this.width + this.units;
      return;
    }

    this.div.classList.remove("indeterminate");
    const progressSize = this.width * this._percent / 100;
    this.div.style.width = progressSize + this.units;
  }

  get percent() {
    return this._percent;
  }

  set percent(val) {
    this._indeterminate = isNaN(val);
    this._percent = clamp(val, 0, 100);

    this._updateBar();
  }

  setWidth(viewer) {
    if (!viewer) {
      return;
    }

    const container = viewer.parentNode;
    const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;

    if (scrollbarWidth > 0) {
      const doc = document.documentElement;
      doc.style.setProperty(LOADINGBAR_END_OFFSET_VAR, `${scrollbarWidth}px`);
    }
  }

  hide() {
    if (!this.visible) {
      return;
    }

    this.visible = false;
    this.bar.classList.add("hidden");
  }

  show() {
    if (this.visible) {
      return;
    }

    this.visible = true;
    this.bar.classList.remove("hidden");
  }

}

exports.ProgressBar = ProgressBar;

function moveToEndOfArray(arr, condition) {
  const moved = [],
        len = arr.length;
  let write = 0;

  for (let read = 0; read < len; ++read) {
    if (condition(arr[read])) {
      moved.push(arr[read]);
    } else {
      arr[write] = arr[read];
      ++write;
    }
  }

  for (let read = 0; write < len; ++read, ++write) {
    arr[write] = moved[read];
  }
}

function getActiveOrFocusedElement() {
  let curRoot = document;
  let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");

  while (curActiveOrFocused?.shadowRoot) {
    curRoot = curActiveOrFocused.shadowRoot;
    curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
  }

  return curActiveOrFocused;
}

function apiPageLayoutToSpreadMode(layout) {
  switch (layout) {
    case "SinglePage":
    case "OneColumn":
      return SpreadMode.NONE;

    case "TwoColumnLeft":
    case "TwoPageLeft":
      return SpreadMode.ODD;

    case "TwoColumnRight":
    case "TwoPageRight":
      return SpreadMode.EVEN;
  }

  return SpreadMode.NONE;
}

function apiPageModeToSidebarView(mode) {
  switch (mode) {
    case "UseNone":
      return SidebarView.NONE;

    case "UseThumbs":
      return SidebarView.THUMBS;

    case "UseOutlines":
      return SidebarView.OUTLINE;

    case "UseAttachments":
      return SidebarView.ATTACHMENTS;

    case "UseOC":
      return SidebarView.LAYERS;
  }

  return SidebarView.NONE;
}

/***/ }),
/* 5 */
/***/ ((module) => {



let pdfjsLib;

if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) {
  pdfjsLib = window["pdfjs-dist/build/pdf"];
} else {
  pdfjsLib = require("../build/pdf.js");
}

module.exports = pdfjsLib;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFCursorTools = exports.CursorTool = void 0;

var _grab_to_pan = __webpack_require__(7);

var _ui_utils = __webpack_require__(4);

const CursorTool = {
  SELECT: 0,
  HAND: 1,
  ZOOM: 2
};
exports.CursorTool = CursorTool;

class PDFCursorTools {
  constructor({
    container,
    eventBus,
    cursorToolOnLoad = CursorTool.SELECT
  }) {
    this.container = container;
    this.eventBus = eventBus;
    this.active = CursorTool.SELECT;
    this.activeBeforePresentationMode = null;
    this.handTool = new _grab_to_pan.GrabToPan({
      element: this.container
    });

    this._addEventListeners();

    Promise.resolve().then(() => {
      this.switchTool(cursorToolOnLoad);
    });
  }

  get activeTool() {
    return this.active;
  }

  switchTool(tool) {
    if (this.activeBeforePresentationMode !== null) {
      return;
    }

    if (tool === this.active) {
      return;
    }

    const disableActiveTool = () => {
      switch (this.active) {
        case CursorTool.SELECT:
          break;

        case CursorTool.HAND:
          this.handTool.deactivate();
          break;

        case CursorTool.ZOOM:
      }
    };

    switch (tool) {
      case CursorTool.SELECT:
        disableActiveTool();
        break;

      case CursorTool.HAND:
        disableActiveTool();
        this.handTool.activate();
        break;

      case CursorTool.ZOOM:
      default:
        console.error(`switchTool: "${tool}" is an unsupported value.`);
        return;
    }

    this.active = tool;

    this._dispatchEvent();
  }

  _dispatchEvent() {
    this.eventBus.dispatch("cursortoolchanged", {
      source: this,
      tool: this.active
    });
  }

  _addEventListeners() {
    this.eventBus._on("switchcursortool", evt => {
      this.switchTool(evt.tool);
    });

    this.eventBus._on("presentationmodechanged", evt => {
      switch (evt.state) {
        case _ui_utils.PresentationModeState.FULLSCREEN:
          {
            const previouslyActive = this.active;
            this.switchTool(CursorTool.SELECT);
            this.activeBeforePresentationMode = previouslyActive;
            break;
          }

        case _ui_utils.PresentationModeState.NORMAL:
          {
            const previouslyActive = this.activeBeforePresentationMode;
            this.activeBeforePresentationMode = null;
            this.switchTool(previouslyActive);
            break;
          }
      }
    });
  }

}

exports.PDFCursorTools = PDFCursorTools;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GrabToPan = GrabToPan;

function GrabToPan(options) {
  this.element = options.element;
  this.document = options.element.ownerDocument;

  if (typeof options.ignoreTarget === "function") {
    this.ignoreTarget = options.ignoreTarget;
  }

  this.onActiveChanged = options.onActiveChanged;
  this.activate = this.activate.bind(this);
  this.deactivate = this.deactivate.bind(this);
  this.toggle = this.toggle.bind(this);
  this._onmousedown = this._onmousedown.bind(this);
  this._onmousemove = this._onmousemove.bind(this);
  this._endPan = this._endPan.bind(this);
  const overlay = this.overlay = document.createElement("div");
  overlay.className = "grab-to-pan-grabbing";
}

GrabToPan.prototype = {
  CSS_CLASS_GRAB: "grab-to-pan-grab",
  activate: function GrabToPan_activate() {
    if (!this.active) {
      this.active = true;
      this.element.addEventListener("mousedown", this._onmousedown, true);
      this.element.classList.add(this.CSS_CLASS_GRAB);

      if (this.onActiveChanged) {
        this.onActiveChanged(true);
      }
    }
  },
  deactivate: function GrabToPan_deactivate() {
    if (this.active) {
      this.active = false;
      this.element.removeEventListener("mousedown", this._onmousedown, true);

      this._endPan();

      this.element.classList.remove(this.CSS_CLASS_GRAB);

      if (this.onActiveChanged) {
        this.onActiveChanged(false);
      }
    }
  },
  toggle: function GrabToPan_toggle() {
    if (this.active) {
      this.deactivate();
    } else {
      this.activate();
    }
  },
  ignoreTarget: function GrabToPan_ignoreTarget(node) {
    return node.matches("a[href], a[href] *, input, textarea, button, button *, select, option");
  },
  _onmousedown: function GrabToPan__onmousedown(event) {
    if (event.button !== 0 || this.ignoreTarget(event.target)) {
      return;
    }

    if (event.originalTarget) {
      try {
        event.originalTarget.tagName;
      } catch (e) {
        return;
      }
    }

    this.scrollLeftStart = this.element.scrollLeft;
    this.scrollTopStart = this.element.scrollTop;
    this.clientXStart = event.clientX;
    this.clientYStart = event.clientY;
    this.document.addEventListener("mousemove", this._onmousemove, true);
    this.document.addEventListener("mouseup", this._endPan, true);
    this.element.addEventListener("scroll", this._endPan, true);
    event.preventDefault();
    event.stopPropagation();
    const focusedElement = document.activeElement;

    if (focusedElement && !focusedElement.contains(event.target)) {
      focusedElement.blur();
    }
  },
  _onmousemove: function GrabToPan__onmousemove(event) {
    this.element.removeEventListener("scroll", this._endPan, true);

    if (isLeftMouseReleased(event)) {
      this._endPan();

      return;
    }

    const xDiff = event.clientX - this.clientXStart;
    const yDiff = event.clientY - this.clientYStart;
    const scrollTop = this.scrollTopStart - yDiff;
    const scrollLeft = this.scrollLeftStart - xDiff;

    if (this.element.scrollTo) {
      this.element.scrollTo({
        top: scrollTop,
        left: scrollLeft,
        behavior: "instant"
      });
    } else {
      this.element.scrollTop = scrollTop;
      this.element.scrollLeft = scrollLeft;
    }

    if (!this.overlay.parentNode) {
      document.body.appendChild(this.overlay);
    }
  },
  _endPan: function GrabToPan__endPan() {
    this.element.removeEventListener("scroll", this._endPan, true);
    this.document.removeEventListener("mousemove", this._onmousemove, true);
    this.document.removeEventListener("mouseup", this._endPan, true);
    this.overlay.remove();
  }
};

function isLeftMouseReleased(event) {
  if ("buttons" in event) {
    return !(event.buttons & 1);
  }

  const chrome = window.chrome;
  const isChrome15OrOpera15plus = chrome && (chrome.webstore || chrome.app);
  const isSafari6plus = /Apple/.test(navigator.vendor) && /Version\/([6-9]\d*|[1-5]\d+)/.test(navigator.userAgent);

  if (isChrome15OrOpera15plus || isSafari6plus) {
    return event.which === 0;
  }

  return false;
}

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RenderingStates = exports.PDFRenderingQueue = void 0;

var _pdfjsLib = __webpack_require__(5);

const CLEANUP_TIMEOUT = 30000;
const RenderingStates = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
};
exports.RenderingStates = RenderingStates;

class PDFRenderingQueue {
  constructor() {
    this.pdfViewer = null;
    this.pdfThumbnailViewer = null;
    this.onIdle = null;
    this.highestPriorityPage = null;
    this.idleTimeout = null;
    this.printing = false;
    this.isThumbnailViewEnabled = false;
  }

  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }

  setThumbnailViewer(pdfThumbnailViewer) {
    this.pdfThumbnailViewer = pdfThumbnailViewer;
  }

  isHighestPriority(view) {
    return this.highestPriorityPage === view.renderingId;
  }

  renderHighestPriority(currentlyVisiblePages) {
    if (this.idleTimeout) {
      clearTimeout(this.idleTimeout);
      this.idleTimeout = null;
    }

    if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
      return;
    }

    if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
      if (this.pdfThumbnailViewer.forceRendering()) {
        return;
      }
    }

    if (this.printing) {
      return;
    }

    if (this.onIdle) {
      this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
    }
  }

  getHighestPriority(visible, views, scrolledDown) {
    const visibleViews = visible.views;
    const numVisible = visibleViews.length;

    if (numVisible === 0) {
      return null;
    }

    for (let i = 0; i < numVisible; ++i) {
      const view = visibleViews[i].view;

      if (!this.isViewFinished(view)) {
        return view;
      }
    }

    if (scrolledDown) {
      const nextPageIndex = visible.last.id;

      if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
        return views[nextPageIndex];
      }
    } else {
      const previousPageIndex = visible.first.id - 2;

      if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
        return views[previousPageIndex];
      }
    }

    return null;
  }

  isViewFinished(view) {
    return view.renderingState === RenderingStates.FINISHED;
  }

  renderView(view) {
    switch (view.renderingState) {
      case RenderingStates.FINISHED:
        return false;

      case RenderingStates.PAUSED:
        this.highestPriorityPage = view.renderingId;
        view.resume();
        break;

      case RenderingStates.RUNNING:
        this.highestPriorityPage = view.renderingId;
        break;

      case RenderingStates.INITIAL:
        this.highestPriorityPage = view.renderingId;
        view.draw().finally(() => {
          this.renderHighestPriority();
        }).catch(reason => {
          if (reason instanceof _pdfjsLib.RenderingCancelledException) {
            return;
          }

          console.error(`renderView: "${reason}"`);
        });
        break;
    }

    return true;
  }

}

exports.PDFRenderingQueue = PDFRenderingQueue;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OverlayManager = void 0;

class OverlayManager {
  constructor() {
    this._overlays = {};
    this._active = null;
    this._keyDownBound = this._keyDown.bind(this);
  }

  get active() {
    return this._active;
  }

  async register(name, element, callerCloseMethod = null, canForceClose = false) {
    let container;

    if (!name || !element || !(container = element.parentNode)) {
      throw new Error("Not enough parameters.");
    } else if (this._overlays[name]) {
      throw new Error("The overlay is already registered.");
    }

    this._overlays[name] = {
      element,
      container,
      callerCloseMethod,
      canForceClose
    };
  }

  async unregister(name) {
    if (!this._overlays[name]) {
      throw new Error("The overlay does not exist.");
    } else if (this._active === name) {
      throw new Error("The overlay cannot be removed while it is active.");
    }

    delete this._overlays[name];
  }

  async open(name) {
    if (!this._overlays[name]) {
      throw new Error("The overlay does not exist.");
    } else if (this._active) {
      if (this._overlays[name].canForceClose) {
        this._closeThroughCaller();
      } else if (this._active === name) {
        throw new Error("The overlay is already active.");
      } else {
        throw new Error("Another overlay is currently active.");
      }
    }

    this._active = name;

    this._overlays[this._active].element.classList.remove("hidden");

    this._overlays[this._active].container.classList.remove("hidden");

    window.addEventListener("keydown", this._keyDownBound);
  }

  async close(name) {
    if (!this._overlays[name]) {
      throw new Error("The overlay does not exist.");
    } else if (!this._active) {
      throw new Error("The overlay is currently not active.");
    } else if (this._active !== name) {
      throw new Error("Another overlay is currently active.");
    }

    this._overlays[this._active].container.classList.add("hidden");

    this._overlays[this._active].element.classList.add("hidden");

    this._active = null;
    window.removeEventListener("keydown", this._keyDownBound);
  }

  _keyDown(evt) {
    if (this._active && evt.keyCode === 27) {
      this._closeThroughCaller();

      evt.preventDefault();
    }
  }

  _closeThroughCaller() {
    if (this._overlays[this._active].callerCloseMethod) {
      this._overlays[this._active].callerCloseMethod();
    }

    if (this._active) {
      this.close(this._active);
    }
  }

}

exports.OverlayManager = OverlayManager;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PasswordPrompt = void 0;

var _pdfjsLib = __webpack_require__(5);

class PasswordPrompt {
  constructor(options, overlayManager, l10n, isViewerEmbedded = false) {
    this.overlayName = options.overlayName;
    this.container = options.container;
    this.label = options.label;
    this.input = options.input;
    this.submitButton = options.submitButton;
    this.cancelButton = options.cancelButton;
    this.overlayManager = overlayManager;
    this.l10n = l10n;
    this._isViewerEmbedded = isViewerEmbedded;
    this.updateCallback = null;
    this.reason = null;
    this.submitButton.addEventListener("click", this.verify.bind(this));
    this.cancelButton.addEventListener("click", this.close.bind(this));
    this.input.addEventListener("keydown", e => {
      if (e.keyCode === 13) {
        this.verify();
      }
    });
    this.overlayManager.register(this.overlayName, this.container, this.close.bind(this), true);
  }

  async open() {
    await this.overlayManager.open(this.overlayName);
    const passwordIncorrect = this.reason === _pdfjsLib.PasswordResponses.INCORRECT_PASSWORD;

    if (!this._isViewerEmbedded || passwordIncorrect) {
      this.input.focus();
    }

    this.label.textContent = await this.l10n.get(`password_${passwordIncorrect ? "invalid" : "label"}`);
  }

  close() {
    this.overlayManager.close(this.overlayName).then(() => {
      this.input.value = "";
    });
  }

  verify() {
    const password = this.input.value;

    if (password?.length > 0) {
      this.close();
      this.updateCallback(password);
    }
  }

  setUpdateCallback(updateCallback, reason) {
    this.updateCallback = updateCallback;
    this.reason = reason;
  }

}

exports.PasswordPrompt = PasswordPrompt;

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFAttachmentViewer = void 0;

var _pdfjsLib = __webpack_require__(5);

var _base_tree_viewer = __webpack_require__(12);

class PDFAttachmentViewer extends _base_tree_viewer.BaseTreeViewer {
  constructor(options) {
    super(options);
    this.downloadManager = options.downloadManager;

    this.eventBus._on("fileattachmentannotation", this._appendAttachment.bind(this));
  }

  reset(keepRenderedCapability = false) {
    super.reset();
    this._attachments = null;

    if (!keepRenderedCapability) {
      this._renderedCapability = (0, _pdfjsLib.createPromiseCapability)();
    }

    if (this._pendingDispatchEvent) {
      clearTimeout(this._pendingDispatchEvent);
    }

    this._pendingDispatchEvent = null;
  }

  _dispatchEvent(attachmentsCount) {
    this._renderedCapability.resolve();

    if (this._pendingDispatchEvent) {
      clearTimeout(this._pendingDispatchEvent);
      this._pendingDispatchEvent = null;
    }

    if (attachmentsCount === 0) {
      this._pendingDispatchEvent = setTimeout(() => {
        this.eventBus.dispatch("attachmentsloaded", {
          source: this,
          attachmentsCount: 0
        });
        this._pendingDispatchEvent = null;
      });
      return;
    }

    this.eventBus.dispatch("attachmentsloaded", {
      source: this,
      attachmentsCount
    });
  }

  _bindLink(element, {
    content,
    filename
  }) {
    element.onclick = () => {
      this.downloadManager.openOrDownloadData(element, content, filename);
      return false;
    };
  }

  render({
    attachments,
    keepRenderedCapability = false
  }) {
    if (this._attachments) {
      this.reset(keepRenderedCapability);
    }

    this._attachments = attachments || null;

    if (!attachments) {
      this._dispatchEvent(0);

      return;
    }

    const names = Object.keys(attachments).sort(function (a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    });
    const fragment = document.createDocumentFragment();
    let attachmentsCount = 0;

    for (const name of names) {
      const item = attachments[name];
      const content = item.content,
            filename = (0, _pdfjsLib.getFilenameFromUrl)(item.filename);
      const div = document.createElement("div");
      div.className = "treeItem";
      const element = document.createElement("a");

      this._bindLink(element, {
        content,
        filename
      });

      element.textContent = this._normalizeTextContent(filename);
      div.appendChild(element);
      fragment.appendChild(div);
      attachmentsCount++;
    }

    this._finishRendering(fragment, attachmentsCount);
  }

  _appendAttachment({
    id,
    filename,
    content
  }) {
    const renderedPromise = this._renderedCapability.promise;
    renderedPromise.then(() => {
      if (renderedPromise !== this._renderedCapability.promise) {
        return;
      }

      let attachments = this._attachments;

      if (!attachments) {
        attachments = Object.create(null);
      } else {
        for (const name in attachments) {
          if (id === name) {
            return;
          }
        }
      }

      attachments[id] = {
        filename,
        content
      };
      this.render({
        attachments,
        keepRenderedCapability: true
      });
    });
  }

}

exports.PDFAttachmentViewer = PDFAttachmentViewer;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseTreeViewer = void 0;

var _pdfjsLib = __webpack_require__(5);

const TREEITEM_OFFSET_TOP = -100;
const TREEITEM_SELECTED_CLASS = "selected";

class BaseTreeViewer {
  constructor(options) {
    if (this.constructor === BaseTreeViewer) {
      throw new Error("Cannot initialize BaseTreeViewer.");
    }

    this.container = options.container;
    this.eventBus = options.eventBus;
    this.reset();
  }

  reset() {
    this._pdfDocument = null;
    this._lastToggleIsShow = true;
    this._currentTreeItem = null;
    this.container.textContent = "";
    this.container.classList.remove("treeWithDeepNesting");
  }

  _dispatchEvent(count) {
    throw new Error("Not implemented: _dispatchEvent");
  }

  _bindLink(element, params) {
    throw new Error("Not implemented: _bindLink");
  }

  _normalizeTextContent(str) {
    return (0, _pdfjsLib.removeNullCharacters)(str) || "\u2013";
  }

  _addToggleButton(div, hidden = false) {
    const toggler = document.createElement("div");
    toggler.className = "treeItemToggler";

    if (hidden) {
      toggler.classList.add("treeItemsHidden");
    }

    toggler.onclick = evt => {
      evt.stopPropagation();
      toggler.classList.toggle("treeItemsHidden");

      if (evt.shiftKey) {
        const shouldShowAll = !toggler.classList.contains("treeItemsHidden");

        this._toggleTreeItem(div, shouldShowAll);
      }
    };

    div.insertBefore(toggler, div.firstChild);
  }

  _toggleTreeItem(root, show = false) {
    this._lastToggleIsShow = show;

    for (const toggler of root.querySelectorAll(".treeItemToggler")) {
      toggler.classList.toggle("treeItemsHidden", !show);
    }
  }

  _toggleAllTreeItems() {
    this._toggleTreeItem(this.container, !this._lastToggleIsShow);
  }

  _finishRendering(fragment, count, hasAnyNesting = false) {
    if (hasAnyNesting) {
      this.container.classList.add("treeWithDeepNesting");
      this._lastToggleIsShow = !fragment.querySelector(".treeItemsHidden");
    }

    this.container.appendChild(fragment);

    this._dispatchEvent(count);
  }

  render(params) {
    throw new Error("Not implemented: render");
  }

  _updateCurrentTreeItem(treeItem = null) {
    if (this._currentTreeItem) {
      this._currentTreeItem.classList.remove(TREEITEM_SELECTED_CLASS);

      this._currentTreeItem = null;
    }

    if (treeItem) {
      treeItem.classList.add(TREEITEM_SELECTED_CLASS);
      this._currentTreeItem = treeItem;
    }
  }

  _scrollToCurrentTreeItem(treeItem) {
    if (!treeItem) {
      return;
    }

    let currentNode = treeItem.parentNode;

    while (currentNode && currentNode !== this.container) {
      if (currentNode.classList.contains("treeItem")) {
        const toggler = currentNode.firstElementChild;
        toggler?.classList.remove("treeItemsHidden");
      }

      currentNode = currentNode.parentNode;
    }

    this._updateCurrentTreeItem(treeItem);

    this.container.scrollTo(treeItem.offsetLeft, treeItem.offsetTop + TREEITEM_OFFSET_TOP);
  }

}

exports.BaseTreeViewer = BaseTreeViewer;

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDocumentProperties = void 0;

var _pdfjsLib = __webpack_require__(5);

var _ui_utils = __webpack_require__(4);

const DEFAULT_FIELD_CONTENT = "-";
const NON_METRIC_LOCALES = ["en-us", "en-lr", "my"];
const US_PAGE_NAMES = {
  "8.5x11": "Letter",
  "8.5x14": "Legal"
};
const METRIC_PAGE_NAMES = {
  "297x420": "A3",
  "210x297": "A4"
};

function getPageName(size, isPortrait, pageNames) {
  const width = isPortrait ? size.width : size.height;
  const height = isPortrait ? size.height : size.width;
  return pageNames[`${width}x${height}`];
}

class PDFDocumentProperties {
  constructor({
    overlayName,
    fields,
    container,
    closeButton
  }, overlayManager, eventBus, l10n) {
    this.overlayName = overlayName;
    this.fields = fields;
    this.container = container;
    this.overlayManager = overlayManager;
    this.l10n = l10n;

    this._reset();

    closeButton.addEventListener("click", this.close.bind(this));
    this.overlayManager.register(this.overlayName, this.container, this.close.bind(this));

    eventBus._on("pagechanging", evt => {
      this._currentPageNumber = evt.pageNumber;
    });

    eventBus._on("rotationchanging", evt => {
      this._pagesRotation = evt.pagesRotation;
    });

    this._isNonMetricLocale = true;
    l10n.getLanguage().then(locale => {
      this._isNonMetricLocale = NON_METRIC_LOCALES.includes(locale);
    });
  }

  async open() {
    const freezeFieldData = data => {
      Object.defineProperty(this, "fieldData", {
        value: Object.freeze(data),
        writable: false,
        enumerable: true,
        configurable: true
      });
    };

    await Promise.all([this.overlayManager.open(this.overlayName), this._dataAvailableCapability.promise]);
    const currentPageNumber = this._currentPageNumber;
    const pagesRotation = this._pagesRotation;

    if (this.fieldData && currentPageNumber === this.fieldData._currentPageNumber && pagesRotation === this.fieldData._pagesRotation) {
      this._updateUI();

      return;
    }

    const {
      info,
      contentDispositionFilename,
      contentLength
    } = await this.pdfDocument.getMetadata();
    const [fileName, fileSize, creationDate, modificationDate, pageSize, isLinearized] = await Promise.all([contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(this.url), this._parseFileSize(contentLength), this._parseDate(info.CreationDate), this._parseDate(info.ModDate), this.pdfDocument.getPage(currentPageNumber).then(pdfPage => {
      return this._parsePageSize((0, _ui_utils.getPageSizeInches)(pdfPage), pagesRotation);
    }), this._parseLinearization(info.IsLinearized)]);
    freezeFieldData({
      fileName,
      fileSize,
      title: info.Title,
      author: info.Author,
      subject: info.Subject,
      keywords: info.Keywords,
      creationDate,
      modificationDate,
      creator: info.Creator,
      producer: info.Producer,
      version: info.PDFFormatVersion,
      pageCount: this.pdfDocument.numPages,
      pageSize,
      linearized: isLinearized,
      _currentPageNumber: currentPageNumber,
      _pagesRotation: pagesRotation
    });

    this._updateUI();

    const {
      length
    } = await this.pdfDocument.getDownloadInfo();

    if (contentLength === length) {
      return;
    }

    const data = Object.assign(Object.create(null), this.fieldData);
    data.fileSize = await this._parseFileSize(length);
    freezeFieldData(data);

    this._updateUI();
  }

  close() {
    this.overlayManager.close(this.overlayName);
  }

  setDocument(pdfDocument, url = null) {
    if (this.pdfDocument) {
      this._reset();

      this._updateUI(true);
    }

    if (!pdfDocument) {
      return;
    }

    this.pdfDocument = pdfDocument;
    this.url = url;

    this._dataAvailableCapability.resolve();
  }

  _reset() {
    this.pdfDocument = null;
    this.url = null;
    delete this.fieldData;
    this._dataAvailableCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._currentPageNumber = 1;
    this._pagesRotation = 0;
  }

  _updateUI(reset = false) {
    if (reset || !this.fieldData) {
      for (const id in this.fields) {
        this.fields[id].textContent = DEFAULT_FIELD_CONTENT;
      }

      return;
    }

    if (this.overlayManager.active !== this.overlayName) {
      return;
    }

    for (const id in this.fields) {
      const content = this.fieldData[id];
      this.fields[id].textContent = content || content === 0 ? content : DEFAULT_FIELD_CONTENT;
    }
  }

  async _parseFileSize(fileSize = 0) {
    const kb = fileSize / 1024,
          mb = kb / 1024;

    if (!kb) {
      return undefined;
    }

    return this.l10n.get(`document_properties_${mb >= 1 ? "mb" : "kb"}`, {
      size_mb: mb >= 1 && (+mb.toPrecision(3)).toLocaleString(),
      size_kb: mb < 1 && (+kb.toPrecision(3)).toLocaleString(),
      size_b: fileSize.toLocaleString()
    });
  }

  async _parsePageSize(pageSizeInches, pagesRotation) {
    if (!pageSizeInches) {
      return undefined;
    }

    if (pagesRotation % 180 !== 0) {
      pageSizeInches = {
        width: pageSizeInches.height,
        height: pageSizeInches.width
      };
    }

    const isPortrait = (0, _ui_utils.isPortraitOrientation)(pageSizeInches);
    let sizeInches = {
      width: Math.round(pageSizeInches.width * 100) / 100,
      height: Math.round(pageSizeInches.height * 100) / 100
    };
    let sizeMillimeters = {
      width: Math.round(pageSizeInches.width * 25.4 * 10) / 10,
      height: Math.round(pageSizeInches.height * 25.4 * 10) / 10
    };
    let rawName = getPageName(sizeInches, isPortrait, US_PAGE_NAMES) || getPageName(sizeMillimeters, isPortrait, METRIC_PAGE_NAMES);

    if (!rawName && !(Number.isInteger(sizeMillimeters.width) && Number.isInteger(sizeMillimeters.height))) {
      const exactMillimeters = {
        width: pageSizeInches.width * 25.4,
        height: pageSizeInches.height * 25.4
      };
      const intMillimeters = {
        width: Math.round(sizeMillimeters.width),
        height: Math.round(sizeMillimeters.height)
      };

      if (Math.abs(exactMillimeters.width - intMillimeters.width) < 0.1 && Math.abs(exactMillimeters.height - intMillimeters.height) < 0.1) {
        rawName = getPageName(intMillimeters, isPortrait, METRIC_PAGE_NAMES);

        if (rawName) {
          sizeInches = {
            width: Math.round(intMillimeters.width / 25.4 * 100) / 100,
            height: Math.round(intMillimeters.height / 25.4 * 100) / 100
          };
          sizeMillimeters = intMillimeters;
        }
      }
    }

    const [{
      width,
      height
    }, unit, name, orientation] = await Promise.all([this._isNonMetricLocale ? sizeInches : sizeMillimeters, this.l10n.get(`document_properties_page_size_unit_${this._isNonMetricLocale ? "inches" : "millimeters"}`), rawName && this.l10n.get(`document_properties_page_size_name_${rawName.toLowerCase()}`), this.l10n.get(`document_properties_page_size_orientation_${isPortrait ? "portrait" : "landscape"}`)]);
    return this.l10n.get(`document_properties_page_size_dimension_${name ? "name_" : ""}string`, {
      width: width.toLocaleString(),
      height: height.toLocaleString(),
      unit,
      name,
      orientation
    });
  }

  async _parseDate(inputDate) {
    const dateObject = _pdfjsLib.PDFDateString.toDateObject(inputDate);

    if (!dateObject) {
      return undefined;
    }

    return this.l10n.get("document_properties_date_string", {
      date: dateObject.toLocaleDateString(),
      time: dateObject.toLocaleTimeString()
    });
  }

  _parseLinearization(isLinearized) {
    return this.l10n.get(`document_properties_linearized_${isLinearized ? "yes" : "no"}`);
  }

}

exports.PDFDocumentProperties = PDFDocumentProperties;

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFFindBar = void 0;

var _pdf_find_controller = __webpack_require__(15);

const MATCHES_COUNT_LIMIT = 1000;

class PDFFindBar {
  constructor(options, eventBus, l10n) {
    this.opened = false;
    this.bar = options.bar;
    this.toggleButton = options.toggleButton;
    this.findField = options.findField;
    this.highlightAll = options.highlightAllCheckbox;
    this.caseSensitive = options.caseSensitiveCheckbox;
    this.entireWord = options.entireWordCheckbox;
    this.findMsg = options.findMsg;
    this.findResultsCount = options.findResultsCount;
    this.findPreviousButton = options.findPreviousButton;
    this.findNextButton = options.findNextButton;
    this.eventBus = eventBus;
    this.l10n = l10n;
    this.toggleButton.addEventListener("click", () => {
      this.toggle();
    });
    this.findField.addEventListener("input", () => {
      this.dispatchEvent("");
    });
    this.bar.addEventListener("keydown", e => {
      switch (e.keyCode) {
        case 13:
          if (e.target === this.findField) {
            this.dispatchEvent("again", e.shiftKey);
          }

          break;

        case 27:
          this.close();
          break;
      }
    });
    this.findPreviousButton.addEventListener("click", () => {
      this.dispatchEvent("again", true);
    });
    this.findNextButton.addEventListener("click", () => {
      this.dispatchEvent("again", false);
    });
    this.highlightAll.addEventListener("click", () => {
      this.dispatchEvent("highlightallchange");
    });
    this.caseSensitive.addEventListener("click", () => {
      this.dispatchEvent("casesensitivitychange");
    });
    this.entireWord.addEventListener("click", () => {
      this.dispatchEvent("entirewordchange");
    });

    this.eventBus._on("resize", this._adjustWidth.bind(this));
  }

  reset() {
    this.updateUIState();
  }

  dispatchEvent(type, findPrev) {
    this.eventBus.dispatch("find", {
      source: this,
      type,
      query: this.findField.value,
      phraseSearch: true,
      caseSensitive: this.caseSensitive.checked,
      entireWord: this.entireWord.checked,
      highlightAll: this.highlightAll.checked,
      findPrevious: findPrev
    });
  }

  updateUIState(state, previous, matchesCount) {
    let findMsg = Promise.resolve("");
    let status = "";

    switch (state) {
      case _pdf_find_controller.FindState.FOUND:
        break;

      case _pdf_find_controller.FindState.PENDING:
        status = "pending";
        break;

      case _pdf_find_controller.FindState.NOT_FOUND:
        findMsg = this.l10n.get("find_not_found");
        status = "notFound";
        break;

      case _pdf_find_controller.FindState.WRAPPED:
        findMsg = this.l10n.get(`find_reached_${previous ? "top" : "bottom"}`);
        break;
    }

    this.findField.setAttribute("data-status", status);
    findMsg.then(msg => {
      this.findMsg.textContent = msg;

      this._adjustWidth();
    });
    this.updateResultsCount(matchesCount);
  }

  updateResultsCount({
    current = 0,
    total = 0
  } = {}) {
    const limit = MATCHES_COUNT_LIMIT;
    let matchCountMsg = Promise.resolve("");

    if (total > 0) {
      if (total > limit) {
        let key = "find_match_count_limit";
        matchCountMsg = this.l10n.get(key, {
          limit
        });
      } else {
        let key = "find_match_count";
        matchCountMsg = this.l10n.get(key, {
          current,
          total
        });
      }
    }

    matchCountMsg.then(msg => {
      this.findResultsCount.textContent = msg;
      this.findResultsCount.classList.toggle("hidden", !total);

      this._adjustWidth();
    });
  }

  open() {
    if (!this.opened) {
      this.opened = true;
      this.toggleButton.classList.add("toggled");
      this.toggleButton.setAttribute("aria-expanded", "true");
      this.bar.classList.remove("hidden");
    }

    this.findField.select();
    this.findField.focus();

    this._adjustWidth();
  }

  close() {
    if (!this.opened) {
      return;
    }

    this.opened = false;
    this.toggleButton.classList.remove("toggled");
    this.toggleButton.setAttribute("aria-expanded", "false");
    this.bar.classList.add("hidden");
    this.eventBus.dispatch("findbarclose", {
      source: this
    });
  }

  toggle() {
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }

  _adjustWidth() {
    if (!this.opened) {
      return;
    }

    this.bar.classList.remove("wrapContainers");
    const findbarHeight = this.bar.clientHeight;
    const inputContainerHeight = this.bar.firstElementChild.clientHeight;

    if (findbarHeight > inputContainerHeight) {
      this.bar.classList.add("wrapContainers");
    }
  }

}

exports.PDFFindBar = PDFFindBar;

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFFindController = exports.FindState = void 0;

var _pdfjsLib = __webpack_require__(5);

var _pdf_find_utils = __webpack_require__(16);

var _ui_utils = __webpack_require__(4);

const FindState = {
  FOUND: 0,
  NOT_FOUND: 1,
  WRAPPED: 2,
  PENDING: 3
};
exports.FindState = FindState;
const FIND_TIMEOUT = 250;
const MATCH_SCROLL_OFFSET_TOP = -50;
const MATCH_SCROLL_OFFSET_LEFT = -400;
const CHARACTERS_TO_NORMALIZE = {
  "\u2018": "'",
  "\u2019": "'",
  "\u201A": "'",
  "\u201B": "'",
  "\u201C": '"',
  "\u201D": '"',
  "\u201E": '"',
  "\u201F": '"',
  "\u00BC": "1/4",
  "\u00BD": "1/2",
  "\u00BE": "3/4"
};
let normalizationRegex = null;

function normalize(text) {
  if (!normalizationRegex) {
    const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
    normalizationRegex = new RegExp(`[${replace}]`, "g");
  }

  let diffs = null;
  const normalizedText = text.replace(normalizationRegex, function (ch, index) {
    const normalizedCh = CHARACTERS_TO_NORMALIZE[ch],
          diff = normalizedCh.length - ch.length;

    if (diff !== 0) {
      (diffs || (diffs = [])).push([index, diff]);
    }

    return normalizedCh;
  });
  return [normalizedText, diffs];
}

function getOriginalIndex(matchIndex, diffs = null) {
  if (!diffs) {
    return matchIndex;
  }

  let totalDiff = 0;

  for (const [index, diff] of diffs) {
    const currentIndex = index + totalDiff;

    if (currentIndex >= matchIndex) {
      break;
    }

    if (currentIndex + diff > matchIndex) {
      totalDiff += matchIndex - currentIndex;
      break;
    }

    totalDiff += diff;
  }

  return matchIndex - totalDiff;
}

class PDFFindController {
  constructor({
    linkService,
    eventBus
  }) {
    this._linkService = linkService;
    this._eventBus = eventBus;

    this._reset();

    eventBus._on("findbarclose", this._onFindBarClose.bind(this));
  }

  get highlightMatches() {
    return this._highlightMatches;
  }

  get pageMatches() {
    return this._pageMatches;
  }

  get pageMatchesLength() {
    return this._pageMatchesLength;
  }

  get selected() {
    return this._selected;
  }

  get state() {
    return this._state;
  }

  setDocument(pdfDocument) {
    if (this._pdfDocument) {
      this._reset();
    }

    if (!pdfDocument) {
      return;
    }

    this._pdfDocument = pdfDocument;

    this._firstPageCapability.resolve();
  }

  executeCommand(cmd, state) {
    if (!state) {
      return;
    }

    const pdfDocument = this._pdfDocument;

    if (this._state === null || this._shouldDirtyMatch(cmd, state)) {
      this._dirtyMatch = true;
    }

    this._state = state;

    if (cmd !== "findhighlightallchange") {
      this._updateUIState(FindState.PENDING);
    }

    this._firstPageCapability.promise.then(() => {
      if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
        return;
      }

      this._extractText();

      const findbarClosed = !this._highlightMatches;
      const pendingTimeout = !!this._findTimeout;

      if (this._findTimeout) {
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
      }

      if (cmd === "find") {
        this._findTimeout = setTimeout(() => {
          this._nextMatch();

          this._findTimeout = null;
        }, FIND_TIMEOUT);
      } else if (this._dirtyMatch) {
        this._nextMatch();
      } else if (cmd === "findagain") {
        this._nextMatch();

        if (findbarClosed && this._state.highlightAll) {
          this._updateAllPages();
        }
      } else if (cmd === "findhighlightallchange") {
        if (pendingTimeout) {
          this._nextMatch();
        } else {
          this._highlightMatches = true;
        }

        this._updateAllPages();
      } else {
        this._nextMatch();
      }
    });
  }

  scrollMatchIntoView({
    element = null,
    pageIndex = -1,
    matchIndex = -1
  }) {
    if (!this._scrollMatches || !element) {
      return;
    } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
      return;
    } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
      return;
    }

    this._scrollMatches = false;
    const spot = {
      top: MATCH_SCROLL_OFFSET_TOP,
      left: MATCH_SCROLL_OFFSET_LEFT
    };
    (0, _ui_utils.scrollIntoView)(element, spot, true);
  }

  _reset() {
    this._highlightMatches = false;
    this._scrollMatches = false;
    this._pdfDocument = null;
    this._pageMatches = [];
    this._pageMatchesLength = [];
    this._state = null;
    this._selected = {
      pageIdx: -1,
      matchIdx: -1
    };
    this._offset = {
      pageIdx: null,
      matchIdx: null,
      wrapped: false
    };
    this._extractTextPromises = [];
    this._pageContents = [];
    this._pageDiffs = [];
    this._matchesCountTotal = 0;
    this._pagesToSearch = null;
    this._pendingFindMatches = new Set();
    this._resumePageIdx = null;
    this._dirtyMatch = false;
    clearTimeout(this._findTimeout);
    this._findTimeout = null;
    this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
  }

  get _query() {
    if (this._state.query !== this._rawQuery) {
      this._rawQuery = this._state.query;
      [this._normalizedQuery] = normalize(this._state.query);
    }

    return this._normalizedQuery;
  }

  _shouldDirtyMatch(cmd, state) {
    if (state.query !== this._state.query) {
      return true;
    }

    switch (cmd) {
      case "findagain":
        const pageNumber = this._selected.pageIdx + 1;
        const linkService = this._linkService;

        if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {
          return true;
        }

        return false;

      case "findhighlightallchange":
        return false;
    }

    return true;
  }

  _prepareMatches(matchesWithLength, matches, matchesLength) {
    function isSubTerm(currentIndex) {
      const currentElem = matchesWithLength[currentIndex];
      const nextElem = matchesWithLength[currentIndex + 1];

      if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) {
        currentElem.skipped = true;
        return true;
      }

      for (let i = currentIndex - 1; i >= 0; i--) {
        const prevElem = matchesWithLength[i];

        if (prevElem.skipped) {
          continue;
        }

        if (prevElem.match + prevElem.matchLength < currentElem.match) {
          break;
        }

        if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) {
          currentElem.skipped = true;
          return true;
        }
      }

      return false;
    }

    matchesWithLength.sort(function (a, b) {
      return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match;
    });

    for (let i = 0, len = matchesWithLength.length; i < len; i++) {
      if (isSubTerm(i)) {
        continue;
      }

      matches.push(matchesWithLength[i].match);
      matchesLength.push(matchesWithLength[i].matchLength);
    }
  }

  _isEntireWord(content, startIdx, length) {
    if (startIdx > 0) {
      const first = content.charCodeAt(startIdx);
      const limit = content.charCodeAt(startIdx - 1);

      if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
        return false;
      }
    }

    const endIdx = startIdx + length - 1;

    if (endIdx < content.length - 1) {
      const last = content.charCodeAt(endIdx);
      const limit = content.charCodeAt(endIdx + 1);

      if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) {
        return false;
      }
    }

    return true;
  }

  _calculatePhraseMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {
    const matches = [],
          matchesLength = [];
    const queryLen = query.length;
    let matchIdx = -queryLen;

    while (true) {
      matchIdx = pageContent.indexOf(query, matchIdx + queryLen);

      if (matchIdx === -1) {
        break;
      }

      if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {
        continue;
      }

      const originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),
            matchEnd = matchIdx + queryLen - 1,
            originalQueryLen = getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;
      matches.push(originalMatchIdx);
      matchesLength.push(originalQueryLen);
    }

    this._pageMatches[pageIndex] = matches;
    this._pageMatchesLength[pageIndex] = matchesLength;
  }

  _calculateWordMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {
    const matchesWithLength = [];
    const queryArray = query.match(/\S+/g);

    for (let i = 0, len = queryArray.length; i < len; i++) {
      const subquery = queryArray[i];
      const subqueryLen = subquery.length;
      let matchIdx = -subqueryLen;

      while (true) {
        matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);

        if (matchIdx === -1) {
          break;
        }

        if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) {
          continue;
        }

        const originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),
              matchEnd = matchIdx + subqueryLen - 1,
              originalQueryLen = getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;
        matchesWithLength.push({
          match: originalMatchIdx,
          matchLength: originalQueryLen,
          skipped: false
        });
      }
    }

    this._pageMatchesLength[pageIndex] = [];
    this._pageMatches[pageIndex] = [];

    this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]);
  }

  _calculateMatch(pageIndex) {
    let pageContent = this._pageContents[pageIndex];
    const pageDiffs = this._pageDiffs[pageIndex];
    let query = this._query;
    const {
      caseSensitive,
      entireWord,
      phraseSearch
    } = this._state;

    if (query.length === 0) {
      return;
    }

    if (!caseSensitive) {
      pageContent = pageContent.toLowerCase();
      query = query.toLowerCase();
    }

    if (phraseSearch) {
      this._calculatePhraseMatch(query, pageIndex, pageContent, pageDiffs, entireWord);
    } else {
      this._calculateWordMatch(query, pageIndex, pageContent, pageDiffs, entireWord);
    }

    if (this._state.highlightAll) {
      this._updatePage(pageIndex);
    }

    if (this._resumePageIdx === pageIndex) {
      this._resumePageIdx = null;

      this._nextPageMatch();
    }

    const pageMatchesCount = this._pageMatches[pageIndex].length;

    if (pageMatchesCount > 0) {
      this._matchesCountTotal += pageMatchesCount;

      this._updateUIResultsCount();
    }
  }

  _extractText() {
    if (this._extractTextPromises.length > 0) {
      return;
    }

    let promise = Promise.resolve();

    for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
      const extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();
      this._extractTextPromises[i] = extractTextCapability.promise;
      promise = promise.then(() => {
        return this._pdfDocument.getPage(i + 1).then(pdfPage => {
          return pdfPage.getTextContent({
            normalizeWhitespace: true
          });
        }).then(textContent => {
          const textItems = textContent.items;
          const strBuf = [];

          for (let j = 0, jj = textItems.length; j < jj; j++) {
            strBuf.push(textItems[j].str);
          }

          [this._pageContents[i], this._pageDiffs[i]] = normalize(strBuf.join(""));
          extractTextCapability.resolve(i);
        }, reason => {
          console.error(`Unable to get text content for page ${i + 1}`, reason);
          this._pageContents[i] = "";
          this._pageDiffs[i] = null;
          extractTextCapability.resolve(i);
        });
      });
    }
  }

  _updatePage(index) {
    if (this._scrollMatches && this._selected.pageIdx === index) {
      this._linkService.page = index + 1;
    }

    this._eventBus.dispatch("updatetextlayermatches", {
      source: this,
      pageIndex: index
    });
  }

  _updateAllPages() {
    this._eventBus.dispatch("updatetextlayermatches", {
      source: this,
      pageIndex: -1
    });
  }

  _nextMatch() {
    const previous = this._state.findPrevious;
    const currentPageIndex = this._linkService.page - 1;
    const numPages = this._linkService.pagesCount;
    this._highlightMatches = true;

    if (this._dirtyMatch) {
      this._dirtyMatch = false;
      this._selected.pageIdx = this._selected.matchIdx = -1;
      this._offset.pageIdx = currentPageIndex;
      this._offset.matchIdx = null;
      this._offset.wrapped = false;
      this._resumePageIdx = null;
      this._pageMatches.length = 0;
      this._pageMatchesLength.length = 0;
      this._matchesCountTotal = 0;

      this._updateAllPages();

      for (let i = 0; i < numPages; i++) {
        if (this._pendingFindMatches.has(i)) {
          continue;
        }

        this._pendingFindMatches.add(i);

        this._extractTextPromises[i].then(pageIdx => {
          this._pendingFindMatches.delete(pageIdx);

          this._calculateMatch(pageIdx);
        });
      }
    }

    if (this._query === "") {
      this._updateUIState(FindState.FOUND);

      return;
    }

    if (this._resumePageIdx) {
      return;
    }

    const offset = this._offset;
    this._pagesToSearch = numPages;

    if (offset.matchIdx !== null) {
      const numPageMatches = this._pageMatches[offset.pageIdx].length;

      if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
        offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;

        this._updateMatch(true);

        return;
      }

      this._advanceOffsetPage(previous);
    }

    this._nextPageMatch();
  }

  _matchesReady(matches) {
    const offset = this._offset;
    const numMatches = matches.length;
    const previous = this._state.findPrevious;

    if (numMatches) {
      offset.matchIdx = previous ? numMatches - 1 : 0;

      this._updateMatch(true);

      return true;
    }

    this._advanceOffsetPage(previous);

    if (offset.wrapped) {
      offset.matchIdx = null;

      if (this._pagesToSearch < 0) {
        this._updateMatch(false);

        return true;
      }
    }

    return false;
  }

  _nextPageMatch() {
    if (this._resumePageIdx !== null) {
      console.error("There can only be one pending page.");
    }

    let matches = null;

    do {
      const pageIdx = this._offset.pageIdx;
      matches = this._pageMatches[pageIdx];

      if (!matches) {
        this._resumePageIdx = pageIdx;
        break;
      }
    } while (!this._matchesReady(matches));
  }

  _advanceOffsetPage(previous) {
    const offset = this._offset;
    const numPages = this._linkService.pagesCount;
    offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
    offset.matchIdx = null;
    this._pagesToSearch--;

    if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
      offset.pageIdx = previous ? numPages - 1 : 0;
      offset.wrapped = true;
    }
  }

  _updateMatch(found = false) {
    let state = FindState.NOT_FOUND;
    const wrapped = this._offset.wrapped;
    this._offset.wrapped = false;

    if (found) {
      const previousPage = this._selected.pageIdx;
      this._selected.pageIdx = this._offset.pageIdx;
      this._selected.matchIdx = this._offset.matchIdx;
      state = wrapped ? FindState.WRAPPED : FindState.FOUND;

      if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
        this._updatePage(previousPage);
      }
    }

    this._updateUIState(state, this._state.findPrevious);

    if (this._selected.pageIdx !== -1) {
      this._scrollMatches = true;

      this._updatePage(this._selected.pageIdx);
    }
  }

  _onFindBarClose(evt) {
    const pdfDocument = this._pdfDocument;

    this._firstPageCapability.promise.then(() => {
      if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
        return;
      }

      if (this._findTimeout) {
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
      }

      if (this._resumePageIdx) {
        this._resumePageIdx = null;
        this._dirtyMatch = true;
      }

      this._updateUIState(FindState.FOUND);

      this._highlightMatches = false;

      this._updateAllPages();
    });
  }

  _requestMatchesCount() {
    const {
      pageIdx,
      matchIdx
    } = this._selected;
    let current = 0,
        total = this._matchesCountTotal;

    if (matchIdx !== -1) {
      for (let i = 0; i < pageIdx; i++) {
        current += this._pageMatches[i]?.length || 0;
      }

      current += matchIdx + 1;
    }

    if (current < 1 || current > total) {
      current = total = 0;
    }

    return {
      current,
      total
    };
  }

  _updateUIResultsCount() {
    this._eventBus.dispatch("updatefindmatchescount", {
      source: this,
      matchesCount: this._requestMatchesCount()
    });
  }

  _updateUIState(state, previous) {
    this._eventBus.dispatch("updatefindcontrolstate", {
      source: this,
      state,
      previous,
      matchesCount: this._requestMatchesCount(),
      rawQuery: this._state?.query ?? null
    });
  }

}

exports.PDFFindController = PDFFindController;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getCharacterType = getCharacterType;
exports.CharacterType = void 0;
const CharacterType = {
  SPACE: 0,
  ALPHA_LETTER: 1,
  PUNCT: 2,
  HAN_LETTER: 3,
  KATAKANA_LETTER: 4,
  HIRAGANA_LETTER: 5,
  HALFWIDTH_KATAKANA_LETTER: 6,
  THAI_LETTER: 7
};
exports.CharacterType = CharacterType;

function isAlphabeticalScript(charCode) {
  return charCode < 0x2e80;
}

function isAscii(charCode) {
  return (charCode & 0xff80) === 0;
}

function isAsciiAlpha(charCode) {
  return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;
}

function isAsciiDigit(charCode) {
  return charCode >= 0x30 && charCode <= 0x39;
}

function isAsciiSpace(charCode) {
  return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;
}

function isHan(charCode) {
  return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;
}

function isKatakana(charCode) {
  return charCode >= 0x30a0 && charCode <= 0x30ff;
}

function isHiragana(charCode) {
  return charCode >= 0x3040 && charCode <= 0x309f;
}

function isHalfwidthKatakana(charCode) {
  return charCode >= 0xff60 && charCode <= 0xff9f;
}

function isThai(charCode) {
  return (charCode & 0xff80) === 0x0e00;
}

function getCharacterType(charCode) {
  if (isAlphabeticalScript(charCode)) {
    if (isAscii(charCode)) {
      if (isAsciiSpace(charCode)) {
        return CharacterType.SPACE;
      } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {
        return CharacterType.ALPHA_LETTER;
      }

      return CharacterType.PUNCT;
    } else if (isThai(charCode)) {
      return CharacterType.THAI_LETTER;
    } else if (charCode === 0xa0) {
      return CharacterType.SPACE;
    }

    return CharacterType.ALPHA_LETTER;
  }

  if (isHan(charCode)) {
    return CharacterType.HAN_LETTER;
  } else if (isKatakana(charCode)) {
    return CharacterType.KATAKANA_LETTER;
  } else if (isHiragana(charCode)) {
    return CharacterType.HIRAGANA_LETTER;
  } else if (isHalfwidthKatakana(charCode)) {
    return CharacterType.HALFWIDTH_KATAKANA_LETTER;
  }

  return CharacterType.ALPHA_LETTER;
}

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isDestArraysEqual = isDestArraysEqual;
exports.isDestHashesEqual = isDestHashesEqual;
exports.PDFHistory = void 0;

var _ui_utils = __webpack_require__(4);

const HASH_CHANGE_TIMEOUT = 1000;
const POSITION_UPDATED_THRESHOLD = 50;
const UPDATE_VIEWAREA_TIMEOUT = 1000;

function getCurrentHash() {
  return document.location.hash;
}

class PDFHistory {
  constructor({
    linkService,
    eventBus
  }) {
    this.linkService = linkService;
    this.eventBus = eventBus;
    this._initialized = false;
    this._fingerprint = "";
    this.reset();
    this._boundEvents = null;
    this._isViewerInPresentationMode = false;

    this.eventBus._on("presentationmodechanged", evt => {
      this._isViewerInPresentationMode = evt.state !== _ui_utils.PresentationModeState.NORMAL;
    });

    this.eventBus._on("pagesinit", () => {
      this._isPagesLoaded = false;

      this.eventBus._on("pagesloaded", evt => {
        this._isPagesLoaded = !!evt.pagesCount;
      }, {
        once: true
      });
    });
  }

  initialize({
    fingerprint,
    resetHistory = false,
    updateUrl = false
  }) {
    if (!fingerprint || typeof fingerprint !== "string") {
      console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
      return;
    }

    if (this._initialized) {
      this.reset();
    }

    const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
    this._fingerprint = fingerprint;
    this._updateUrl = updateUrl === true;
    this._initialized = true;

    this._bindEvents();

    const state = window.history.state;
    this._popStateInProgress = false;
    this._blockHashChange = 0;
    this._currentHash = getCurrentHash();
    this._numPositionUpdates = 0;
    this._uid = this._maxUid = 0;
    this._destination = null;
    this._position = null;

    if (!this._isValidState(state, true) || resetHistory) {
      const {
        hash,
        page,
        rotation
      } = this._parseCurrentHash(true);

      if (!hash || reInitialized || resetHistory) {
        this._pushOrReplaceState(null, true);

        return;
      }

      this._pushOrReplaceState({
        hash,
        page,
        rotation
      }, true);

      return;
    }

    const destination = state.destination;

    this._updateInternalState(destination, state.uid, true);

    if (destination.rotation !== undefined) {
      this._initialRotation = destination.rotation;
    }

    if (destination.dest) {
      this._initialBookmark = JSON.stringify(destination.dest);
      this._destination.page = null;
    } else if (destination.hash) {
      this._initialBookmark = destination.hash;
    } else if (destination.page) {
      this._initialBookmark = `page=${destination.page}`;
    }
  }

  reset() {
    if (this._initialized) {
      this._pageHide();

      this._initialized = false;

      this._unbindEvents();
    }

    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }

    this._initialBookmark = null;
    this._initialRotation = null;
  }

  push({
    namedDest = null,
    explicitDest,
    pageNumber
  }) {
    if (!this._initialized) {
      return;
    }

    if (namedDest && typeof namedDest !== "string") {
      console.error("PDFHistory.push: " + `"${namedDest}" is not a valid namedDest parameter.`);
      return;
    } else if (!Array.isArray(explicitDest)) {
      console.error("PDFHistory.push: " + `"${explicitDest}" is not a valid explicitDest parameter.`);
      return;
    } else if (!this._isValidPage(pageNumber)) {
      if (pageNumber !== null || this._destination) {
        console.error("PDFHistory.push: " + `"${pageNumber}" is not a valid pageNumber parameter.`);
        return;
      }
    }

    const hash = namedDest || JSON.stringify(explicitDest);

    if (!hash) {
      return;
    }

    let forceReplace = false;

    if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
      if (this._destination.page) {
        return;
      }

      forceReplace = true;
    }

    if (this._popStateInProgress && !forceReplace) {
      return;
    }

    this._pushOrReplaceState({
      dest: explicitDest,
      hash,
      page: pageNumber,
      rotation: this.linkService.rotation
    }, forceReplace);

    if (!this._popStateInProgress) {
      this._popStateInProgress = true;
      Promise.resolve().then(() => {
        this._popStateInProgress = false;
      });
    }
  }

  pushPage(pageNumber) {
    if (!this._initialized) {
      return;
    }

    if (!this._isValidPage(pageNumber)) {
      console.error(`PDFHistory.pushPage: "${pageNumber}" is not a valid page number.`);
      return;
    }

    if (this._destination?.page === pageNumber) {
      return;
    }

    if (this._popStateInProgress) {
      return;
    }

    this._pushOrReplaceState({
      dest: null,
      hash: `page=${pageNumber}`,
      page: pageNumber,
      rotation: this.linkService.rotation
    });

    if (!this._popStateInProgress) {
      this._popStateInProgress = true;
      Promise.resolve().then(() => {
        this._popStateInProgress = false;
      });
    }
  }

  pushCurrentPosition() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }

    this._tryPushCurrentPosition();
  }

  back() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }

    const state = window.history.state;

    if (this._isValidState(state) && state.uid > 0) {
      window.history.back();
    }
  }

  forward() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }

    const state = window.history.state;

    if (this._isValidState(state) && state.uid < this._maxUid) {
      window.history.forward();
    }
  }

  get popStateInProgress() {
    return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
  }

  get initialBookmark() {
    return this._initialized ? this._initialBookmark : null;
  }

  get initialRotation() {
    return this._initialized ? this._initialRotation : null;
  }

  _pushOrReplaceState(destination, forceReplace = false) {
    const shouldReplace = forceReplace || !this._destination;
    const newState = {
      fingerprint: this._fingerprint,
      uid: shouldReplace ? this._uid : this._uid + 1,
      destination
    };

    this._updateInternalState(destination, newState.uid);

    let newUrl;

    if (this._updateUrl && destination?.hash) {
      const baseUrl = document.location.href.split("#")[0];

      if (!baseUrl.startsWith("file://")) {
        newUrl = `${baseUrl}#${destination.hash}`;
      }
    }

    if (shouldReplace) {
      window.history.replaceState(newState, "", newUrl);
    } else {
      window.history.pushState(newState, "", newUrl);
    }
  }

  _tryPushCurrentPosition(temporary = false) {
    if (!this._position) {
      return;
    }

    let position = this._position;

    if (temporary) {
      position = Object.assign(Object.create(null), this._position);
      position.temporary = true;
    }

    if (!this._destination) {
      this._pushOrReplaceState(position);

      return;
    }

    if (this._destination.temporary) {
      this._pushOrReplaceState(position, true);

      return;
    }

    if (this._destination.hash === position.hash) {
      return;
    }

    if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
      return;
    }

    let forceReplace = false;

    if (this._destination.page >= position.first && this._destination.page <= position.page) {
      if (this._destination.dest !== undefined || !this._destination.first) {
        return;
      }

      forceReplace = true;
    }

    this._pushOrReplaceState(position, forceReplace);
  }

  _isValidPage(val) {
    return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;
  }

  _isValidState(state, checkReload = false) {
    if (!state) {
      return false;
    }

    if (state.fingerprint !== this._fingerprint) {
      if (checkReload) {
        if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
          return false;
        }

        const [perfEntry] = performance.getEntriesByType("navigation");

        if (perfEntry?.type !== "reload") {
          return false;
        }
      } else {
        return false;
      }
    }

    if (!Number.isInteger(state.uid) || state.uid < 0) {
      return false;
    }

    if (state.destination === null || typeof state.destination !== "object") {
      return false;
    }

    return true;
  }

  _updateInternalState(destination, uid, removeTemporary = false) {
    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }

    if (removeTemporary && destination?.temporary) {
      delete destination.temporary;
    }

    this._destination = destination;
    this._uid = uid;
    this._maxUid = Math.max(this._maxUid, uid);
    this._numPositionUpdates = 0;
  }

  _parseCurrentHash(checkNameddest = false) {
    const hash = unescape(getCurrentHash()).substring(1);
    const params = (0, _ui_utils.parseQueryString)(hash);
    const nameddest = params.nameddest || "";
    let page = params.page | 0;

    if (!this._isValidPage(page) || checkNameddest && nameddest.length > 0) {
      page = null;
    }

    return {
      hash,
      page,
      rotation: this.linkService.rotation
    };
  }

  _updateViewarea({
    location
  }) {
    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }

    this._position = {
      hash: this._isViewerInPresentationMode ? `page=${location.pageNumber}` : location.pdfOpenParams.substring(1),
      page: this.linkService.page,
      first: location.pageNumber,
      rotation: location.rotation
    };

    if (this._popStateInProgress) {
      return;
    }

    if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
      this._numPositionUpdates++;
    }

    if (UPDATE_VIEWAREA_TIMEOUT > 0) {
      this._updateViewareaTimeout = setTimeout(() => {
        if (!this._popStateInProgress) {
          this._tryPushCurrentPosition(true);
        }

        this._updateViewareaTimeout = null;
      }, UPDATE_VIEWAREA_TIMEOUT);
    }
  }

  _popState({
    state
  }) {
    const newHash = getCurrentHash(),
          hashChanged = this._currentHash !== newHash;
    this._currentHash = newHash;

    if (!state) {
      this._uid++;

      const {
        hash,
        page,
        rotation
      } = this._parseCurrentHash();

      this._pushOrReplaceState({
        hash,
        page,
        rotation
      }, true);

      return;
    }

    if (!this._isValidState(state)) {
      return;
    }

    this._popStateInProgress = true;

    if (hashChanged) {
      this._blockHashChange++;
      (0, _ui_utils.waitOnEventOrTimeout)({
        target: window,
        name: "hashchange",
        delay: HASH_CHANGE_TIMEOUT
      }).then(() => {
        this._blockHashChange--;
      });
    }

    const destination = state.destination;

    this._updateInternalState(destination, state.uid, true);

    if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
      this.linkService.rotation = destination.rotation;
    }

    if (destination.dest) {
      this.linkService.goToDestination(destination.dest);
    } else if (destination.hash) {
      this.linkService.setHash(destination.hash);
    } else if (destination.page) {
      this.linkService.page = destination.page;
    }

    Promise.resolve().then(() => {
      this._popStateInProgress = false;
    });
  }

  _pageHide() {
    if (!this._destination || this._destination.temporary) {
      this._tryPushCurrentPosition();
    }
  }

  _bindEvents() {
    if (this._boundEvents) {
      return;
    }

    this._boundEvents = {
      updateViewarea: this._updateViewarea.bind(this),
      popState: this._popState.bind(this),
      pageHide: this._pageHide.bind(this)
    };

    this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);

    window.addEventListener("popstate", this._boundEvents.popState);
    window.addEventListener("pagehide", this._boundEvents.pageHide);
  }

  _unbindEvents() {
    if (!this._boundEvents) {
      return;
    }

    this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);

    window.removeEventListener("popstate", this._boundEvents.popState);
    window.removeEventListener("pagehide", this._boundEvents.pageHide);
    this._boundEvents = null;
  }

}

exports.PDFHistory = PDFHistory;

function isDestHashesEqual(destHash, pushHash) {
  if (typeof destHash !== "string" || typeof pushHash !== "string") {
    return false;
  }

  if (destHash === pushHash) {
    return true;
  }

  const {
    nameddest
  } = (0, _ui_utils.parseQueryString)(destHash);

  if (nameddest === pushHash) {
    return true;
  }

  return false;
}

function isDestArraysEqual(firstDest, secondDest) {
  function isEntryEqual(first, second) {
    if (typeof first !== typeof second) {
      return false;
    }

    if (Array.isArray(first) || Array.isArray(second)) {
      return false;
    }

    if (first !== null && typeof first === "object" && second !== null) {
      if (Object.keys(first).length !== Object.keys(second).length) {
        return false;
      }

      for (const key in first) {
        if (!isEntryEqual(first[key], second[key])) {
          return false;
        }
      }

      return true;
    }

    return first === second || Number.isNaN(first) && Number.isNaN(second);
  }

  if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
    return false;
  }

  if (firstDest.length !== secondDest.length) {
    return false;
  }

  for (let i = 0, ii = firstDest.length; i < ii; i++) {
    if (!isEntryEqual(firstDest[i], secondDest[i])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFLayerViewer = void 0;

var _base_tree_viewer = __webpack_require__(12);

class PDFLayerViewer extends _base_tree_viewer.BaseTreeViewer {
  constructor(options) {
    super(options);
    this.l10n = options.l10n;

    this.eventBus._on("resetlayers", this._resetLayers.bind(this));

    this.eventBus._on("togglelayerstree", this._toggleAllTreeItems.bind(this));
  }

  reset() {
    super.reset();
    this._optionalContentConfig = null;
  }

  _dispatchEvent(layersCount) {
    this.eventBus.dispatch("layersloaded", {
      source: this,
      layersCount
    });
  }

  _bindLink(element, {
    groupId,
    input
  }) {
    const setVisibility = () => {
      this._optionalContentConfig.setVisibility(groupId, input.checked);

      this.eventBus.dispatch("optionalcontentconfig", {
        source: this,
        promise: Promise.resolve(this._optionalContentConfig)
      });
    };

    element.onclick = evt => {
      if (evt.target === input) {
        setVisibility();
        return true;
      } else if (evt.target !== element) {
        return true;
      }

      input.checked = !input.checked;
      setVisibility();
      return false;
    };
  }

  async _setNestedName(element, {
    name = null
  }) {
    if (typeof name === "string") {
      element.textContent = this._normalizeTextContent(name);
      return;
    }

    element.textContent = await this.l10n.get("additional_layers");
    element.style.fontStyle = "italic";
  }

  _addToggleButton(div, {
    name = null
  }) {
    super._addToggleButton(div, name === null);
  }

  _toggleAllTreeItems() {
    if (!this._optionalContentConfig) {
      return;
    }

    super._toggleAllTreeItems();
  }

  render({
    optionalContentConfig,
    pdfDocument
  }) {
    if (this._optionalContentConfig) {
      this.reset();
    }

    this._optionalContentConfig = optionalContentConfig || null;
    this._pdfDocument = pdfDocument || null;
    const groups = optionalContentConfig?.getOrder();

    if (!groups) {
      this._dispatchEvent(0);

      return;
    }

    const fragment = document.createDocumentFragment(),
          queue = [{
      parent: fragment,
      groups
    }];
    let layersCount = 0,
        hasAnyNesting = false;

    while (queue.length > 0) {
      const levelData = queue.shift();

      for (const groupId of levelData.groups) {
        const div = document.createElement("div");
        div.className = "treeItem";
        const element = document.createElement("a");
        div.appendChild(element);

        if (typeof groupId === "object") {
          hasAnyNesting = true;

          this._addToggleButton(div, groupId);

          this._setNestedName(element, groupId);

          const itemsDiv = document.createElement("div");
          itemsDiv.className = "treeItems";
          div.appendChild(itemsDiv);
          queue.push({
            parent: itemsDiv,
            groups: groupId.order
          });
        } else {
          const group = optionalContentConfig.getGroup(groupId);
          const input = document.createElement("input");

          this._bindLink(element, {
            groupId,
            input
          });

          input.type = "checkbox";
          input.id = groupId;
          input.checked = group.visible;
          const label = document.createElement("label");
          label.setAttribute("for", groupId);
          label.textContent = this._normalizeTextContent(group.name);
          element.appendChild(input);
          element.appendChild(label);
          layersCount++;
        }

        levelData.parent.appendChild(div);
      }
    }

    this._finishRendering(fragment, layersCount, hasAnyNesting);
  }

  async _resetLayers() {
    if (!this._optionalContentConfig) {
      return;
    }

    const optionalContentConfig = await this._pdfDocument.getOptionalContentConfig();
    this.eventBus.dispatch("optionalcontentconfig", {
      source: this,
      promise: Promise.resolve(optionalContentConfig)
    });
    this.render({
      optionalContentConfig,
      pdfDocument: this._pdfDocument
    });
  }

}

exports.PDFLayerViewer = PDFLayerViewer;

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SimpleLinkService = exports.PDFLinkService = void 0;

var _ui_utils = __webpack_require__(4);

class PDFLinkService {
  constructor({
    eventBus,
    externalLinkTarget = null,
    externalLinkRel = null,
    externalLinkEnabled = true,
    ignoreDestinationZoom = false
  } = {}) {
    this.eventBus = eventBus;
    this.externalLinkTarget = externalLinkTarget;
    this.externalLinkRel = externalLinkRel;
    this.externalLinkEnabled = externalLinkEnabled;
    this._ignoreDestinationZoom = ignoreDestinationZoom;
    this.baseUrl = null;
    this.pdfDocument = null;
    this.pdfViewer = null;
    this.pdfHistory = null;
    this._pagesRefCache = null;
  }

  setDocument(pdfDocument, baseUrl = null) {
    this.baseUrl = baseUrl;
    this.pdfDocument = pdfDocument;
    this._pagesRefCache = Object.create(null);
  }

  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }

  setHistory(pdfHistory) {
    this.pdfHistory = pdfHistory;
  }

  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }

  get page() {
    return this.pdfViewer.currentPageNumber;
  }

  set page(value) {
    this.pdfViewer.currentPageNumber = value;
  }

  get rotation() {
    return this.pdfViewer.pagesRotation;
  }

  set rotation(value) {
    this.pdfViewer.pagesRotation = value;
  }

  _goToDestinationHelper(rawDest, namedDest = null, explicitDest) {
    const destRef = explicitDest[0];
    let pageNumber;

    if (destRef instanceof Object) {
      pageNumber = this._cachedPageNumber(destRef);

      if (pageNumber === null) {
        this.pdfDocument.getPageIndex(destRef).then(pageIndex => {
          this.cachePageRef(pageIndex + 1, destRef);

          this._goToDestinationHelper(rawDest, namedDest, explicitDest);
        }).catch(() => {
          console.error(`PDFLinkService._goToDestinationHelper: "${destRef}" is not ` + `a valid page reference, for dest="${rawDest}".`);
        });
        return;
      }
    } else if (Number.isInteger(destRef)) {
      pageNumber = destRef + 1;
    } else {
      console.error(`PDFLinkService._goToDestinationHelper: "${destRef}" is not ` + `a valid destination reference, for dest="${rawDest}".`);
      return;
    }

    if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
      console.error(`PDFLinkService._goToDestinationHelper: "${pageNumber}" is not ` + `a valid page number, for dest="${rawDest}".`);
      return;
    }

    if (this.pdfHistory) {
      this.pdfHistory.pushCurrentPosition();
      this.pdfHistory.push({
        namedDest,
        explicitDest,
        pageNumber
      });
    }

    this.pdfViewer.scrollPageIntoView({
      pageNumber,
      destArray: explicitDest,
      ignoreDestinationZoom: this._ignoreDestinationZoom
    });
  }

  async goToDestination(dest) {
    if (!this.pdfDocument) {
      return;
    }

    let namedDest, explicitDest;

    if (typeof dest === "string") {
      namedDest = dest;
      explicitDest = await this.pdfDocument.getDestination(dest);
    } else {
      namedDest = null;
      explicitDest = await dest;
    }

    if (!Array.isArray(explicitDest)) {
      console.error(`PDFLinkService.goToDestination: "${explicitDest}" is not ` + `a valid destination array, for dest="${dest}".`);
      return;
    }

    this._goToDestinationHelper(dest, namedDest, explicitDest);
  }

  goToPage(val) {
    if (!this.pdfDocument) {
      return;
    }

    const pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;

    if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
      console.error(`PDFLinkService.goToPage: "${val}" is not a valid page.`);
      return;
    }

    if (this.pdfHistory) {
      this.pdfHistory.pushCurrentPosition();
      this.pdfHistory.pushPage(pageNumber);
    }

    this.pdfViewer.scrollPageIntoView({
      pageNumber
    });
  }

  getDestinationHash(dest) {
    if (typeof dest === "string") {
      if (dest.length > 0) {
        return this.getAnchorUrl("#" + escape(dest));
      }
    } else if (Array.isArray(dest)) {
      const str = JSON.stringify(dest);

      if (str.length > 0) {
        return this.getAnchorUrl("#" + escape(str));
      }
    }

    return this.getAnchorUrl("");
  }

  getAnchorUrl(anchor) {
    return (this.baseUrl || "") + anchor;
  }

  setHash(hash) {
    if (!this.pdfDocument) {
      return;
    }

    let pageNumber, dest;

    if (hash.includes("=")) {
      const params = (0, _ui_utils.parseQueryString)(hash);

      if ("search" in params) {
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: params.search.replace(/"/g, ""),
          phraseSearch: params.phrase === "true"
        });
      }

      if ("page" in params) {
        pageNumber = params.page | 0 || 1;
      }

      if ("zoom" in params) {
        const zoomArgs = params.zoom.split(",");
        const zoomArg = zoomArgs[0];
        const zoomArgNumber = parseFloat(zoomArg);

        if (!zoomArg.includes("Fit")) {
          dest = [null, {
            name: "XYZ"
          }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
        } else {
          if (zoomArg === "Fit" || zoomArg === "FitB") {
            dest = [null, {
              name: zoomArg
            }];
          } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
            dest = [null, {
              name: zoomArg
            }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
          } else if (zoomArg === "FitR") {
            if (zoomArgs.length !== 5) {
              console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
            } else {
              dest = [null, {
                name: zoomArg
              }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
            }
          } else {
            console.error(`PDFLinkService.setHash: "${zoomArg}" is not ` + "a valid zoom value.");
          }
        }
      }

      if (dest) {
        this.pdfViewer.scrollPageIntoView({
          pageNumber: pageNumber || this.page,
          destArray: dest,
          allowNegativeOffset: true
        });
      } else if (pageNumber) {
        this.page = pageNumber;
      }

      if ("pagemode" in params) {
        this.eventBus.dispatch("pagemode", {
          source: this,
          mode: params.pagemode
        });
      }

      if ("nameddest" in params) {
        this.goToDestination(params.nameddest);
      }
    } else {
      dest = unescape(hash);

      try {
        dest = JSON.parse(dest);

        if (!Array.isArray(dest)) {
          dest = dest.toString();
        }
      } catch (ex) {}

      if (typeof dest === "string" || isValidExplicitDestination(dest)) {
        this.goToDestination(dest);
        return;
      }

      console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not ` + "a valid destination.");
    }
  }

  executeNamedAction(action) {
    switch (action) {
      case "GoBack":
        if (this.pdfHistory) {
          this.pdfHistory.back();
        }

        break;

      case "GoForward":
        if (this.pdfHistory) {
          this.pdfHistory.forward();
        }

        break;

      case "NextPage":
        this.pdfViewer.nextPage();
        break;

      case "PrevPage":
        this.pdfViewer.previousPage();
        break;

      case "LastPage":
        this.page = this.pagesCount;
        break;

      case "FirstPage":
        this.page = 1;
        break;

      default:
        break;
    }

    this.eventBus.dispatch("namedaction", {
      source: this,
      action
    });
  }

  cachePageRef(pageNum, pageRef) {
    if (!pageRef) {
      return;
    }

    const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
    this._pagesRefCache[refStr] = pageNum;
  }

  _cachedPageNumber(pageRef) {
    const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
    return this._pagesRefCache?.[refStr] || null;
  }

  isPageVisible(pageNumber) {
    return this.pdfViewer.isPageVisible(pageNumber);
  }

  isPageCached(pageNumber) {
    return this.pdfViewer.isPageCached(pageNumber);
  }

}

exports.PDFLinkService = PDFLinkService;

function isValidExplicitDestination(dest) {
  if (!Array.isArray(dest)) {
    return false;
  }

  const destLength = dest.length;

  if (destLength < 2) {
    return false;
  }

  const page = dest[0];

  if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
    return false;
  }

  const zoom = dest[1];

  if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
    return false;
  }

  let allowNull = true;

  switch (zoom.name) {
    case "XYZ":
      if (destLength !== 5) {
        return false;
      }

      break;

    case "Fit":
    case "FitB":
      return destLength === 2;

    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (destLength !== 3) {
        return false;
      }

      break;

    case "FitR":
      if (destLength !== 6) {
        return false;
      }

      allowNull = false;
      break;

    default:
      return false;
  }

  for (let i = 2; i < destLength; i++) {
    const param = dest[i];

    if (!(typeof param === "number" || allowNull && param === null)) {
      return false;
    }
  }

  return true;
}

class SimpleLinkService {
  constructor() {
    this.externalLinkTarget = null;
    this.externalLinkRel = null;
    this.externalLinkEnabled = true;
    this._ignoreDestinationZoom = false;
  }

  get pagesCount() {
    return 0;
  }

  get page() {
    return 0;
  }

  set page(value) {}

  get rotation() {
    return 0;
  }

  set rotation(value) {}

  async goToDestination(dest) {}

  goToPage(val) {}

  getDestinationHash(dest) {
    return "#";
  }

  getAnchorUrl(hash) {
    return "#";
  }

  setHash(hash) {}

  executeNamedAction(action) {}

  cachePageRef(pageNum, pageRef) {}

  isPageVisible(pageNumber) {
    return true;
  }

  isPageCached(pageNumber) {
    return true;
  }

}

exports.SimpleLinkService = SimpleLinkService;

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFOutlineViewer = void 0;

var _pdfjsLib = __webpack_require__(5);

var _base_tree_viewer = __webpack_require__(12);

var _ui_utils = __webpack_require__(4);

class PDFOutlineViewer extends _base_tree_viewer.BaseTreeViewer {
  constructor(options) {
    super(options);
    this.linkService = options.linkService;

    this.eventBus._on("toggleoutlinetree", this._toggleAllTreeItems.bind(this));

    this.eventBus._on("currentoutlineitem", this._currentOutlineItem.bind(this));

    this.eventBus._on("pagechanging", evt => {
      this._currentPageNumber = evt.pageNumber;
    });

    this.eventBus._on("pagesloaded", evt => {
      this._isPagesLoaded = !!evt.pagesCount;

      if (this._currentOutlineItemCapability && !this._currentOutlineItemCapability.settled) {
        this._currentOutlineItemCapability.resolve(this._isPagesLoaded);
      }
    });

    this.eventBus._on("sidebarviewchanged", evt => {
      this._sidebarView = evt.view;
    });
  }

  reset() {
    super.reset();
    this._outline = null;
    this._pageNumberToDestHashCapability = null;
    this._currentPageNumber = 1;
    this._isPagesLoaded = false;

    if (this._currentOutlineItemCapability && !this._currentOutlineItemCapability.settled) {
      this._currentOutlineItemCapability.resolve(false);
    }

    this._currentOutlineItemCapability = null;
  }

  _dispatchEvent(outlineCount) {
    this._currentOutlineItemCapability = (0, _pdfjsLib.createPromiseCapability)();

    if (outlineCount === 0 || this._pdfDocument?.loadingParams.disableAutoFetch) {
      this._currentOutlineItemCapability.resolve(false);
    } else if (this._isPagesLoaded) {
      this._currentOutlineItemCapability.resolve(true);
    }

    this.eventBus.dispatch("outlineloaded", {
      source: this,
      outlineCount,
      currentOutlineItemPromise: this._currentOutlineItemCapability.promise
    });
  }

  _bindLink(element, {
    url,
    newWindow,
    dest
  }) {
    const {
      linkService
    } = this;

    if (url) {
      (0, _pdfjsLib.addLinkAttributes)(element, {
        url,
        target: newWindow ? _pdfjsLib.LinkTarget.BLANK : linkService.externalLinkTarget,
        rel: linkService.externalLinkRel,
        enabled: linkService.externalLinkEnabled
      });
      return;
    }

    element.href = linkService.getDestinationHash(dest);

    element.onclick = evt => {
      this._updateCurrentTreeItem(evt.target.parentNode);

      if (dest) {
        linkService.goToDestination(dest);
      }

      return false;
    };
  }

  _setStyles(element, {
    bold,
    italic
  }) {
    if (bold) {
      element.style.fontWeight = "bold";
    }

    if (italic) {
      element.style.fontStyle = "italic";
    }
  }

  _addToggleButton(div, {
    count,
    items
  }) {
    let hidden = false;

    if (count < 0) {
      let totalCount = items.length;

      if (totalCount > 0) {
        const queue = [...items];

        while (queue.length > 0) {
          const {
            count: nestedCount,
            items: nestedItems
          } = queue.shift();

          if (nestedCount > 0 && nestedItems.length > 0) {
            totalCount += nestedItems.length;
            queue.push(...nestedItems);
          }
        }
      }

      if (Math.abs(count) === totalCount) {
        hidden = true;
      }
    }

    super._addToggleButton(div, hidden);
  }

  _toggleAllTreeItems() {
    if (!this._outline) {
      return;
    }

    super._toggleAllTreeItems();
  }

  render({
    outline,
    pdfDocument
  }) {
    if (this._outline) {
      this.reset();
    }

    this._outline = outline || null;
    this._pdfDocument = pdfDocument || null;

    if (!outline) {
      this._dispatchEvent(0);

      return;
    }

    const fragment = document.createDocumentFragment();
    const queue = [{
      parent: fragment,
      items: outline
    }];
    let outlineCount = 0,
        hasAnyNesting = false;

    while (queue.length > 0) {
      const levelData = queue.shift();

      for (const item of levelData.items) {
        const div = document.createElement("div");
        div.className = "treeItem";
        const element = document.createElement("a");

        this._bindLink(element, item);

        this._setStyles(element, item);

        element.textContent = this._normalizeTextContent(item.title);
        div.appendChild(element);

        if (item.items.length > 0) {
          hasAnyNesting = true;

          this._addToggleButton(div, item);

          const itemsDiv = document.createElement("div");
          itemsDiv.className = "treeItems";
          div.appendChild(itemsDiv);
          queue.push({
            parent: itemsDiv,
            items: item.items
          });
        }

        levelData.parent.appendChild(div);
        outlineCount++;
      }
    }

    this._finishRendering(fragment, outlineCount, hasAnyNesting);
  }

  async _currentOutlineItem() {
    if (!this._isPagesLoaded) {
      throw new Error("_currentOutlineItem: All pages have not been loaded.");
    }

    if (!this._outline || !this._pdfDocument) {
      return;
    }

    const pageNumberToDestHash = await this._getPageNumberToDestHash(this._pdfDocument);

    if (!pageNumberToDestHash) {
      return;
    }

    this._updateCurrentTreeItem(null);

    if (this._sidebarView !== _ui_utils.SidebarView.OUTLINE) {
      return;
    }

    for (let i = this._currentPageNumber; i > 0; i--) {
      const destHash = pageNumberToDestHash.get(i);

      if (!destHash) {
        continue;
      }

      const linkElement = this.container.querySelector(`a[href="${destHash}"]`);

      if (!linkElement) {
        continue;
      }

      this._scrollToCurrentTreeItem(linkElement.parentNode);

      break;
    }
  }

  async _getPageNumberToDestHash(pdfDocument) {
    if (this._pageNumberToDestHashCapability) {
      return this._pageNumberToDestHashCapability.promise;
    }

    this._pageNumberToDestHashCapability = (0, _pdfjsLib.createPromiseCapability)();
    const pageNumberToDestHash = new Map(),
          pageNumberNesting = new Map();
    const queue = [{
      nesting: 0,
      items: this._outline
    }];

    while (queue.length > 0) {
      const levelData = queue.shift(),
            currentNesting = levelData.nesting;

      for (const {
        dest,
        items
      } of levelData.items) {
        let explicitDest, pageNumber;

        if (typeof dest === "string") {
          explicitDest = await pdfDocument.getDestination(dest);

          if (pdfDocument !== this._pdfDocument) {
            return null;
          }
        } else {
          explicitDest = dest;
        }

        if (Array.isArray(explicitDest)) {
          const [destRef] = explicitDest;

          if (destRef instanceof Object) {
            pageNumber = this.linkService._cachedPageNumber(destRef);

            if (!pageNumber) {
              try {
                pageNumber = (await pdfDocument.getPageIndex(destRef)) + 1;

                if (pdfDocument !== this._pdfDocument) {
                  return null;
                }

                this.linkService.cachePageRef(pageNumber, destRef);
              } catch (ex) {}
            }
          } else if (Number.isInteger(destRef)) {
            pageNumber = destRef + 1;
          }

          if (Number.isInteger(pageNumber) && (!pageNumberToDestHash.has(pageNumber) || currentNesting > pageNumberNesting.get(pageNumber))) {
            const destHash = this.linkService.getDestinationHash(dest);
            pageNumberToDestHash.set(pageNumber, destHash);
            pageNumberNesting.set(pageNumber, currentNesting);
          }
        }

        if (items.length > 0) {
          queue.push({
            nesting: currentNesting + 1,
            items
          });
        }
      }
    }

    this._pageNumberToDestHashCapability.resolve(pageNumberToDestHash.size > 0 ? pageNumberToDestHash : null);

    return this._pageNumberToDestHashCapability.promise;
  }

}

exports.PDFOutlineViewer = PDFOutlineViewer;

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFPresentationMode = void 0;

var _ui_utils = __webpack_require__(4);

const DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1500;
const DELAY_BEFORE_HIDING_CONTROLS = 3000;
const ACTIVE_SELECTOR = "pdfPresentationMode";
const CONTROLS_SELECTOR = "pdfPresentationModeControls";
const MOUSE_SCROLL_COOLDOWN_TIME = 50;
const PAGE_SWITCH_THRESHOLD = 0.1;
const SWIPE_MIN_DISTANCE_THRESHOLD = 50;
const SWIPE_ANGLE_THRESHOLD = Math.PI / 6;

class PDFPresentationMode {
  constructor({
    container,
    pdfViewer,
    eventBus
  }) {
    this.container = container;
    this.pdfViewer = pdfViewer;
    this.eventBus = eventBus;
    this.active = false;
    this.args = null;
    this.contextMenuOpen = false;
    this.mouseScrollTimeStamp = 0;
    this.mouseScrollDelta = 0;
    this.touchSwipeState = null;
  }

  request() {
    if (this.switchInProgress || this.active || !this.pdfViewer.pagesCount) {
      return false;
    }

    this._addFullscreenChangeListeners();

    this._setSwitchInProgress();

    this._notifyStateChange();

    if (this.container.requestFullscreen) {
      this.container.requestFullscreen();
    } else if (this.container.mozRequestFullScreen) {
      this.container.mozRequestFullScreen();
    } else if (this.container.webkitRequestFullscreen) {
      this.container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    } else {
      return false;
    }

    this.args = {
      page: this.pdfViewer.currentPageNumber,
      previousScale: this.pdfViewer.currentScaleValue
    };
    return true;
  }

  _mouseWheel(evt) {
    if (!this.active) {
      return;
    }

    evt.preventDefault();
    const delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);
    const currentTime = Date.now();
    const storedTime = this.mouseScrollTimeStamp;

    if (currentTime > storedTime && currentTime - storedTime < MOUSE_SCROLL_COOLDOWN_TIME) {
      return;
    }

    if (this.mouseScrollDelta > 0 && delta < 0 || this.mouseScrollDelta < 0 && delta > 0) {
      this._resetMouseScrollState();
    }

    this.mouseScrollDelta += delta;

    if (Math.abs(this.mouseScrollDelta) >= PAGE_SWITCH_THRESHOLD) {
      const totalDelta = this.mouseScrollDelta;

      this._resetMouseScrollState();

      const success = totalDelta > 0 ? this.pdfViewer.previousPage() : this.pdfViewer.nextPage();

      if (success) {
        this.mouseScrollTimeStamp = currentTime;
      }
    }
  }

  get isFullscreen() {
    return !!(document.fullscreenElement || document.mozFullScreen || document.webkitIsFullScreen);
  }

  _notifyStateChange() {
    let state = _ui_utils.PresentationModeState.NORMAL;

    if (this.switchInProgress) {
      state = _ui_utils.PresentationModeState.CHANGING;
    } else if (this.active) {
      state = _ui_utils.PresentationModeState.FULLSCREEN;
    }

    this.eventBus.dispatch("presentationmodechanged", {
      source: this,
      state
    });
  }

  _setSwitchInProgress() {
    if (this.switchInProgress) {
      clearTimeout(this.switchInProgress);
    }

    this.switchInProgress = setTimeout(() => {
      this._removeFullscreenChangeListeners();

      delete this.switchInProgress;

      this._notifyStateChange();
    }, DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS);
  }

  _resetSwitchInProgress() {
    if (this.switchInProgress) {
      clearTimeout(this.switchInProgress);
      delete this.switchInProgress;
    }
  }

  _enter() {
    this.active = true;

    this._resetSwitchInProgress();

    this._notifyStateChange();

    this.container.classList.add(ACTIVE_SELECTOR);
    setTimeout(() => {
      this.pdfViewer.currentPageNumber = this.args.page;
      this.pdfViewer.currentScaleValue = "page-fit";
    }, 0);

    this._addWindowListeners();

    this._showControls();

    this.contextMenuOpen = false;
    window.getSelection().removeAllRanges();
  }

  _exit() {
    const page = this.pdfViewer.currentPageNumber;
    this.container.classList.remove(ACTIVE_SELECTOR);
    setTimeout(() => {
      this.active = false;

      this._removeFullscreenChangeListeners();

      this._notifyStateChange();

      this.pdfViewer.currentScaleValue = this.args.previousScale;
      this.pdfViewer.currentPageNumber = page;
      this.args = null;
    }, 0);

    this._removeWindowListeners();

    this._hideControls();

    this._resetMouseScrollState();

    this.contextMenuOpen = false;
  }

  _mouseDown(evt) {
    if (this.contextMenuOpen) {
      this.contextMenuOpen = false;
      evt.preventDefault();
      return;
    }

    if (evt.button === 0) {
      const isInternalLink = evt.target.href && evt.target.classList.contains("internalLink");

      if (!isInternalLink) {
        evt.preventDefault();

        if (evt.shiftKey) {
          this.pdfViewer.previousPage();
        } else {
          this.pdfViewer.nextPage();
        }
      }
    }
  }

  _contextMenu() {
    this.contextMenuOpen = true;
  }

  _showControls() {
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
    } else {
      this.container.classList.add(CONTROLS_SELECTOR);
    }

    this.controlsTimeout = setTimeout(() => {
      this.container.classList.remove(CONTROLS_SELECTOR);
      delete this.controlsTimeout;
    }, DELAY_BEFORE_HIDING_CONTROLS);
  }

  _hideControls() {
    if (!this.controlsTimeout) {
      return;
    }

    clearTimeout(this.controlsTimeout);
    this.container.classList.remove(CONTROLS_SELECTOR);
    delete this.controlsTimeout;
  }

  _resetMouseScrollState() {
    this.mouseScrollTimeStamp = 0;
    this.mouseScrollDelta = 0;
  }

  _touchSwipe(evt) {
    if (!this.active) {
      return;
    }

    if (evt.touches.length > 1) {
      this.touchSwipeState = null;
      return;
    }

    switch (evt.type) {
      case "touchstart":
        this.touchSwipeState = {
          startX: evt.touches[0].pageX,
          startY: evt.touches[0].pageY,
          endX: evt.touches[0].pageX,
          endY: evt.touches[0].pageY
        };
        break;

      case "touchmove":
        if (this.touchSwipeState === null) {
          return;
        }

        this.touchSwipeState.endX = evt.touches[0].pageX;
        this.touchSwipeState.endY = evt.touches[0].pageY;
        evt.preventDefault();
        break;

      case "touchend":
        if (this.touchSwipeState === null) {
          return;
        }

        let delta = 0;
        const dx = this.touchSwipeState.endX - this.touchSwipeState.startX;
        const dy = this.touchSwipeState.endY - this.touchSwipeState.startY;
        const absAngle = Math.abs(Math.atan2(dy, dx));

        if (Math.abs(dx) > SWIPE_MIN_DISTANCE_THRESHOLD && (absAngle <= SWIPE_ANGLE_THRESHOLD || absAngle >= Math.PI - SWIPE_ANGLE_THRESHOLD)) {
          delta = dx;
        } else if (Math.abs(dy) > SWIPE_MIN_DISTANCE_THRESHOLD && Math.abs(absAngle - Math.PI / 2) <= SWIPE_ANGLE_THRESHOLD) {
          delta = dy;
        }

        if (delta > 0) {
          this.pdfViewer.previousPage();
        } else if (delta < 0) {
          this.pdfViewer.nextPage();
        }

        break;
    }
  }

  _addWindowListeners() {
    this.showControlsBind = this._showControls.bind(this);
    this.mouseDownBind = this._mouseDown.bind(this);
    this.mouseWheelBind = this._mouseWheel.bind(this);
    this.resetMouseScrollStateBind = this._resetMouseScrollState.bind(this);
    this.contextMenuBind = this._contextMenu.bind(this);
    this.touchSwipeBind = this._touchSwipe.bind(this);
    window.addEventListener("mousemove", this.showControlsBind);
    window.addEventListener("mousedown", this.mouseDownBind);
    window.addEventListener("wheel", this.mouseWheelBind, {
      passive: false
    });
    window.addEventListener("keydown", this.resetMouseScrollStateBind);
    window.addEventListener("contextmenu", this.contextMenuBind);
    window.addEventListener("touchstart", this.touchSwipeBind);
    window.addEventListener("touchmove", this.touchSwipeBind);
    window.addEventListener("touchend", this.touchSwipeBind);
  }

  _removeWindowListeners() {
    window.removeEventListener("mousemove", this.showControlsBind);
    window.removeEventListener("mousedown", this.mouseDownBind);
    window.removeEventListener("wheel", this.mouseWheelBind, {
      passive: false
    });
    window.removeEventListener("keydown", this.resetMouseScrollStateBind);
    window.removeEventListener("contextmenu", this.contextMenuBind);
    window.removeEventListener("touchstart", this.touchSwipeBind);
    window.removeEventListener("touchmove", this.touchSwipeBind);
    window.removeEventListener("touchend", this.touchSwipeBind);
    delete this.showControlsBind;
    delete this.mouseDownBind;
    delete this.mouseWheelBind;
    delete this.resetMouseScrollStateBind;
    delete this.contextMenuBind;
    delete this.touchSwipeBind;
  }

  _fullscreenChange() {
    if (this.isFullscreen) {
      this._enter();
    } else {
      this._exit();
    }
  }

  _addFullscreenChangeListeners() {
    this.fullscreenChangeBind = this._fullscreenChange.bind(this);
    window.addEventListener("fullscreenchange", this.fullscreenChangeBind);
    window.addEventListener("mozfullscreenchange", this.fullscreenChangeBind);
    window.addEventListener("webkitfullscreenchange", this.fullscreenChangeBind);
  }

  _removeFullscreenChangeListeners() {
    window.removeEventListener("fullscreenchange", this.fullscreenChangeBind);
    window.removeEventListener("mozfullscreenchange", this.fullscreenChangeBind);
    window.removeEventListener("webkitfullscreenchange", this.fullscreenChangeBind);
    delete this.fullscreenChangeBind;
  }

}

exports.PDFPresentationMode = PDFPresentationMode;

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFScriptingManager = void 0;

var _pdfjsLib = __webpack_require__(5);

var _ui_utils = __webpack_require__(4);

var _pdf_rendering_queue = __webpack_require__(8);

class PDFScriptingManager {
  constructor({
    eventBus,
    sandboxBundleSrc = null,
    scriptingFactory = null,
    docPropertiesLookup = null
  }) {
    this._pdfDocument = null;
    this._pdfViewer = null;
    this._closeCapability = null;
    this._destroyCapability = null;
    this._scripting = null;
    this._mouseState = Object.create(null);
    this._pageEventsReady = false;
    this._ready = false;
    this._eventBus = eventBus;
    this._sandboxBundleSrc = sandboxBundleSrc;
    this._scriptingFactory = scriptingFactory;
    this._docPropertiesLookup = docPropertiesLookup;
  }

  setViewer(pdfViewer) {
    this._pdfViewer = pdfViewer;
  }

  async setDocument(pdfDocument) {
    if (this._pdfDocument) {
      await this._destroyScripting();
    }

    this._pdfDocument = pdfDocument;

    if (!pdfDocument) {
      return;
    }

    const [objects, calculationOrder, docActions] = await Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]);

    if (!objects && !docActions) {
      await this._destroyScripting();
      return;
    }

    if (pdfDocument !== this._pdfDocument) {
      return;
    }

    this._scripting = this._createScripting();

    this._internalEvents.set("updatefromsandbox", event => {
      if (event?.source !== window) {
        return;
      }

      this._updateFromSandbox(event.detail);
    });

    this._internalEvents.set("dispatcheventinsandbox", event => {
      this._scripting?.dispatchEventInSandbox(event.detail);
    });

    this._internalEvents.set("pagechanging", ({
      pageNumber,
      previous
    }) => {
      if (pageNumber === previous) {
        return;
      }

      this._dispatchPageClose(previous);

      this._dispatchPageOpen(pageNumber);
    });

    this._internalEvents.set("pagerendered", ({
      pageNumber
    }) => {
      if (!this._pageOpenPending.has(pageNumber)) {
        return;
      }

      if (pageNumber !== this._pdfViewer.currentPageNumber) {
        return;
      }

      this._dispatchPageOpen(pageNumber);
    });

    this._internalEvents.set("pagesdestroy", async event => {
      await this._dispatchPageClose(this._pdfViewer.currentPageNumber);
      await this._scripting?.dispatchEventInSandbox({
        id: "doc",
        name: "WillClose"
      });
      this._closeCapability?.resolve();
    });

    this._domEvents.set("mousedown", event => {
      this._mouseState.isDown = true;
    });

    this._domEvents.set("mouseup", event => {
      this._mouseState.isDown = false;
    });

    for (const [name, listener] of this._internalEvents) {
      this._eventBus._on(name, listener);
    }

    for (const [name, listener] of this._domEvents) {
      window.addEventListener(name, listener);
    }

    try {
      const docProperties = await this._getDocProperties();

      if (pdfDocument !== this._pdfDocument) {
        return;
      }

      await this._scripting.createSandbox({
        objects,
        calculationOrder,
        appInfo: {
          platform: navigator.platform,
          language: navigator.language
        },
        docInfo: { ...docProperties,
          actions: docActions
        }
      });

      this._eventBus.dispatch("sandboxcreated", {
        source: this
      });
    } catch (error) {
      console.error(`PDFScriptingManager.setDocument: "${error?.message}".`);
      await this._destroyScripting();
      return;
    }

    await this._scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "Open"
    });
    await this._dispatchPageOpen(this._pdfViewer.currentPageNumber, true);
    Promise.resolve().then(() => {
      if (pdfDocument === this._pdfDocument) {
        this._ready = true;
      }
    });
  }

  async dispatchWillSave(detail) {
    return this._scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "WillSave"
    });
  }

  async dispatchDidSave(detail) {
    return this._scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "DidSave"
    });
  }

  async dispatchWillPrint(detail) {
    return this._scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "WillPrint"
    });
  }

  async dispatchDidPrint(detail) {
    return this._scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "DidPrint"
    });
  }

  get mouseState() {
    return this._mouseState;
  }

  get destroyPromise() {
    return this._destroyCapability?.promise || null;
  }

  get ready() {
    return this._ready;
  }

  get _internalEvents() {
    return (0, _pdfjsLib.shadow)(this, "_internalEvents", new Map());
  }

  get _domEvents() {
    return (0, _pdfjsLib.shadow)(this, "_domEvents", new Map());
  }

  get _pageOpenPending() {
    return (0, _pdfjsLib.shadow)(this, "_pageOpenPending", new Set());
  }

  get _visitedPages() {
    return (0, _pdfjsLib.shadow)(this, "_visitedPages", new Map());
  }

  async _updateFromSandbox(detail) {
    const isInPresentationMode = this._pdfViewer.isInPresentationMode || this._pdfViewer.isChangingPresentationMode;
    const {
      id,
      siblings,
      command,
      value
    } = detail;

    if (!id) {
      switch (command) {
        case "clear":
          console.clear();
          break;

        case "error":
          console.error(value);
          break;

        case "layout":
          this._pdfViewer.spreadMode = (0, _ui_utils.apiPageLayoutToSpreadMode)(value);
          break;

        case "page-num":
          this._pdfViewer.currentPageNumber = value + 1;
          break;

        case "print":
          await this._pdfViewer.pagesPromise;

          this._eventBus.dispatch("print", {
            source: this
          });

          break;

        case "println":
          console.log(value);
          break;

        case "zoom":
          if (isInPresentationMode) {
            return;
          }

          this._pdfViewer.currentScaleValue = value;
          break;
      }

      return;
    }

    if (isInPresentationMode) {
      if (detail.focus) {
        return;
      }
    }

    delete detail.id;
    delete detail.siblings;
    const ids = siblings ? [id, ...siblings] : [id];

    for (const elementId of ids) {
      const element = document.getElementById(elementId);

      if (element) {
        element.dispatchEvent(new CustomEvent("updatefromsandbox", {
          detail
        }));
      } else {
        this._pdfDocument?.annotationStorage.setValue(elementId, detail);
      }
    }
  }

  async _dispatchPageOpen(pageNumber, initialize = false) {
    const pdfDocument = this._pdfDocument,
          visitedPages = this._visitedPages;

    if (initialize) {
      this._closeCapability = (0, _pdfjsLib.createPromiseCapability)();
      this._pageEventsReady = true;
    }

    if (!this._pageEventsReady) {
      return;
    }

    const pageView = this._pdfViewer.getPageView(pageNumber - 1);

    if (pageView?.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
      this._pageOpenPending.add(pageNumber);

      return;
    }

    this._pageOpenPending.delete(pageNumber);

    const actionsPromise = (async () => {
      const actions = await (!visitedPages.has(pageNumber) ? pageView.pdfPage?.getJSActions() : null);

      if (pdfDocument !== this._pdfDocument) {
        return;
      }

      await this._scripting?.dispatchEventInSandbox({
        id: "page",
        name: "PageOpen",
        pageNumber,
        actions
      });
    })();

    visitedPages.set(pageNumber, actionsPromise);
  }

  async _dispatchPageClose(pageNumber) {
    const pdfDocument = this._pdfDocument,
          visitedPages = this._visitedPages;

    if (!this._pageEventsReady) {
      return;
    }

    if (this._pageOpenPending.has(pageNumber)) {
      return;
    }

    const actionsPromise = visitedPages.get(pageNumber);

    if (!actionsPromise) {
      return;
    }

    visitedPages.set(pageNumber, null);
    await actionsPromise;

    if (pdfDocument !== this._pdfDocument) {
      return;
    }

    await this._scripting?.dispatchEventInSandbox({
      id: "page",
      name: "PageClose",
      pageNumber
    });
  }

  async _getDocProperties() {
    if (this._docPropertiesLookup) {
      return this._docPropertiesLookup(this._pdfDocument);
    }

    throw new Error("_getDocProperties: Unable to lookup properties.");
  }

  _createScripting() {
    this._destroyCapability = (0, _pdfjsLib.createPromiseCapability)();

    if (this._scripting) {
      throw new Error("_createScripting: Scripting already exists.");
    }

    if (this._scriptingFactory) {
      return this._scriptingFactory.createScripting({
        sandboxBundleSrc: this._sandboxBundleSrc
      });
    }

    throw new Error("_createScripting: Cannot create scripting.");
  }

  async _destroyScripting() {
    if (!this._scripting) {
      this._pdfDocument = null;
      this._destroyCapability?.resolve();
      return;
    }

    if (this._closeCapability) {
      await Promise.race([this._closeCapability.promise, new Promise(resolve => {
        setTimeout(resolve, 1000);
      })]).catch(reason => {});
      this._closeCapability = null;
    }

    this._pdfDocument = null;

    try {
      await this._scripting.destroySandbox();
    } catch (ex) {}

    for (const [name, listener] of this._internalEvents) {
      this._eventBus._off(name, listener);
    }

    this._internalEvents.clear();

    for (const [name, listener] of this._domEvents) {
      window.removeEventListener(name, listener);
    }

    this._domEvents.clear();

    this._pageOpenPending.clear();

    this._visitedPages.clear();

    this._scripting = null;
    delete this._mouseState.isDown;
    this._pageEventsReady = false;
    this._ready = false;
    this._destroyCapability?.resolve();
  }

}

exports.PDFScriptingManager = PDFScriptingManager;

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFSidebar = void 0;

var _ui_utils = __webpack_require__(4);

var _pdf_rendering_queue = __webpack_require__(8);

const UI_NOTIFICATION_CLASS = "pdfSidebarNotification";

class PDFSidebar {
  constructor({
    elements,
    pdfViewer,
    pdfThumbnailViewer,
    eventBus,
    l10n
  }) {
    this.isOpen = false;
    this.active = _ui_utils.SidebarView.THUMBS;
    this.isInitialViewSet = false;
    this.onToggled = null;
    this.pdfViewer = pdfViewer;
    this.pdfThumbnailViewer = pdfThumbnailViewer;
    this.outerContainer = elements.outerContainer;
    this.viewerContainer = elements.viewerContainer;
    this.toggleButton = elements.toggleButton;
    this.thumbnailButton = elements.thumbnailButton;
    this.outlineButton = elements.outlineButton;
    this.attachmentsButton = elements.attachmentsButton;
    this.layersButton = elements.layersButton;
    this.thumbnailView = elements.thumbnailView;
    this.outlineView = elements.outlineView;
    this.attachmentsView = elements.attachmentsView;
    this.layersView = elements.layersView;
    this._outlineOptionsContainer = elements.outlineOptionsContainer;
    this._currentOutlineItemButton = elements.currentOutlineItemButton;
    this.eventBus = eventBus;
    this.l10n = l10n;

    this._addEventListeners();
  }

  reset() {
    this.isInitialViewSet = false;

    this._hideUINotification(true);

    this.switchView(_ui_utils.SidebarView.THUMBS);
    this.outlineButton.disabled = false;
    this.attachmentsButton.disabled = false;
    this.layersButton.disabled = false;
    this._currentOutlineItemButton.disabled = true;
  }

  get visibleView() {
    return this.isOpen ? this.active : _ui_utils.SidebarView.NONE;
  }

  get isThumbnailViewVisible() {
    return this.isOpen && this.active === _ui_utils.SidebarView.THUMBS;
  }

  get isOutlineViewVisible() {
    return this.isOpen && this.active === _ui_utils.SidebarView.OUTLINE;
  }

  get isAttachmentsViewVisible() {
    return this.isOpen && this.active === _ui_utils.SidebarView.ATTACHMENTS;
  }

  get isLayersViewVisible() {
    return this.isOpen && this.active === _ui_utils.SidebarView.LAYERS;
  }

  setInitialView(view = _ui_utils.SidebarView.NONE) {
    if (this.isInitialViewSet) {
      return;
    }

    this.isInitialViewSet = true;

    if (view === _ui_utils.SidebarView.NONE || view === _ui_utils.SidebarView.UNKNOWN) {
      this._dispatchEvent();

      return;
    }

    if (!this._switchView(view, true)) {
      this._dispatchEvent();
    }
  }

  switchView(view, forceOpen = false) {
    this._switchView(view, forceOpen);
  }

  _switchView(view, forceOpen = false) {
    const isViewChanged = view !== this.active;
    let shouldForceRendering = false;

    switch (view) {
      case _ui_utils.SidebarView.NONE:
        if (this.isOpen) {
          this.close();
          return true;
        }

        return false;

      case _ui_utils.SidebarView.THUMBS:
        if (this.isOpen && isViewChanged) {
          shouldForceRendering = true;
        }

        break;

      case _ui_utils.SidebarView.OUTLINE:
        if (this.outlineButton.disabled) {
          return false;
        }

        break;

      case _ui_utils.SidebarView.ATTACHMENTS:
        if (this.attachmentsButton.disabled) {
          return false;
        }

        break;

      case _ui_utils.SidebarView.LAYERS:
        if (this.layersButton.disabled) {
          return false;
        }

        break;

      default:
        console.error(`PDFSidebar._switchView: "${view}" is not a valid view.`);
        return false;
    }

    this.active = view;
    this.thumbnailButton.classList.toggle("toggled", view === _ui_utils.SidebarView.THUMBS);
    this.outlineButton.classList.toggle("toggled", view === _ui_utils.SidebarView.OUTLINE);
    this.attachmentsButton.classList.toggle("toggled", view === _ui_utils.SidebarView.ATTACHMENTS);
    this.layersButton.classList.toggle("toggled", view === _ui_utils.SidebarView.LAYERS);
    this.thumbnailView.classList.toggle("hidden", view !== _ui_utils.SidebarView.THUMBS);
    this.outlineView.classList.toggle("hidden", view !== _ui_utils.SidebarView.OUTLINE);
    this.attachmentsView.classList.toggle("hidden", view !== _ui_utils.SidebarView.ATTACHMENTS);
    this.layersView.classList.toggle("hidden", view !== _ui_utils.SidebarView.LAYERS);

    this._outlineOptionsContainer.classList.toggle("hidden", view !== _ui_utils.SidebarView.OUTLINE);

    if (forceOpen && !this.isOpen) {
      this.open();
      return true;
    }

    if (shouldForceRendering) {
      this._updateThumbnailViewer();

      this._forceRendering();
    }

    if (isViewChanged) {
      this._dispatchEvent();
    }

    return isViewChanged;
  }

  open() {
    if (this.isOpen) {
      return;
    }

    this.isOpen = true;
    this.toggleButton.classList.add("toggled");
    this.toggleButton.setAttribute("aria-expanded", "true");
    this.outerContainer.classList.add("sidebarMoving", "sidebarOpen");

    if (this.active === _ui_utils.SidebarView.THUMBS) {
      this._updateThumbnailViewer();
    }

    this._forceRendering();

    this._dispatchEvent();

    this._hideUINotification();
  }

  close() {
    if (!this.isOpen) {
      return;
    }

    this.isOpen = false;
    this.toggleButton.classList.remove("toggled");
    this.toggleButton.setAttribute("aria-expanded", "false");
    this.outerContainer.classList.add("sidebarMoving");
    this.outerContainer.classList.remove("sidebarOpen");

    this._forceRendering();

    this._dispatchEvent();
  }

  toggle() {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  }

  _dispatchEvent() {
    this.eventBus.dispatch("sidebarviewchanged", {
      source: this,
      view: this.visibleView
    });
  }

  _forceRendering() {
    if (this.onToggled) {
      this.onToggled();
    } else {
      this.pdfViewer.forceRendering();
      this.pdfThumbnailViewer.forceRendering();
    }
  }

  _updateThumbnailViewer() {
    const {
      pdfViewer,
      pdfThumbnailViewer
    } = this;
    const pagesCount = pdfViewer.pagesCount;

    for (let pageIndex = 0; pageIndex < pagesCount; pageIndex++) {
      const pageView = pdfViewer.getPageView(pageIndex);

      if (pageView?.renderingState === _pdf_rendering_queue.RenderingStates.FINISHED) {
        const thumbnailView = pdfThumbnailViewer.getThumbnail(pageIndex);
        thumbnailView.setImage(pageView);
      }
    }

    pdfThumbnailViewer.scrollThumbnailIntoView(pdfViewer.currentPageNumber);
  }

  _showUINotification() {
    this.l10n.get("toggle_sidebar_notification2.title").then(msg => {
      this.toggleButton.title = msg;
    });

    if (!this.isOpen) {
      this.toggleButton.classList.add(UI_NOTIFICATION_CLASS);
    }
  }

  _hideUINotification(reset = false) {
    if (this.isOpen || reset) {
      this.toggleButton.classList.remove(UI_NOTIFICATION_CLASS);
    }

    if (reset) {
      this.l10n.get("toggle_sidebar.title").then(msg => {
        this.toggleButton.title = msg;
      });
    }
  }

  _addEventListeners() {
    this.viewerContainer.addEventListener("transitionend", evt => {
      if (evt.target === this.viewerContainer) {
        this.outerContainer.classList.remove("sidebarMoving");
      }
    });
    this.toggleButton.addEventListener("click", () => {
      this.toggle();
    });
    this.thumbnailButton.addEventListener("click", () => {
      this.switchView(_ui_utils.SidebarView.THUMBS);
    });
    this.outlineButton.addEventListener("click", () => {
      this.switchView(_ui_utils.SidebarView.OUTLINE);
    });
    this.outlineButton.addEventListener("dblclick", () => {
      this.eventBus.dispatch("toggleoutlinetree", {
        source: this
      });
    });
    this.attachmentsButton.addEventListener("click", () => {
      this.switchView(_ui_utils.SidebarView.ATTACHMENTS);
    });
    this.layersButton.addEventListener("click", () => {
      this.switchView(_ui_utils.SidebarView.LAYERS);
    });
    this.layersButton.addEventListener("dblclick", () => {
      this.eventBus.dispatch("resetlayers", {
        source: this
      });
    });

    this._currentOutlineItemButton.addEventListener("click", () => {
      this.eventBus.dispatch("currentoutlineitem", {
        source: this
      });
    });

    const onTreeLoaded = (count, button, view) => {
      button.disabled = !count;

      if (count) {
        this._showUINotification();
      } else if (this.active === view) {
        this.switchView(_ui_utils.SidebarView.THUMBS);
      }
    };

    this.eventBus._on("outlineloaded", evt => {
      onTreeLoaded(evt.outlineCount, this.outlineButton, _ui_utils.SidebarView.OUTLINE);
      evt.currentOutlineItemPromise.then(enabled => {
        if (!this.isInitialViewSet) {
          return;
        }

        this._currentOutlineItemButton.disabled = !enabled;
      });
    });

    this.eventBus._on("attachmentsloaded", evt => {
      onTreeLoaded(evt.attachmentsCount, this.attachmentsButton, _ui_utils.SidebarView.ATTACHMENTS);
    });

    this.eventBus._on("layersloaded", evt => {
      onTreeLoaded(evt.layersCount, this.layersButton, _ui_utils.SidebarView.LAYERS);
    });

    this.eventBus._on("presentationmodechanged", evt => {
      if (evt.state === _ui_utils.PresentationModeState.NORMAL && this.isThumbnailViewVisible) {
        this._updateThumbnailViewer();
      }
    });
  }

}

exports.PDFSidebar = PDFSidebar;

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFSidebarResizer = void 0;
const SIDEBAR_WIDTH_VAR = "--sidebar-width";
const SIDEBAR_MIN_WIDTH = 200;
const SIDEBAR_RESIZING_CLASS = "sidebarResizing";

class PDFSidebarResizer {
  constructor(options, eventBus, l10n) {
    this.isRTL = false;
    this.sidebarOpen = false;
    this.doc = document.documentElement;
    this._width = null;
    this._outerContainerWidth = null;
    this._boundEvents = Object.create(null);
    this.outerContainer = options.outerContainer;
    this.resizer = options.resizer;
    this.eventBus = eventBus;
    l10n.getDirection().then(dir => {
      this.isRTL = dir === "rtl";
    });

    this._addEventListeners();
  }

  get outerContainerWidth() {
    return this._outerContainerWidth || (this._outerContainerWidth = this.outerContainer.clientWidth);
  }

  _updateWidth(width = 0) {
    const maxWidth = Math.floor(this.outerContainerWidth / 2);

    if (width > maxWidth) {
      width = maxWidth;
    }

    if (width < SIDEBAR_MIN_WIDTH) {
      width = SIDEBAR_MIN_WIDTH;
    }

    if (width === this._width) {
      return false;
    }

    this._width = width;
    this.doc.style.setProperty(SIDEBAR_WIDTH_VAR, `${width}px`);
    return true;
  }

  _mouseMove(evt) {
    let width = evt.clientX;

    if (this.isRTL) {
      width = this.outerContainerWidth - width;
    }

    this._updateWidth(width);
  }

  _mouseUp(evt) {
    this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);
    this.eventBus.dispatch("resize", {
      source: this
    });
    const _boundEvents = this._boundEvents;
    window.removeEventListener("mousemove", _boundEvents.mouseMove);
    window.removeEventListener("mouseup", _boundEvents.mouseUp);
  }

  _addEventListeners() {
    const _boundEvents = this._boundEvents;
    _boundEvents.mouseMove = this._mouseMove.bind(this);
    _boundEvents.mouseUp = this._mouseUp.bind(this);
    this.resizer.addEventListener("mousedown", evt => {
      if (evt.button !== 0) {
        return;
      }

      this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);
      window.addEventListener("mousemove", _boundEvents.mouseMove);
      window.addEventListener("mouseup", _boundEvents.mouseUp);
    });

    this.eventBus._on("sidebarviewchanged", evt => {
      this.sidebarOpen = !!evt?.view;
    });

    this.eventBus._on("resize", evt => {
      if (evt?.source !== window) {
        return;
      }

      this._outerContainerWidth = null;

      if (!this._width) {
        return;
      }

      if (!this.sidebarOpen) {
        this._updateWidth(this._width);

        return;
      }

      this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);

      const updated = this._updateWidth(this._width);

      Promise.resolve().then(() => {
        this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);

        if (updated) {
          this.eventBus.dispatch("resize", {
            source: this
          });
        }
      });
    });
  }

}

exports.PDFSidebarResizer = PDFSidebarResizer;

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFThumbnailViewer = void 0;

var _ui_utils = __webpack_require__(4);

var _pdf_thumbnail_view = __webpack_require__(26);

var _pdf_rendering_queue = __webpack_require__(8);

const THUMBNAIL_SCROLL_MARGIN = -19;
const THUMBNAIL_SELECTED_CLASS = "selected";

class PDFThumbnailViewer {
  constructor({
    container,
    eventBus,
    linkService,
    renderingQueue,
    l10n
  }) {
    this.container = container;
    this.linkService = linkService;
    this.renderingQueue = renderingQueue;
    this.l10n = l10n;
    this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdated.bind(this));

    this._resetView();

    eventBus._on("optionalcontentconfigchanged", () => {
      this._setImageDisabled = true;
    });
  }

  _scrollUpdated() {
    this.renderingQueue.renderHighestPriority();
  }

  getThumbnail(index) {
    return this._thumbnails[index];
  }

  _getVisibleThumbs() {
    return (0, _ui_utils.getVisibleElements)({
      scrollEl: this.container,
      views: this._thumbnails
    });
  }

  scrollThumbnailIntoView(pageNumber) {
    if (!this.pdfDocument) {
      return;
    }

    const thumbnailView = this._thumbnails[pageNumber - 1];

    if (!thumbnailView) {
      console.error('scrollThumbnailIntoView: Invalid "pageNumber" parameter.');
      return;
    }

    if (pageNumber !== this._currentPageNumber) {
      const prevThumbnailView = this._thumbnails[this._currentPageNumber - 1];
      prevThumbnailView.div.classList.remove(THUMBNAIL_SELECTED_CLASS);
      thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);
    }

    const visibleThumbs = this._getVisibleThumbs();

    const numVisibleThumbs = visibleThumbs.views.length;

    if (numVisibleThumbs > 0) {
      const first = visibleThumbs.first.id;
      const last = numVisibleThumbs > 1 ? visibleThumbs.last.id : first;
      let shouldScroll = false;

      if (pageNumber <= first || pageNumber >= last) {
        shouldScroll = true;
      } else {
        visibleThumbs.views.some(function (view) {
          if (view.id !== pageNumber) {
            return false;
          }

          shouldScroll = view.percent < 100;
          return true;
        });
      }

      if (shouldScroll) {
        (0, _ui_utils.scrollIntoView)(thumbnailView.div, {
          top: THUMBNAIL_SCROLL_MARGIN
        });
      }
    }

    this._currentPageNumber = pageNumber;
  }

  get pagesRotation() {
    return this._pagesRotation;
  }

  set pagesRotation(rotation) {
    if (!(0, _ui_utils.isValidRotation)(rotation)) {
      throw new Error("Invalid thumbnails rotation angle.");
    }

    if (!this.pdfDocument) {
      return;
    }

    if (this._pagesRotation === rotation) {
      return;
    }

    this._pagesRotation = rotation;

    for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
      this._thumbnails[i].update(rotation);
    }
  }

  cleanup() {
    for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
      if (this._thumbnails[i] && this._thumbnails[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
        this._thumbnails[i].reset();
      }
    }

    _pdf_thumbnail_view.TempImageFactory.destroyCanvas();
  }

  _resetView() {
    this._thumbnails = [];
    this._currentPageNumber = 1;
    this._pageLabels = null;
    this._pagesRotation = 0;
    this._optionalContentConfigPromise = null;
    this._pagesRequests = new WeakMap();
    this._setImageDisabled = false;
    this.container.textContent = "";
  }

  setDocument(pdfDocument) {
    if (this.pdfDocument) {
      this._cancelRendering();

      this._resetView();
    }

    this.pdfDocument = pdfDocument;

    if (!pdfDocument) {
      return;
    }

    const firstPagePromise = pdfDocument.getPage(1);
    const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();
    firstPagePromise.then(firstPdfPage => {
      this._optionalContentConfigPromise = optionalContentConfigPromise;
      const pagesCount = pdfDocument.numPages;
      const viewport = firstPdfPage.getViewport({
        scale: 1
      });

      const checkSetImageDisabled = () => {
        return this._setImageDisabled;
      };

      for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
        const thumbnail = new _pdf_thumbnail_view.PDFThumbnailView({
          container: this.container,
          id: pageNum,
          defaultViewport: viewport.clone(),
          optionalContentConfigPromise,
          linkService: this.linkService,
          renderingQueue: this.renderingQueue,
          checkSetImageDisabled,
          l10n: this.l10n
        });

        this._thumbnails.push(thumbnail);
      }

      const firstThumbnailView = this._thumbnails[0];

      if (firstThumbnailView) {
        firstThumbnailView.setPdfPage(firstPdfPage);
      }

      const thumbnailView = this._thumbnails[this._currentPageNumber - 1];
      thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);
    }).catch(reason => {
      console.error("Unable to initialize thumbnail viewer", reason);
    });
  }

  _cancelRendering() {
    for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
      if (this._thumbnails[i]) {
        this._thumbnails[i].cancelRendering();
      }
    }
  }

  setPageLabels(labels) {
    if (!this.pdfDocument) {
      return;
    }

    if (!labels) {
      this._pageLabels = null;
    } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
      this._pageLabels = null;
      console.error("PDFThumbnailViewer_setPageLabels: Invalid page labels.");
    } else {
      this._pageLabels = labels;
    }

    for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
      this._thumbnails[i].setPageLabel(this._pageLabels?.[i] ?? null);
    }
  }

  _ensurePdfPageLoaded(thumbView) {
    if (thumbView.pdfPage) {
      return Promise.resolve(thumbView.pdfPage);
    }

    if (this._pagesRequests.has(thumbView)) {
      return this._pagesRequests.get(thumbView);
    }

    const promise = this.pdfDocument.getPage(thumbView.id).then(pdfPage => {
      if (!thumbView.pdfPage) {
        thumbView.setPdfPage(pdfPage);
      }

      this._pagesRequests.delete(thumbView);

      return pdfPage;
    }).catch(reason => {
      console.error("Unable to get page for thumb view", reason);

      this._pagesRequests.delete(thumbView);
    });

    this._pagesRequests.set(thumbView, promise);

    return promise;
  }

  forceRendering() {
    const visibleThumbs = this._getVisibleThumbs();

    const thumbView = this.renderingQueue.getHighestPriority(visibleThumbs, this._thumbnails, this.scroll.down);

    if (thumbView) {
      this._ensurePdfPageLoaded(thumbView).then(() => {
        this.renderingQueue.renderView(thumbView);
      });

      return true;
    }

    return false;
  }

}

exports.PDFThumbnailViewer = PDFThumbnailViewer;

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TempImageFactory = exports.PDFThumbnailView = void 0;

var _ui_utils = __webpack_require__(4);

var _pdfjsLib = __webpack_require__(5);

var _pdf_rendering_queue = __webpack_require__(8);

const DRAW_UPSCALE_FACTOR = 2;
const MAX_NUM_SCALING_STEPS = 3;
const THUMBNAIL_CANVAS_BORDER_WIDTH = 1;
const THUMBNAIL_WIDTH = 98;

const TempImageFactory = function TempImageFactoryClosure() {
  let tempCanvasCache = null;
  return {
    getCanvas(width, height) {
      let tempCanvas = tempCanvasCache;

      if (!tempCanvas) {
        tempCanvas = document.createElement("canvas");
        tempCanvasCache = tempCanvas;
      }

      tempCanvas.width = width;
      tempCanvas.height = height;
      tempCanvas.mozOpaque = true;
      const ctx = tempCanvas.getContext("2d", {
        alpha: false
      });
      ctx.save();
      ctx.fillStyle = "rgb(255, 255, 255)";
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
      return [tempCanvas, tempCanvas.getContext("2d")];
    },

    destroyCanvas() {
      const tempCanvas = tempCanvasCache;

      if (tempCanvas) {
        tempCanvas.width = 0;
        tempCanvas.height = 0;
      }

      tempCanvasCache = null;
    }

  };
}();

exports.TempImageFactory = TempImageFactory;

class PDFThumbnailView {
  constructor({
    container,
    id,
    defaultViewport,
    optionalContentConfigPromise,
    linkService,
    renderingQueue,
    checkSetImageDisabled,
    l10n
  }) {
    this.id = id;
    this.renderingId = "thumbnail" + id;
    this.pageLabel = null;
    this.pdfPage = null;
    this.rotation = 0;
    this.viewport = defaultViewport;
    this.pdfPageRotate = defaultViewport.rotation;
    this._optionalContentConfigPromise = optionalContentConfigPromise || null;
    this.linkService = linkService;
    this.renderingQueue = renderingQueue;
    this.renderTask = null;
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    this.resume = null;

    this._checkSetImageDisabled = checkSetImageDisabled || function () {
      return false;
    };

    const pageWidth = this.viewport.width,
          pageHeight = this.viewport.height,
          pageRatio = pageWidth / pageHeight;
    this.canvasWidth = THUMBNAIL_WIDTH;
    this.canvasHeight = this.canvasWidth / pageRatio | 0;
    this.scale = this.canvasWidth / pageWidth;
    this.l10n = l10n;
    const anchor = document.createElement("a");
    anchor.href = linkService.getAnchorUrl("#page=" + id);

    this._thumbPageTitle.then(msg => {
      anchor.title = msg;
    });

    anchor.onclick = function () {
      linkService.goToPage(id);
      return false;
    };

    this.anchor = anchor;
    const div = document.createElement("div");
    div.className = "thumbnail";
    div.setAttribute("data-page-number", this.id);
    this.div = div;
    const ring = document.createElement("div");
    ring.className = "thumbnailSelectionRing";
    const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
    ring.style.width = this.canvasWidth + borderAdjustment + "px";
    ring.style.height = this.canvasHeight + borderAdjustment + "px";
    this.ring = ring;
    div.appendChild(ring);
    anchor.appendChild(div);
    container.appendChild(anchor);
  }

  setPdfPage(pdfPage) {
    this.pdfPage = pdfPage;
    this.pdfPageRotate = pdfPage.rotate;
    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = pdfPage.getViewport({
      scale: 1,
      rotation: totalRotation
    });
    this.reset();
  }

  reset() {
    this.cancelRendering();
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    const pageWidth = this.viewport.width,
          pageHeight = this.viewport.height,
          pageRatio = pageWidth / pageHeight;
    this.canvasHeight = this.canvasWidth / pageRatio | 0;
    this.scale = this.canvasWidth / pageWidth;
    this.div.removeAttribute("data-loaded");
    const ring = this.ring;
    ring.textContent = "";
    const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
    ring.style.width = this.canvasWidth + borderAdjustment + "px";
    ring.style.height = this.canvasHeight + borderAdjustment + "px";

    if (this.canvas) {
      this.canvas.width = 0;
      this.canvas.height = 0;
      delete this.canvas;
    }

    if (this.image) {
      this.image.removeAttribute("src");
      delete this.image;
    }
  }

  update(rotation) {
    if (typeof rotation !== "undefined") {
      this.rotation = rotation;
    }

    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = this.viewport.clone({
      scale: 1,
      rotation: totalRotation
    });
    this.reset();
  }

  cancelRendering() {
    if (this.renderTask) {
      this.renderTask.cancel();
      this.renderTask = null;
    }

    this.resume = null;
  }

  _getPageDrawContext(upscaleFactor = 1) {
    const canvas = document.createElement("canvas");
    canvas.mozOpaque = true;
    const ctx = canvas.getContext("2d", {
      alpha: false
    });
    const outputScale = (0, _ui_utils.getOutputScale)(ctx);
    canvas.width = upscaleFactor * this.canvasWidth * outputScale.sx | 0;
    canvas.height = upscaleFactor * this.canvasHeight * outputScale.sy | 0;
    const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null;
    return {
      ctx,
      canvas,
      transform
    };
  }

  _convertCanvasToImage(canvas) {
    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
      throw new Error("_convertCanvasToImage: Rendering has not finished.");
    }

    const reducedCanvas = this._reduceImage(canvas);

    const image = document.createElement("img");
    image.className = "thumbnailImage";

    this._thumbPageCanvas.then(msg => {
      image.setAttribute("aria-label", msg);
    });

    image.style.width = this.canvasWidth + "px";
    image.style.height = this.canvasHeight + "px";
    image.src = reducedCanvas.toDataURL();
    this.image = image;
    this.div.setAttribute("data-loaded", true);
    this.ring.appendChild(image);
    reducedCanvas.width = 0;
    reducedCanvas.height = 0;
  }

  draw() {
    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
      console.error("Must be in new state before drawing");
      return Promise.resolve(undefined);
    }

    const {
      pdfPage
    } = this;

    if (!pdfPage) {
      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
      return Promise.reject(new Error("pdfPage is not loaded"));
    }

    this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;

    const finishRenderTask = async (error = null) => {
      if (renderTask === this.renderTask) {
        this.renderTask = null;
      }

      if (error instanceof _pdfjsLib.RenderingCancelledException) {
        return;
      }

      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

      this._convertCanvasToImage(canvas);

      if (error) {
        throw error;
      }
    };

    const {
      ctx,
      canvas,
      transform
    } = this._getPageDrawContext(DRAW_UPSCALE_FACTOR);

    const drawViewport = this.viewport.clone({
      scale: DRAW_UPSCALE_FACTOR * this.scale
    });

    const renderContinueCallback = cont => {
      if (!this.renderingQueue.isHighestPriority(this)) {
        this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;

        this.resume = () => {
          this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
          cont();
        };

        return;
      }

      cont();
    };

    const renderContext = {
      canvasContext: ctx,
      transform,
      viewport: drawViewport,
      optionalContentConfigPromise: this._optionalContentConfigPromise
    };
    const renderTask = this.renderTask = pdfPage.render(renderContext);
    renderTask.onContinue = renderContinueCallback;
    const resultPromise = renderTask.promise.then(function () {
      return finishRenderTask(null);
    }, function (error) {
      return finishRenderTask(error);
    });
    resultPromise.finally(() => {
      canvas.width = 0;
      canvas.height = 0;
      const pageCached = this.linkService.isPageCached(this.id);

      if (!pageCached) {
        this.pdfPage?.cleanup();
      }
    });
    return resultPromise;
  }

  setImage(pageView) {
    if (this._checkSetImageDisabled()) {
      return;
    }

    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
      return;
    }

    const {
      canvas,
      pdfPage
    } = pageView;

    if (!canvas) {
      return;
    }

    if (!this.pdfPage) {
      this.setPdfPage(pdfPage);
    }

    this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

    this._convertCanvasToImage(canvas);
  }

  _reduceImage(img) {
    const {
      ctx,
      canvas
    } = this._getPageDrawContext();

    if (img.width <= 2 * canvas.width) {
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
      return canvas;
    }

    let reducedWidth = canvas.width << MAX_NUM_SCALING_STEPS;
    let reducedHeight = canvas.height << MAX_NUM_SCALING_STEPS;
    const [reducedImage, reducedImageCtx] = TempImageFactory.getCanvas(reducedWidth, reducedHeight);

    while (reducedWidth > img.width || reducedHeight > img.height) {
      reducedWidth >>= 1;
      reducedHeight >>= 1;
    }

    reducedImageCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, reducedWidth, reducedHeight);

    while (reducedWidth > 2 * canvas.width) {
      reducedImageCtx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, reducedWidth >> 1, reducedHeight >> 1);
      reducedWidth >>= 1;
      reducedHeight >>= 1;
    }

    ctx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, canvas.width, canvas.height);
    return canvas;
  }

  get _thumbPageTitle() {
    return this.l10n.get("thumb_page_title", {
      page: this.pageLabel ?? this.id
    });
  }

  get _thumbPageCanvas() {
    return this.l10n.get("thumb_page_canvas", {
      page: this.pageLabel ?? this.id
    });
  }

  setPageLabel(label) {
    this.pageLabel = typeof label === "string" ? label : null;

    this._thumbPageTitle.then(msg => {
      this.anchor.title = msg;
    });

    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
      return;
    }

    this._thumbPageCanvas.then(msg => {
      this.image?.setAttribute("aria-label", msg);
    });
  }

}

exports.PDFThumbnailView = PDFThumbnailView;

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFViewer = void 0;

var _ui_utils = __webpack_require__(4);

var _base_viewer = __webpack_require__(28);

var _pdfjsLib = __webpack_require__(5);

class PDFViewer extends _base_viewer.BaseViewer {
  get _viewerElement() {
    return (0, _pdfjsLib.shadow)(this, "_viewerElement", this.viewer);
  }

  _scrollIntoView({
    pageDiv,
    pageSpot = null,
    pageNumber = null
  }) {
    if (!pageSpot && !this.isInPresentationMode) {
      const left = pageDiv.offsetLeft + pageDiv.clientLeft;
      const right = left + pageDiv.clientWidth;
      const {
        scrollLeft,
        clientWidth
      } = this.container;

      if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) {
        pageSpot = {
          left: 0,
          top: 0
        };
      }
    }

    super._scrollIntoView({
      pageDiv,
      pageSpot,
      pageNumber
    });
  }

  _getVisiblePages() {
    if (this.isInPresentationMode) {
      return this._getCurrentVisiblePage();
    }

    return super._getVisiblePages();
  }

  _updateHelper(visiblePages) {
    if (this.isInPresentationMode) {
      return;
    }

    let currentId = this._currentPageNumber;
    let stillFullyVisible = false;

    for (const page of visiblePages) {
      if (page.percent < 100) {
        break;
      }

      if (page.id === currentId && this._scrollMode === _ui_utils.ScrollMode.VERTICAL && this._spreadMode === _ui_utils.SpreadMode.NONE) {
        stillFullyVisible = true;
        break;
      }
    }

    if (!stillFullyVisible) {
      currentId = visiblePages[0].id;
    }

    this._setCurrentPageNumber(currentId);
  }

}

exports.PDFViewer = PDFViewer;

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseViewer = void 0;

var _pdfjsLib = __webpack_require__(5);

var _ui_utils = __webpack_require__(4);

var _pdf_rendering_queue = __webpack_require__(8);

var _annotation_layer_builder = __webpack_require__(29);

var _l10n_utils = __webpack_require__(30);

var _pdf_page_view = __webpack_require__(31);

var _pdf_link_service = __webpack_require__(19);

var _struct_tree_layer_builder = __webpack_require__(32);

var _text_layer_builder = __webpack_require__(33);

var _xfa_layer_builder = __webpack_require__(34);

const DEFAULT_CACHE_SIZE = 10;

function PDFPageViewBuffer(size) {
  const data = [];

  this.push = function (view) {
    const i = data.indexOf(view);

    if (i >= 0) {
      data.splice(i, 1);
    }

    data.push(view);

    if (data.length > size) {
      data.shift().destroy();
    }
  };

  this.resize = function (newSize, pagesToKeep) {
    size = newSize;

    if (pagesToKeep) {
      const pageIdsToKeep = new Set();

      for (let i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {
        pageIdsToKeep.add(pagesToKeep[i].id);
      }

      (0, _ui_utils.moveToEndOfArray)(data, function (page) {
        return pageIdsToKeep.has(page.id);
      });
    }

    while (data.length > size) {
      data.shift().destroy();
    }
  };

  this.has = function (view) {
    return data.includes(view);
  };
}

function isSameScale(oldScale, newScale) {
  if (newScale === oldScale) {
    return true;
  }

  if (Math.abs(newScale - oldScale) < 1e-15) {
    return true;
  }

  return false;
}

class BaseViewer {
  constructor(options) {
    if (this.constructor === BaseViewer) {
      throw new Error("Cannot initialize BaseViewer.");
    }

    const viewerVersion = '2.9.0';

    if (_pdfjsLib.version !== viewerVersion) {
      throw new Error(`The API version "${_pdfjsLib.version}" does not match the Viewer version "${viewerVersion}".`);
    }

    this._name = this.constructor.name;
    this.container = options.container;
    this.viewer = options.viewer || options.container.firstElementChild;

    if (!(this.container?.tagName.toUpperCase() === "DIV" && this.viewer?.tagName.toUpperCase() === "DIV")) {
      throw new Error("Invalid `container` and/or `viewer` option.");
    }

    if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute") {
      throw new Error("The `container` must be absolutely positioned.");
    }

    this.eventBus = options.eventBus;
    this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
    this.downloadManager = options.downloadManager || null;
    this.findController = options.findController || null;
    this._scriptingManager = options.scriptingManager || null;
    this.removePageBorders = options.removePageBorders || false;
    this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
    this.imageResourcesPath = options.imageResourcesPath || "";
    this.renderInteractiveForms = options.renderInteractiveForms !== false;
    this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
    this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
    this.useOnlyCssZoom = options.useOnlyCssZoom || false;
    this.maxCanvasPixels = options.maxCanvasPixels;
    this.l10n = options.l10n || _l10n_utils.NullL10n;
    this.enableScripting = options.enableScripting === true && !!this._scriptingManager;
    this.defaultRenderingQueue = !options.renderingQueue;

    if (this.defaultRenderingQueue) {
      this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
      this.renderingQueue.setViewer(this);
    } else {
      this.renderingQueue = options.renderingQueue;
    }

    this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
    this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
    this._onBeforeDraw = this._onAfterDraw = null;

    this._resetView();

    if (this.removePageBorders) {
      this.viewer.classList.add("removePageBorders");
    }

    Promise.resolve().then(() => {
      this.eventBus.dispatch("baseviewerinit", {
        source: this
      });
    });
  }

  get pagesCount() {
    return this._pages.length;
  }

  getPageView(index) {
    return this._pages[index];
  }

  get pageViewsReady() {
    if (!this._pagesCapability.settled) {
      return false;
    }

    return this._pages.every(function (pageView) {
      return pageView?.pdfPage;
    });
  }

  get currentPageNumber() {
    return this._currentPageNumber;
  }

  set currentPageNumber(val) {
    if (!Number.isInteger(val)) {
      throw new Error("Invalid page number.");
    }

    if (!this.pdfDocument) {
      return;
    }

    if (!this._setCurrentPageNumber(val, true)) {
      console.error(`${this._name}.currentPageNumber: "${val}" is not a valid page.`);
    }
  }

  _setCurrentPageNumber(val, resetCurrentPageView = false) {
    if (this._currentPageNumber === val) {
      if (resetCurrentPageView) {
        this._resetCurrentPageView();
      }

      return true;
    }

    if (!(0 < val && val <= this.pagesCount)) {
      return false;
    }

    const previous = this._currentPageNumber;
    this._currentPageNumber = val;
    this.eventBus.dispatch("pagechanging", {
      source: this,
      pageNumber: val,
      pageLabel: this._pageLabels?.[val - 1] ?? null,
      previous
    });

    if (resetCurrentPageView) {
      this._resetCurrentPageView();
    }

    return true;
  }

  get currentPageLabel() {
    return this._pageLabels?.[this._currentPageNumber - 1] ?? null;
  }

  set currentPageLabel(val) {
    if (!this.pdfDocument) {
      return;
    }

    let page = val | 0;

    if (this._pageLabels) {
      const i = this._pageLabels.indexOf(val);

      if (i >= 0) {
        page = i + 1;
      }
    }

    if (!this._setCurrentPageNumber(page, true)) {
      console.error(`${this._name}.currentPageLabel: "${val}" is not a valid page.`);
    }
  }

  get currentScale() {
    return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
  }

  set currentScale(val) {
    if (isNaN(val)) {
      throw new Error("Invalid numeric scale.");
    }

    if (!this.pdfDocument) {
      return;
    }

    this._setScale(val, false);
  }

  get currentScaleValue() {
    return this._currentScaleValue;
  }

  set currentScaleValue(val) {
    if (!this.pdfDocument) {
      return;
    }

    this._setScale(val, false);
  }

  get pagesRotation() {
    return this._pagesRotation;
  }

  set pagesRotation(rotation) {
    if (!(0, _ui_utils.isValidRotation)(rotation)) {
      throw new Error("Invalid pages rotation angle.");
    }

    if (!this.pdfDocument) {
      return;
    }

    rotation %= 360;

    if (rotation < 0) {
      rotation += 360;
    }

    if (this._pagesRotation === rotation) {
      return;
    }

    this._pagesRotation = rotation;
    const pageNumber = this._currentPageNumber;

    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      const pageView = this._pages[i];
      pageView.update(pageView.scale, rotation);
    }

    if (this._currentScaleValue) {
      this._setScale(this._currentScaleValue, true);
    }

    this.eventBus.dispatch("rotationchanging", {
      source: this,
      pagesRotation: rotation,
      pageNumber
    });

    if (this.defaultRenderingQueue) {
      this.update();
    }
  }

  get firstPagePromise() {
    return this.pdfDocument ? this._firstPageCapability.promise : null;
  }

  get onePageRendered() {
    return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
  }

  get pagesPromise() {
    return this.pdfDocument ? this._pagesCapability.promise : null;
  }

  get _viewerElement() {
    throw new Error("Not implemented: _viewerElement");
  }

  _onePageRenderedOrForceFetch() {
    if (!this.container.offsetParent || this._getVisiblePages().views.length === 0) {
      return Promise.resolve();
    }

    return this._onePageRenderedCapability.promise;
  }

  setDocument(pdfDocument) {
    if (this.pdfDocument) {
      this.eventBus.dispatch("pagesdestroy", {
        source: this
      });

      this._cancelRendering();

      this._resetView();

      if (this.findController) {
        this.findController.setDocument(null);
      }

      if (this._scriptingManager) {
        this._scriptingManager.setDocument(null);
      }
    }

    this.pdfDocument = pdfDocument;

    if (!pdfDocument) {
      return;
    }

    const isPureXfa = pdfDocument.isPureXfa;
    const pagesCount = pdfDocument.numPages;
    const firstPagePromise = pdfDocument.getPage(1);
    const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();

    this._pagesCapability.promise.then(() => {
      this.eventBus.dispatch("pagesloaded", {
        source: this,
        pagesCount
      });
    });

    this._onBeforeDraw = evt => {
      const pageView = this._pages[evt.pageNumber - 1];

      if (!pageView) {
        return;
      }

      this._buffer.push(pageView);
    };

    this.eventBus._on("pagerender", this._onBeforeDraw);

    this._onAfterDraw = evt => {
      if (evt.cssTransform || this._onePageRenderedCapability.settled) {
        return;
      }

      this._onePageRenderedCapability.resolve();

      this.eventBus._off("pagerendered", this._onAfterDraw);

      this._onAfterDraw = null;
    };

    this.eventBus._on("pagerendered", this._onAfterDraw);

    firstPagePromise.then(firstPdfPage => {
      this._firstPageCapability.resolve(firstPdfPage);

      this._optionalContentConfigPromise = optionalContentConfigPromise;
      const scale = this.currentScale;
      const viewport = firstPdfPage.getViewport({
        scale: scale * _ui_utils.CSS_UNITS
      });
      const textLayerFactory = this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE ? this : null;
      const xfaLayerFactory = isPureXfa ? this : null;

      for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
        const pageView = new _pdf_page_view.PDFPageView({
          container: this._viewerElement,
          eventBus: this.eventBus,
          id: pageNum,
          scale,
          defaultViewport: viewport.clone(),
          optionalContentConfigPromise,
          renderingQueue: this.renderingQueue,
          textLayerFactory,
          textLayerMode: this.textLayerMode,
          annotationLayerFactory: this,
          xfaLayerFactory,
          structTreeLayerFactory: this,
          imageResourcesPath: this.imageResourcesPath,
          renderInteractiveForms: this.renderInteractiveForms,
          renderer: this.renderer,
          useOnlyCssZoom: this.useOnlyCssZoom,
          maxCanvasPixels: this.maxCanvasPixels,
          l10n: this.l10n
        });

        this._pages.push(pageView);
      }

      const firstPageView = this._pages[0];

      if (firstPageView) {
        firstPageView.setPdfPage(firstPdfPage);
        this.linkService.cachePageRef(1, firstPdfPage.ref);
      }

      if (this._spreadMode !== _ui_utils.SpreadMode.NONE) {
        this._updateSpreadMode();
      }

      this._onePageRenderedOrForceFetch().then(() => {
        if (this.findController) {
          this.findController.setDocument(pdfDocument);
        }

        if (this.enableScripting) {
          this._scriptingManager.setDocument(pdfDocument);
        }

        if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) {
          this._pagesCapability.resolve();

          return;
        }

        let getPagesLeft = pagesCount - 1;

        if (getPagesLeft <= 0) {
          this._pagesCapability.resolve();

          return;
        }

        for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
          pdfDocument.getPage(pageNum).then(pdfPage => {
            const pageView = this._pages[pageNum - 1];

            if (!pageView.pdfPage) {
              pageView.setPdfPage(pdfPage);
            }

            this.linkService.cachePageRef(pageNum, pdfPage.ref);

            if (--getPagesLeft === 0) {
              this._pagesCapability.resolve();
            }
          }, reason => {
            console.error(`Unable to get page ${pageNum} to initialize viewer`, reason);

            if (--getPagesLeft === 0) {
              this._pagesCapability.resolve();
            }
          });
        }
      });

      this.eventBus.dispatch("pagesinit", {
        source: this
      });

      if (this.defaultRenderingQueue) {
        this.update();
      }
    }).catch(reason => {
      console.error("Unable to initialize viewer", reason);
    });
  }

  setPageLabels(labels) {
    if (!this.pdfDocument) {
      return;
    }

    if (!labels) {
      this._pageLabels = null;
    } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
      this._pageLabels = null;
      console.error(`${this._name}.setPageLabels: Invalid page labels.`);
    } else {
      this._pageLabels = labels;
    }

    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      this._pages[i].setPageLabel(this._pageLabels?.[i] ?? null);
    }
  }

  _resetView() {
    this._pages = [];
    this._currentPageNumber = 1;
    this._currentScale = _ui_utils.UNKNOWN_SCALE;
    this._currentScaleValue = null;
    this._pageLabels = null;
    this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
    this._location = null;
    this._pagesRotation = 0;
    this._optionalContentConfigPromise = null;
    this._pagesRequests = new WeakMap();
    this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)();
    this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
    this._spreadMode = _ui_utils.SpreadMode.NONE;

    if (this._onBeforeDraw) {
      this.eventBus._off("pagerender", this._onBeforeDraw);

      this._onBeforeDraw = null;
    }

    if (this._onAfterDraw) {
      this.eventBus._off("pagerendered", this._onAfterDraw);

      this._onAfterDraw = null;
    }

    this.viewer.textContent = "";

    this._updateScrollMode();
  }

  _scrollUpdate() {
    if (this.pagesCount === 0) {
      return;
    }

    this.update();
  }

  _scrollIntoView({
    pageDiv,
    pageSpot = null,
    pageNumber = null
  }) {
    (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot);
  }

  _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {
    this._currentScaleValue = newValue.toString();

    if (isSameScale(this._currentScale, newScale)) {
      if (preset) {
        this.eventBus.dispatch("scalechanging", {
          source: this,
          scale: newScale,
          presetValue: newValue
        });
      }

      return;
    }

    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      this._pages[i].update(newScale);
    }

    this._currentScale = newScale;

    if (!noScroll) {
      let page = this._currentPageNumber,
          dest;

      if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
        page = this._location.pageNumber;
        dest = [null, {
          name: "XYZ"
        }, this._location.left, this._location.top, null];
      }

      this.scrollPageIntoView({
        pageNumber: page,
        destArray: dest,
        allowNegativeOffset: true
      });
    }

    this.eventBus.dispatch("scalechanging", {
      source: this,
      scale: newScale,
      presetValue: preset ? newValue : undefined
    });

    if (this.defaultRenderingQueue) {
      this.update();
    }
  }

  get _pageWidthScaleFactor() {
    if (this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL && !this.isInPresentationMode) {
      return 2;
    }

    return 1;
  }

  _setScale(value, noScroll = false) {
    let scale = parseFloat(value);

    if (scale > 0) {
      this._setScaleUpdatePages(scale, value, noScroll, false);
    } else {
      const currentPage = this._pages[this._currentPageNumber - 1];

      if (!currentPage) {
        return;
      }

      const noPadding = this.isInPresentationMode || this.removePageBorders;
      let hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING;
      let vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING;

      if (!noPadding && this._isScrollModeHorizontal) {
        [hPadding, vPadding] = [vPadding, hPadding];
      }

      const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor;
      const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;

      switch (value) {
        case "page-actual":
          scale = 1;
          break;

        case "page-width":
          scale = pageWidthScale;
          break;

        case "page-height":
          scale = pageHeightScale;
          break;

        case "page-fit":
          scale = Math.min(pageWidthScale, pageHeightScale);
          break;

        case "auto":
          const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
          scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
          break;

        default:
          console.error(`${this._name}._setScale: "${value}" is an unknown zoom value.`);
          return;
      }

      this._setScaleUpdatePages(scale, value, noScroll, true);
    }
  }

  _resetCurrentPageView() {
    if (this.isInPresentationMode) {
      this._setScale(this._currentScaleValue, true);
    }

    const pageView = this._pages[this._currentPageNumber - 1];

    this._scrollIntoView({
      pageDiv: pageView.div
    });
  }

  pageLabelToPageNumber(label) {
    if (!this._pageLabels) {
      return null;
    }

    const i = this._pageLabels.indexOf(label);

    if (i < 0) {
      return null;
    }

    return i + 1;
  }

  scrollPageIntoView({
    pageNumber,
    destArray = null,
    allowNegativeOffset = false,
    ignoreDestinationZoom = false
  }) {
    if (!this.pdfDocument) {
      return;
    }

    const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];

    if (!pageView) {
      console.error(`${this._name}.scrollPageIntoView: ` + `"${pageNumber}" is not a valid pageNumber parameter.`);
      return;
    }

    if (this.isInPresentationMode || !destArray) {
      this._setCurrentPageNumber(pageNumber, true);

      return;
    }

    let x = 0,
        y = 0;
    let width = 0,
        height = 0,
        widthScale,
        heightScale;
    const changeOrientation = pageView.rotation % 180 !== 0;
    const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS;
    const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS;
    let scale = 0;

    switch (destArray[1].name) {
      case "XYZ":
        x = destArray[2];
        y = destArray[3];
        scale = destArray[4];
        x = x !== null ? x : 0;
        y = y !== null ? y : pageHeight;
        break;

      case "Fit":
      case "FitB":
        scale = "page-fit";
        break;

      case "FitH":
      case "FitBH":
        y = destArray[2];
        scale = "page-width";

        if (y === null && this._location) {
          x = this._location.left;
          y = this._location.top;
        } else if (typeof y !== "number") {
          y = pageHeight;
        }

        break;

      case "FitV":
      case "FitBV":
        x = destArray[2];
        width = pageWidth;
        height = pageHeight;
        scale = "page-height";
        break;

      case "FitR":
        x = destArray[2];
        y = destArray[3];
        width = destArray[4] - x;
        height = destArray[5] - y;
        const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
        const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
        widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS;
        heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS;
        scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
        break;

      default:
        console.error(`${this._name}.scrollPageIntoView: ` + `"${destArray[1].name}" is not a valid destination type.`);
        return;
    }

    if (!ignoreDestinationZoom) {
      if (scale && scale !== this._currentScale) {
        this.currentScaleValue = scale;
      } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
        this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
      }
    }

    if (scale === "page-fit" && !destArray[4]) {
      this._scrollIntoView({
        pageDiv: pageView.div,
        pageNumber
      });

      return;
    }

    const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
    let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
    let top = Math.min(boundingRect[0][1], boundingRect[1][1]);

    if (!allowNegativeOffset) {
      left = Math.max(left, 0);
      top = Math.max(top, 0);
    }

    this._scrollIntoView({
      pageDiv: pageView.div,
      pageSpot: {
        left,
        top
      },
      pageNumber
    });
  }

  _updateLocation(firstPage) {
    const currentScale = this._currentScale;
    const currentScaleValue = this._currentScaleValue;
    const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;
    const pageNumber = firstPage.id;
    let pdfOpenParams = "#page=" + pageNumber;
    pdfOpenParams += "&zoom=" + normalizedScaleValue;
    const currentPageView = this._pages[pageNumber - 1];
    const container = this.container;
    const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
    const intLeft = Math.round(topLeft[0]);
    const intTop = Math.round(topLeft[1]);
    pdfOpenParams += "," + intLeft + "," + intTop;
    this._location = {
      pageNumber,
      scale: normalizedScaleValue,
      top: intTop,
      left: intLeft,
      rotation: this._pagesRotation,
      pdfOpenParams
    };
  }

  _updateHelper(visiblePages) {
    throw new Error("Not implemented: _updateHelper");
  }

  update() {
    const visible = this._getVisiblePages();

    const visiblePages = visible.views,
          numVisiblePages = visiblePages.length;

    if (numVisiblePages === 0) {
      return;
    }

    const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);

    this._buffer.resize(newCacheSize, visiblePages);

    this.renderingQueue.renderHighestPriority(visible);

    this._updateHelper(visiblePages);

    this._updateLocation(visible.first);

    this.eventBus.dispatch("updateviewarea", {
      source: this,
      location: this._location
    });
  }

  containsElement(element) {
    return this.container.contains(element);
  }

  focus() {
    this.container.focus();
  }

  get _isScrollModeHorizontal() {
    return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL;
  }

  get _isContainerRtl() {
    return getComputedStyle(this.container).direction === "rtl";
  }

  get isInPresentationMode() {
    return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
  }

  get isChangingPresentationMode() {
    return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
  }

  get isHorizontalScrollbarEnabled() {
    return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
  }

  get isVerticalScrollbarEnabled() {
    return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
  }

  _getCurrentVisiblePage() {
    if (!this.pagesCount) {
      return {
        views: []
      };
    }

    const pageView = this._pages[this._currentPageNumber - 1];
    const element = pageView.div;
    const view = {
      id: pageView.id,
      x: element.offsetLeft + element.clientLeft,
      y: element.offsetTop + element.clientTop,
      view: pageView
    };
    return {
      first: view,
      last: view,
      views: [view]
    };
  }

  _getVisiblePages() {
    return (0, _ui_utils.getVisibleElements)({
      scrollEl: this.container,
      views: this._pages,
      sortByVisibility: true,
      horizontal: this._isScrollModeHorizontal,
      rtl: this._isScrollModeHorizontal && this._isContainerRtl
    });
  }

  isPageVisible(pageNumber) {
    if (!this.pdfDocument) {
      return false;
    }

    if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
      console.error(`${this._name}.isPageVisible: "${pageNumber}" is not a valid page.`);
      return false;
    }

    return this._getVisiblePages().views.some(function (view) {
      return view.id === pageNumber;
    });
  }

  isPageCached(pageNumber) {
    if (!this.pdfDocument || !this._buffer) {
      return false;
    }

    if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
      console.error(`${this._name}.isPageCached: "${pageNumber}" is not a valid page.`);
      return false;
    }

    const pageView = this._pages[pageNumber - 1];

    if (!pageView) {
      return false;
    }

    return this._buffer.has(pageView);
  }

  cleanup() {
    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
        this._pages[i].reset();
      }
    }
  }

  _cancelRendering() {
    for (let i = 0, ii = this._pages.length; i < ii; i++) {
      if (this._pages[i]) {
        this._pages[i].cancelRendering();
      }
    }
  }

  _ensurePdfPageLoaded(pageView) {
    if (pageView.pdfPage) {
      return Promise.resolve(pageView.pdfPage);
    }

    if (this._pagesRequests.has(pageView)) {
      return this._pagesRequests.get(pageView);
    }

    const promise = this.pdfDocument.getPage(pageView.id).then(pdfPage => {
      if (!pageView.pdfPage) {
        pageView.setPdfPage(pdfPage);
      }

      this._pagesRequests.delete(pageView);

      return pdfPage;
    }).catch(reason => {
      console.error("Unable to get page for page view", reason);

      this._pagesRequests.delete(pageView);
    });

    this._pagesRequests.set(pageView, promise);

    return promise;
  }

  forceRendering(currentlyVisiblePages) {
    const visiblePages = currentlyVisiblePages || this._getVisiblePages();

    const scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down;
    const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead);

    if (pageView) {
      this._ensurePdfPageLoaded(pageView).then(() => {
        this.renderingQueue.renderView(pageView);
      });

      return true;
    }

    return false;
  }

  createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) {
    return new _text_layer_builder.TextLayerBuilder({
      textLayerDiv,
      eventBus,
      pageIndex,
      viewport,
      findController: this.isInPresentationMode ? null : this.findController,
      enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection
    });
  }

  createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = "", renderInteractiveForms = false, l10n = _l10n_utils.NullL10n, enableScripting = null, hasJSActionsPromise = null, mouseState = null) {
    return new _annotation_layer_builder.AnnotationLayerBuilder({
      pageDiv,
      pdfPage,
      annotationStorage: annotationStorage || this.pdfDocument?.annotationStorage,
      imageResourcesPath,
      renderInteractiveForms,
      linkService: this.linkService,
      downloadManager: this.downloadManager,
      l10n,
      enableScripting: enableScripting ?? this.enableScripting,
      hasJSActionsPromise: hasJSActionsPromise || this.pdfDocument?.hasJSActions(),
      mouseState: mouseState || this._scriptingManager?.mouseState
    });
  }

  createXfaLayerBuilder(pageDiv, pdfPage) {
    return new _xfa_layer_builder.XfaLayerBuilder({
      pageDiv,
      pdfPage
    });
  }

  createStructTreeLayerBuilder(pdfPage) {
    return new _struct_tree_layer_builder.StructTreeLayerBuilder({
      pdfPage
    });
  }

  get hasEqualPageSizes() {
    const firstPageView = this._pages[0];

    for (let i = 1, ii = this._pages.length; i < ii; ++i) {
      const pageView = this._pages[i];

      if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
        return false;
      }
    }

    return true;
  }

  getPagesOverview() {
    return this._pages.map(pageView => {
      const viewport = pageView.pdfPage.getViewport({
        scale: 1
      });

      if (!this.enablePrintAutoRotate || (0, _ui_utils.isPortraitOrientation)(viewport)) {
        return {
          width: viewport.width,
          height: viewport.height,
          rotation: viewport.rotation
        };
      }

      return {
        width: viewport.height,
        height: viewport.width,
        rotation: (viewport.rotation - 90) % 360
      };
    });
  }

  get optionalContentConfigPromise() {
    if (!this.pdfDocument) {
      return Promise.resolve(null);
    }

    if (!this._optionalContentConfigPromise) {
      return this.pdfDocument.getOptionalContentConfig();
    }

    return this._optionalContentConfigPromise;
  }

  set optionalContentConfigPromise(promise) {
    if (!(promise instanceof Promise)) {
      throw new Error(`Invalid optionalContentConfigPromise: ${promise}`);
    }

    if (!this.pdfDocument) {
      return;
    }

    if (!this._optionalContentConfigPromise) {
      return;
    }

    this._optionalContentConfigPromise = promise;

    for (const pageView of this._pages) {
      pageView.update(pageView.scale, pageView.rotation, promise);
    }

    this.update();
    this.eventBus.dispatch("optionalcontentconfigchanged", {
      source: this,
      promise
    });
  }

  get scrollMode() {
    return this._scrollMode;
  }

  set scrollMode(mode) {
    if (this._scrollMode === mode) {
      return;
    }

    if (!(0, _ui_utils.isValidScrollMode)(mode)) {
      throw new Error(`Invalid scroll mode: ${mode}`);
    }

    this._scrollMode = mode;
    this.eventBus.dispatch("scrollmodechanged", {
      source: this,
      mode
    });

    this._updateScrollMode(this._currentPageNumber);
  }

  _updateScrollMode(pageNumber = null) {
    const scrollMode = this._scrollMode,
          viewer = this.viewer;
    viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
    viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);

    if (!this.pdfDocument || !pageNumber) {
      return;
    }

    if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
      this._setScale(this._currentScaleValue, true);
    }

    this._setCurrentPageNumber(pageNumber, true);

    this.update();
  }

  get spreadMode() {
    return this._spreadMode;
  }

  set spreadMode(mode) {
    if (this._spreadMode === mode) {
      return;
    }

    if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
      throw new Error(`Invalid spread mode: ${mode}`);
    }

    this._spreadMode = mode;
    this.eventBus.dispatch("spreadmodechanged", {
      source: this,
      mode
    });

    this._updateSpreadMode(this._currentPageNumber);
  }

  _updateSpreadMode(pageNumber = null) {
    if (!this.pdfDocument) {
      return;
    }

    const viewer = this.viewer,
          pages = this._pages;
    viewer.textContent = "";

    if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
      for (let i = 0, iMax = pages.length; i < iMax; ++i) {
        viewer.appendChild(pages[i].div);
      }
    } else {
      const parity = this._spreadMode - 1;
      let spread = null;

      for (let i = 0, iMax = pages.length; i < iMax; ++i) {
        if (spread === null) {
          spread = document.createElement("div");
          spread.className = "spread";
          viewer.appendChild(spread);
        } else if (i % 2 === parity) {
          spread = spread.cloneNode(false);
          viewer.appendChild(spread);
        }

        spread.appendChild(pages[i].div);
      }
    }

    if (!pageNumber) {
      return;
    }

    if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
      this._setScale(this._currentScaleValue, true);
    }

    this._setCurrentPageNumber(pageNumber, true);

    this.update();
  }

  _getPageAdvance(currentPageNumber, previous = false) {
    if (this.isInPresentationMode) {
      return 1;
    }

    switch (this._scrollMode) {
      case _ui_utils.ScrollMode.WRAPPED:
        {
          const {
            views
          } = this._getVisiblePages(),
                pageLayout = new Map();

          for (const {
            id,
            y,
            percent,
            widthPercent
          } of views) {
            if (percent === 0 || widthPercent < 100) {
              continue;
            }

            let yArray = pageLayout.get(y);

            if (!yArray) {
              pageLayout.set(y, yArray || (yArray = []));
            }

            yArray.push(id);
          }

          for (const yArray of pageLayout.values()) {
            const currentIndex = yArray.indexOf(currentPageNumber);

            if (currentIndex === -1) {
              continue;
            }

            const numPages = yArray.length;

            if (numPages === 1) {
              break;
            }

            if (previous) {
              for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {
                const currentId = yArray[i],
                      expectedId = yArray[i + 1] - 1;

                if (currentId < expectedId) {
                  return currentPageNumber - expectedId;
                }
              }
            } else {
              for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {
                const currentId = yArray[i],
                      expectedId = yArray[i - 1] + 1;

                if (currentId > expectedId) {
                  return expectedId - currentPageNumber;
                }
              }
            }

            if (previous) {
              const firstId = yArray[0];

              if (firstId < currentPageNumber) {
                return currentPageNumber - firstId + 1;
              }
            } else {
              const lastId = yArray[numPages - 1];

              if (lastId > currentPageNumber) {
                return lastId - currentPageNumber + 1;
              }
            }

            break;
          }

          break;
        }

      case _ui_utils.ScrollMode.HORIZONTAL:
        {
          break;
        }

      case _ui_utils.ScrollMode.VERTICAL:
        {
          if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
            break;
          }

          const parity = this._spreadMode - 1;

          if (previous && currentPageNumber % 2 !== parity) {
            break;
          } else if (!previous && currentPageNumber % 2 === parity) {
            break;
          }

          const {
            views
          } = this._getVisiblePages(),
                expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;

          for (const {
            id,
            percent,
            widthPercent
          } of views) {
            if (id !== expectedId) {
              continue;
            }

            if (percent > 0 && widthPercent === 100) {
              return 2;
            }

            break;
          }

          break;
        }
    }

    return 1;
  }

  nextPage() {
    const currentPageNumber = this._currentPageNumber,
          pagesCount = this.pagesCount;

    if (currentPageNumber >= pagesCount) {
      return false;
    }

    const advance = this._getPageAdvance(currentPageNumber, false) || 1;
    this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);
    return true;
  }

  previousPage() {
    const currentPageNumber = this._currentPageNumber;

    if (currentPageNumber <= 1) {
      return false;
    }

    const advance = this._getPageAdvance(currentPageNumber, true) || 1;
    this.currentPageNumber = Math.max(currentPageNumber - advance, 1);
    return true;
  }

}

exports.BaseViewer = BaseViewer;

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = void 0;

var _pdfjsLib = __webpack_require__(5);

var _l10n_utils = __webpack_require__(30);

var _pdf_link_service = __webpack_require__(19);

class AnnotationLayerBuilder {
  constructor({
    pageDiv,
    pdfPage,
    linkService,
    downloadManager,
    annotationStorage = null,
    imageResourcesPath = "",
    renderInteractiveForms = true,
    l10n = _l10n_utils.NullL10n,
    enableScripting = false,
    hasJSActionsPromise = null,
    mouseState = null
  }) {
    this.pageDiv = pageDiv;
    this.pdfPage = pdfPage;
    this.linkService = linkService;
    this.downloadManager = downloadManager;
    this.imageResourcesPath = imageResourcesPath;
    this.renderInteractiveForms = renderInteractiveForms;
    this.l10n = l10n;
    this.annotationStorage = annotationStorage;
    this.enableScripting = enableScripting;
    this._hasJSActionsPromise = hasJSActionsPromise;
    this._mouseState = mouseState;
    this.div = null;
    this._cancelled = false;
  }

  render(viewport, intent = "display") {
    return Promise.all([this.pdfPage.getAnnotations({
      intent
    }), this._hasJSActionsPromise]).then(([annotations, hasJSActions = false]) => {
      if (this._cancelled) {
        return;
      }

      if (annotations.length === 0) {
        return;
      }

      const parameters = {
        viewport: viewport.clone({
          dontFlip: true
        }),
        div: this.div,
        annotations,
        page: this.pdfPage,
        imageResourcesPath: this.imageResourcesPath,
        renderInteractiveForms: this.renderInteractiveForms,
        linkService: this.linkService,
        downloadManager: this.downloadManager,
        annotationStorage: this.annotationStorage,
        enableScripting: this.enableScripting,
        hasJSActions,
        mouseState: this._mouseState
      };

      if (this.div) {
        _pdfjsLib.AnnotationLayer.update(parameters);
      } else {
        this.div = document.createElement("div");
        this.div.className = "annotationLayer";
        this.pageDiv.appendChild(this.div);
        parameters.div = this.div;

        _pdfjsLib.AnnotationLayer.render(parameters);

        this.l10n.translate(this.div);
      }
    });
  }

  cancel() {
    this._cancelled = true;
  }

  hide() {
    if (!this.div) {
      return;
    }

    this.div.hidden = true;
  }

}

exports.AnnotationLayerBuilder = AnnotationLayerBuilder;

class DefaultAnnotationLayerFactory {
  createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = "", renderInteractiveForms = true, l10n = _l10n_utils.NullL10n, enableScripting = false, hasJSActionsPromise = null, mouseState = null) {
    return new AnnotationLayerBuilder({
      pageDiv,
      pdfPage,
      imageResourcesPath,
      renderInteractiveForms,
      linkService: new _pdf_link_service.SimpleLinkService(),
      l10n,
      annotationStorage,
      enableScripting,
      hasJSActionsPromise,
      mouseState
    });
  }

}

exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getL10nFallback = getL10nFallback;
exports.NullL10n = void 0;
const DEFAULT_L10N_STRINGS = {
  of_pages: "of ",
  page_of_pages: "( of )",
  document_properties_kb: " KB ( bytes)",
  document_properties_mb: " MB ( bytes)",
  document_properties_date_string: "1622354702096, ",
  document_properties_page_size_unit_inches: "in",
  document_properties_page_size_unit_millimeters: "mm",
  document_properties_page_size_orientation_portrait: "portrait",
  document_properties_page_size_orientation_landscape: "landscape",
  document_properties_page_size_name_a3: "A3",
  document_properties_page_size_name_a4: "A4",
  document_properties_page_size_name_letter: "Letter",
  document_properties_page_size_name_legal: "Legal",
  document_properties_page_size_dimension_string: " ×   ()",
  document_properties_page_size_dimension_name_string: " ×   (, )",
  document_properties_linearized_yes: "Yes",
  document_properties_linearized_no: "No",
  print_progress_percent: "%",
  "toggle_sidebar.title": "Toggle Sidebar",
  "toggle_sidebar_notification2.title": "Toggle Sidebar (document contains outline/attachments/layers)",
  additional_layers: "Additional Layers",
  page_landmark: "Page ",
  thumb_page_title: "Page ",
  thumb_page_canvas: "Thumbnail of Page ",
  find_reached_top: "Reached top of document, continued from bottom",
  find_reached_bottom: "Reached end of document, continued from top",
  "find_match_count[one]": " of  match",
  "find_match_count[other]": " of  matches",
  "find_match_count_limit[one]": "More than  match",
  "find_match_count_limit[other]": "More than  matches",
  find_not_found: "Phrase not found",
  error_version_info: "PDF.js v (build: )",
  error_message: "Message: ",
  error_stack: "Stack: ",
  error_file: "File: ",
  error_line: "Line: ",
  rendering_error: "An error occurred while rendering the page.",
  page_scale_width: "Page Width",
  page_scale_fit: "Page Fit",
  page_scale_auto: "Automatic Zoom",
  page_scale_actual: "Actual Size",
  page_scale_percent: "%",
  loading: "Loading…",
  loading_error: "An error occurred while loading the PDF.",
  invalid_file_error: "Invalid or corrupted PDF file.",
  missing_file_error: "Missing PDF file.",
  unexpected_response_error: "Unexpected server response.",
  printing_not_supported: "Warning: Printing is not fully supported by this browser.",
  printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
  web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts."
};

function getL10nFallback(key, args) {
  switch (key) {
    case "find_match_count":
      key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
      break;

    case "find_match_count_limit":
      key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
      break;
  }

  return DEFAULT_L10N_STRINGS[key] || "";
}

function formatL10nValue(text, args) {
  if (!args) {
    return text;
  }

  return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
    return name in args ? args[name] : " + name + ";
  });
}

const NullL10n = {
  async getLanguage() {
    return "en-us";
  },

  async getDirection() {
    return "ltr";
  },

  async get(key, args = null, fallback = getL10nFallback(key, args)) {
    return formatL10nValue(fallback, args);
  },

  async translate(element) {}

};
exports.NullL10n = NullL10n;

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFPageView = void 0;

var _ui_utils = __webpack_require__(4);

var _pdfjsLib = __webpack_require__(5);

var _l10n_utils = __webpack_require__(30);

var _pdf_rendering_queue = __webpack_require__(8);

var _viewer_compatibility = __webpack_require__(2);

const MAX_CANVAS_PIXELS = _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels || 16777216;

class PDFPageView {
  constructor(options) {
    const container = options.container;
    const defaultViewport = options.defaultViewport;
    this.id = options.id;
    this.renderingId = "page" + this.id;
    this.pdfPage = null;
    this.pageLabel = null;
    this.rotation = 0;
    this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
    this.viewport = defaultViewport;
    this.pdfPageRotate = defaultViewport.rotation;
    this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;
    this.hasRestrictedScaling = false;
    this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
    this.imageResourcesPath = options.imageResourcesPath || "";
    this.renderInteractiveForms = options.renderInteractiveForms !== false;
    this.useOnlyCssZoom = options.useOnlyCssZoom || false;
    this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
    this.eventBus = options.eventBus;
    this.renderingQueue = options.renderingQueue;
    this.textLayerFactory = options.textLayerFactory;
    this.annotationLayerFactory = options.annotationLayerFactory;
    this.xfaLayerFactory = options.xfaLayerFactory;
    this.structTreeLayerFactory = options.structTreeLayerFactory;
    this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
    this.l10n = options.l10n || _l10n_utils.NullL10n;
    this.paintTask = null;
    this.paintedViewportMap = new WeakMap();
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    this.resume = null;
    this._renderError = null;
    this.annotationLayer = null;
    this.textLayer = null;
    this.zoomLayer = null;
    this.xfaLayer = null;
    this.structTreeLayer = null;
    const div = document.createElement("div");
    div.className = "page";
    div.style.width = Math.floor(this.viewport.width) + "px";
    div.style.height = Math.floor(this.viewport.height) + "px";
    div.setAttribute("data-page-number", this.id);
    div.setAttribute("role", "region");
    this.l10n.get("page_landmark", {
      page: this.id
    }).then(msg => {
      div.setAttribute("aria-label", msg);
    });
    this.div = div;
    container.appendChild(div);
  }

  setPdfPage(pdfPage) {
    this.pdfPage = pdfPage;
    this.pdfPageRotate = pdfPage.rotate;
    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = pdfPage.getViewport({
      scale: this.scale * _ui_utils.CSS_UNITS,
      rotation: totalRotation
    });
    this.reset();
  }

  destroy() {
    this.reset();

    if (this.pdfPage) {
      this.pdfPage.cleanup();
    }
  }

  async _renderAnnotationLayer() {
    let error = null;

    try {
      await this.annotationLayer.render(this.viewport, "display");
    } catch (ex) {
      error = ex;
    } finally {
      this.eventBus.dispatch("annotationlayerrendered", {
        source: this,
        pageNumber: this.id,
        error
      });
    }
  }

  async _renderXfaLayer() {
    let error = null;

    try {
      await this.xfaLayer.render(this.viewport, "display");
    } catch (ex) {
      error = ex;
    } finally {
      this.eventBus.dispatch("xfalayerrendered", {
        source: this,
        pageNumber: this.id,
        error
      });
    }
  }

  _resetZoomLayer(removeFromDOM = false) {
    if (!this.zoomLayer) {
      return;
    }

    const zoomLayerCanvas = this.zoomLayer.firstChild;
    this.paintedViewportMap.delete(zoomLayerCanvas);
    zoomLayerCanvas.width = 0;
    zoomLayerCanvas.height = 0;

    if (removeFromDOM) {
      this.zoomLayer.remove();
    }

    this.zoomLayer = null;
  }

  reset(keepZoomLayer = false, keepAnnotations = false) {
    this.cancelRendering(keepAnnotations);
    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
    const div = this.div;
    div.style.width = Math.floor(this.viewport.width) + "px";
    div.style.height = Math.floor(this.viewport.height) + "px";
    const childNodes = div.childNodes;
    const currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null;
    const currentAnnotationNode = keepAnnotations && this.annotationLayer?.div || null;
    const currentXfaLayerNode = this.xfaLayer?.div || null;

    for (let i = childNodes.length - 1; i >= 0; i--) {
      const node = childNodes[i];

      if (currentZoomLayerNode === node || currentAnnotationNode === node || currentXfaLayerNode === node) {
        continue;
      }

      div.removeChild(node);
    }

    div.removeAttribute("data-loaded");

    if (currentAnnotationNode) {
      this.annotationLayer.hide();
    } else if (this.annotationLayer) {
      this.annotationLayer.cancel();
      this.annotationLayer = null;
    }

    if (!currentZoomLayerNode) {
      if (this.canvas) {
        this.paintedViewportMap.delete(this.canvas);
        this.canvas.width = 0;
        this.canvas.height = 0;
        delete this.canvas;
      }

      this._resetZoomLayer();
    }

    if (this.svg) {
      this.paintedViewportMap.delete(this.svg);
      delete this.svg;
    }

    this.loadingIconDiv = document.createElement("div");
    this.loadingIconDiv.className = "loadingIcon";
    this.loadingIconDiv.setAttribute("role", "img");
    this.l10n.get("loading").then(msg => {
      this.loadingIconDiv?.setAttribute("aria-label", msg);
    });
    div.appendChild(this.loadingIconDiv);
  }

  update(scale, rotation, optionalContentConfigPromise = null) {
    this.scale = scale || this.scale;

    if (typeof rotation !== "undefined") {
      this.rotation = rotation;
    }

    if (optionalContentConfigPromise instanceof Promise) {
      this._optionalContentConfigPromise = optionalContentConfigPromise;
    }

    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = this.viewport.clone({
      scale: this.scale * _ui_utils.CSS_UNITS,
      rotation: totalRotation
    });

    if (this.svg) {
      this.cssTransform(this.svg, true);
      this.eventBus.dispatch("pagerendered", {
        source: this,
        pageNumber: this.id,
        cssTransform: true,
        timestamp: performance.now(),
        error: this._renderError
      });
      return;
    }

    let isScalingRestricted = false;

    if (this.canvas && this.maxCanvasPixels > 0) {
      const outputScale = this.outputScale;

      if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
        isScalingRestricted = true;
      }
    }

    if (this.canvas) {
      if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
        this.cssTransform(this.canvas, true);
        this.eventBus.dispatch("pagerendered", {
          source: this,
          pageNumber: this.id,
          cssTransform: true,
          timestamp: performance.now(),
          error: this._renderError
        });
        return;
      }

      if (!this.zoomLayer && !this.canvas.hidden) {
        this.zoomLayer = this.canvas.parentNode;
        this.zoomLayer.style.position = "absolute";
      }
    }

    if (this.zoomLayer) {
      this.cssTransform(this.zoomLayer.firstChild);
    }

    this.reset(true, true);
  }

  cancelRendering(keepAnnotations = false) {
    if (this.paintTask) {
      this.paintTask.cancel();
      this.paintTask = null;
    }

    this.resume = null;

    if (this.textLayer) {
      this.textLayer.cancel();
      this.textLayer = null;
    }

    if (!keepAnnotations && this.annotationLayer) {
      this.annotationLayer.cancel();
      this.annotationLayer = null;
    }

    if (this._onTextLayerRendered) {
      this.eventBus._off("textlayerrendered", this._onTextLayerRendered);

      this._onTextLayerRendered = null;
    }
  }

  cssTransform(target, redrawAnnotations = false) {
    const width = this.viewport.width;
    const height = this.viewport.height;
    const div = this.div;
    target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
    target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
    const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
    const absRotation = Math.abs(relativeRotation);
    let scaleX = 1,
        scaleY = 1;

    if (absRotation === 90 || absRotation === 270) {
      scaleX = height / width;
      scaleY = width / height;
    }

    target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`;

    if (this.textLayer) {
      const textLayerViewport = this.textLayer.viewport;
      const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
      const textAbsRotation = Math.abs(textRelativeRotation);
      let scale = width / textLayerViewport.width;

      if (textAbsRotation === 90 || textAbsRotation === 270) {
        scale = width / textLayerViewport.height;
      }

      const textLayerDiv = this.textLayer.textLayerDiv;
      let transX, transY;

      switch (textAbsRotation) {
        case 0:
          transX = transY = 0;
          break;

        case 90:
          transX = 0;
          transY = "-" + textLayerDiv.style.height;
          break;

        case 180:
          transX = "-" + textLayerDiv.style.width;
          transY = "-" + textLayerDiv.style.height;
          break;

        case 270:
          transX = "-" + textLayerDiv.style.width;
          transY = 0;
          break;

        default:
          console.error("Bad rotation value.");
          break;
      }

      textLayerDiv.style.transform = `rotate(${textAbsRotation}deg) ` + `scale(${scale}) ` + `translate(${transX}, ${transY})`;
      textLayerDiv.style.transformOrigin = "0% 0%";
    }

    if (redrawAnnotations && this.annotationLayer) {
      this._renderAnnotationLayer();
    }

    if (this.xfaLayer) {
      this._renderXfaLayer();
    }
  }

  get width() {
    return this.viewport.width;
  }

  get height() {
    return this.viewport.height;
  }

  getPagePoint(x, y) {
    return this.viewport.convertToPdfPoint(x, y);
  }

  draw() {
    if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
      console.error("Must be in new state before drawing");
      this.reset();
    }

    const {
      div,
      pdfPage
    } = this;

    if (!pdfPage) {
      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

      if (this.loadingIconDiv) {
        div.removeChild(this.loadingIconDiv);
        delete this.loadingIconDiv;
      }

      return Promise.reject(new Error("pdfPage is not loaded"));
    }

    this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
    const canvasWrapper = document.createElement("div");
    canvasWrapper.style.width = div.style.width;
    canvasWrapper.style.height = div.style.height;
    canvasWrapper.classList.add("canvasWrapper");

    if (this.annotationLayer?.div) {
      div.insertBefore(canvasWrapper, this.annotationLayer.div);
    } else {
      div.appendChild(canvasWrapper);
    }

    let textLayer = null;

    if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {
      const textLayerDiv = document.createElement("div");
      textLayerDiv.className = "textLayer";
      textLayerDiv.style.width = canvasWrapper.style.width;
      textLayerDiv.style.height = canvasWrapper.style.height;

      if (this.annotationLayer?.div) {
        div.insertBefore(textLayerDiv, this.annotationLayer.div);
      } else {
        div.appendChild(textLayerDiv);
      }

      textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus);
    }

    this.textLayer = textLayer;
    let renderContinueCallback = null;

    if (this.renderingQueue) {
      renderContinueCallback = cont => {
        if (!this.renderingQueue.isHighestPriority(this)) {
          this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;

          this.resume = () => {
            this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
            cont();
          };

          return;
        }

        cont();
      };
    }

    const finishPaintTask = async (error = null) => {
      if (paintTask === this.paintTask) {
        this.paintTask = null;
      }

      if (error instanceof _pdfjsLib.RenderingCancelledException) {
        this._renderError = null;
        return;
      }

      this._renderError = error;
      this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

      if (this.loadingIconDiv) {
        div.removeChild(this.loadingIconDiv);
        delete this.loadingIconDiv;
      }

      this._resetZoomLayer(true);

      this.eventBus.dispatch("pagerendered", {
        source: this,
        pageNumber: this.id,
        cssTransform: false,
        timestamp: performance.now(),
        error: this._renderError
      });

      if (error) {
        throw error;
      }
    };

    const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
    paintTask.onRenderContinue = renderContinueCallback;
    this.paintTask = paintTask;
    const resultPromise = paintTask.promise.then(() => {
      return finishPaintTask(null).then(() => {
        if (textLayer) {
          const readableStream = pdfPage.streamTextContent({
            normalizeWhitespace: true,
            includeMarkedContent: true
          });
          textLayer.setTextContentStream(readableStream);
          textLayer.render();
        }
      });
    }, function (reason) {
      return finishPaintTask(reason);
    });

    if (this.annotationLayerFactory) {
      if (!this.annotationLayer) {
        this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, null, this.imageResourcesPath, this.renderInteractiveForms, this.l10n, null, null, null);
      }

      this._renderAnnotationLayer();
    }

    if (this.xfaLayerFactory) {
      if (!this.xfaLayer) {
        this.xfaLayer = this.xfaLayerFactory.createXfaLayerBuilder(div, pdfPage);
      }

      this._renderXfaLayer();
    }

    if (this.structTreeLayerFactory && this.textLayer && this.canvas) {
      this._onTextLayerRendered = event => {
        if (event.pageNumber !== this.id) {
          return;
        }

        this.eventBus._off("textlayerrendered", this._onTextLayerRendered);

        this._onTextLayerRendered = null;

        if (!this.canvas) {
          return;
        }

        this.pdfPage.getStructTree().then(tree => {
          if (!tree) {
            return;
          }

          if (!this.canvas) {
            return;
          }

          const treeDom = this.structTreeLayer.render(tree);
          treeDom.classList.add("structTree");
          this.canvas.appendChild(treeDom);
        });
      };

      this.eventBus._on("textlayerrendered", this._onTextLayerRendered);

      this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder(pdfPage);
    }

    div.setAttribute("data-loaded", true);
    this.eventBus.dispatch("pagerender", {
      source: this,
      pageNumber: this.id
    });
    return resultPromise;
  }

  paintOnCanvas(canvasWrapper) {
    const renderCapability = (0, _pdfjsLib.createPromiseCapability)();
    const result = {
      promise: renderCapability.promise,

      onRenderContinue(cont) {
        cont();
      },

      cancel() {
        renderTask.cancel();
      }

    };
    const viewport = this.viewport;
    const canvas = document.createElement("canvas");
    canvas.hidden = true;
    let isCanvasHidden = true;

    const showCanvas = function () {
      if (isCanvasHidden) {
        canvas.hidden = false;
        isCanvasHidden = false;
      }
    };

    canvasWrapper.appendChild(canvas);
    this.canvas = canvas;
    canvas.mozOpaque = true;
    const ctx = canvas.getContext("2d", {
      alpha: false
    });
    const outputScale = (0, _ui_utils.getOutputScale)(ctx);
    this.outputScale = outputScale;

    if (this.useOnlyCssZoom) {
      const actualSizeViewport = viewport.clone({
        scale: _ui_utils.CSS_UNITS
      });
      outputScale.sx *= actualSizeViewport.width / viewport.width;
      outputScale.sy *= actualSizeViewport.height / viewport.height;
      outputScale.scaled = true;
    }

    if (this.maxCanvasPixels > 0) {
      const pixelsInViewport = viewport.width * viewport.height;
      const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);

      if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
        outputScale.sx = maxScale;
        outputScale.sy = maxScale;
        outputScale.scaled = true;
        this.hasRestrictedScaling = true;
      } else {
        this.hasRestrictedScaling = false;
      }
    }

    const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
    const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
    canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
    canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
    canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px";
    canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px";
    this.paintedViewportMap.set(canvas, viewport);
    const transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
    const renderContext = {
      canvasContext: ctx,
      transform,
      viewport: this.viewport,
      renderInteractiveForms: this.renderInteractiveForms,
      optionalContentConfigPromise: this._optionalContentConfigPromise
    };
    const renderTask = this.pdfPage.render(renderContext);

    renderTask.onContinue = function (cont) {
      showCanvas();

      if (result.onRenderContinue) {
        result.onRenderContinue(cont);
      } else {
        cont();
      }
    };

    renderTask.promise.then(function () {
      showCanvas();
      renderCapability.resolve(undefined);
    }, function (error) {
      showCanvas();
      renderCapability.reject(error);
    });
    return result;
  }

  paintOnSvg(wrapper) {
    let cancelled = false;

    const ensureNotCancelled = () => {
      if (cancelled) {
        throw new _pdfjsLib.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, "svg");
      }
    };

    const pdfPage = this.pdfPage;
    const actualSizeViewport = this.viewport.clone({
      scale: _ui_utils.CSS_UNITS
    });
    const promise = pdfPage.getOperatorList().then(opList => {
      ensureNotCancelled();
      const svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs, _viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL);
      return svgGfx.getSVG(opList, actualSizeViewport).then(svg => {
        ensureNotCancelled();
        this.svg = svg;
        this.paintedViewportMap.set(svg, actualSizeViewport);
        svg.style.width = wrapper.style.width;
        svg.style.height = wrapper.style.height;
        this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
        wrapper.appendChild(svg);
      });
    });
    return {
      promise,

      onRenderContinue(cont) {
        cont();
      },

      cancel() {
        cancelled = true;
      }

    };
  }

  setPageLabel(label) {
    this.pageLabel = typeof label === "string" ? label : null;

    if (this.pageLabel !== null) {
      this.div.setAttribute("data-page-label", this.pageLabel);
    } else {
      this.div.removeAttribute("data-page-label");
    }
  }

}

exports.PDFPageView = PDFPageView;

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StructTreeLayerBuilder = exports.DefaultStructTreeLayerFactory = void 0;
const PDF_ROLE_TO_HTML_ROLE = {
  Document: null,
  DocumentFragment: null,
  Part: "group",
  Sect: "group",
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  P: null,
  H: "heading",
  Title: null,
  FENote: "note",
  Sub: "group",
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  L: "list",
  LI: "listitem",
  LBody: null,
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  Caption: null,
  Figure: "figure",
  Formula: null,
  Artifact: null
};
const HEADING_PATTERN = /^H(\d+)$/;

class StructTreeLayerBuilder {
  constructor({
    pdfPage
  }) {
    this.pdfPage = pdfPage;
  }

  render(structTree) {
    return this._walk(structTree);
  }

  _setAttributes(structElement, htmlElement) {
    if (structElement.alt !== undefined) {
      htmlElement.setAttribute("aria-label", structElement.alt);
    }

    if (structElement.id !== undefined) {
      htmlElement.setAttribute("aria-owns", structElement.id);
    }
  }

  _walk(node) {
    if (!node) {
      return null;
    }

    const element = document.createElement("span");

    if ("role" in node) {
      const {
        role
      } = node;
      const match = role.match(HEADING_PATTERN);

      if (match) {
        element.setAttribute("role", "heading");
        element.setAttribute("aria-level", match[1]);
      } else if (PDF_ROLE_TO_HTML_ROLE[role]) {
        element.setAttribute("role", PDF_ROLE_TO_HTML_ROLE[role]);
      }
    }

    this._setAttributes(node, element);

    if (node.children) {
      if (node.children.length === 1 && "id" in node.children[0]) {
        this._setAttributes(node.children[0], element);
      } else {
        for (const kid of node.children) {
          element.appendChild(this._walk(kid));
        }
      }
    }

    return element;
  }

}

exports.StructTreeLayerBuilder = StructTreeLayerBuilder;

class DefaultStructTreeLayerFactory {
  createStructTreeLayerBuilder(pdfPage) {
    return new StructTreeLayerBuilder({
      pdfPage
    });
  }

}

exports.DefaultStructTreeLayerFactory = DefaultStructTreeLayerFactory;

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TextLayerBuilder = exports.DefaultTextLayerFactory = void 0;

var _pdfjsLib = __webpack_require__(5);

const EXPAND_DIVS_TIMEOUT = 300;

class TextLayerBuilder {
  constructor({
    textLayerDiv,
    eventBus,
    pageIndex,
    viewport,
    findController = null,
    enhanceTextSelection = false
  }) {
    this.textLayerDiv = textLayerDiv;
    this.eventBus = eventBus;
    this.textContent = null;
    this.textContentItemsStr = [];
    this.textContentStream = null;
    this.renderingDone = false;
    this.pageIdx = pageIndex;
    this.pageNumber = this.pageIdx + 1;
    this.matches = [];
    this.viewport = viewport;
    this.textDivs = [];
    this.findController = findController;
    this.textLayerRenderTask = null;
    this.enhanceTextSelection = enhanceTextSelection;
    this._onUpdateTextLayerMatches = null;

    this._bindMouse();
  }

  _finishRendering() {
    this.renderingDone = true;

    if (!this.enhanceTextSelection) {
      const endOfContent = document.createElement("div");
      endOfContent.className = "endOfContent";
      this.textLayerDiv.appendChild(endOfContent);
    }

    this.eventBus.dispatch("textlayerrendered", {
      source: this,
      pageNumber: this.pageNumber,
      numTextDivs: this.textDivs.length
    });
  }

  render(timeout = 0) {
    if (!(this.textContent || this.textContentStream) || this.renderingDone) {
      return;
    }

    this.cancel();
    this.textDivs = [];
    const textLayerFrag = document.createDocumentFragment();
    this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
      textContent: this.textContent,
      textContentStream: this.textContentStream,
      container: textLayerFrag,
      viewport: this.viewport,
      textDivs: this.textDivs,
      textContentItemsStr: this.textContentItemsStr,
      timeout,
      enhanceTextSelection: this.enhanceTextSelection
    });
    this.textLayerRenderTask.promise.then(() => {
      this.textLayerDiv.appendChild(textLayerFrag);

      this._finishRendering();

      this._updateMatches();
    }, function (reason) {});

    if (!this._onUpdateTextLayerMatches) {
      this._onUpdateTextLayerMatches = evt => {
        if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
          this._updateMatches();
        }
      };

      this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
    }
  }

  cancel() {
    if (this.textLayerRenderTask) {
      this.textLayerRenderTask.cancel();
      this.textLayerRenderTask = null;
    }

    if (this._onUpdateTextLayerMatches) {
      this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);

      this._onUpdateTextLayerMatches = null;
    }
  }

  setTextContentStream(readableStream) {
    this.cancel();
    this.textContentStream = readableStream;
  }

  setTextContent(textContent) {
    this.cancel();
    this.textContent = textContent;
  }

  _convertMatches(matches, matchesLength) {
    if (!matches) {
      return [];
    }

    const {
      textContentItemsStr
    } = this;
    let i = 0,
        iIndex = 0;
    const end = textContentItemsStr.length - 1;
    const result = [];

    for (let m = 0, mm = matches.length; m < mm; m++) {
      let matchIdx = matches[m];

      while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
        iIndex += textContentItemsStr[i].length;
        i++;
      }

      if (i === textContentItemsStr.length) {
        console.error("Could not find a matching mapping");
      }

      const match = {
        begin: {
          divIdx: i,
          offset: matchIdx - iIndex
        }
      };
      matchIdx += matchesLength[m];

      while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
        iIndex += textContentItemsStr[i].length;
        i++;
      }

      match.end = {
        divIdx: i,
        offset: matchIdx - iIndex
      };
      result.push(match);
    }

    return result;
  }

  _renderMatches(matches) {
    if (matches.length === 0) {
      return;
    }

    const {
      findController,
      pageIdx,
      textContentItemsStr,
      textDivs
    } = this;
    const isSelectedPage = pageIdx === findController.selected.pageIdx;
    const selectedMatchIdx = findController.selected.matchIdx;
    const highlightAll = findController.state.highlightAll;
    let prevEnd = null;
    const infinity = {
      divIdx: -1,
      offset: undefined
    };

    function beginText(begin, className) {
      const divIdx = begin.divIdx;
      textDivs[divIdx].textContent = "";
      appendTextToDiv(divIdx, 0, begin.offset, className);
    }

    function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
      const div = textDivs[divIdx];
      const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
      const node = document.createTextNode(content);

      if (className) {
        const span = document.createElement("span");
        span.className = className;
        span.appendChild(node);
        div.appendChild(span);
        return;
      }

      div.appendChild(node);
    }

    let i0 = selectedMatchIdx,
        i1 = i0 + 1;

    if (highlightAll) {
      i0 = 0;
      i1 = matches.length;
    } else if (!isSelectedPage) {
      return;
    }

    for (let i = i0; i < i1; i++) {
      const match = matches[i];
      const begin = match.begin;
      const end = match.end;
      const isSelected = isSelectedPage && i === selectedMatchIdx;
      const highlightSuffix = isSelected ? " selected" : "";

      if (isSelected) {
        findController.scrollMatchIntoView({
          element: textDivs[begin.divIdx],
          pageIndex: pageIdx,
          matchIndex: selectedMatchIdx
        });
      }

      if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
        if (prevEnd !== null) {
          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
        }

        beginText(begin);
      } else {
        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
      }

      if (begin.divIdx === end.divIdx) {
        appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
      } else {
        appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);

        for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
          textDivs[n0].className = "highlight middle" + highlightSuffix;
        }

        beginText(end, "highlight end" + highlightSuffix);
      }

      prevEnd = end;
    }

    if (prevEnd) {
      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
    }
  }

  _updateMatches() {
    if (!this.renderingDone) {
      return;
    }

    const {
      findController,
      matches,
      pageIdx,
      textContentItemsStr,
      textDivs
    } = this;
    let clearedUntilDivIdx = -1;

    for (let i = 0, ii = matches.length; i < ii; i++) {
      const match = matches[i];
      const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);

      for (let n = begin, end = match.end.divIdx; n <= end; n++) {
        const div = textDivs[n];
        div.textContent = textContentItemsStr[n];
        div.className = "";
      }

      clearedUntilDivIdx = match.end.divIdx + 1;
    }

    if (!findController?.highlightMatches) {
      return;
    }

    const pageMatches = findController.pageMatches[pageIdx] || null;
    const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
    this.matches = this._convertMatches(pageMatches, pageMatchesLength);

    this._renderMatches(this.matches);
  }

  _bindMouse() {
    const div = this.textLayerDiv;
    let expandDivsTimer = null;
    div.addEventListener("mousedown", evt => {
      if (this.enhanceTextSelection && this.textLayerRenderTask) {
        this.textLayerRenderTask.expandTextDivs(true);

        if (expandDivsTimer) {
          clearTimeout(expandDivsTimer);
          expandDivsTimer = null;
        }

        return;
      }

      const end = div.querySelector(".endOfContent");

      if (!end) {
        return;
      }

      let adjustTop = evt.target !== div;
      adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";

      if (adjustTop) {
        const divBounds = div.getBoundingClientRect();
        const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
        end.style.top = (r * 100).toFixed(2) + "%";
      }

      end.classList.add("active");
    });
    div.addEventListener("mouseup", () => {
      if (this.enhanceTextSelection && this.textLayerRenderTask) {
        expandDivsTimer = setTimeout(() => {
          if (this.textLayerRenderTask) {
            this.textLayerRenderTask.expandTextDivs(false);
          }

          expandDivsTimer = null;
        }, EXPAND_DIVS_TIMEOUT);
        return;
      }

      const end = div.querySelector(".endOfContent");

      if (!end) {
        return;
      }

      end.style.top = "";
      end.classList.remove("active");
    });
  }

}

exports.TextLayerBuilder = TextLayerBuilder;

class DefaultTextLayerFactory {
  createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) {
    return new TextLayerBuilder({
      textLayerDiv,
      pageIndex,
      viewport,
      enhanceTextSelection,
      eventBus
    });
  }

}

exports.DefaultTextLayerFactory = DefaultTextLayerFactory;

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaLayerBuilder = exports.DefaultXfaLayerFactory = void 0;

var _pdfjsLib = __webpack_require__(5);

class XfaLayerBuilder {
  constructor({
    pageDiv,
    pdfPage
  }) {
    this.pageDiv = pageDiv;
    this.pdfPage = pdfPage;
    this.div = null;
    this._cancelled = false;
  }

  render(viewport, intent = "display") {
    return this.pdfPage.getXfa().then(xfa => {
      if (this._cancelled) {
        return;
      }

      const parameters = {
        viewport: viewport.clone({
          dontFlip: true
        }),
        div: this.div,
        xfa,
        page: this.pdfPage
      };

      if (this.div) {
        _pdfjsLib.XfaLayer.update(parameters);
      } else {
        this.div = document.createElement("div");
        this.pageDiv.appendChild(this.div);
        parameters.div = this.div;

        _pdfjsLib.XfaLayer.render(parameters);
      }
    });
  }

  cancel() {
    this._cancelled = true;
  }

  hide() {
    if (!this.div) {
      return;
    }

    this.div.hidden = true;
  }

}

exports.XfaLayerBuilder = XfaLayerBuilder;

class DefaultXfaLayerFactory {
  createXfaLayerBuilder(pageDiv, pdfPage) {
    return new XfaLayerBuilder({
      pageDiv,
      pdfPage
    });
  }

}

exports.DefaultXfaLayerFactory = DefaultXfaLayerFactory;

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SecondaryToolbar = void 0;

var _ui_utils = __webpack_require__(4);

var _pdf_cursor_tools = __webpack_require__(6);

var _pdf_single_page_viewer = __webpack_require__(36);

class SecondaryToolbar {
  constructor(options, mainContainer, eventBus) {
    this.toolbar = options.toolbar;
    this.toggleButton = options.toggleButton;
    this.toolbarButtonContainer = options.toolbarButtonContainer;
    this.buttons = [{
      element: options.presentationModeButton,
      eventName: "presentationmode",
      close: true
    }, {
      element: options.openFileButton,
      eventName: "openfile",
      close: true
    }, {
      element: options.printButton,
      eventName: "print",
      close: true
    }, {
      element: options.downloadButton,
      eventName: "download",
      close: true
    }, {
      element: options.viewBookmarkButton,
      eventName: null,
      close: true
    }, {
      element: options.firstPageButton,
      eventName: "firstpage",
      close: true
    }, {
      element: options.lastPageButton,
      eventName: "lastpage",
      close: true
    }, {
      element: options.pageRotateCwButton,
      eventName: "rotatecw",
      close: false
    }, {
      element: options.pageRotateCcwButton,
      eventName: "rotateccw",
      close: false
    }, {
      element: options.cursorSelectToolButton,
      eventName: "switchcursortool",
      eventDetails: {
        tool: _pdf_cursor_tools.CursorTool.SELECT
      },
      close: true
    }, {
      element: options.cursorHandToolButton,
      eventName: "switchcursortool",
      eventDetails: {
        tool: _pdf_cursor_tools.CursorTool.HAND
      },
      close: true
    }, {
      element: options.scrollVerticalButton,
      eventName: "switchscrollmode",
      eventDetails: {
        mode: _ui_utils.ScrollMode.VERTICAL
      },
      close: true
    }, {
      element: options.scrollHorizontalButton,
      eventName: "switchscrollmode",
      eventDetails: {
        mode: _ui_utils.ScrollMode.HORIZONTAL
      },
      close: true
    }, {
      element: options.scrollWrappedButton,
      eventName: "switchscrollmode",
      eventDetails: {
        mode: _ui_utils.ScrollMode.WRAPPED
      },
      close: true
    }, {
      element: options.spreadNoneButton,
      eventName: "switchspreadmode",
      eventDetails: {
        mode: _ui_utils.SpreadMode.NONE
      },
      close: true
    }, {
      element: options.spreadOddButton,
      eventName: "switchspreadmode",
      eventDetails: {
        mode: _ui_utils.SpreadMode.ODD
      },
      close: true
    }, {
      element: options.spreadEvenButton,
      eventName: "switchspreadmode",
      eventDetails: {
        mode: _ui_utils.SpreadMode.EVEN
      },
      close: true
    }, {
      element: options.documentPropertiesButton,
      eventName: "documentproperties",
      close: true
    }];
    this.items = {
      firstPage: options.firstPageButton,
      lastPage: options.lastPageButton,
      pageRotateCw: options.pageRotateCwButton,
      pageRotateCcw: options.pageRotateCcwButton
    };
    this.mainContainer = mainContainer;
    this.eventBus = eventBus;
    this.opened = false;
    this.containerHeight = null;
    this.previousContainerHeight = null;
    this.reset();

    this._bindClickListeners();

    this._bindCursorToolsListener(options);

    this._bindScrollModeListener(options);

    this._bindSpreadModeListener(options);

    this.eventBus._on("resize", this._setMaxHeight.bind(this));

    this.eventBus._on("baseviewerinit", evt => {
      if (evt.source instanceof _pdf_single_page_viewer.PDFSinglePageViewer) {
        this.toolbarButtonContainer.classList.add("hiddenScrollModeButtons", "hiddenSpreadModeButtons");
      } else {
        this.toolbarButtonContainer.classList.remove("hiddenScrollModeButtons", "hiddenSpreadModeButtons");
      }
    });
  }

  get isOpen() {
    return this.opened;
  }

  setPageNumber(pageNumber) {
    this.pageNumber = pageNumber;

    this._updateUIState();
  }

  setPagesCount(pagesCount) {
    this.pagesCount = pagesCount;

    this._updateUIState();
  }

  reset() {
    this.pageNumber = 0;
    this.pagesCount = 0;

    this._updateUIState();

    this.eventBus.dispatch("secondarytoolbarreset", {
      source: this
    });
  }

  _updateUIState() {
    this.items.firstPage.disabled = this.pageNumber <= 1;
    this.items.lastPage.disabled = this.pageNumber >= this.pagesCount;
    this.items.pageRotateCw.disabled = this.pagesCount === 0;
    this.items.pageRotateCcw.disabled = this.pagesCount === 0;
  }

  _bindClickListeners() {
    this.toggleButton.addEventListener("click", this.toggle.bind(this));

    for (const {
      element,
      eventName,
      close,
      eventDetails
    } of this.buttons) {
      element.addEventListener("click", evt => {
        if (eventName !== null) {
          const details = {
            source: this
          };

          for (const property in eventDetails) {
            details[property] = eventDetails[property];
          }

          this.eventBus.dispatch(eventName, details);
        }

        if (close) {
          this.close();
        }
      });
    }
  }

  _bindCursorToolsListener(buttons) {
    this.eventBus._on("cursortoolchanged", function ({
      tool
    }) {
      buttons.cursorSelectToolButton.classList.toggle("toggled", tool === _pdf_cursor_tools.CursorTool.SELECT);
      buttons.cursorHandToolButton.classList.toggle("toggled", tool === _pdf_cursor_tools.CursorTool.HAND);
    });
  }

  _bindScrollModeListener(buttons) {
    function scrollModeChanged({
      mode
    }) {
      buttons.scrollVerticalButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.VERTICAL);
      buttons.scrollHorizontalButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.HORIZONTAL);
      buttons.scrollWrappedButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.WRAPPED);
      const isScrollModeHorizontal = mode === _ui_utils.ScrollMode.HORIZONTAL;
      buttons.spreadNoneButton.disabled = isScrollModeHorizontal;
      buttons.spreadOddButton.disabled = isScrollModeHorizontal;
      buttons.spreadEvenButton.disabled = isScrollModeHorizontal;
    }

    this.eventBus._on("scrollmodechanged", scrollModeChanged);

    this.eventBus._on("secondarytoolbarreset", evt => {
      if (evt.source === this) {
        scrollModeChanged({
          mode: _ui_utils.ScrollMode.VERTICAL
        });
      }
    });
  }

  _bindSpreadModeListener(buttons) {
    function spreadModeChanged({
      mode
    }) {
      buttons.spreadNoneButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.NONE);
      buttons.spreadOddButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.ODD);
      buttons.spreadEvenButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.EVEN);
    }

    this.eventBus._on("spreadmodechanged", spreadModeChanged);

    this.eventBus._on("secondarytoolbarreset", evt => {
      if (evt.source === this) {
        spreadModeChanged({
          mode: _ui_utils.SpreadMode.NONE
        });
      }
    });
  }

  open() {
    if (this.opened) {
      return;
    }

    this.opened = true;

    this._setMaxHeight();

    this.toggleButton.classList.add("toggled");
    this.toggleButton.setAttribute("aria-expanded", "true");
    this.toolbar.classList.remove("hidden");
  }

  close() {
    if (!this.opened) {
      return;
    }

    this.opened = false;
    this.toolbar.classList.add("hidden");
    this.toggleButton.classList.remove("toggled");
    this.toggleButton.setAttribute("aria-expanded", "false");
  }

  toggle() {
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }

  _setMaxHeight() {
    if (!this.opened) {
      return;
    }

    this.containerHeight = this.mainContainer.clientHeight;

    if (this.containerHeight === this.previousContainerHeight) {
      return;
    }

    this.toolbarButtonContainer.style.maxHeight = `${this.containerHeight - _ui_utils.SCROLLBAR_PADDING}px`;
    this.previousContainerHeight = this.containerHeight;
  }

}

exports.SecondaryToolbar = SecondaryToolbar;

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFSinglePageViewer = void 0;

var _base_viewer = __webpack_require__(28);

var _pdfjsLib = __webpack_require__(5);

class PDFSinglePageViewer extends _base_viewer.BaseViewer {
  constructor(options) {
    super(options);

    this.eventBus._on("pagesinit", evt => {
      this._ensurePageViewVisible();
    });
  }

  get _viewerElement() {
    return (0, _pdfjsLib.shadow)(this, "_viewerElement", this._shadowViewer);
  }

  get _pageWidthScaleFactor() {
    return 1;
  }

  _resetView() {
    super._resetView();

    this._previousPageNumber = 1;
    this._shadowViewer = document.createDocumentFragment();
    this._updateScrollDown = null;
  }

  _ensurePageViewVisible() {
    const pageView = this._pages[this._currentPageNumber - 1];
    const previousPageView = this._pages[this._previousPageNumber - 1];
    const viewerNodes = this.viewer.childNodes;

    switch (viewerNodes.length) {
      case 0:
        this.viewer.appendChild(pageView.div);
        break;

      case 1:
        if (viewerNodes[0] !== previousPageView.div) {
          throw new Error("_ensurePageViewVisible: Unexpected previously visible page.");
        }

        if (pageView === previousPageView) {
          break;
        }

        this._shadowViewer.appendChild(previousPageView.div);

        this.viewer.appendChild(pageView.div);
        this.container.scrollTop = 0;
        break;

      default:
        throw new Error("_ensurePageViewVisible: Only one page should be visible at a time.");
    }

    this._previousPageNumber = this._currentPageNumber;
  }

  _scrollUpdate() {
    if (this._updateScrollDown) {
      this._updateScrollDown();
    }

    super._scrollUpdate();
  }

  _scrollIntoView({
    pageDiv,
    pageSpot = null,
    pageNumber = null
  }) {
    if (pageNumber) {
      this._setCurrentPageNumber(pageNumber);
    }

    const scrolledDown = this._currentPageNumber >= this._previousPageNumber;

    this._ensurePageViewVisible();

    this.update();

    super._scrollIntoView({
      pageDiv,
      pageSpot,
      pageNumber
    });

    this._updateScrollDown = () => {
      this.scroll.down = scrolledDown;
      this._updateScrollDown = null;
    };
  }

  _getVisiblePages() {
    return this._getCurrentVisiblePage();
  }

  _updateHelper(visiblePages) {}

  get _isScrollModeHorizontal() {
    return (0, _pdfjsLib.shadow)(this, "_isScrollModeHorizontal", false);
  }

  _updateScrollMode() {}

  _updateSpreadMode() {}

  _getPageAdvance() {
    return 1;
  }

}

exports.PDFSinglePageViewer = PDFSinglePageViewer;

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Toolbar = void 0;

var _ui_utils = __webpack_require__(4);

const PAGE_NUMBER_LOADING_INDICATOR = "visiblePageIsLoading";
const SCALE_SELECT_CONTAINER_WIDTH = 140;
const SCALE_SELECT_WIDTH = 162;

class Toolbar {
  constructor(options, eventBus, l10n) {
    this.toolbar = options.container;
    this.eventBus = eventBus;
    this.l10n = l10n;
    this.buttons = [{
      element: options.previous,
      eventName: "previouspage"
    }, {
      element: options.next,
      eventName: "nextpage"
    }, {
      element: options.zoomIn,
      eventName: "zoomin"
    }, {
      element: options.zoomOut,
      eventName: "zoomout"
    }, {
      element: options.openFile,
      eventName: "openfile"
    }, {
      element: options.print,
      eventName: "print"
    }, {
      element: options.presentationModeButton,
      eventName: "presentationmode"
    }, {
      element: options.download,
      eventName: "download"
    }, {
      element: options.viewBookmark,
      eventName: null
    }];
    this.items = {
      numPages: options.numPages,
      pageNumber: options.pageNumber,
      scaleSelectContainer: options.scaleSelectContainer,
      scaleSelect: options.scaleSelect,
      customScaleOption: options.customScaleOption,
      previous: options.previous,
      next: options.next,
      zoomIn: options.zoomIn,
      zoomOut: options.zoomOut
    };
    this._wasLocalized = false;
    this.reset();

    this._bindListeners();
  }

  setPageNumber(pageNumber, pageLabel) {
    this.pageNumber = pageNumber;
    this.pageLabel = pageLabel;

    this._updateUIState(false);
  }

  setPagesCount(pagesCount, hasPageLabels) {
    this.pagesCount = pagesCount;
    this.hasPageLabels = hasPageLabels;

    this._updateUIState(true);
  }

  setPageScale(pageScaleValue, pageScale) {
    this.pageScaleValue = (pageScaleValue || pageScale).toString();
    this.pageScale = pageScale;

    this._updateUIState(false);
  }

  reset() {
    this.pageNumber = 0;
    this.pageLabel = null;
    this.hasPageLabels = false;
    this.pagesCount = 0;
    this.pageScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
    this.pageScale = _ui_utils.DEFAULT_SCALE;

    this._updateUIState(true);

    this.updateLoadingIndicatorState();
  }

  _bindListeners() {
    const {
      pageNumber,
      scaleSelect
    } = this.items;
    const self = this;

    for (const {
      element,
      eventName
    } of this.buttons) {
      element.addEventListener("click", evt => {
        if (eventName !== null) {
          this.eventBus.dispatch(eventName, {
            source: this
          });
        }
      });
    }

    pageNumber.addEventListener("click", function () {
      this.select();
    });
    pageNumber.addEventListener("change", function () {
      self.eventBus.dispatch("pagenumberchanged", {
        source: self,
        value: this.value
      });
    });
    scaleSelect.addEventListener("change", function () {
      if (this.value === "custom") {
        return;
      }

      self.eventBus.dispatch("scalechanged", {
        source: self,
        value: this.value
      });
    });
    scaleSelect.addEventListener("click", function (evt) {
      const target = evt.target;

      if (this.value === self.pageScaleValue && target.tagName.toUpperCase() === "OPTION") {
        this.blur();
      }
    });
    scaleSelect.oncontextmenu = _ui_utils.noContextMenuHandler;

    this.eventBus._on("localized", () => {
      this._wasLocalized = true;

      this._adjustScaleWidth();

      this._updateUIState(true);
    });
  }

  _updateUIState(resetNumPages = false) {
    if (!this._wasLocalized) {
      return;
    }

    const {
      pageNumber,
      pagesCount,
      pageScaleValue,
      pageScale,
      items
    } = this;

    if (resetNumPages) {
      if (this.hasPageLabels) {
        items.pageNumber.type = "text";
      } else {
        items.pageNumber.type = "number";
        this.l10n.get("of_pages", {
          pagesCount
        }).then(msg => {
          items.numPages.textContent = msg;
        });
      }

      items.pageNumber.max = pagesCount;
    }

    if (this.hasPageLabels) {
      items.pageNumber.value = this.pageLabel;
      this.l10n.get("page_of_pages", {
        pageNumber,
        pagesCount
      }).then(msg => {
        items.numPages.textContent = msg;
      });
    } else {
      items.pageNumber.value = pageNumber;
    }

    items.previous.disabled = pageNumber <= 1;
    items.next.disabled = pageNumber >= pagesCount;
    items.zoomOut.disabled = pageScale <= _ui_utils.MIN_SCALE;
    items.zoomIn.disabled = pageScale >= _ui_utils.MAX_SCALE;
    this.l10n.get("page_scale_percent", {
      scale: Math.round(pageScale * 10000) / 100
    }).then(msg => {
      let predefinedValueFound = false;

      for (const option of items.scaleSelect.options) {
        if (option.value !== pageScaleValue) {
          option.selected = false;
          continue;
        }

        option.selected = true;
        predefinedValueFound = true;
      }

      if (!predefinedValueFound) {
        items.customScaleOption.textContent = msg;
        items.customScaleOption.selected = true;
      }
    });
  }

  updateLoadingIndicatorState(loading = false) {
    const pageNumberInput = this.items.pageNumber;
    pageNumberInput.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading);
  }

  async _adjustScaleWidth() {
    const {
      items,
      l10n
    } = this;
    const predefinedValuesPromise = Promise.all([l10n.get("page_scale_auto"), l10n.get("page_scale_actual"), l10n.get("page_scale_fit"), l10n.get("page_scale_width")]);
    let canvas = document.createElement("canvas");
    canvas.mozOpaque = true;
    let ctx = canvas.getContext("2d", {
      alpha: false
    });
    await _ui_utils.animationStarted;
    const {
      fontSize,
      fontFamily
    } = getComputedStyle(items.scaleSelect);
    ctx.font = `${fontSize} ${fontFamily}`;
    let maxWidth = 0;

    for (const predefinedValue of await predefinedValuesPromise) {
      const {
        width
      } = ctx.measureText(predefinedValue);

      if (width > maxWidth) {
        maxWidth = width;
      }
    }

    const overflow = SCALE_SELECT_WIDTH - SCALE_SELECT_CONTAINER_WIDTH;
    maxWidth += 2 * overflow;

    if (maxWidth > SCALE_SELECT_CONTAINER_WIDTH) {
      items.scaleSelect.style.width = `${maxWidth + overflow}px`;
      items.scaleSelectContainer.style.width = `${maxWidth}px`;
    }

    canvas.width = 0;
    canvas.height = 0;
    canvas = ctx = null;
  }

}

exports.Toolbar = Toolbar;

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ViewHistory = void 0;
const DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20;

class ViewHistory {
  constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) {
    this.fingerprint = fingerprint;
    this.cacheSize = cacheSize;
    this._initializedPromise = this._readFromStorage().then(databaseStr => {
      const database = JSON.parse(databaseStr || "{}");
      let index = -1;

      if (!Array.isArray(database.files)) {
        database.files = [];
      } else {
        while (database.files.length >= this.cacheSize) {
          database.files.shift();
        }

        for (let i = 0, ii = database.files.length; i < ii; i++) {
          const branch = database.files[i];

          if (branch.fingerprint === this.fingerprint) {
            index = i;
            break;
          }
        }
      }

      if (index === -1) {
        index = database.files.push({
          fingerprint: this.fingerprint
        }) - 1;
      }

      this.file = database.files[index];
      this.database = database;
    });
  }

  async _writeToStorage() {
    const databaseStr = JSON.stringify(this.database);
    localStorage.setItem("pdfjs.history", databaseStr);
  }

  async _readFromStorage() {
    return localStorage.getItem("pdfjs.history");
  }

  async set(name, val) {
    await this._initializedPromise;
    this.file[name] = val;
    return this._writeToStorage();
  }

  async setMultiple(properties) {
    await this._initializedPromise;

    for (const name in properties) {
      this.file[name] = properties[name];
    }

    return this._writeToStorage();
  }

  async get(name, defaultValue) {
    await this._initializedPromise;
    const val = this.file[name];
    return val !== undefined ? val : defaultValue;
  }

  async getMultiple(properties) {
    await this._initializedPromise;
    const values = Object.create(null);

    for (const name in properties) {
      const val = this.file[name];
      values[name] = val !== undefined ? val : properties[name];
    }

    return values;
  }

}

exports.ViewHistory = ViewHistory;

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GenericCom = void 0;

var _app = __webpack_require__(3);

var _preferences = __webpack_require__(40);

var _download_manager = __webpack_require__(41);

var _genericl10n = __webpack_require__(42);

var _generic_scripting = __webpack_require__(44);

;
const GenericCom = {};
exports.GenericCom = GenericCom;

class GenericPreferences extends _preferences.BasePreferences {
  async _writeToStorage(prefObj) {
    localStorage.setItem("pdfjs.preferences", JSON.stringify(prefObj));
  }

  async _readFromStorage(prefObj) {
    return JSON.parse(localStorage.getItem("pdfjs.preferences"));
  }

}

class GenericExternalServices extends _app.DefaultExternalServices {
  static createDownloadManager(options) {
    return new _download_manager.DownloadManager();
  }

  static createPreferences() {
    return new GenericPreferences();
  }

  static createL10n({
    locale = "en-US"
  }) {
    return new _genericl10n.GenericL10n(locale);
  }

  static createScripting({
    sandboxBundleSrc
  }) {
    return new _generic_scripting.GenericScripting(sandboxBundleSrc);
  }

}

_app.PDFViewerApplication.externalServices = GenericExternalServices;

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BasePreferences = void 0;

var _app_options = __webpack_require__(1);

class BasePreferences {
  constructor() {
    if (this.constructor === BasePreferences) {
      throw new Error("Cannot initialize BasePreferences.");
    }

    Object.defineProperty(this, "defaults", {
      value: Object.freeze({
        "cursorToolOnLoad": 0,
        "defaultZoomValue": "",
        "disablePageLabels": false,
        "enablePermissions": false,
        "enablePrintAutoRotate": true,
        "enableScripting": true,
        "externalLinkTarget": 0,
        "historyUpdateUrl": false,
        "ignoreDestinationZoom": false,
        "pdfBugEnabled": false,
        "renderer": "canvas",
        "renderInteractiveForms": true,
        "sidebarViewOnLoad": -1,
        "scrollModeOnLoad": -1,
        "spreadModeOnLoad": -1,
        "textLayerMode": 1,
        "useOnlyCssZoom": false,
        "viewerCssTheme": 0,
        "viewOnLoad": 0,
        "disableAutoFetch": false,
        "disableFontFace": false,
        "disableRange": false,
        "disableStream": false,
        "enableXfa": false
      }),
      writable: false,
      enumerable: true,
      configurable: false
    });
    this.prefs = Object.create(null);
    this._initializedPromise = this._readFromStorage(this.defaults).then(prefs => {
      for (const name in this.defaults) {
        const prefValue = prefs?.[name];

        if (typeof prefValue === typeof this.defaults[name]) {
          this.prefs[name] = prefValue;
        }
      }
    });
  }

  async _writeToStorage(prefObj) {
    throw new Error("Not implemented: _writeToStorage");
  }

  async _readFromStorage(prefObj) {
    throw new Error("Not implemented: _readFromStorage");
  }

  async reset() {
    await this._initializedPromise;
    this.prefs = Object.create(null);
    return this._writeToStorage(this.defaults);
  }

  async set(name, value) {
    await this._initializedPromise;
    const defaultValue = this.defaults[name];

    if (defaultValue === undefined) {
      throw new Error(`Set preference: "${name}" is undefined.`);
    } else if (value === undefined) {
      throw new Error("Set preference: no value is specified.");
    }

    const valueType = typeof value;
    const defaultType = typeof defaultValue;

    if (valueType !== defaultType) {
      if (valueType === "number" && defaultType === "string") {
        value = value.toString();
      } else {
        throw new Error(`Set preference: "${value}" is a ${valueType}, expected a ${defaultType}.`);
      }
    } else {
      if (valueType === "number" && !Number.isInteger(value)) {
        throw new Error(`Set preference: "${value}" must be an integer.`);
      }
    }

    this.prefs[name] = value;
    return this._writeToStorage(this.prefs);
  }

  async get(name) {
    await this._initializedPromise;
    const defaultValue = this.defaults[name],
          prefValue = this.prefs[name];

    if (defaultValue === undefined) {
      throw new Error(`Get preference: "${name}" is undefined.`);
    }

    return prefValue !== undefined ? prefValue : defaultValue;
  }

  async getAll() {
    await this._initializedPromise;
    const obj = Object.create(null);

    for (const name in this.defaults) {
      const prefValue = this.prefs[name];
      obj[name] = prefValue !== undefined ? prefValue : this.defaults[name];
    }

    return obj;
  }

}

exports.BasePreferences = BasePreferences;

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DownloadManager = void 0;

var _pdfjsLib = __webpack_require__(5);

var _viewer_compatibility = __webpack_require__(2);

;

function download(blobUrl, filename) {
  const a = document.createElement("a");

  if (!a.click) {
    throw new Error('DownloadManager: "a.click()" is not supported.');
  }

  a.href = blobUrl;
  a.target = "_parent";

  if ("download" in a) {
    a.download = filename;
  }

  (document.body || document.documentElement).appendChild(a);
  a.click();
  a.remove();
}

class DownloadManager {
  constructor() {
    this._openBlobUrls = new WeakMap();
  }

  downloadUrl(url, filename) {
    if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
      return;
    }

    download(url + "#pdfjs.action=download", filename);
  }

  downloadData(data, filename, contentType) {
    const blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, _viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL);
    download(blobUrl, filename);
  }

  openOrDownloadData(element, data, filename) {
    const isPdfData = (0, _pdfjsLib.isPdfFile)(filename);
    const contentType = isPdfData ? "application/pdf" : "";

    if (isPdfData && !_viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL) {
      let blobUrl = this._openBlobUrls.get(element);

      if (!blobUrl) {
        blobUrl = URL.createObjectURL(new Blob([data], {
          type: contentType
        }));

        this._openBlobUrls.set(element, blobUrl);
      }

      let viewerUrl;
      viewerUrl = "?file=" + encodeURIComponent(blobUrl + "#" + filename);

      try {
        window.open(viewerUrl);
        return true;
      } catch (ex) {
        console.error(`openOrDownloadData: ${ex}`);
        URL.revokeObjectURL(blobUrl);

        this._openBlobUrls.delete(element);
      }
    }

    this.downloadData(data, filename, contentType);
    return false;
  }

  download(blob, url, filename, sourceEventType = "download") {
    if (_viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL) {
      this.downloadUrl(url, filename);
      return;
    }

    const blobUrl = URL.createObjectURL(blob);
    download(blobUrl, filename);
  }

}

exports.DownloadManager = DownloadManager;

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GenericL10n = void 0;

__webpack_require__(43);

var _l10n_utils = __webpack_require__(30);

const webL10n = document.webL10n;

class GenericL10n {
  constructor(lang) {
    this._lang = lang;
    this._ready = new Promise((resolve, reject) => {
      webL10n.setLanguage(lang, () => {
        resolve(webL10n);
      });
    });
  }

  async getLanguage() {
    const l10n = await this._ready;
    return l10n.getLanguage();
  }

  async getDirection() {
    const l10n = await this._ready;
    return l10n.getDirection();
  }

  async get(key, args = null, fallback = (0, _l10n_utils.getL10nFallback)(key, args)) {
    const l10n = await this._ready;
    return l10n.get(key, args, fallback);
  }

  async translate(element) {
    const l10n = await this._ready;
    return l10n.translate(element);
  }

}

exports.GenericL10n = GenericL10n;

/***/ }),
/* 43 */
/***/ (() => {



document.webL10n = function (window, document, undefined) {
  var gL10nData = {};
  var gTextData = '';
  var gTextProp = 'textContent';
  var gLanguage = '';
  var gMacros = {};
  var gReadyState = 'loading';
  var gAsyncResourceLoading = true;

  function getL10nResourceLinks() {
    return document.querySelectorAll('link[type="application/l10n"]');
  }

  function getL10nDictionary() {
    var script = document.querySelector('script[type="application/l10n"]');
    return script ? JSON.parse(script.innerHTML) : null;
  }

  function getTranslatableChildren(element) {
    return element ? element.querySelectorAll('*[data-l10n-id]') : [];
  }

  function getL10nAttributes(element) {
    if (!element) return {};
    var l10nId = element.getAttribute('data-l10n-id');
    var l10nArgs = element.getAttribute('data-l10n-args');
    var args = {};

    if (l10nArgs) {
      try {
        args = JSON.parse(l10nArgs);
      } catch (e) {
        console.warn('could not parse arguments for #' + l10nId);
      }
    }

    return {
      id: l10nId,
      args: args
    };
  }

  function xhrLoadText(url, onSuccess, onFailure) {
    onSuccess = onSuccess || function _onSuccess(data) {};

    onFailure = onFailure || function _onFailure() {};

    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, gAsyncResourceLoading);

    if (xhr.overrideMimeType) {
      xhr.overrideMimeType('text/plain; charset=utf-8');
    }

    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        if (xhr.status == 200 || xhr.status === 0) {
          onSuccess(xhr.responseText);
        } else {
          onFailure();
        }
      }
    };

    xhr.onerror = onFailure;
    xhr.ontimeout = onFailure;

    try {
      xhr.send(null);
    } catch (e) {
      onFailure();
    }
  }

  function parseResource(href, lang, successCallback, failureCallback) {
    var baseURL = href.replace(/[^\/]*$/, '') || './';

    function evalString(text) {
      if (text.lastIndexOf('\\') < 0) return text;
      return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
    }

    function parseProperties(text, parsedPropertiesCallback) {
      var dictionary = {};
      var reBlank = /^\s*|\s*$/;
      var reComment = /^\s*#|^\s*$/;
      var reSection = /^\s*\[(.*)\]\s*$/;
      var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
      var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;

      function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
        var entries = rawText.replace(reBlank, '').split(/[\r\n]+/);
        var currentLang = '*';
        var genericLang = lang.split('-', 1)[0];
        var skipLang = false;
        var match = '';

        function nextEntry() {
          while (true) {
            if (!entries.length) {
              parsedRawLinesCallback();
              return;
            }

            var line = entries.shift();
            if (reComment.test(line)) continue;

            if (extendedSyntax) {
              match = reSection.exec(line);

              if (match) {
                currentLang = match[1].toLowerCase();
                skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang;
                continue;
              } else if (skipLang) {
                continue;
              }

              match = reImport.exec(line);

              if (match) {
                loadImport(baseURL + match[1], nextEntry);
                return;
              }
            }

            var tmp = line.match(reSplit);

            if (tmp && tmp.length == 3) {
              dictionary[tmp[1]] = evalString(tmp[2]);
            }
          }
        }

        nextEntry();
      }

      function loadImport(url, callback) {
        xhrLoadText(url, function (content) {
          parseRawLines(content, false, callback);
        }, function () {
          console.warn(url + ' not found.');
          callback();
        });
      }

      parseRawLines(text, true, function () {
        parsedPropertiesCallback(dictionary);
      });
    }

    xhrLoadText(href, function (response) {
      gTextData += response;
      parseProperties(response, function (data) {
        for (var key in data) {
          var id,
              prop,
              index = key.lastIndexOf('.');

          if (index > 0) {
            id = key.substring(0, index);
            prop = key.substring(index + 1);
          } else {
            id = key;
            prop = gTextProp;
          }

          if (!gL10nData[id]) {
            gL10nData[id] = {};
          }

          gL10nData[id][prop] = data[key];
        }

        if (successCallback) {
          successCallback();
        }
      });
    }, failureCallback);
  }

  function loadLocale(lang, callback) {
    if (lang) {
      lang = lang.toLowerCase();
    }

    callback = callback || function _callback() {};

    clear();
    gLanguage = lang;
    var langLinks = getL10nResourceLinks();
    var langCount = langLinks.length;

    if (langCount === 0) {
      var dict = getL10nDictionary();

      if (dict && dict.locales && dict.default_locale) {
        console.log('using the embedded JSON directory, early way out');
        gL10nData = dict.locales[lang];

        if (!gL10nData) {
          var defaultLocale = dict.default_locale.toLowerCase();

          for (var anyCaseLang in dict.locales) {
            anyCaseLang = anyCaseLang.toLowerCase();

            if (anyCaseLang === lang) {
              gL10nData = dict.locales[lang];
              break;
            } else if (anyCaseLang === defaultLocale) {
              gL10nData = dict.locales[defaultLocale];
            }
          }
        }

        callback();
      } else {
        console.log('no resource to load, early way out');
      }

      gReadyState = 'complete';
      return;
    }

    var onResourceLoaded = null;
    var gResourceCount = 0;

    onResourceLoaded = function () {
      gResourceCount++;

      if (gResourceCount >= langCount) {
        callback();
        gReadyState = 'complete';
      }
    };

    function L10nResourceLink(link) {
      var href = link.href;

      this.load = function (lang, callback) {
        parseResource(href, lang, callback, function () {
          console.warn(href + ' not found.');
          console.warn('"' + lang + '" resource not found');
          gLanguage = '';
          callback();
        });
      };
    }

    for (var i = 0; i < langCount; i++) {
      var resource = new L10nResourceLink(langLinks[i]);
      resource.load(lang, onResourceLoaded);
    }
  }

  function clear() {
    gL10nData = {};
    gTextData = '';
    gLanguage = '';
  }

  function getPluralRules(lang) {
    var locales2rules = {
      'af': 3,
      'ak': 4,
      'am': 4,
      'ar': 1,
      'asa': 3,
      'az': 0,
      'be': 11,
      'bem': 3,
      'bez': 3,
      'bg': 3,
      'bh': 4,
      'bm': 0,
      'bn': 3,
      'bo': 0,
      'br': 20,
      'brx': 3,
      'bs': 11,
      'ca': 3,
      'cgg': 3,
      'chr': 3,
      'cs': 12,
      'cy': 17,
      'da': 3,
      'de': 3,
      'dv': 3,
      'dz': 0,
      'ee': 3,
      'el': 3,
      'en': 3,
      'eo': 3,
      'es': 3,
      'et': 3,
      'eu': 3,
      'fa': 0,
      'ff': 5,
      'fi': 3,
      'fil': 4,
      'fo': 3,
      'fr': 5,
      'fur': 3,
      'fy': 3,
      'ga': 8,
      'gd': 24,
      'gl': 3,
      'gsw': 3,
      'gu': 3,
      'guw': 4,
      'gv': 23,
      'ha': 3,
      'haw': 3,
      'he': 2,
      'hi': 4,
      'hr': 11,
      'hu': 0,
      'id': 0,
      'ig': 0,
      'ii': 0,
      'is': 3,
      'it': 3,
      'iu': 7,
      'ja': 0,
      'jmc': 3,
      'jv': 0,
      'ka': 0,
      'kab': 5,
      'kaj': 3,
      'kcg': 3,
      'kde': 0,
      'kea': 0,
      'kk': 3,
      'kl': 3,
      'km': 0,
      'kn': 0,
      'ko': 0,
      'ksb': 3,
      'ksh': 21,
      'ku': 3,
      'kw': 7,
      'lag': 18,
      'lb': 3,
      'lg': 3,
      'ln': 4,
      'lo': 0,
      'lt': 10,
      'lv': 6,
      'mas': 3,
      'mg': 4,
      'mk': 16,
      'ml': 3,
      'mn': 3,
      'mo': 9,
      'mr': 3,
      'ms': 0,
      'mt': 15,
      'my': 0,
      'nah': 3,
      'naq': 7,
      'nb': 3,
      'nd': 3,
      'ne': 3,
      'nl': 3,
      'nn': 3,
      'no': 3,
      'nr': 3,
      'nso': 4,
      'ny': 3,
      'nyn': 3,
      'om': 3,
      'or': 3,
      'pa': 3,
      'pap': 3,
      'pl': 13,
      'ps': 3,
      'pt': 3,
      'rm': 3,
      'ro': 9,
      'rof': 3,
      'ru': 11,
      'rwk': 3,
      'sah': 0,
      'saq': 3,
      'se': 7,
      'seh': 3,
      'ses': 0,
      'sg': 0,
      'sh': 11,
      'shi': 19,
      'sk': 12,
      'sl': 14,
      'sma': 7,
      'smi': 7,
      'smj': 7,
      'smn': 7,
      'sms': 7,
      'sn': 3,
      'so': 3,
      'sq': 3,
      'sr': 11,
      'ss': 3,
      'ssy': 3,
      'st': 3,
      'sv': 3,
      'sw': 3,
      'syr': 3,
      'ta': 3,
      'te': 3,
      'teo': 3,
      'th': 0,
      'ti': 4,
      'tig': 3,
      'tk': 3,
      'tl': 4,
      'tn': 3,
      'to': 0,
      'tr': 0,
      'ts': 3,
      'tzm': 22,
      'uk': 11,
      'ur': 3,
      've': 3,
      'vi': 0,
      'vun': 3,
      'wa': 4,
      'wae': 3,
      'wo': 0,
      'xh': 3,
      'xog': 3,
      'yo': 0,
      'zh': 0,
      'zu': 3
    };

    function isIn(n, list) {
      return list.indexOf(n) !== -1;
    }

    function isBetween(n, start, end) {
      return start <= n && n <= end;
    }

    var pluralRules = {
      '0': function (n) {
        return 'other';
      },
      '1': function (n) {
        if (isBetween(n % 100, 3, 10)) return 'few';
        if (n === 0) return 'zero';
        if (isBetween(n % 100, 11, 99)) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '2': function (n) {
        if (n !== 0 && n % 10 === 0) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '3': function (n) {
        if (n == 1) return 'one';
        return 'other';
      },
      '4': function (n) {
        if (isBetween(n, 0, 1)) return 'one';
        return 'other';
      },
      '5': function (n) {
        if (isBetween(n, 0, 2) && n != 2) return 'one';
        return 'other';
      },
      '6': function (n) {
        if (n === 0) return 'zero';
        if (n % 10 == 1 && n % 100 != 11) return 'one';
        return 'other';
      },
      '7': function (n) {
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '8': function (n) {
        if (isBetween(n, 3, 6)) return 'few';
        if (isBetween(n, 7, 10)) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '9': function (n) {
        if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few';
        if (n == 1) return 'one';
        return 'other';
      },
      '10': function (n) {
        if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few';
        if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one';
        return 'other';
      },
      '11': function (n) {
        if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
        if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many';
        if (n % 10 == 1 && n % 100 != 11) return 'one';
        return 'other';
      },
      '12': function (n) {
        if (isBetween(n, 2, 4)) return 'few';
        if (n == 1) return 'one';
        return 'other';
      },
      '13': function (n) {
        if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
        if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many';
        if (n == 1) return 'one';
        return 'other';
      },
      '14': function (n) {
        if (isBetween(n % 100, 3, 4)) return 'few';
        if (n % 100 == 2) return 'two';
        if (n % 100 == 1) return 'one';
        return 'other';
      },
      '15': function (n) {
        if (n === 0 || isBetween(n % 100, 2, 10)) return 'few';
        if (isBetween(n % 100, 11, 19)) return 'many';
        if (n == 1) return 'one';
        return 'other';
      },
      '16': function (n) {
        if (n % 10 == 1 && n != 11) return 'one';
        return 'other';
      },
      '17': function (n) {
        if (n == 3) return 'few';
        if (n === 0) return 'zero';
        if (n == 6) return 'many';
        if (n == 2) return 'two';
        if (n == 1) return 'one';
        return 'other';
      },
      '18': function (n) {
        if (n === 0) return 'zero';
        if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one';
        return 'other';
      },
      '19': function (n) {
        if (isBetween(n, 2, 10)) return 'few';
        if (isBetween(n, 0, 1)) return 'one';
        return 'other';
      },
      '20': function (n) {
        if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few';
        if (n % 1000000 === 0 && n !== 0) return 'many';
        if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two';
        if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one';
        return 'other';
      },
      '21': function (n) {
        if (n === 0) return 'zero';
        if (n == 1) return 'one';
        return 'other';
      },
      '22': function (n) {
        if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one';
        return 'other';
      },
      '23': function (n) {
        if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one';
        return 'other';
      },
      '24': function (n) {
        if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few';
        if (isIn(n, [2, 12])) return 'two';
        if (isIn(n, [1, 11])) return 'one';
        return 'other';
      }
    };
    var index = locales2rules[lang.replace(/-.*$/, '')];

    if (!(index in pluralRules)) {
      console.warn('plural form unknown for [' + lang + ']');
      return function () {
        return 'other';
      };
    }

    return pluralRules[index];
  }

  gMacros.plural = function (str, param, key, prop) {
    var n = parseFloat(param);
    if (isNaN(n)) return str;
    if (prop != gTextProp) return str;

    if (!gMacros._pluralRules) {
      gMacros._pluralRules = getPluralRules(gLanguage);
    }

    var index = '[' + gMacros._pluralRules(n) + ']';

    if (n === 0 && key + '[zero]' in gL10nData) {
      str = gL10nData[key + '[zero]'][prop];
    } else if (n == 1 && key + '[one]' in gL10nData) {
      str = gL10nData[key + '[one]'][prop];
    } else if (n == 2 && key + '[two]' in gL10nData) {
      str = gL10nData[key + '[two]'][prop];
    } else if (key + index in gL10nData) {
      str = gL10nData[key + index][prop];
    } else if (key + '[other]' in gL10nData) {
      str = gL10nData[key + '[other]'][prop];
    }

    return str;
  };

  function getL10nData(key, args, fallback) {
    var data = gL10nData[key];

    if (!data) {
      console.warn('#' + key + ' is undefined.');

      if (!fallback) {
        return null;
      }

      data = fallback;
    }

    var rv = {};

    for (var prop in data) {
      var str = data[prop];
      str = substIndexes(str, args, key, prop);
      str = substArguments(str, args, key);
      rv[prop] = str;
    }

    return rv;
  }

  function substIndexes(str, args, key, prop) {
    var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
    var reMatch = reIndex.exec(str);
    if (!reMatch || !reMatch.length) return str;
    var macroName = reMatch[1];
    var paramName = reMatch[2];
    var param;

    if (args && paramName in args) {
      param = args[paramName];
    } else if (paramName in gL10nData) {
      param = gL10nData[paramName];
    }

    if (macroName in gMacros) {
      var macro = gMacros[macroName];
      str = macro(str, param, key, prop);
    }

    return str;
  }

  function substArguments(str, args, key) {
    var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
    return str.replace(reArgs, function (matched_text, arg) {
      if (args && arg in args) {
        return args[arg];
      }

      if (arg in gL10nData) {
        return gL10nData[arg];
      }

      console.log('argument  + arg +  for #' + key + ' is undefined.');
      return matched_text;
    });
  }

  function translateElement(element) {
    var l10n = getL10nAttributes(element);
    if (!l10n.id) return;
    var data = getL10nData(l10n.id, l10n.args);

    if (!data) {
      console.warn('#' + l10n.id + ' is undefined.');
      return;
    }

    if (data[gTextProp]) {
      if (getChildElementCount(element) === 0) {
        element[gTextProp] = data[gTextProp];
      } else {
        var children = element.childNodes;
        var found = false;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
            if (found) {
              children[i].nodeValue = '';
            } else {
              children[i].nodeValue = data[gTextProp];
              found = true;
            }
          }
        }

        if (!found) {
          var textNode = document.createTextNode(data[gTextProp]);
          element.insertBefore(textNode, element.firstChild);
        }
      }

      delete data[gTextProp];
    }

    for (var k in data) {
      element[k] = data[k];
    }
  }

  function getChildElementCount(element) {
    if (element.children) {
      return element.children.length;
    }

    if (typeof element.childElementCount !== 'undefined') {
      return element.childElementCount;
    }

    var count = 0;

    for (var i = 0; i < element.childNodes.length; i++) {
      count += element.nodeType === 1 ? 1 : 0;
    }

    return count;
  }

  function translateFragment(element) {
    element = element || document.documentElement;
    var children = getTranslatableChildren(element);
    var elementCount = children.length;

    for (var i = 0; i < elementCount; i++) {
      translateElement(children[i]);
    }

    translateElement(element);
  }

  return {
    get: function (key, args, fallbackString) {
      var index = key.lastIndexOf('.');
      var prop = gTextProp;

      if (index > 0) {
        prop = key.substring(index + 1);
        key = key.substring(0, index);
      }

      var fallback;

      if (fallbackString) {
        fallback = {};
        fallback[prop] = fallbackString;
      }

      var data = getL10nData(key, args, fallback);

      if (data && prop in data) {
        return data[prop];
      }

      return ' + key + ';
    },
    getData: function () {
      return gL10nData;
    },
    getText: function () {
      return gTextData;
    },
    getLanguage: function () {
      return gLanguage;
    },
    setLanguage: function (lang, callback) {
      loadLocale(lang, function () {
        if (callback) callback();
      });
    },
    getDirection: function () {
      var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];
      var shortCode = gLanguage.split('-', 1)[0];
      return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr';
    },
    translate: translateFragment,
    getReadyState: function () {
      return gReadyState;
    },
    ready: function (callback) {
      if (!callback) {
        return;
      } else if (gReadyState == 'complete' || gReadyState == 'interactive') {
        window.setTimeout(function () {
          callback();
        });
      } else if (document.addEventListener) {
        document.addEventListener('localized', function once() {
          document.removeEventListener('localized', once);
          callback();
        });
      }
    }
  };
}(window, document);

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.docPropertiesLookup = docPropertiesLookup;
exports.GenericScripting = void 0;

var _pdfjsLib = __webpack_require__(5);

async function docPropertiesLookup(pdfDocument) {
  const url = "",
        baseUrl = url.split("#")[0];
  let {
    info,
    metadata,
    contentDispositionFilename,
    contentLength
  } = await pdfDocument.getMetadata();

  if (!contentLength) {
    const {
      length
    } = await pdfDocument.getDownloadInfo();
    contentLength = length;
  }

  return { ...info,
    baseURL: baseUrl,
    filesize: contentLength,
    filename: contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(url),
    metadata: metadata?.getRaw(),
    authors: metadata?.get("dc:creator"),
    numPages: pdfDocument.numPages,
    URL: url
  };
}

class GenericScripting {
  constructor(sandboxBundleSrc) {
    this._ready = (0, _pdfjsLib.loadScript)(sandboxBundleSrc, true).then(() => {
      return window.pdfjsSandbox.QuickJSSandbox();
    });
  }

  async createSandbox(data) {
    const sandbox = await this._ready;
    sandbox.create(data);
  }

  async dispatchEventInSandbox(event) {
    const sandbox = await this._ready;
    sandbox.dispatchEvent(event);
  }

  async destroySandbox() {
    const sandbox = await this._ready;
    sandbox.nukeSandbox();
  }

}

exports.GenericScripting = GenericScripting;

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFPrintService = PDFPrintService;

var _app = __webpack_require__(3);

var _viewer_compatibility = __webpack_require__(2);

let activeService = null;
let overlayManager = null;

function renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size, printResolution, optionalContentConfigPromise) {
  const scratchCanvas = activeService.scratchCanvas;
  const PRINT_UNITS = printResolution / 72.0;
  scratchCanvas.width = Math.floor(size.width * PRINT_UNITS);
  scratchCanvas.height = Math.floor(size.height * PRINT_UNITS);
  const ctx = scratchCanvas.getContext("2d");
  ctx.save();
  ctx.fillStyle = "rgb(255, 255, 255)";
  ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);
  ctx.restore();
  return pdfDocument.getPage(pageNumber).then(function (pdfPage) {
    const renderContext = {
      canvasContext: ctx,
      transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0],
      viewport: pdfPage.getViewport({
        scale: 1,
        rotation: size.rotation
      }),
      intent: "print",
      includeAnnotationStorage: true,
      optionalContentConfigPromise
    };
    return pdfPage.render(renderContext).promise;
  });
}

function PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise = null, l10n) {
  this.pdfDocument = pdfDocument;
  this.pagesOverview = pagesOverview;
  this.printContainer = printContainer;
  this._printResolution = printResolution || 150;
  this._optionalContentConfigPromise = optionalContentConfigPromise || pdfDocument.getOptionalContentConfig();
  this.l10n = l10n;
  this.currentPage = -1;
  this.scratchCanvas = document.createElement("canvas");
}

PDFPrintService.prototype = {
  layout() {
    this.throwIfInactive();
    const body = document.querySelector("body");
    body.setAttribute("data-pdfjsprinting", true);
    const hasEqualPageSizes = this.pagesOverview.every(function (size) {
      return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height;
    }, this);

    if (!hasEqualPageSizes) {
      console.warn("Not all pages have the same size. The printed " + "result may be incorrect!");
    }

    this.pageStyleSheet = document.createElement("style");
    const pageSize = this.pagesOverview[0];
    this.pageStyleSheet.textContent = "@page { size: " + pageSize.width + "pt " + pageSize.height + "pt;}";
    body.appendChild(this.pageStyleSheet);
  },

  destroy() {
    if (activeService !== this) {
      return;
    }

    this.printContainer.textContent = "";
    const body = document.querySelector("body");
    body.removeAttribute("data-pdfjsprinting");

    if (this.pageStyleSheet) {
      this.pageStyleSheet.remove();
      this.pageStyleSheet = null;
    }

    this.scratchCanvas.width = this.scratchCanvas.height = 0;
    this.scratchCanvas = null;
    activeService = null;
    ensureOverlay().then(function () {
      if (overlayManager.active !== "printServiceOverlay") {
        return;
      }

      overlayManager.close("printServiceOverlay");
    });
  },

  renderPages() {
    const pageCount = this.pagesOverview.length;

    const renderNextPage = (resolve, reject) => {
      this.throwIfInactive();

      if (++this.currentPage >= pageCount) {
        renderProgress(pageCount, pageCount, this.l10n);
        resolve();
        return;
      }

      const index = this.currentPage;
      renderProgress(index, pageCount, this.l10n);
      renderPage(this, this.pdfDocument, index + 1, this.pagesOverview[index], this._printResolution, this._optionalContentConfigPromise).then(this.useRenderedPage.bind(this)).then(function () {
        renderNextPage(resolve, reject);
      }, reject);
    };

    return new Promise(renderNextPage);
  },

  useRenderedPage() {
    this.throwIfInactive();
    const img = document.createElement("img");
    const scratchCanvas = this.scratchCanvas;

    if ("toBlob" in scratchCanvas && !_viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL) {
      scratchCanvas.toBlob(function (blob) {
        img.src = URL.createObjectURL(blob);
      });
    } else {
      img.src = scratchCanvas.toDataURL();
    }

    const wrapper = document.createElement("div");
    wrapper.appendChild(img);
    this.printContainer.appendChild(wrapper);
    return new Promise(function (resolve, reject) {
      img.onload = resolve;
      img.onerror = reject;
    });
  },

  performPrint() {
    this.throwIfInactive();
    return new Promise(resolve => {
      setTimeout(() => {
        if (!this.active) {
          resolve();
          return;
        }

        print.call(window);
        setTimeout(resolve, 20);
      }, 0);
    });
  },

  get active() {
    return this === activeService;
  },

  throwIfInactive() {
    if (!this.active) {
      throw new Error("This print request was cancelled or completed.");
    }
  }

};
const print = window.print;

window.print = function () {
  if (activeService) {
    console.warn("Ignored window.print() because of a pending print job.");
    return;
  }

  ensureOverlay().then(function () {
    if (activeService) {
      overlayManager.open("printServiceOverlay");
    }
  });

  try {
    dispatchEvent("beforeprint");
  } finally {
    if (!activeService) {
      console.error("Expected print service to be initialized.");
      ensureOverlay().then(function () {
        if (overlayManager.active === "printServiceOverlay") {
          overlayManager.close("printServiceOverlay");
        }
      });
      return;
    }

    const activeServiceOnEntry = activeService;
    activeService.renderPages().then(function () {
      return activeServiceOnEntry.performPrint();
    }).catch(function () {}).then(function () {
      if (activeServiceOnEntry.active) {
        abort();
      }
    });
  }
};

function dispatchEvent(eventType) {
  const event = document.createEvent("CustomEvent");
  event.initCustomEvent(eventType, false, false, "custom");
  window.dispatchEvent(event);
}

function abort() {
  if (activeService) {
    activeService.destroy();
    dispatchEvent("afterprint");
  }
}

function renderProgress(index, total, l10n) {
  const progressContainer = document.getElementById("printServiceOverlay");
  const progress = Math.round(100 * index / total);
  const progressBar = progressContainer.querySelector("progress");
  const progressPerc = progressContainer.querySelector(".relative-progress");
  progressBar.value = progress;
  l10n.get("print_progress_percent", {
    progress
  }).then(msg => {
    progressPerc.textContent = msg;
  });
}

window.addEventListener("keydown", function (event) {
  if (event.keyCode === 80 && (event.ctrlKey || event.metaKey) && !event.altKey && (!event.shiftKey || window.chrome || window.opera)) {
    window.print();
    event.preventDefault();

    if (event.stopImmediatePropagation) {
      event.stopImmediatePropagation();
    } else {
      event.stopPropagation();
    }
  }
}, true);

if ("onbeforeprint" in window) {
  const stopPropagationIfNeeded = function (event) {
    if (event.detail !== "custom" && event.stopImmediatePropagation) {
      event.stopImmediatePropagation();
    }
  };

  window.addEventListener("beforeprint", stopPropagationIfNeeded);
  window.addEventListener("afterprint", stopPropagationIfNeeded);
}

let overlayPromise;

function ensureOverlay() {
  if (!overlayPromise) {
    overlayManager = _app.PDFViewerApplication.overlayManager;

    if (!overlayManager) {
      throw new Error("The overlay manager has not yet been initialized.");
    }

    overlayPromise = overlayManager.register("printServiceOverlay", document.getElementById("printServiceOverlay"), abort, true);
    document.getElementById("printCancel").onclick = abort;
  }

  return overlayPromise;
}

_app.PDFPrintServiceFactory.instance = {
  supportsPrinting: true,

  createPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, l10n) {
    if (activeService) {
      throw new Error("The print service is created and active.");
    }

    activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, l10n);
    return activeService;
  }

};

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "PDFViewerApplicationOptions", ({
  enumerable: true,
  get: function () {
    return _app_options.AppOptions;
  }
}));
Object.defineProperty(exports, "PDFViewerApplication", ({
  enumerable: true,
  get: function () {
    return _app.PDFViewerApplication;
  }
}));

var _app_options = __webpack_require__(1);

var _app = __webpack_require__(3);

const pdfjsVersion = '2.9.0';
const pdfjsBuild = '3538ef0';
window.PDFViewerApplication = _app.PDFViewerApplication;
window.PDFViewerApplicationOptions = _app_options.AppOptions;
;
;
{
  __webpack_require__(39);
}
;
{
  __webpack_require__(45);
}

function getViewerConfiguration() {
  let errorWrapper = null;
  errorWrapper = {
    container: document.getElementById("errorWrapper"),
    errorMessage: document.getElementById("errorMessage"),
    closeButton: document.getElementById("errorClose"),
    errorMoreInfo: document.getElementById("errorMoreInfo"),
    moreInfoButton: document.getElementById("errorShowMore"),
    lessInfoButton: document.getElementById("errorShowLess")
  };
  return {
    appContainer: document.body,
    mainContainer: document.getElementById("viewerContainer"),
    viewerContainer: document.getElementById("viewer"),
    eventBus: null,
    toolbar: {
      container: document.getElementById("toolbarViewer"),
      numPages: document.getElementById("numPages"),
      pageNumber: document.getElementById("pageNumber"),
      scaleSelectContainer: document.getElementById("scaleSelectContainer"),
      scaleSelect: document.getElementById("scaleSelect"),
      customScaleOption: document.getElementById("customScaleOption"),
      previous: document.getElementById("previous"),
      next: document.getElementById("next"),
      zoomIn: document.getElementById("zoomIn"),
      zoomOut: document.getElementById("zoomOut"),
      viewFind: document.getElementById("viewFind"),
      openFile: document.getElementById("openFile"),
      print: document.getElementById("print"),
      presentationModeButton: document.getElementById("presentationMode"),
      download: document.getElementById("download"),
      viewBookmark: document.getElementById("viewBookmark")
    },
    secondaryToolbar: {
      toolbar: document.getElementById("secondaryToolbar"),
      toggleButton: document.getElementById("secondaryToolbarToggle"),
      toolbarButtonContainer: document.getElementById("secondaryToolbarButtonContainer"),
      presentationModeButton: document.getElementById("secondaryPresentationMode"),
      openFileButton: document.getElementById("secondaryOpenFile"),
      printButton: document.getElementById("secondaryPrint"),
      downloadButton: document.getElementById("secondaryDownload"),
      viewBookmarkButton: document.getElementById("secondaryViewBookmark"),
      firstPageButton: document.getElementById("firstPage"),
      lastPageButton: document.getElementById("lastPage"),
      pageRotateCwButton: document.getElementById("pageRotateCw"),
      pageRotateCcwButton: document.getElementById("pageRotateCcw"),
      cursorSelectToolButton: document.getElementById("cursorSelectTool"),
      cursorHandToolButton: document.getElementById("cursorHandTool"),
      scrollVerticalButton: document.getElementById("scrollVertical"),
      scrollHorizontalButton: document.getElementById("scrollHorizontal"),
      scrollWrappedButton: document.getElementById("scrollWrapped"),
      spreadNoneButton: document.getElementById("spreadNone"),
      spreadOddButton: document.getElementById("spreadOdd"),
      spreadEvenButton: document.getElementById("spreadEven"),
      documentPropertiesButton: document.getElementById("documentProperties")
    },
    sidebar: {
      outerContainer: document.getElementById("outerContainer"),
      viewerContainer: document.getElementById("viewerContainer"),
      toggleButton: document.getElementById("sidebarToggle"),
      thumbnailButton: document.getElementById("viewThumbnail"),
      outlineButton: document.getElementById("viewOutline"),
      attachmentsButton: document.getElementById("viewAttachments"),
      layersButton: document.getElementById("viewLayers"),
      thumbnailView: document.getElementById("thumbnailView"),
      outlineView: document.getElementById("outlineView"),
      attachmentsView: document.getElementById("attachmentsView"),
      layersView: document.getElementById("layersView"),
      outlineOptionsContainer: document.getElementById("outlineOptionsContainer"),
      currentOutlineItemButton: document.getElementById("currentOutlineItem")
    },
    sidebarResizer: {
      outerContainer: document.getElementById("outerContainer"),
      resizer: document.getElementById("sidebarResizer")
    },
    findBar: {
      bar: document.getElementById("findbar"),
      toggleButton: document.getElementById("viewFind"),
      findField: document.getElementById("findInput"),
      highlightAllCheckbox: document.getElementById("findHighlightAll"),
      caseSensitiveCheckbox: document.getElementById("findMatchCase"),
      entireWordCheckbox: document.getElementById("findEntireWord"),
      findMsg: document.getElementById("findMsg"),
      findResultsCount: document.getElementById("findResultsCount"),
      findPreviousButton: document.getElementById("findPrevious"),
      findNextButton: document.getElementById("findNext")
    },
    passwordOverlay: {
      overlayName: "passwordOverlay",
      container: document.getElementById("passwordOverlay"),
      label: document.getElementById("passwordText"),
      input: document.getElementById("password"),
      submitButton: document.getElementById("passwordSubmit"),
      cancelButton: document.getElementById("passwordCancel")
    },
    documentProperties: {
      overlayName: "documentPropertiesOverlay",
      container: document.getElementById("documentPropertiesOverlay"),
      closeButton: document.getElementById("documentPropertiesClose"),
      fields: {
        fileName: document.getElementById("fileNameField"),
        fileSize: document.getElementById("fileSizeField"),
        title: document.getElementById("titleField"),
        author: document.getElementById("authorField"),
        subject: document.getElementById("subjectField"),
        keywords: document.getElementById("keywordsField"),
        creationDate: document.getElementById("creationDateField"),
        modificationDate: document.getElementById("modificationDateField"),
        creator: document.getElementById("creatorField"),
        producer: document.getElementById("producerField"),
        version: document.getElementById("versionField"),
        pageCount: document.getElementById("pageCountField"),
        pageSize: document.getElementById("pageSizeField"),
        linearized: document.getElementById("linearizedField")
      }
    },
    errorWrapper,
    printContainer: document.getElementById("printContainer"),
    openFileInputName: "fileInput",
    debuggerScriptPath: "./debugger.js"
  };
}

function webViewerLoad() {
  const config = getViewerConfiguration();
  const event = document.createEvent("CustomEvent");
  event.initCustomEvent("webviewerloaded", true, true, {
    source: window
  });

  try {
    parent.document.dispatchEvent(event);
  } catch (ex) {
    console.error(`webviewerloaded: ${ex}`);
    document.dispatchEvent(event);
  }

  _app.PDFViewerApplication.run(config);
}

if (document.blockUnblockOnload) {
  document.blockUnblockOnload(true);
}

if (document.readyState === "interactive" || document.readyState === "complete") {
  webViewerLoad();
} else {
  document.addEventListener("DOMContentLoaded", webViewerLoad, true);
}
})();

/******/ })()
;
//# sourceMappingURL=viewer.js.map]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/build/pdf.sandbox.js</url>
    <content><![CDATA[/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf.sandbox", [], factory);
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf.sandbox"] = factory();
	else
		root["pdfjs-dist/build/pdf.sandbox"] = root.pdfjsSandbox = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports) => {

Object.defineProperty(exports, "__esModule", ({value:true}));exports.default=void 0;var Module=function(){var _scriptDir=typeof document!=='undefined'&&document.currentScript?document.currentScript.src:undefined;return function(Module){Module=Module||{};var b;b||(b=typeof Module!=='undefined'?Module:{});var h,n;b.ready=new Promise(function(a,c){h=a;n=c;});var q={},r;for(r in b)b.hasOwnProperty(r)&&(q[r]=b[r]);var t="";"undefined"!==typeof document&&document.currentScript&&(t=document.currentScript.src);_scriptDir&&(t=_scriptDir);0!==t.indexOf("blob:")?t=t.substr(0,t.lastIndexOf("/")+1):t="";var aa=b.print||console.log.bind(console),u=b.printErr||console.warn.bind(console);for(r in q)q.hasOwnProperty(r)&&(b[r]=q[r]);q=null;var v;b.wasmBinary&&(v=b.wasmBinary);var noExitRuntime=b.noExitRuntime||!0;"object"!==typeof WebAssembly&&w("no native wasm support detected");var x,z=!1;function A(a){var c=b["_"+a];c||w("Assertion failed: Cannot call unknown function "+(a+", make sure it is exported"));return c;}function B(a,c,d,e){var f={string:function(l){var p=0;if(null!==l&&void 0!==l&&0!==l){var U=(l.length<<2)+1;p=C(U);D(l,E,p,U);}return p;},array:function(l){var p=C(l.length);F.set(l,p);return p;}},g=A(a),k=[];a=0;if(e)for(var m=0;m<e.length;m++){var y=f[d[m]];y?(0===a&&(a=G()),k[m]=y(e[m])):k[m]=e[m];}d=g.apply(null,k);d=function(l){return"string"===c?H(l):"boolean"===c?!!l:l;}(d);0!==a&&I(a);return d;}var J="undefined"!==typeof TextDecoder?new TextDecoder("utf8"):void 0;function K(a,c,d){var e=c+d;for(d=c;a[d]&&!(d>=e);)++d;if(16<d-c&&a.subarray&&J)return J.decode(a.subarray(c,d));for(e="";c<d;){var f=a[c++];if(f&128){var g=a[c++]&63;if(192==(f&224))e+=String.fromCharCode((f&31)<<6|g);else{var k=a[c++]&63;f=224==(f&240)?(f&15)<<12|g<<6|k:(f&7)<<18|g<<12|k<<6|a[c++]&63;65536>f?e+=String.fromCharCode(f):(f-=65536,e+=String.fromCharCode(55296|f>>10,56320|f&1023));}}else e+=String.fromCharCode(f);}return e;}function H(a){return a?K(E,a,void 0):"";}function D(a,c,d,e){if(0<e){e=d+e-1;for(var f=0;f<a.length;++f){var g=a.charCodeAt(f);if(55296<=g&&57343>=g){var k=a.charCodeAt(++f);g=65536+((g&1023)<<10)|k&1023;}if(127>=g){if(d>=e)break;c[d++]=g;}else{if(2047>=g){if(d+1>=e)break;c[d++]=192|g>>6;}else{if(65535>=g){if(d+2>=e)break;c[d++]=224|g>>12;}else{if(d+3>=e)break;c[d++]=240|g>>18;c[d++]=128|g>>12&63;}c[d++]=128|g>>6&63;}c[d++]=128|g&63;}}c[d]=0;}}function L(a){for(var c=0,d=0;d<a.length;++d){var e=a.charCodeAt(d);55296<=e&&57343>=e&&(e=65536+((e&1023)<<10)|a.charCodeAt(++d)&1023);127>=e?++c:c=2047>=e?c+2:65535>=e?c+3:c+4;}return c;}function ba(a){var c=L(a)+1,d=M(c);d&&D(a,F,d,c);return d;}var ca,F,E,N;function da(){var a=x.buffer;ca=a;b.HEAP8=F=new Int8Array(a);b.HEAP16=new Int16Array(a);b.HEAP32=N=new Int32Array(a);b.HEAPU8=E=new Uint8Array(a);b.HEAPU16=new Uint16Array(a);b.HEAPU32=new Uint32Array(a);b.HEAPF32=new Float32Array(a);b.HEAPF64=new Float64Array(a);}var O,ea=[],fa=[],ha=[],ia=[];function ja(){var a=b.preRun.shift();ea.unshift(a);}var P=0,Q=null,R=null;b.preloadedImages={};b.preloadedAudios={};function w(a){if(b.onAbort)b.onAbort(a);u(a);z=!0;a=new WebAssembly.RuntimeError("abort("+a+"). Build with -s ASSERTIONS=1 for more info.");n(a);throw a;}function S(a){return String.prototype.startsWith?a.startsWith("data:application/octet-stream;base64,"):0===a.indexOf("data:application/octet-stream;base64,");}var T="data:application/octet-stream;base64,AGFzbQEAAAABxQZsYAR/fn9/AX5gA39/fwF/YAJ/fwF/YAJ/fwBgAX8Bf2AFf35/f38BfmADf39/AGABfAF8YAF/AGACf34BfmACf34AYAR/f39/AX9gAn9/AX5gAn9+AX9gA39/fgF/YAN/fn8BfmABfgF/YAN/fn8AYAZ/fn9/f38BfmADf35/AX9gBX9/f39/AX9gBn9+fn9/fwF+YAN/fn4BfmAEf39+fwF/YAN/f38BfmAEf39/fwBgBn9/f39/fwF/YAR/f39/AX5gA39+fgF/YAF/AX5gBX9+fn5+AGABfgF+YAJ8fAF8YAABf2AFf35/fn8Bf2AHf35/fn5+fwF/YAV/fn5/fwF+YAAAYAV/f39/fwBgA39+fgBgBH9+fn8AYAd/f39/f39/AX9gBn9+f35+fwF/YAV/fn5+fwF/YAV/fn5/fwBgAn5/AGAJf39/f39/f39/AX9gBH9+f38Bf2AEf35+fwF/YAJ+fwF/YAZ/f39/f38BfmAHf35/f39/fwF+YAR/fn9+AX5gBH9+fn8BfmAHf39/f39/fwBgA39/fgBgBH9/fn8AYAR/fn9/AGAIf39/f39/f38Bf2AEf39/fgF/YAR/fn9+AX9gBH9+fn4Bf2AGf3x/f39/AX9gA35/fwF/YAR/fn5+AX5gAn5+AX5gAnx/AXxgA3x8fwF8YAZ/f39/f38AYAN/f3wAYAV/fn9/fwBgBH9+f34AYAJ/fABgB3x/f39/f38AYAp/f39/f39/f39/AX9gB39/f35+fn8Bf2AFf39+f38Bf2AEf39+fgF/YAV/f35+fwF/YAZ/f35+f38Bf2AGf39+fn5+AX9gBX9+f39/AX9gBn9+f39/fwF/YAV/fn5+fgF/YAZ/fn5+fn8Bf2AEf3x/fwF/YAN+fn4Bf2AEfn5+fgF/YAJ8fwF/YAJ8fAF/YAABfmABfAF+YAV/f39/fwF+YAd/f39/f39+AX5gBX9/f39+AX5gBH9/f34BfmADf39+AX5gBH9/fn8BfmAFf39+fn4BfmAFf35/fn8BfmAHf35+fn9/fwF+YAh/fn5+fn9+fgF+YAN/fnwBfmAFf3x/f38BfmABfwF8YAF+AXxgAn9/AXxgAn5+AXwCPQoBYQFhABkBYQFiACUBYQFjAAIBYQFkAAsBYQFlAAQBYQFmAAMBYQFnAAEBYQFoAAIB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QQBHDwsgAacPCyABpykCBCEEIAAgARAKIARC/////weDQgBSDwsgAactAAUhAiAAIAEQCiACQX9zQYABcUEHdg8LIANBC2pBEk8EQCABEEkiBb1C////////////AINCgYCAgICAgPj/AFQgBUQAAAAAAAAAAGJxDwsgACABEApBASECCyACCxkAIAAoAhAgARDnASIBRQRAIAAQxgELIAELPwEBfyMAQRBrIgIkAAJ/IAEgACgCEEcEQCACIAE2AgAgAEH91gAgAhATQX8MAQsgABAPCyEAIAJBEGokACAACyEAIAAoAgRBf0wEQCAAIAFBAXRqLwEQDwsgACABai0AEAsoAQF/IwBBEGsiAiQAIAIgATsBDiAAIAJBDmpBAhCHARogAkEQaiQACwsAIAAgAUEBEOMFC5oLAgV/D34jAEHgAGsiBSQAIAJCIIYgAUIgiIQhDyAEQi+GIANCEYiEIQwgBEL///////8/gyINQg+GIANCMYiEIRAgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiC0IgiCERIA1CEYghEiAEQjCIp0H//wFxIQcCQAJ/IAJCMIinQf//AXEiCUEBa0H9/wFNBEBBACAHQQFrQf7/AUkNARoLIAFQIAJC////////////AIMiDkKAgICAgIDA//8AVCAOQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASAOQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgDoQhAkIAIQEgAlAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgDoRQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIA5C////////P1gEQCAFQdAAaiABIAsgASALIAtQIgYbeSAGQQZ0rXynIgZBD2sQciAFKQNYIgtCIIYgBSkDUCIBQiCIhCEPIAtCIIghEUEQIAZrIQYLIAYgAkL///////8/Vg0AGiAFQUBrIAMgDSADIA0gDVAiCBt5IAhBBnStfKciCEEPaxByIAUpA0giAkIPhiAFKQNAIgNCMYiEIRAgAkIvhiADQhGIhCEMIAJCEYghEiAGIAhrQRBqCyEGIAxC/////w+DIgIgAUL/////D4MiAX4iEyADQg+GQoCA/v8PgyIDIA9C/////w+DIg5+fCIEQiCGIg0gASADfnwiDCANVK0gAiAOfiIVIAMgC0L/////D4MiC358IhQgEEL/////D4MiDSABfnwiECAEIBNUrUIghiAEQiCIhHwiEyACIAt+IhYgAyARQoCABIQiD358IgMgDSAOfnwiESABIBJC/////weDQoCAgIAIhCIBfnwiEkIghnwiF3whBCAHIAlqIAZqQf//AGshBgJAIAsgDX4iGCACIA9+fCICIBhUrSACIAIgASAOfnwiAlatfCACIAIgFCAVVK0gECAUVK18fCICVq18IAEgD358IAEgC34iCyANIA9+fCIBIAtUrUIghiABQiCIhHwgAiABQiCGfCIBIAJUrXwgASABIBEgElatIAMgFlStIAMgEVatfHxCIIYgEkIgiIR8IgFWrXwgASAQIBNWrSATIBdWrXx8IgIgAVStfCIBQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAxCP4ghAyABQgGGIAJCP4iEIQEgAkIBhiAEQj+IhCECIAxCAYYhDCADIARCAYaEIQQLIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQYABTwRAQgAhAQwDCyAFQTBqIAwgBCAGQf8AaiIGEHIgBUEgaiACIAEgBhByIAVBEGogDCAEIAcQ1gIgBSACIAEgBxDWAiAFKQMwIAUpAziEQgBSrSAFKQMgIAUpAxCEhCEMIAUpAyggBSkDGIQhBCAFKQMAIQIgBSkDCAwBCyABQv///////z+DIAatQjCGhAsgCoQhCiAMUCAEQn9VIARCgICAgICAgICAf1EbRQRAIAogAkIBfCIBIAJUrXwhCgwBCyAMIARCgICAgICAgICAf4WEUEUEQCACIQEMAQsgCiACIAJCAYN8IgEgAlStfCEKCyAAIAE3AwAgACAKNwMIIAVB4ABqJAALagECfwJAIAAoAtgCIgNFDQAgACgC4AIiBCAAKALcAk4NACAAKALoAiABSw0AIAAoAuQC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AC0AAEEgcUUEQCABIAIgABCnBBoLC64CAAJAAkACQAJAIAJBA0wEQAJAAkACQAJAAkACQAJAAkACQCABQdgAaw4JAAECAwQFBgcICgsgACACQT1rQf8BcRAODwsgACACQTlrQf8BcRAODwsgACACQTVrQf8BcRAODwsgACACQTFrQf8BcRAODwsgACACQS1rQf8BcRAODwsgACACQSlrQf8BcRAODwsgACACQSVrQf8BcRAODwsgACACQSFrQf8BcRAODwsgACACQR1rQf8BcRAODwsgAkH/AUoNAQJAAkACQCABQdgAaw4DAAECBAsgAEHAARAODAULIABBwQEQDgwECyAAQcIBEA4MAwsgAUEiRg0BCyAAIAFB/wFxEA4gACACQf//A3EQMA8LIAAgAkEUa0H/AXEQDg8LIAAgAkH/AXEQDgscAQF/IAAgARA6BH9BAAUgAEGPxABBABAUQX8LCxkBAX8gASACED8iA0UEQCAAIAIQnAMLIAMLJgEBfyMAQRBrIgIkACACQQA2AgwgAEEBIAFBABD9ASACQRBqJAALGQAgACgCECABEJwCIgFFBEAgABDGAQsgAQsPACAAKAJAQYACaiABEA4LbwIBfgF/IAAhBAJAAkAgARAQDQAgACABQTsgAUEAEBIiAxALBEAgAw8LIAMQIA0BIAAgAxAKIAAgARCNAyIEDQBCgICAgOAADwsgBCgCKCACQQN0aikDABANIQMLIAAgAyACEFAhASAAIAMQCiABCzEAIAAgASACQoCAgIAIfEL/////D1gEfiACQv////8PgwUgArkQFQsgA0GHgAEQygILEAAgACAANgIEIAAgADYCAAtjAAJAAkAgAUEASA0AIAAoAqwCIAFMDQAgACgCpAIgAUEUbGoiACAAKAIAIAJqIgA2AgAgAEF/TA0BIAAPC0GeigFBoQ1ByKgBQcOKARAAAAtB0IoBQaENQcuoAUHDigEQAAALDAAgAEG80AFBABAUCw0AIAAgASABEEMQ/gELUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgLbQEBfyMAQYACayIFJAAgBEGAwARxIAIgA0xyRQRAIAUgAUH/AXEgAiADayICQYACIAJB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2RcQdiEHDAELQX8hBwsgCkEQaiQAIAcLTAECfyMAQRBrIgMkAAJAIAFBgIABcUUEQCABQYCAAnFFDQEgABD6AUUNAQsgA0EANgIMIABBBCACQQAQ/QFBfyEECyADQRBqJAAgBAvMAQECfwJAAkAgAUKAgICAcFoEQCABpyEDA0ACQCADLQAFQQRxRQ0AIAAoAhAoAkQgAy8BBkEYbGooAhQiBEUNACAEKAIQRQ0AIAAgA61CgICAgHCEEA0iASACIAQoAhAREwAhAiAAIAEQCiACDwsgA61CgICAgHCEEA0hASAAQQAgAyACEFMhBCAAIAEQCiAEDQIgAy8BBkEVa0H//wNxQQhNBEAgACACEKUDIgQNBAsgAygCECgCLCIDDQALC0EAIQQLIAQPCyAEQR91CxoAIAAgASACQQBOBH4gAq0FIAK4EBULEJ4BCwsAIABB/////wdxC80JAgR/BH4jAEHwAGsiBSQAIARC////////////AIMhCgJAAkAgAUIBfSILQn9RIAJC////////////AIMiCSABIAtWrXxCAX0iC0L///////+///8AViALQv///////7///wBRG0UEQCADQgF9IgtCf1IgCiADIAtWrXxCAX0iC0L///////+///8AVCALQv///////7///wBRGw0BCyABUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAJQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBhshBEIAIAEgBhshAwwCCyADIApCgICAgICAwP//AIWEUA0BIAEgCYRQBEAgAyAKhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAKhFBFDQAgASEDIAIhBAwBCyADIAEgASADVCAJIApUIAkgClEbIgcbIQogBCACIAcbIgtC////////P4MhCSACIAQgBxsiAkIwiKdB//8BcSEIIAtCMIinQf//AXEiBkUEQCAFQeAAaiAKIAkgCiAJIAlQIgYbeSAGQQZ0rXynIgZBD2sQciAFKQNoIQkgBSkDYCEKQRAgBmshBgsg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LQACENwBDQBBWQwEC0GDfwsMAgtBCgwBCyADCyEAIARBEGokACAAC58BAQJ/AkACQCACQv////8HWARAIAAgASACpxCTARB3IgRBAUgNAUF/IAQgACABIAIQngEiAhALGyEEDAILIAAgAhCdAyIFRQRAQX8hBAwBCwJAIAAgASAFEHciBEEBSARAQoCAgIAwIQIMAQtBfyAEIAAgASAFIAFBABASIgIQCxshBAsgACAFEBEMAQtCgICAgDAhAgsgAyACNwMAIAQLFgAgAEKAgICAcFoEQCAApyABNgIgCwsNACAAIAEgARBDEJ0CC3sBAX9BfyECIAAoAhQEf0F/BSABQoCAgIBwg0KAgICAkH9SBEAgACgCACABECsiARALBEAgABCIA0F/DwsgACABpyICQQAgAigCBEH/////B3EQVyECIAAoAgAgARAKIAIPCyAAIAGnIgBBACAAKAIEQf////8HcRBXCwtqAQF/IAAoAhQEQCAAKAIAIAEQCkF/DwsCQCABQoCAgIBwg0KAgICAkH9RDQAgACgCACABED4iARALRQ0AIAAQiANBfw8LIAAgAaciAkEAIAIoAgRB/////wdxEFchAiAAKAIAIAEQCiACCxYBAX8gAEIgiKciAUUgAUELakERS3ILSgECfyACQv////8HWARAIAAgASACIANBgIABEOABDwsgACACEJ0DIgRFBEAgACADEApBfw8LIAAgASAEIAMQSCEFIAAgBBARIAULggoBEn8jAEEwayIHJAAgAUEANgIAIAJBADYCACAHQQA2AiwgB0EANgIoIARBMHEhDiAEQRBxIREgAygCECIJECchBQJAAkACQAJ/A0AgCSgCICAISgRAAkAgBSgCBCINRQ0AQQAgESAFKAIAQYCAgIABcRsgBCAAIA0QpAMiC3ZBAXFFcg0AAkAgDkUNACAFKAIAQYCAgIB8cUGAgICAeEcNACADKAIUIAhBA3RqKAIAKAIQKQMAEIMBRQ0AIAAgBSgCBBDhAUF/DAQLIAAgB0EkaiANELIBBEAgDEEBaiEMDAELIAtFBEAgD0EBaiEPDAELIApBAWohCgsgBUEIaiEFIAhBAWohCAwBCwtBACEFAkAgAy0ABSIGQQRxRQ0AIAZBCHEEQCAEQQFxRQ0BIAMoAiggDGohDAwBCyADLwEGIgZBBUYEQCAEQQFx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HgAgACABIAJBAE4EfiACrQUgArgQFQsgAyAEEMoCC6wCAQR/IwBBEGsiAiQAAkACQAJAAkACQANAAkACQAJAIAEQVEEIag4QBAIFBQUFBQEIAAAGBQUICAULIAFC/////w+DIQEMBwsgACABQQEQwAEiARALRQ0BDAULCyAAIAJBCGogARCQAiEDIAAgARAKIAMEQCACIAM2AgwgAiADIAMQhgMiBGoiBTYCDEIAIQECQCAEIAIoAghGDQAgACAFIAJBDGpBAEEEEMICIgEQCw0AIAIgAigCDBCGAyACKAIMaiIENgIMIAIoAgggBCADa0YNACAAIAEQCkKAgICAwH4hAQsgACADEDYLIANFDQMMBAsgACABEAogAEGIwwBBABAUDAILIAAgARAKC0KAgICAwH4hAQwBC0KAgICA4AAhAQsgAkEQaiQAIAELzQIBA38CQCABQoCAgIBwVCACQv////8PVnINACACpyIEIAGnIgMoAihPDQACQAJAAkACQAJAAkACQAJAAkACQCADLwEGIgVBCGsOFgEKCgoKCgoKCgoKCgoDAgMEBQYHCAkACyAFQQJHDQkLIAMoAiQgBEEDdGopAwAQDQ8LIAMoAiQgBGowAABC/////w+DDwsgAygCJCAEajEAAA8LIAMoAiQgBEEBdGoyAQBC/////w+DDwsgAygCJCAEQQF0ajMBAA8LIAMoAiQgBEECdGo1AgAPCyADKAIkIARBAnRqKAIAIgBBAE4EQCAArQ8LIAC4EBUPCyADKAIkIARBAnRqKgIAuxAVDwsgAygCJCAEQQN0aisDABAVDwsgACACEDkhAyAAIAIQCiADRQRAQoCAgIDgAA8LIAAgASADIAFBABASIQEgACADEBEgAQuzAQEDfyABQoCAgIBwVARAQQAPCyABpyICLwEGQSlGBEAjAEEQayIEJAACQAJAIAAgBEEIaiABQeEAEIQBIgJFDQAgBCkDCCIBEBAEQCAAIAIpAwAQnwEhAwwCCyAAIAEgAikDCEEBIAIQNSIBEAsNACAAIAEQLCEDIAAgAikDABCfASICQQBIDQAgAiADRg0BIABBgNgAQQAQFAtBfyEDCyAEQRBqJAAgAw8LIAItAAVBAXELHgAgAEKAgICAcINCgICAgJB/UQRAIACnIAEQngQLCxYAIAAgACgCKCABQQN0aikDACAB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LCACTQ0BAn8CQCAAKAI4IAJBAnRqKAIAIgApAgRCgICAgICAgIBAg0KAgICAgICAgMAAUg0AIANBDGogABDoBUUNAEEBIAMoAgwiAEF/Rw0BGgtBACEAQQALIQIgASAANgIACyADQRBqJAAgAg8LQcovQaENQb8YQcI/EAAAC0UAIAAoAhAgASACEOYBIgEgAkVyRQRAIAAQxgEgAQ8LIAMEQCADQQAgACgCECABEKMEIgAgAmsiAiAAIAJJGzYCAAsgAQtpAQN+IAAgAkIgiCIDIAFCIIgiBH4gAkL/////D4MiAiABQv////8PgyIBfiIFQiCIIAIgBH58IgJCIIh8IAEgA34gAkL/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwAL+QECA34CfyMAQRBrIgUkAAJ+IAG9IgNC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQQgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCADQjyGIQQgA0IEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgA6dnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahByIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAsqAQF/IwBBEGsiAyQAIAMgAjYCDCAAIAEgAkHuAkEAEK0EGiADQRBqJAALDQAgAEEAIAFBABChBAsbACAAIAFB/wFxEA4gACgCBCEBIAAgAhAcIAELlwwBB38jAEEgayICJAACQAJAAkACQAJAAn8gACgCECIDQYN/RwRAQQAgA0FXRw0BGiAAKAJAIgMtAGxBAXFFBEAgAEHjhgFBABATDAMLIAMoAmRFBEAgAEH+hgFBABATDAMLQX8hBSAAEA8NBQJ/AkACQAJAIAAoAhAiA0Epaw4EAgEBAgALIANB3QBGIANBOmtBAklyIANB/QBGcg0BCyAAKAIwDQAgA0EqRgRAIAAQDw0IQQEhBAsgACABELkBDQcgBEUMAQsgAEEGEAxBAQshAyAAKAJALQBsIQEgA0UEQCAAEDQhBSAAEDQhAyAAQf4AQf0AIAFBA0YbEAwgAEEOEAwg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ACEIDAMLIABB8AAQDCAAQRQQDEHKACEIDAILEAEACwJAAkACQCAIQccAaw4EAQQEAgALIAhBtgFHDQMgABA0IQcgAEG5ARAMIAAgChAaIAAgBxA4IAAgCxAWIAkgB0EBEG8aQTwhCAwDCyAAQfEAEAxBxwAhCAwCCyAAQfAAEAxBygAhCAwBCyAAIAgQDAsgASAINgIAIAIgCzYCACADIAo2AgAgBCAHNgIAIAUEQCAFIAw2AgALQQALWgEDfyMAQRBrIgEkAAJAIAAoAhAiA0Gqf0YNACADQTtHBEAgA0H9AEYNASAAKAIwDQEgAUE7NgIAIABB/dYAIAEQE0F/IQIMAQsgABAPIQILIAFBEGokACACCxkAIAEgAkEPcToABCABQQhqIABB0ABqEEwLvAEBBX8jAEEgayIEJAACfgJAIAJCgICAgHCDQoCAgICQf1IEQCAAIAIQPiICEAsNAQsgACAEQQhqIAEQQyIGIAMQQyIHaiACpyIFKAIEIghB/////wdxaiAIQR92EKoDDQAgBEEIaiABIAYQnQIaIARBCGogBUEAIAUoAgRB/////wdxEFcaIARBCGogAyAHEJ0CGiAAIAIQCiAEQQhqEDcMAQsgACACEApCgICAgOAACyECIARBIGokACACCzsAAn8gACABQYCABE8Ef0F/IAAgAUGAgARrQQp2QYCwA2oQlAENARogAUH/B3FBgLgDcgUgAQsQlAELC1MBAX8gAUKAgICAcFoEfyABpy8BBiICQSlGBEACf0EAIAFBKRA/IgJFDQAaIAItABEEQCAAEMgCQX8MAQsgACACKQMAEL8BCw8LIAJBAkYFQQALC8kCAgF+An8jAEEQayIFJAACQCABQoCAgIBwVARAIAEhAwwBCyACQW9xIQQCQAJAAkAgAkEQcQ0AIAAgAUHCASABQQAQEiIDEAsNASADEBANACADECYNACAFIABBxgBBFiAEQQFGG0HIACAEGxAxNwMIIAAgAyABQQEgBUEIahA1IQMgACAFKQMIEAogAxALDQEgACABEAogA0KAgICAcFQNAyAAIAMQCiAAQajDAEEAEBQMAgsgBEEARyEEQQAhAgNAIAJBAkcEQCAAIAFBN0E5IAIgBEYbIAFBABASIgMQCw0CAkAgACADEDpFDQAgACADIAFBAEEAEDUiAxALDQMgA0L/////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IAJqLQAAIAFGDQIgAkEBaiECDAALAAtBfyECCyACC44BAQF/IwBBEGsiAyQAIAMgAjcDCAJAIAAgAUGGASABQQAQEiICEAsNACAAIAIQOgRAIAAgAiABQQEgA0EIahA1IgIQCw0BIAIQIA0BIAIQJg0BIAAgAhAKIABBj9MAQQAQFEKAgICA4AAhAgwBCyAAIAIQCiAAIAFBASADQQhqEJEFIQILIANBEGokACACC5oBAQN/IAEoAgAhAwJAIAAoAgQiAkF/TARAIAAgA0EBdGovARAiBEGA+ANxQYCwA0cgAkH/////B3EgA0EBaiICTHINASAAIAJBAXRqLwEQIgBBgPgDcUGAuANHDQEgBEEKdEGA+D9xIABB/wdxckGAgARqIQQgA0ECaiECDAELIANBAWohAiAAIANqLQAQIQQLIAEgAjYCACAECygAIAAgAkEwIAJBABASIgIQCwRAIAFBADYCAEF/DwsgACABIAIQ6QMLMwEBfwJAIAFCgICAgHBUDQAgAaciAy8BBkESRw0AIANBIGoPCyACBEAgAEESEJwDC0EACzkAIABB/wBNBEAgAEEDdkH8////AXFB4N8BaigCACAAdkEBcQ8LIABBfnFBjMAARiAAELgEQQBHcgtdAQF/QX8hBAJAIAAgARApIgEQCw0AIAAgAacgAhCUBCEEIAAgARAKIAQNACADQYCAAXFFBEBBACEEIANBgIACcUUNASAAEPoBRQ0BCyAAQfAYQQAQFEF/IQQLIAQL2AICA38CfCABEFQhBiACEFQhBAJAAkACfAJAAkACQAJAAkACQAJAAkAgBkEIag4QAgEKCgoKCgMEAAkJCgoKBQoLIARBAUcNCSABpyACp0YPCyAEQXlHDQggAacgAqcQlQJFIQUMCAsgAacgAqdGIARBeEZxIQUMBwsgBEF/Rw0GIAGnIAKnRiEFDAYLIAGntyEHIARBB0YNASAEDQUgAqe3DAMLIAEQSSEHIARFDQEgBEEHRw0ECyACEEkMAQsgAqe3CyEIAkAgAwRAIAe9Qv///////////wCDIgFCgICAgICAgPj/AFhBACAIvUL///////////8AgyICQoGAgICAgID4/wBUG0UEQCABQoGAgICAgID4/wBUIAJCgICAgICAgPj/AFZzDwsgA0ECRw0BCyAHIAhhDwsgB70gCL1RDwsg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IQ5BASEJIAUCfyAFIAhBAnYgAmwiAWoiByAFIAFBAXRqIgYgBCADEQEAIQAgBiAFIAFBA2xqIgogBCADEQEAIQECQCAAQX9MBEAgAUEASA0BIAogByAHIAogBCADEQEAQQBIGwwCCyABQQBKDQAgByAKIAcgCiAEIAMRAQBBAEgbIQYLIAYLIAIgDREGACAFIAIgCGxqIgohASAKIQYgAiAFaiIPIQBBASERA0ACQAJAIAAgAU8NACAFIAAgBCADEQEAIgdBf0wNACAHDQEgDyAAIAIgDREGACACIA9qIQ8gEUEBaiERDAELAkADQCAAIAEgEGoiAU8NASAFIAEgBCADEQEAIgdBAEwEQCAHDQEgBiAQaiIGIAEgAiANEQYAIAhBAWshCAwBCwsgACABIAIgDREGAAwBCyAFIAAgACAPayIHIA8gBWsiASABIAdLGyIBayABIBIRBgAgACAKIAYgAGsiASAKIAZrIgAgACABSxsiAGsgACASEQYAIAggCWshBiAKIAFrIQECQCAGIAkgEWsiCEkEQCAFIQkgCCEAIAEhBSAGIQgMAQsgASEJIAYhAAsgCyAONgIIIAsgADYCBCALIAk2AgAgC0EMaiELDAMLIAAgAmohACAJQQFqIQkMAAsACwsgACAFaiEGIAUhCQNAIAIgCWoiCSEAIAYgCU0NAQNAIAAgBU0NASAAIBBqIgEgACAEIAMRAQBBAUgNASAAIAEgAiANEQYAIAEhAAwACwALAAsACyAMQeAEaiQAC08BAX8gARCOAQRAIAEQDQ8LAkAgAUKAgICAcFQNACABpyICLwEGQQRHDQAgAikDICIBEI4BRQ0AIAEQDQ8LIABB2bQBQQAQFEKAgICA4AALkAIBAn8jAEEQayIDJAAgAyACNwMIQoCAgIDgACECAkAgACABEL8BIgRBAEgNACAERQRAIABCgICAgDBBASADQQhqEOYCIQIMAQsgACABQTwgAUEAEBIiARALBEAgASECDAELAkACQCABELEBRQ0AIAAgARCNAyIERQ0BIAAgBEYNACAAIAEgBCkDQBBYRQ0AIAAgARAKQoCAgIAwIQELAn4gARAgBEAgACABQcwBIAFBABASIQIgACABEAogAhALDQNCgICAgDAgAiACECYbIQELIAELEBAEQCAAQoCAgIAwQQEgA0EIahDmAiECDAIL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JAAgAAvcBAIGfwJ+AkAgAUKAgICAcINCgICAgJB/UgRAQoCAgIDgACEJIAAgARA+IgEQCw0BCwJAIAJCgICAgHCDQoCAgICQf1ENAEKAgICA4AAhCSAAIAIQPiICEAtFDQAgASECDAELAkAgAqciBCkCBCIJQv////8Hg1ANAAJAIAGnIgMoAgBBAUcNACADKQIEIAmFp0EASA0AIAAoAhAgAxCjBCAEKAIEIgVB/////wdxIgcgAykCBCIJpyIIQf////8HcSIGaiAFQR92dCAIQR92IghrQRFqSQ0AIAgEQCADIAZBAXRqQRBqIARBEGogBUEBdBAjGiADIAQpAgQgCXxC/////weDIAlCgICAgHiDhDcCBAwCCyADQRBqIgUgBmogBEEQaiAHECMaIAMgBCkCBCAJfEL/////B4MiCiAJQoCAgIB4g4Q3AgQgBSAKp2pBADoAAAwBCwJ+AkACQCAEKQIEIgmnQf////8HcSADKQIEIgqnQf////8HcWoiBkGAgICABE8EQCAAQfQNQQAQQQwBCyAAIAYgCSAKhKdBH3YiBxD8ASIFDQELQoCAgIDgAAwBCwJAIAdFBEAgBUEQaiADQRBqIAMoAgRB/////wdxECMiByADKAIEQf////8HcWogBEEQaiAEKAIEQf////8HcRAjGiAGIAdqQQA6AAAMAQsgBUEQaiIGIAMgAygCBEH/////B3EQlQUgBiADKAIEQQF0aiAEIAQoAgRB/////wdxEJUFCyAFrUKAgICAkH+ECyEJIAAgARAKDAELIAEhCQsgACACEAogCQtAACAAAn8CfyADBEAgASgCJCACQQN0akEEagwBC0EAIAEoAiAiA0UNARogAyABLwEoIAJqQQR0agsoAgALEOEBCwsAIABB4ztBABAUC50MAgx/BH4jAEGAAWsiCiQAIAohBSMAQeABayIIJAACQCABvSIRQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgEUL///////////8Ag0KBgICAgICA+P8AWgRAIAVBzsK5AjYAAAwCCyABRAAAAAAAAAAAYwRAIAVBLToAACAFQQFqIQULIAVBvMMALQAAOgAIIAVBtMMAKQAANwAADAELAkAgBEUEQAJ+IAGZRAAAAAAAAOBDYwRAIAGwDAELQoCAgICAgICAgH8LIhJC////////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AwAQCiADQQFqIQMMAQsLIAAgARAYC2UBAn8jAEEQayIFJAACQCACEJsBRQRAIAIQDSECDAELIAAgBUEMaiACEJACIgZFBEBCgICAgOAAIQIMAQsgACABIAYgBSgCDEGQyAAgAyAEELcFIQIgACAGEDYLIAVBEGokACACC7wBAgN+AX8jAEEQayICJABCgICAgOAAIQUCQCAAIAEQZw0AIAMpAwAhBgJAAkAgAykDCCIHQiCIpyIDQQNHBEAgBEECRg0CIANBAkYNAQwCCyAEQQJGDQELIAAgASAGQQBBABAiIQUMAQsgACACQQxqIAcQiwQiA0UNACACKAIMIQgCfiAEQQFxBEAgACABIAYgCCADEI4DDAELIAAgASAGIAggAxAiCyEFIAAgAyAIEJgDCyACQRBqJAAgBQsNACAAIAEQDSACEMABCxwAIAAgACgCECgCRCABQRhsaigCBEH1wgAQxQELZQEBfyMAQTBrIgIkAAJ/IAFC/////wdYBEAgAacQkwEMAQsgAiABNwMAIAJBEGpBGEGBwQAgAhBVGkEAIAAgAkEQahBxIgEQCw0AGiAAKAIQIAGnQQEQ1AILIQAgAkEwaiQAIAALPAEBfyABIAAoAtQBIAEoAhQgACgCyAEQ0QJBAnRqIgIoAgA2AiggAiABNgIAIAAgACgC0AFBAWo2AtABC0MAAn9BACACKAIAKAIAQRp2IANGDQAaQX8gACABIAIQ4wENABogAigCACIAIAAoAgBB////H3EgA0EadHI2AgBBAAsLqwEBBH9BfyECAkAgACABQQAQ4wENACABKAIoIgQgASgCECIDKAIgaiIFIAMoAhxLBEAgACABQRBqIAEgBRDRBQ0BCyABKAIkIQNBACECA0AgAiAERkUEQCAAIAEgAhCTAUEHEIABIAMpAwA3AwAgAkEBaiECIANBCGohAwwBCwsgACABKAIkEBhBACECIAFBADYCKCABQgA3AyAgASABLQAFQfcBcToABQsgAgt5AQN/AkACQCAAQQFxIgINACABQYECcUGBAkYgAUGACHFBACAAIAFzQQRxG3INASACIAFBgPQAcUVyDQAgAEEwcSICQRBGIAFBgDBxIgRBAEdzDQEgAEECcSABQYIEcUGCBEdyIAJBEEZyDQAgBEUNAQtBASEDCyADC5QBAQF/IwBBEGsiBSQAIAUg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AkACQCAAIARBCGogAUHiABCEASICRQ0AIAQpAwgiARAQBEAgACACKQMAEJkEIQMMAgsgACABIAIpAwhBASACEDUiARALDQAgACABECwiA0UEQEEAIQMMAgsgACACKQMAEJ8BIgJBAEgNACACRQ0BIABBodgAQQAQFAtBfyEDCyAEQRBqJAAgAw8LIAIgAi0ABUH+AXE6AAVBAQsuAQF/IACnKQMgIgBCgICAgHCDQoCAgICQf1EEfyAApygCBEH/////B3EFQQALCwoAIAAoAgBBfHELMwAgACACQQEQ/AEiAEUEQEKAgICA4AAPCyAAQRBqIAEgAkEBdBAjGiAArUKAgICAkH+EC2UCAn8BfkEEIQJCgICAgCAhBAJAAkACQAJAAkACQCABEFQiA0EIag4KAwIFBQUFBQUEAQALIANBB0YNAwwEC0EGIQIMAgtBBSECDAELQQchAgsgACgCKCACQQN0aikDACEECyAEC18BAXwgACkCBEL//////////z9YBEAgASABKwMIRAAAAAAAAPA/IAAoAgC3IgKjoDkDCCABIAErAxAgACgCBCIAQf////8HcSAAQR92IgB0IABrQRFquCACo6A5AxALC+cGAQV/AkACQAJAAkACQAJAAkACQAJAIAEtAARBD3EOBgABBAIDBgULIAAgASgCECIHIAIRAwAgBxAnIQUDQCAHKAIgIANKBEACQCAFKAIERQ0AIAEoAhQgA0EDdGohBAJAAkACQAJAIAUoAgBBHnZBAWsOAwABAgMLIAQoAgAiBgRAIAAgBiACEQMACyAEKAIEIgRFDQMgACAEIAIRAwAMAwsgBCgCACIELQAFQQFxRQ0CIAAgBCACEQMADAILIAAgBBCbBCACEQMADAELIAAgBCkDACACECELIANBAWohAyAFQQhqIQUMAQsLIAEvAQYiA0EBRg0GIAAoAkQgA0EYbGooAgwiA0UNBiAAIAGtQoCAgIBwhCACIAMREQAPCwNAIAEoAjggA0oEQCAAIAEoAjQgA0EDdGopAwAgAhAhIANBAWohAwwBCwsgASgCMCIBRQ0FIAAgASACEQMADwsgAS0ABUEBcUUNBSAAIAEoAhApAwAgAhAhDwsgASgCIARAIAAgAUEoaiACEPADCyAAIAEpAxAgAhAhIAAgASkDGCACECEPCyABKAIsIgFFDQIgACABIAIRAwAPCxABAAsgAUHkAWohAyABQeABaiEHA0AgByADKAIAIgVHBEAgBUEIayEDQQAhBANAIAMoAiAgBEoEQAJAIAMoAhwgBEEUbGoiBigCCA0AIAYoAgQiBkUNACAAIAYgAhEDAAsgBEEBaiEEDAELCyAAIAMpA0AgAhAhIAAgAykDSCACECEgACADKQNgIAIQISAAIAMpA2ggAhAhIAVBBGohAwwBCwsgACABKQPAASACECEgACABKQPIASACECEgACABKQOwASACECEgACABKQO4ASACECEgACABKQOoASACECFBACEDA0AgA0EIRgRAQQAhAwNAIAAoAkAgA0oEQCAAIAEoAiggA0EDdGopAwAgAhAhIANBAWohAwwBCwsgACABKQOYASACECEgACABKQOgASACECEgACABKQNQIAIQISAAIAEpA0AgAhAhIAAgASkDSCACECEgACABKQM4IAIQISAAIAEpAzAgAhAhIAEoAiQiAQRAIAAgASACEQMACwUgACABIANBA3RqKQNYIAIQISADQQFqIQMMAQsLCw8LQbM5QaENQY4sQcg5EAAAC4kCAgF+An8jAEEwayIEJABBoRkhBUKAgICA4AAhAwJAAkACQAJAAkACQAJAAkACQAJAAkACQCABEFRBCGoOEAUGCQkJCQoEAAECAwkJCwgJCyAEIAE+AgAgBEEQakEgQZ4ZIAQQVRogBEEQaiEFDAkLIABBA0ECIAGnGxAxIQMMCQsgAEEBEDEhAwwICyAAQcUAEDEhAwwHCyAAIAFBABCbAyIBEAsEQCABIQMMBwsgACABIAIQoAQhAyAAIAEQCgwGCyACRQ0BCyABEA0hAwwECyAAQbUZQQAQFAwDCyAAIAEQSUEKQQBBABDJAiEDDAILQdUZIQULIAAgBRBxIQMLIARBMGokACADC6YEAQl/AkACQAJAIAJCgICAgHCDQoCAgICQf1IEQCAAIAIQKyICEAtFDQEMAgsgAhANIQILIAKnIgooAgQiBUH/////B3EhBgJAIAVBAE4EQCAKQRBqIQVBACEDA0AgBCAGRkUEQCADIAQgBWotAABBB3ZqIQMgBEEBaiEEDAELCyADRQRAIAFFDQQgASAGNgIAIAUPCyAAIAMgBmpBABD8ASIHRQ0CQQAhAyAHQRBqIgshBANAIAMgBkYNAgJ/IAMgBWosAAAiCEEATgRAIAQgCDoAACAEQQFqDAELIAQgCEE/cUGAAXI6AAEgBCAIQcABcUEGdkHAAXI6AAAgBEECagshBCADQQFqIQMMAAsACyAAIAZBA2xBABD8ASIHRQ0BQQAhBSAHQRBqIgshBANAIAUiCCAGTg0BIAhBAWohBSAKIAhBAXRqLwEQIglB/wBNBEAgBCAJOgAAIARBAWohBAUCQCADIAUgBk5yIAlBgPgDcUGAsANHcg0AIAogBUEBdGovARAiDEGA+ANxQYC4A0cNACAJQQp0QYD4P3EgDEH/B3FyQYCABGohCSAIQQJqIQULIAQgCRDjAiAEaiEECwwACwALIARBADoAACAHIAQgB2tBEGtB/////wdxrSAHKQIEQoCAgIB4g4Q3AgQgACACEAogAQRAIAEgBygCBEH/////B3E2AgALIAsPCyABRQRAQQAPC0EAIQUgAUEANgIACyAFCyUCAX8BfiAAIAEQMSIDEAtFBEAgACADELcBIQIgACADEAoLIAILDAAgASAAKAIMEQQACz0BAX8gASABKAIAIgJBAWs2AgAgAkEBTARAIAEpAgRCgICAgICAgIDAAFoEQCAAIAEQqwMPCyAAIAEQHwsLVQECfyMAQRBrIgIkACAAKAIQIQACfwJAIAJBDGogARDoBUUNACACKAIMIgNBAEgNACAAIAEQpAQgAxCTAQwBCyAAIAFBARDUAgshASACQRBqJAAgAQtcAQN/IABB4AFqIQQgACgC5AEhAwNAIAQgAyICRwRAIAIoAgQhAwJAAkACQCABDgMCAAEECyACLABMDQMMAQsgAikCTEIghkI4h6cNAgsgACACQQhrEOoFDAELCwu8AQEDfwJAIAEgAigCECIDBH8gAwVBACEDIAIQ8AUNASACKAIQCyACKAIUIgVrSwRAIAIgACABIAIoAiQRAQAPCwJ/IAIsAEtBf0oEQCABIQMDQCABIAMiBEUNAhogACAEQQFrIgNqLQAAQQpHDQALIAIgACAEIAIoAiQRAQAiAyAESQ0CIAAgBGohACACKAIUIQUgASAEawwBCyABCyEDIAUgACADECMaIAIgAigCFCADajYCFCABIQMLIAMLQAEBfyMAQRBrIgUkACAFIAEgAiADIARCgICAgICAgICAf4UQeiAAIAUpAwA3AwAgACAFKQMINwMIIAVBEGok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5wBBABDXASEDIAAgARAKIANBf0oNASAAQYbCAUEAEBQLQX8hAgsgAgtdAQF/AkACQAJAAkAgAUIgiKdBAWoOAwECAAILIAEQDQ8LIAGnIgIvAQZBBkcNACACKQMgIgFCgICAgHCDQoCAgIAQUQ0BCyAAQYC4AUEAEBRCgICAgOAAIQELIAELEABB4bEBIABBCxCBAkEARwteAQJ/QcCxASEDAkACQCABKAIEQf////8HcSIEIAJMDQAgASACEC9BJUcNAEHNsQEhAyACQQJqIARODQAgASACQQFqQQIQwwMiAkF/Sg0BCyAAIAMQxANBfyECCyACC1cAIwBBEGsiAiQAAn5CgICAgOAAIAAgAkEIaiADKQMAEEcNABogAisDCL1CgICAgICAgPj/AINCgICAgICAgPj/AFKtQoCAgIAQhAshASACQRBqJAAgAQtXACMAQRBrIgIkAAJ+QoCAgIDgACAAIAJBCGogAykDABBHDQAaIAIrAwi9Qv///////////wCDQoCAgICAgID4/wBWrUKAgICAEIQLIQEgAkEQaiQAIAEL+AICA38DfiMAQTBrIggkACADQgAgA0IAVRshDSAFQQFrIQogBUEBSCEFQgAhAwNAAkAgAyANUQRAIAQhDAwBC0J/IQwgACACIAMgCEEoahCJASIJQQBIDQACQCAJRQ0AIAYQEEUEQCAIIAgpAyg3AwAgAyELIANCgICAgAhaBEAgA7kQFSELCyAIIAI3AxAgCCALNwMIIAggACAGIAdBAyAIECIiCzcDKCAAIAgpAwAQCiAAIAgpAwgQCiALEAsNAgsCQAJAAkAgBQ0AIAAgCCkDKCILEL8BIglBAEgNASAJRQ0AIAAgCEEgaiALEEBBAEgNASAAIAEgCyAIKQMgIAQgCkKAgICAMEKAgICAMBDTBCIEQgBTDQEgACALEAoMAwsgBEL/////////D1MNASAAQfusAUEAEBQgCCkDKCELCyAAIAsQCgwCCyAAIAEgBCAIKQMoEG1BAEgNASAEQgF8IQQLIANCAXwhAwwBCwsgCEEwaiQAIAwLDAAgAEIAIABCAFUbCygAAkAgARAQRQRAIAEQJkUNAQsgACABED4PCyAAIAFBOEEAQQAQuQILowICBn8BfiMAQTBrIgIkAAJAAkAgAykDACIBECBFDQBCgICAgOAAIQsgACAB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ARAKQoCAgIDgAAuYAQICfgF/IAAgARAxIQMCfwJAIAEQXA0AQQAgACgCECgCOCABQQJ0aigCACkCBCICQoCAgICAgICAQINCgICAgICAgICAf1IgAkKAgICA8P///z+DUCACQv//////////v39WcRsNACACp0F/c0EfdkEBIAJC/////weDUBshBAsgBAsEfiAAQcHKACADQcPKABC9AQUgAwsLpwEBBX8gAKciAygCECIBIAEoAhhBf3NBAnRBpH5yaigCACECIAEQJyEBA0AgAkUEQEEADwsgASACQQFrIgRBA3RqIgUoAgAhAiAFKAIEQTZHBEAgAkH///8fcSECDAELC0EBIQECQCACQf////8DSw0AIAMoAhQgBEEDdGopAwAiAEKAgICAcINCgICAgJB/Ug0AIACnKAIEQf////8HcUEARyEBCyABC8wDAQZ/IABB4ABqIgQQbiAAQdAAaiEFIAAoAlQhAgJAAkADQCAFIAIiAUcEQCABQQRrIgMtAABBEE8NAiABKAIEIQIgACABQQhrIgZBBhCfBCADIAMtAABBD3FBEHI6AAAgBigCAA0BIAEQRiABIAQQTAwBCwsMAQtBnDlBoQ1BxCxBqTkQAAALIABB1ABqIQEgAEHQAGohAgJAAkADQCACIAEoAgAiAUcEQCABQQhrIgMoAgBBAEwNAiABQQRrIgQgBC0AAEEPcToAACAAIANBBxCfBCABQQRqIQEMAQsLIABB5ABqIQEgAEHgAGohAgNAIAIgASgCACIBRwRAIAAgAUEIa0EIEJ8EIAFBBGohAQwBCwsMAQtB1jlBoQ1B5yxB9zkQAAALIAAiAkECOgBoIABB2ABqIQMgAEHgAGohAQNAIAEgAigCZCIARwRAIABBBGstAABBDnEEQCAAEEYgACADEEwFIAIgAEEIaxDfBQsMAQsLIAJBADoAaCACKAJcIQACQAJAA0AgACADRwRAIABBBGstAABBDnENAiAAKAIEIQEgAiAAQQhrEB8gASEADAELCyADEG4MAQtB/zlBoQ1BnS1B4DoQAAALCw0AIAAgAUHxyQAQxQELUAIBfwF+AkAgACABQekAIAFBABASIgQQC0UEQCAAIAQQLCEDIAAgAUHAACABQQAQEiIBEAtFDQELQoCAgIDgACEBQQAhAwsgAiADNgIAIAELxAEBBH8gAaci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AkAgAikDCCIHQgFTBEAMAQsgB0IBfSEGAkACQAJAAkAgASACQQRqIAIQjgJFDQAgByACKAIAIgitUg0AIAGnIQkgAigCBCEDIARFDQEgAykDACEFIAMgA0EIaiAIQQN0QQhrEOgBDAILAkAgBARAIAAgAUIAEGIiBRALDQYgACABQgBCASAGQQEQgANFDQEMBgsgACABIAYQYiIFEAsNBQsgACABIAYQlAJBAE4NAgwECyAIQQN0IANqQQhrKQMAIQULIAkgCSgCKEEBazYCKAsgB0KBgICACFQNACAGuRAVIQYLIAAgAUEwIAYQSEF/Sg0BCyAAIAUQCkKAgICA4AAhBQsgACABEAogAkEQaiQAIAULEAAgACADKQMAQREgBBD/AgvqBAIFfgN/IwBBEGsiCyQAAn4CQAJAAkAgACABECkiBkKAgICAcFQNACAGpyIKLwEGQQJHDQAgCi0ABUEJcUEJRw0AIAooAhAQJy0AA0EIcUUNACAKKAIUKQMAIgFC/////w9WDQAgCyABQiCGQiCHIgc3AwggByAKNQIoUg0AIAcgAqx8IgVC/////wdVDQAgCjUCICAFUwRAIAAgCiAFpxDTBQ0DCwJ/IARFIAJBAUhyRQRAIAooAiQiBCACQQN0aiAEIAGnQQN0EOgBQQAMAQsgAacLIQxBACEEIAJBACACQQBKGyECA0AgAiAERkUEQCADIARBA3RqKQMAEA0hASAKKAIkIAQgDGpBA3RqIAE3AwAgBEEBaiEEDAELCyAKIAU+AiggCigCFCAFQv////8PgzcDACAFQoCAgIAIfCEBDAELIAAgC0EIaiAGEEANASALKQMIIgEgAqwiCHwiBUKAgICAgICAEFkEQCAAQZXXAEEAEBQMAgsCQCAERSACQQFIckUEQEIAIQcgACAGIAhCACABQX8QgAMNAwwBCyABIQcLIAJBACACQQBKG60hCEIAIQFBACEEA0AgASAIUgRAIAEgB3whCSAEQQN0IQIgBEEBaiEEIAFCAXwhASAAIAYgCSACIANqKQMAEA0QjwFBAE4NAQwDCwsgACAGQTACfiAFQv////8PgyAFQoCAgIAIfCIBQv////8PWA0AGiAFuRAVCxBIQQBIDQELIAAgBhAKIAVC/////w+DIAFC/////w9YDQEaIAW5EBUMAQsgACAGEApCgICAgOAACyEBIAtBEGokACABCzwAIAFBAEHQABBLIgEgBDYCDCABIAA2AgAgASACIANqNgI8IAEgAjYCOCABQQE2AgggAUKggICAEDcDEAt/AQR/IAEtAABB2wBGBEAgAUEBaiIDEENBAWshAiAAKAIQKAI4IQRBwgEhAQNAIAFBzwFHBEACQCAEIAFBAnRqKAIAIgUoAgRB/////wdxIAJHDQAgBUEQaiADIAIQdA0AIAAgARAXDwsgAUEBaiEBDAELCxABAAsgACABEMcBCxcAIAAgACkDwAEgASACIANBAEF/ELcFCzUBAX8gACgC7AEiB0UEQCAAQdzNAEEAEBRCgICAgOAADwsgACABIAIgAyAEIAUgBiAHETMAC8YCAgJ+An9CgICAgDAhAgJAAkAgASkCVCIDQhiGQjiHpw0AIANCIIZCOIenBEAgA0IQhkI4h6dFDQEgACABKQNgEA0QkgFCgICAgOAADwsgASADQv////+PYINCgICAgBCENwJUA0AgASgCFCAESgRAIAEoAhAgBEEDdGooAgQiBSkCVEIYhkI4h6dFBEAgACAFELgFIgIQCw0EIAAgAhAKCyAEQQFqIQQMAQsLAkAgASgCUCIEBEBCgICAgOAAQoCAgIAwIAAgASAEEQIAQQBIGyECDAELIAAgASkDSEKAgICAMEEAQQAQNSECIAFCgICAgDA3A0gLIAIQCwRAIAFBAToAWSABIAAoAhApA4ABEA03A2ALIAEgASkCVEL///+HgGCDQoCAgAiENwJUCyACDwsgASABKQJUQv////+PYIM3AlQgAgvLBQIHfwF+IwBBEGsiBiQAAn9BACABKQJUIglCKIZCOIenDQAaIAEgCUL//4N4g0KAgASENwJUAkADQAJAIAEoAhQgAkwEQEEAIQIMAQsgAkEDdCEDIAJBAWohAiAAIAMgASgCEGooAgQQuQVBAE4NAQwCCwsCQANAIAIgASgCIE4NAQJAAkAgASgCHCIIIAJBFGxqIgMoAghBAUcNACADKAIMIgVB/QBGDQAgACAGQQhqIAZBDGogASgCECADKAIAQQN0aigCBCAFEO0DIgMNAQsgAkEBaiECDAELCyAAIAMgASAIIAJBFGxqKAIQEOwDDAELQQAgASgCUA0BGiABKAJIKAIkIQhBACECQQAhBQNAAkAgASgCOCAFTARAA0AgAiAB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JCABIARBA3YgAGo2AiBBAAshASADQRBqJAAgAQtfAgF/AXwjAEEQayICJAACf0EAIAEQjgFFDQAaQX8gACACQQhqIAEQRw0AGiACKwMIIgO9QoCAgICAgID4/wCDQoCAgICAgID4/wBSIAOcIANhcQshACACQRBqJAAgAAu7AQEBfCABAn8CfwNAAkACQAJAIAIQVA4IAAAAAAICAgECC0EAIQBBAEH/ASACpxCwARBKDAQLQQAiACACEEkiA71C////////////AINCgICAgICAgPj/AFYgA0QAAAAAAAAAAGNyDQIaQf8BIANEAAAAAADgb0BkDQMaAn8gA54iA5lEAAAAAAAA4EFjBEAgA6oMAQtBgICAgHgLDAMLIAAgAhCdASICEAtFDQALQX8LIQBBAAs2AgAgAAuyBAEIfyMAQRBrIgYkAAJ/QX8gACAGQQxqIAJBABDLAg0AGiABKAIQLQAzQQhxRQRAIAAgA0EwEN8BDAELIAEtAAVBCHEEQCAGKAIMIgMgASgCKCIFSQRAIAMhBANAIAQgBUZFBEAgACABKAIkIARBA3RqKQMAEAogBEEBaiEEDAELCyABIAM2AigLIANBAE4EfiADrQUgA7gQFQshAiABKAIUIAI3AwBBAQwBCyAAIAZBBGogASgCFCkDABDEARogBigCDCIJIQUCQCAGKAIEIgcgCU0NACABKAIQIgsoAiAiBCAHIAlrTwRAA0AgByIFIAlNDQIgACABIAAgBUEBayIHEOcFIgoQlAQhBCAAIAoQESAEDQAMAgsACyAJIQUgCxAnIgchCANAIAQgCkwEQCAGIAU2AgRBACEIA0AgBCAITA0DAkAgBygCBCIERQ0AIAAgBkEIaiAEELIBRQ0AIAYoAgggBUkNACAAIAEgBygCBBCUBBogASgCECILECcgCEEDdGohBwsgB0EIaiEHIAhBAWohCCALKAIgIQQMAAsABQJAIAgoAgQiBEUNACAAIAZBCGogBBCyAUUNACAGKAIIIgQgBUkNACAFIARBAWogCC0AA0EEcRshBQsgCEEIaiEIIApBAWohCiALKAIgIQQMAQsACwALIAAgASgCFCAFQQBOBH4gBa0FIAW4EBULEB5BASAFIAlNDQAaIAAgA0GawAAQdgshBCAGQRBqJAAgBAumBAEKfyMAQRBrIgIkACACQQA2Agwg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ACACQQVqQQtB8Q0gAhBVGiAAIAJBBWoQcSIEEAsNACAAKAIQIASnQQEQ1AIhAwsgAkEQaiQAIAML4QECBn8BfgJAIAEoAgQiBEH/////B3EiAkEBa0EJSw0AAn8gBEF/TARAIAEvARAMAQsgAS0AEAsiAxBFRQ0AAn8CQCADQTBGBEBBACIDIAJBAUcNAhoMAQsgAkEBIAJBAUsbIQUgAUEQaiEGIANBMGshAyAEQX9KIQdBASECA0AgAiAFRg0BAn8gB0UEQCABIAJBAXRqLwEQDAELIAIgBmotAAALIgQQRUUNAyAEQTBrrCADrUIKfnwiCKchAyACQQFqIQIgCEKAgICAEFQNAAsMAgsgACADNgIAQQELDwtBAAssAQF/A0AgASADRkUEQCAAIANqLQAAIAJBhwJsaiECIANBAWohAwwBCwsgAguIAgECfyAAIAEoAgQQEQNAIAIgASgCFE5FBEAgACABKAIQIAJBA3RqKAIAEBEgAkEBaiECDAELCyAAIAEoAhAQGEEAIQIDQCABKAIgIAJKBEAgASgCHCACQRRsaiIDKAIIRQRAIAAoAhAgAygCBBD5AQsgACADKAIQEBEgACADKAIMEBEgAkEBaiECDAELCyAAIAEoAhwQGCAAIAEoAigQGEEAIQIDQCACIAEoAjhORQRAIAAgASgCNCACQQxsaigCBBARIAJBAWohAgwBCwsgACABKAI0EBggACABKQNAEAogACABKQNIEAogACABKQNgEAogACABKQNoEAogAUEIahBGIAAgARAYC68CAgJ/A34jAEEgayICJABCgICAgOAAIQcCQCAAIAMpAwAiBhBnDQAgACABQSoQbCIBEAsNAAJAIABBIBBqIgRFDQBBACEDIARBADYCFCAEQQA2AgAgBEEEaiEFA0AgA0ECRkUEQCAFIANBA3RqEG4gA0EBaiEDDAELCyAEQoCAgIAwNwMYIAEgBBCKASAAIAJBEGogARCsBQ0AAkAgACAGQoCAgIAwQQIgAkEQahAiIggQCwRAIAIgABCRATcDCCAAIAIpAxhCgICAgDBBASACQQhqECIhBiAAIAIpAwgQCiAGEAsNASAAIAYQCgsgACAIEAogACACKQMQEAogACACKQMYEAogASEHDAILIAAgAikDEBAKIAAgAikDGBAKCyAAIAEQCgsgAkEgaiQAIAcL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BSkDeCECIAUpA3AhBAwBCyAGBH4gAQUgBUHgAGogASAKQgBCgICAgICAwLvAABAyIAUpA2giCkIwiKdB+ABrIQYgBSkDYAshBCAHRQRAIAVB0ABqIAMgCUIAQoCAgICAgMC7wAAQMiAFKQNYIglCMIinQfgAayEHIAUpA1AhAwsgCUL///////8/g0KAgICAgIDAAIQhCSAKQv///////z+DQoCAgICAgMAAhCEKIAYgB0oEQANAAn4gCiAJfSADIARWrX0iC0IAWQRAIAsgBCADfSIEhFAEQCAFQSBqIAEgAkIAQgAQMiAFKQMoIQIgBSkDICEEDAULIAtCAYYgBEI/iIQMAQsgCkIBhiAEQj+IhAshCiAEQgGGIQQgBkEBayIGIAdKDQALIAchBgsCQCAKIAl9IAMgBFatfSIJQgBTBEAgCiEJDAELIAkgBCADfSIEhEIAUg0AIAVBMGogASACQgBCABAyIAUpAzghAiAFKQMwIQQMAQsgCUL///////8/WARAA0AgBEI/iCEBIAZBAWshBiAEQgGGIQQgASAJQgGGhCIJQoCAgICAgMAAVA0ACwsgCEGAgAJxIQcgBkEATARAIAVBQGsgBCAJQv///////z+DIAZB+ABqIAdyrUIwhoRCAEKAgICAgIDAwz8QMiAFKQNIIQIgBSkDQCEEDAELIAlC////////P4MgBiAHcq1CMIaEIQILIAAgBDcDACAAIAI3AwggBUGAAWokAAuhBAIEfgJ/AkAgAb0iBEIBhiIDUCAEQv///////////wCDQoCAgICAgID4/wBWckUEQCAAvSIFQjSIp0H/D3EiBkH/D0cNAQsgACABoiIAIACjDwsCfgJAIAMgBUIBhiICVARAIARCNIinQf8PcSEHIAZFBEAgBUIMhiICQgBTBEBBACEGDAMLQX8hBgNAIAJCAYYiAkIAUw0DIAZBAWshBgwACwALIAVC/////////weDQoCAgICAgIAIhAwCCyAARAAAAAAAAAAAoiAAIAIgA1EbDwsgBUEBIAZrrYYLIQICfgJAIAdFBEAgBEIMhiIDQgBTBEBBACEHDAILQX8hBwNAIANCAYYiA0IAUw0CIAdBAWshBwwACwALIARC/////////weDQoCAgICAgIAIhAwBCyAEQQEgB2uthgshBCAGIAdKBEADQAJAIAIgBH0i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IAxBA3I2AgQgBSAKaiICIAIoAgRBAXI2AgQgAyAMEPQFCyAFIQILIAILIgIEQCACQQhqDwsgARChAiIFRQRAQQAPCyAFIABBfEF4IABBBGsoAgAiAkEDcRsgAkF4cWoiAiABIAEgAksbECMaIAAQ6QEgBQvYAwICfgJ/IwBBIGsiBCQAAkAgAUL///////////8AgyIDQoCAgICAgMCAPH0gA0KAgICAgIDA/8MAfVQEQCABQgSGIABCPIiEIQMgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIANCgYCAgICAgIDAAHwhAgwCCyADQoCAgICAgICAQH0hAiAAQoCAgICAgICACIVCAFINASACIANCAYN8IQIMAQsgAFAgA0KAgICAgIDA//8AVCADQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiADQv///////7//wwBWDQBCACECIANCMIinIgVBkfcASQ0AIARBEGogACABQv///////z+DQoCAgICAgMAAhCICIAVBgfcAaxByIAQgACACQYH4ACAFaxDWAiAEKQMIQgSGIAQpAwAiAEI8iIQhAiAEKQMQIAQpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACIVCAFINACACQgGDIAJ8IQILIARBIGokACACIAFCgICAgICAgICAf4OEvwuCEQIFfwt+IwBBwAFrIgUkACAEQv///////z+DIRIgAkL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhESAEQjCIp0H//wFxIQcCQAJAAkAgAkIwiKdB//8BcSIJQQFrQf3/AU0EQCAHQQFrQf7/AUkNAQsgAVAgAkL///////////8AgyIKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhEQwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCERIAMhAQwCCyABIApCgICAgICAwP//AIWEUARAIAMgAkKAgICAgIDA//8AhYRQBEBCACEBQoCAgICAgOD//wAhEQwDCyARQoCAgICAgMD//wCEIRFCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEBCACEBDAILIAEgCoRQDQIgAiADhFAEQCARQoCAgICAgMD//wCEIRFCACEBDAILIApC////////P1gEQCAFQbABaiABIAwgASAMIAxQIgYbeSAGQQZ0rXynIgZBD2sQckEQIAZrIQYgBSkDuAEhDCAFKQOwASEBCyACQv///////z9WDQAgBUGgAWogAyASIAMgEiASUCIIG3kgCEEGdK18pyIIQQ9rEHIgBiAIakEQayEGIAUpA6gBIRIgBSkDoAEhAwsgBUGQAWogEkKAgICAgIDAAIQiFEIPhiADQjGIhCICQoTJ+c6/5ryC9QAgAn0iBBC0ASAFQYABakIAIAUpA5gBfSAEELQBIAVB8ABqIAUpA4gBQgGGIAUpA4ABQj+IhCIEIAIQtAEgBUHgAGogBEIAIAUpA3h9ELQBIAVB0ABqIAUpA2hCAYYgBSkDYEI/iIQiBCACELQBIAVBQGsgBEIAIAUpA1h9ELQBIAVBMGogBSkDSEIBhiAFKQNAQj+IhCIEIAIQtAEgBUEgaiAEQgAgBSkDOH0QtAEgBUEQaiAFKQMoQgGGIAUpAyBCP4iEIgQgAhC0ASAFIARCACAFKQMYfRC0ASAGIAkgB2tqIQYCfkIAIAUpAwhCAYYgBSkDAEI/iIRCAX0iCkL/////D4MiBCACQiCIIgt+Ig4gCkIgiCIKIAJC/////w+DIg9+fCICQiCIIAIgDlStQiCGhCAKIAt+fCACQiCGIgsgBCAPfnwiAiALVK0gAiACIAQgA0IRiEL/////D4MiDn4iDyAKIANCD4ZCgID+/w+DIg1+fCILQiCGIhAgBCANfnwgEFStIAogDn4gCyAPVK1CIIYgC0IgiIR8fHwiAlatfHwgAkIAUq18fSILQv////8PgyIOIAR+Ig8gCiAOfiINIAQgC0IgiCIQfnwiC0IghnwiDiAPVK0gCiAQfiALIA1UrUIghiALQiCIhHx8IA5CACACfSICQiCIIgsgBH4iDyACQv////8PgyINIAp+fCICQiCGIhAgBCANfnwgEFStIAogC34gAiAPVK1CIIYgAkIgiIR8fHwiAiAOVK18IAJCAn0iDyACVK18QgF9IgtC/////w+DIgIgDEIChiABQj6IhEL/////D4MiBH4iDiABQh6IQv////8PgyIKIAtCIIgiC358Ig0gDlStIA0gDSAPQiCIIg4gDEIeiEL//+//D4NCgIAQhCIMfnwiDVatfCALIAx+fCACIAx+IhMgBCALfnwiECATVK1CIIYgEEIgiIR8IA0gDSAQQiCGfCINVq18IA0gDSAKIA5+IhMgD0L/////D4MiDyAEfnwiECATVK0gECAQIAIgAUIChkL8////D4MiE358IhBWrXx8Ig1WrXwgDSALIBN+IgsgDCAPfnwiDCAEIA5+fCIEIAIgCn58IgJCIIggAiAEVK0gCyAMVq0gBCAMVK18fEIghoR8IgQgDVStfCAEIAQgECAOIBN+IgwgCiAPfnwiCkIgiCAKIAxUrUIghoR8IgogEFStIAogAkIghnwgClStfHwiBFatfCICQv////////8AWARAIAFCMYYgBEIgiCIBIANC/////w+DIgp+Ig0gBEL/////D4MiDCADQiCIIgt+fCIOQiCGIhAgCiAMfnwiDyAQVK19IA9CAFKtfSACQv////8PgyAKfiAMIBJC/////w+DfnwgASALfnwgDSAOVq1CIIYgDkIgiIR8IAQgFEIgiH4gAyACQiCIfnwgAiALfnwgASASfnxCIIZ8fSESIAZBAWshBkIAIA99DAELIARCIYghDCABQjCGIAJCP4YgBEIBiIQiBEL/////D4MiASADQiCIIgp+Ig8gDCACQh+GhCINQv////8PgyIQIANC/////w+DIgx+fCILQiCGIhMgASAMfnwiDiATVK19IA5CAFKtfSAEIBRCIIh+IAMgAkIhiH58IAJCAYgiAiAKfnwgDSASfnxCIIYgCiAQfiACQv////8PgyAMfnwgASASQv////8Pg358IAsgD1StQiCGIAtCIIiEfHx9IRJCACAOfQshASAGQYCAAU4EQCARQoCAgICAgMD//wCEIRFCACEBDAELIAZB//8AaiEHIAZBgYB/TARAAkAgBw0AIAQgAUIBhiADViASQgGGIAFCP4iEIgEgFFYgASAUURutfCIBIARUrSACQv///////z+DfCICQoCAgICAgMAAg1ANACACIBGEIREMAgtCACEBDAELIAQgAUIBhiADWiASQgGGIAFCP4iEIgEgFFogASAUURutfCIBIARUrSACQv///////z+DfCAHrUIwhnwgEYQhEQsgACABNwMAIAAgETcDCCAFQcABaiQADwsgAEIANwMAIABCgICAgICA4P//ACARIAIgA4RQGzcDCCAFQcABaiQAC8QBAgF/An5BfyEDAkAgAEIAUiABQv///////////wCDIgRCgICAgICAwP//AFYgBEKAgICAgIDA//8AURsNAEEAIAJC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAAgBCAFhIRQBEBBAA8LIAEgAoNCAFkEQEEAIAEgAlMgASACURsNASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADC9wyAxV/B34BfCMAQRBrIhEkACMAQaABayIOJAAgDkEQakEAQZABEEsaIA5BfzYCXCAOIAA2AjwgDkF/NgIYIA4gADYCFCAOQRBqEKoEIA5BEGohAiMAQTBrIg0kAEHgowQoAgAhEEHUowQoAgAhDwNAAn8gAigCBCIAIAIoAmhJBEAgAiAAQQFqNgIEIAAtAAAMAQsgAhBaCyIFEP0FDQALQQEhAAJAAkAgBUEraw4DAAEAAQtBf0EBIAVBLUYbIQAgAigCBCIEIAIoAmhJBEAgAiAEQQFqNgIEIAQtAAAhBQwBCyACEFohBQsCQAJAAkADQCAGQYmjBGosAAAgBUEgckYEQAJAIAZBBksNACACKAIEIgQgAigCaEkEQCACIARBAWo2AgQgBC0AACEFDAELIAIQWiEFCyAGQQFqIgZBCEcNAQwCCwsgBkEDRwRAIAZBCEYNASAGQQRJDQIgBkEIRg0BCyACKAJoIgQEQCACIAIoAgRBAWs2AgQLIAZBBEkNAANAIAQEQCACIAIoAgRBAWs2AgQLIAZBAWsiBkEDSw0ACwsjAEEQayICJAACfiAAskMAAIB/lLwiBEH/////B3EiAEGAgIAEa0H////3B00EQCAArUIZhkKAgICAgICAwD98DAELIAStQhmGQoCAgICAgMD//wCEIABBgICA/AdPDQAaQgAgAEUNABogAiAArUIAIABnIgBB0QBqEHIgAikDACEWIAIpAwhCgICAgICAwACFQYn/ACAAa61CMIaECyEXIA0gFjcDACANIBcgBEGAgICAeHGtQiCGhDcDCCACQRBqJAAgDSkDCCEWIA0pAwAhFwwBCwJAAkACQCAGDQBBACEGA0AgBkGSowRqLAAAIAVBIHJHDQECQCAGQQFLDQAgAigCBCIEIAIoAmhJBEAgAiAEQQFqNgIEIAQtAAAhBQwBCyACEFohBQsgBkEBaiIGQQNHDQALDAELAkACQCAGDgQAAQECAQsCQCAFQTBHDQACfyACKAIEIgQgAigCaEkEQCACIARBAWo2AgQgBC0AAAwBCyACEFoLQV9xQdgARgRAIwBBsANrIgMkAAJ/IAIoAgQiBCACKAJoSQRAIAIgBEEBajYCBCAELQAADAELIAIQWgshBQJAAn8DQCAFQTBHBEACQCAFQS5HDQQgAigCBCIEIAIoAmhPDQAgAiAEQQFqNgIEIAQtAAAMAwsFIAIoAgQiBCACKAJoSQR/QQEhCiACIARBAWo2AgQgBC0AAAVBASEKIAIQWgshBQwBCwsgAhBaCyEFQQEhCCAFQTBHDQADQCAZQgF9IRkCfyACKAIEIgQgAigCaEkEQCACIARBAWo2AgQgBC0AAAwBCyACEFoLIgVBMEYNAAtBASEKC0KAgICAgIDA/z8hFwNAAkAgBUEgciEGAkACQCAFQTBrIgRBCkkNACAFQS5HQQAgBkHhAGtBBUsbDQIgBUEuRw0AIAgNAkEBIQggFiEZDAELIAZB1wBrIAQgBUE5ShshBAJAIBZCB1cEQCAEIAlBBHRqIQkMAQsgFkIcVwRAIANBMGogBBCBASADQSBqIBsgF0IAQoCAgICAgMD9PxAyIANBEGogAykDICIbIAMpAygiFyADKQMwIAMpAzgQMiADIBggGiADKQMQIAMpAxgQeiADKQMIIRogAykDACEYDAELIAwgBEVyDQAgA0HQAGogGyAXQgBCgICAgICAgP8/EDIgA0FAayAYIBogAykDUCADKQNYEHogAykDSCEaQQEhDCADKQNAIRgLIBZCAXwhFkEBIQoLIAIoAgQiBCACKAJoSQR/IAIgBEEBajYCBCAELQAABSACEFoLIQUMAQsLAn4CQCAKRQRAIAIoAmhFDQEgAiACKAIEIgRBAWs2AgQgAiAEQQJrNgIEIAhFDQEgAiAEQQNrNgIEDAELIBZCB1cEQCAWIRcDQCAJQQR0IQkgF0IBfCIXQghSDQALCwJAIAVBX3FB0ABGBEAgAhD6BSIXQoCAgICAgICAgH9SDQFCACEXIAIoAmhFDQEgAiACKAIEQQFrNgIEDAELQgAhFyACKAJoRQ0AIAIgAigCBEEBazYCBAsgCUUEQCADQfAAaiAAt0QAAAAAAAAAAKIQtQEgAykDcCEYIAMpA3gMAgsgGSAWIAgbQgKGIBd8QiB9IhZBACAQa61VBEBBhKcEQcQANgIAIANBoAFqIAAQgQEgA0GQAWogAykDoAEgAykDqAFCf0L///////+///8AEDIgA0GAAWogAykDkAEgAykDmAFCf0L///////+///8AEDIgAykDgAEhGCADKQOIAQwCCyAQQeIBa6wgFlcEQCAJQX9KBEADQCADQaADaiAYIBpCAEKAgICAgIDA/79/EHogGCAaQoCAgICAgID/PxD4BSECIANBkANqIBggGiAYIAMpA6ADIAJBAEgiBBsgGiADKQOoAyAEGxB6IBZCAX0hFiADKQOYAyEaIAMpA5ADIRggCUEBdCACQX9KciIJQX9KDQALCwJ+IBYgEKx9QiB8IhenIgRBACAEQQBKGyAPIBcgD61TGyIEQfEATgRAIANBgANqIAAQgQEgAykDiAMhGSADKQOAAyEbQgAMAQsgA0HgAmpEAAAAAAAA8D9BkAEgBGsQyAEQtQEgA0HQAmogABCBASADQfACaiADKQPgAiADKQPoAiADKQPQAiIbIAMpA9gCIhkQ/AUgAykD+AIhHCADKQPwAgshFyADQcACaiAJIAlBAXFFIBggGkIAQgAQgAJBAEcgBEEgSHFxIgBqEKICIANBsAJqIBsgGSADKQPAAiADKQPIAhAyIANBkAJqIAMpA7ACIAMpA7gCIBcgHBB6IANBoAJqQgAgGCAAG0IAIBogABsgGyAZEDIgA0GAAmogAykDoAIgAykDqAIgAykDkAIgAykDmAIQeiADQfABaiADKQOAAiADKQOIAiAXIBwQqAQgAykD8AEiGSADKQP4ASIXQgBCABCAAkUEQEGEpwRBxAA2AgALIANB4AFqIBkgFyAWpxD7BSADKQPgASEYIAMpA+gBDAILQYSnBEHEADYCACADQdABaiAAEIEBIANBwAFqIAMpA9ABIAMpA9gBQgBCgICAgICAwAAQMiADQbABaiADKQPAASADKQPIAUIAQoCAgICAgMAAEDIgAykDsAEhGCADKQO4AQwBCyADQeAAaiAAt0QAAAAAAAAAAKIQtQEgAykDYCEYIAMpA2gLIRYgDSAYNwMQIA0gFjcDGCADQbADaiQAIA0pAxghFiANKQMQIRcMBQsgAigCaEUNACACIAIoAgRBAWs2AgQLIAAhDEEAIQRBACEGIwBBkMYAayIBJABBACAPIBBqIhRrIRUCQAJ/A0AgBUEwRwRAAkAgBUEuRw0EIAIoAgQiACACKAJoTw0AIAIgAEEBajYCBCAALQAADAMLBSACKAIEIgAgAigCaEkEfyACIABBAWo2AgQgAC0AAAUgAhBaCyEFQQEhBgwBCwsgAhBaCyEFQQEhByAFQTBHDQBCfyEWA38CfyACKAIEIgAgAigCaEkEQCACIABBAWo2AgQgAC0AAAwBCyACEFoLIgVBMEcEf0EBBSAWQgF9IRYMAQsLIQYLIAFBADYCkAYCfgJAAkACQCAFQS5GIghFQQAgBUEwayIAQQlLG0UEQANAAkAgCEEBcQRAIAdFBEAgFyEWQQEhBwwCCyAGRSEIDAQLIBdCAXwhFyAEQfwPTARAIAMgF6cgBUEwRhshAyABQZAGaiAEQQJ0aiIGIAsEfyAFIAYoAgBBCmxqQTBrBSAACzYCAEEBIQZBACALQQFqIgAgAEEJRiIAGyELIAAgBGohBAwBCyAFQTBGDQAgASABKAKARkEBcjYCgEZB3I8BIQMLAn8gAigCBCIAIAIoAmhJBEAgAiAAQQFqNgIEIAAtAAAMAQsgAhBaCyIFQS5GIgggBUEwayIAQQpJcg0ACwsgFiAXIAcbIRYgBkUgBUFfcUHFAEdyRQRAIAIQ+gUiGUKAgICAgICAgIB/UgRAIBYgGXwhFgwECyACKAJoRQ0DIAIgAigCBEEBazYCBAwDCyAGRSEIIAVBAEgNAQsgAigCaEUNACACIAIoAgRBAWs2AgQLIAhFDQBBhKcEQRw2AgBCACEXIAIQqgRCAAwBCyABKAKQBiIARQRAIAEgDLdEAAAAAAAAAACiELUBIAEpAwAhFyABKQMIDAELIBYgF1IgF0IJVXIgD0EeTEEAIAAgD3YbckUEQCABQTBqIAwQgQEgAUEgaiAAEKICIAFBEGogASkDMCABKQM4IAEpAyAgASkDKBAyIAEpAxAhFyABKQMYDAELIBBBfm2tIBZTBEBBhKcEQcQANgIAIAFB4ABqIAwQgQEgAUHQAGogASkDYCABKQNoQn9C////////v///ABAyIAFBQGsgASkDUCABKQNYQn9C////////v///ABAyIAEpA0AhFyABKQNIDAELIBBB4gFrrCAWVQRAQYSnBEHEADYCACABQZABaiAMEIEBIAFBgAFqIAEpA5ABIAEpA5gBQgBCgICAgICAwAAQMiABQfAAaiABKQOAASABKQOIAUIAQoCAgICAgMAAEDIgASkDcCEXIAEpA3gMAQsgCwRAIAtBCEwEQCABQZAGaiAEQQJ0aiICKAIAIQADQCAAQQpsIQAgC0EBaiILQQlHDQALIAIgADYCAAsgBEEBaiEECwJAIAMgFqciB0ogA0EJTnIgB0ERSnINACAHQQlGBEAgAUHAAWogDBCBASABQbABaiABKAKQBhCiAiABQaABaiABKQPAASABKQPIASABKQOwASABKQO4ARAyIAEpA6ABIRcgASkDqAEMAgsgB0EITARAIAFBkAJqIAwQgQEgAUGAAmogASgCkAYQogIgAUHwAWogASkDkAIgASkDmAIgASkDgAIgASkDiAIQMiABQeABakEAIAdrQQJ0QdCjBGooAgAQgQEgAUHQAWogASkD8AEgASkD+AEgASkD4AEgASkD6AEQ9wUgASkD0AEhFyABKQPYAQwCCyAPIAdBfWxqQRtqIgJBHkxBACABKAKQBiIAIAJ2Gw0AIAFB4AJqIAwQgQEgAUHQAmogABCiAiABQcACaiABKQPgAiABKQPoAiABKQPQAiABKQPYAhAyIAFBsAJqIAdBAnRBiKMEaigCABCBASABQaACaiABKQPAAiABKQPIAiABKQOwAiABKQO4AhAyIAEpA6ACIRcgASkDqAIMAQsDQCABQZAGaiAEIgBBAWsiBEECdGooAgBFDQALQQAhCwJAIAdBCW8iBEUEQEEAIQQMAQsgBCAEQQlqIAdBf0obIRICQCAARQRAQQAhBEEAIQAMAQtBgJTr3ANBACASa0ECdEHQowRqKAIAIgltIQpBACEIQQAhBUEAIQQDQCABQZAGaiAFQQJ0aiICIAggAigCACIDIAluIgZqIgI2AgAgBEEBakH/D3EgBCACRSAEIAVGcSICGyEEIAdBCWsgByACGyEHIAogAyAGIAlsa2whCCAFQQFqIgUgAEcNAAsgCEUNACABQZAGaiAAQQJ0aiAINgIAIABBAWohAAsgByASa0EJaiEHCwNAIAFBkAZqIARB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BX0gBSAEGyEFDAELQoCAgICAgICAgH8hBSAAKAJoRQ0AIAAgACgCBEEBazYCBEKAgICAgICAgIB/DwsgBQu/AgEBfyMAQdAAayIEJAACQCADQYCAAU4EQCAEQSBqIAEgAkIAQoCAgICAgID//wAQMiAEKQMoIQIgBCkDICEBIANB//8BSARAIANB//8AayEDDAILIARBEGogASACQgBCgICAgICAgP//ABAyIANB/f8CIANB/f8CSBtB/v8BayEDIAQpAxghAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEFAayABIAJCAEKAgICAgIDAABAyIAQpA0ghAiAEKQNAIQEgA0GDgH5KBEAgA0H+/wBqIQMMAQsgBEEwaiABIAJCAEKAgICAgIDAABAyIANBhoB9IANBhoB9ShtB/P8BaiEDIAQpAzghAiAEKQMwIQELIAQgASACQgAgA0H//wBqrUIwhhAyIAAgBCkDCDcDCCAAIAQpAwA3AwAgBEHQAGokAAs1ACAAIAE3AwAgACACQv///////z+DIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGhDcDCAsQACAAQSBGIABBCWtBBUlyC9gBAQR/IAAoAlQhAwJAIAAoAhQgACgCHCIFayIGBEAgACAFNgIUIAAgBSAGEP4FIAZJDQELAkAgAygCEEHhAEcEQCADKAIAIQQMAQsgAyADKAIEIgQ2AgALIAMoAgwgBGogASADKAIIIARrIgEgAiABIAJJGyIEECMaIAMgAygCACAEaiIBNgIAIAEgAygCBE0NACADIAE2AgQgAygCCCICIAFLBEAgAygCDCABakEAOgAAIAQPCyAALQAAQQRxRSACRXINACACIAMoAgxqQQFrQQA6AAALIAQLuwIAAkAgAUEUSw0AAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4KAAECAwQFBgcICQoLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASsDADkDAA8LIAAgAiADEQMACwtQAQN/AkAgACgCACwAABBFRQRADAELA0AgACgCACICLAAAIQMgACACQQFqNgIAIAEgA2pBMGshASACLAABEEVFDQEgAUEKbCEBDAALAAsgAQt/AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARCBBiEAIAEoAgBBQGoLNgIAIAAPCyABIAJB/gdrNgIAIANC/////////4eAf4NCgICAgICAgPA/hL8FIAALC5sCACAARQRAQQAPCwJ/AkAgAAR/IAFB/wBNDQECQEGcpQQoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAwwECyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBAwECwtBhKcEQRk2AgBBfwVBAQsMAQsgACABOgAAQQELC24BAX8gAARAIAAoAkxBf0wEQCAAEK4EDwsgABCuBA8LQeimBCgCAARAQeimBCgCABCDBiEBC0HQpwQoAgAiAARAA0AgACgCTBogACgCFCAAKAIcSwRAIAAQrgQgAXIhAQsgACgCOCIADQALCyABC6wDAwN8An8BfiAAvSIIQoCAgICA/////wCDQoGAgIDwhOXyP1QiB0UEQEQYLURU+yHpPyAAIACaIAhCf1UiBhuhRAdcFDMmpoE8IAEgAZogBhuhoCEAIAhCP4inIQZEAAAAAAAAAAAhAQsgACAAIAAgAKIiA6IiBERjVVVVVVXVP6IgASADIAEgBCADIAOiIgEgASABIAEgAURzU2Dby3XzvqJEppI3oIh+FD+gokQBZfLy2ERDP6CiRCgDVskibW0/oKJEN9YGhPRklj+gokR6/hARERHBP6AgAyABIAEgASABIAFE1Hq/dHAq+z6iROmn8DIPuBI/oKJEaBCNGvcmMD+gokQVg+D+yNtXP6CiRJOEbunjJoI/oKJE/kGzG7qhqz+goqCioKKgoCIDoCEBIAdFBEBBASACQQF0a7ciBCAAIAMgASABoiABIASgo6GgIgAgAKChIgCaIAAgBhsPCyACBHxEAAAAAAAA8L8gAaMiBCABvUKAgICAcIO/IgUgBL1CgICAgHCDvyIBokQAAAAAAADwP6AgAyAFIAChoSABoqCiIAGgBSABCwvLDwMIfAh/An5EAAAAAAAA8D8hAgJAAkACQCABvSISQiCIpyILQf////8HcSIKIBKnIg5yRQ0AIAC9IhNCIIinIQ0gE6ciEUVBACANQYCAwP8DRhsNACANQf////8HcSIMQYCAwP8HSyAMQYCAwP8HRiARQQBHcXIgCkGAgMD/B0tyRUEAIA5FIApBgIDA/wdHchtFBEAgACABoA8LAkACQAJ/AkAgDUF/Sg0AQQIgCkH///+ZBEsNARogCkGAgMD/A0kNACAKQRR2IQ8gCkGAgICKBE8EQEEAIA5BswggD2siEHYiDyAQdCAORw0CGkECIA9BAXFrDAILIA4NAyAKQZMIIA9rIg52Ig8gDnQgCkcNAkECIA9BAXFrIRAMAgtBAAshECAODQELIApBgIDA/wdGBEAgDEGAgMD/A2sgEXJFDQIgDEGAgMD/A08EQCABRAAAAAAAAAAAIAtBf0obDwtEAAAAAAAAAAAgAZogC0F/ShsPCyAKQYCAwP8DRgRAIAtBf0oEQCAADwtEAAAAAAAA8D8gAKMPCyALQYCAgIAERgRAIAAgAKIPCyALQYCAgP8DRyANQQBIcg0AIACfDwsgAJkhAiANQf////8DcUGAgMD/A0dBACAMGyARckUEQEQAAAAAAADwPyACoyACIAtBAEgbIQIgDUF/Sg0BIBAgDEGAgMD/A2tyRQRAIAIgAqEiACAAow8LIAKaIAIgEEEBRhsPC0QAAAAAAADwPyEDAkAgDUF/Sg0AAkACQCAQDgIAAQILIAAgAKEiACAAow8LRAAAAAAAAPC/IQMLAnwgCkGBgICPBE8EQCAKQYGAwJ8ETwRAIAxB//+//wNNBEBEAAAAAAAA8H9EAAAAAAAAAAAgC0EASBsPC0QAAAAAAADwf0QAAAAAAAAAACALQQBKGw8LIAxB/v+//wNNBEAgA0ScdQCIPOQ3fqJEnHUAiDzkN36iIANEWfP4wh9upQGiRFnz+MIfbqUBoiALQQBIGw8LIAxBgYDA/wNPBEAgA0ScdQCIPOQ3fqJEnHUAiDzkN36iIANEWfP4wh9upQGiRFnz+MIfbqUBoiALQQBKGw8LIAJEAAAAAAAA8L+gIgBEAAAAYEcV9z+iIgIgAERE3134C65UPqIgACAAokQAAAAAAADgPyAAIABEAAAAAAAA0L+iRFVVVVVVVdU/oKKhokT+gitlRxX3v6KgIgWgvUKAgICAcIO/IgAgAqEMAQsgAkQAAAAAAABAQ6IiACACIAxBgIDAAEkiChshAiAAvUIgiKcgDCAKGyIMQf//P3EiDUGAgMD/A3IhCyAMQRR1Qcx3QYF4IAobaiEMQQAhCgJAIA1Bj7EOSQ0AIA1B+uwuSQRAQQEhCgwBCyALQYCAQGohCyAMQQFqIQwLIApBA3QiDUHAnQRqKwMAIgcgAr1C/////w+DIAutQiCGhL8iBSANQaCdBGorAwAiBKEiBkQAAAAAAADwPyAEIAWgoyIIoiICvUKAgICAcIO/IgAgACAAoiIJRAAAAAAAAAhAoCACIACgIAggBiAAIAtBAXVBgICAgAJyIApBEnRqQYCAIGqtQiCGvyIGoqEgACAFIAYgBKGhoqGiIgWiIAIgAqIiACAAoiAAIAAgACAAIABE705FSih+yj+iRGXbyZNKhs0/oKJEAUEdqWB00T+gokRNJo9RVVXVP6CiRP+rb9u2bds/oKJEAzMzMzMz4z+goqAiBKC9QoCAgIBwg78iAKIiBiAFIACiIAIgBCAARAAAAAAAAAjAoCAJoaGioCICoL1CgICAgHCDvyIARAAAAOAJx+4/oiIEIA1BsJ0EaisDACACIAAgBqGhRP0DOtwJx+4/oiAARPUBWxTgLz6+oqCgIgWgoCAMtyICoL1CgICAgHCDvyIAIAKhIAehIAShCyEEIAAgEkKAgICAcIO/IgeiIgIgBSAEoSABoiABIAehIACioCIAoCIBvSISpyEKAkAgEkIgiKciC0GAgMCEBE4EQCALQYCAwIQEayAKcg0DIABE/oIrZUcVlzygIAEgAqFkRQ0BDAMLIAtBgPj//wdxQYCYw4QESQ0AIAtBgOi8+wNqIApyDQMgACABIAKhZUUNAAwDC0EAIQogAwJ8IAtB/////wdxIgxBgYCA/wNPBH5BAEGAgMAAIAxBFHZB/gdrdiALaiIMQf//P3FBgIDAAHJBkwggDEEUdkH/D3EiDWt2IgprIAogC0EASBshCiAAIAJBgIBAIA1B/wdrdSAMca1CIIa/oSICoL0FIBILQoCAgIBwg78iAUQAAAAAQy7mP6IiAyAAIAEgAqGhRO85+v5CLuY/oiABRDlsqAxhXCC+oqAiAqAiACAAIAAgACAAoiIBIAEgASABIAFE0KS+cmk3Zj6iRPFr0sVBvbu+oKJELN4lr2pWET+gokSTvb4WbMFmv6CiRD5VVVVVVcU/oKKhIgGiIAFEAAAAAAAAAMCgoyACIAAgA6GhIgEgACABoqChoUQAAAAAAADwP6AiAL0iEkIgiKcgCkEUdGoiC0H//z9MBEAgACAKEMgBDAELIBJC/////w+DIAutQiCGhL8LoiECCyACDwsgA0ScdQCIPOQ3fqJEnHUAiDzkN36iDwsgA0RZ8/jCH26lAaJEWfP4wh9upQGiC0UBAnwgACACIAKiIgQ5AwAgASACIAJEAAAAAgAAoEGiIgMgAiADoaAiAqEiAyADoiACIAKiIAShIAIgAqAgA6KgoDkDAAslACAARIvdGhVmIJbAoBCxBEQAAAAAAADAf6JEAAAAAAAAwH+iC58BAQJ+AkAgAykDACIEQoCAgIBwWgRAIAMpAwgiBUL/////b1YNAQsgABAoQoCAgIDgAA8LIABCgICAgCBBKRBQIgEQC0UEQCAAQRgQLSICRQRAIAAgARAKQoCAgIDgAA8LIAIgBBANIgQ3AwAgAiAFEA03AwggACAEEDohACACQQA6ABEgAiAAOgAQIAEgAhCKASABIAQQsQEQrgMLIAELyAEBAX8CQAJAIAAgAXNBA3ENACABQQNxBEADQCAAIAEtAAAiAjoAACACRQ0DIABBAWohACABQQFqIgFBA3ENAAsLIAEoAgAiAkF/cyACQYGChAhrcUGAgYKEeHENAANAIAAgAjYCACABKAIEIQIgAEEEaiEAIAFBBGohASACQYGChAhrIAJBf3NxQYCBgoR4cUUNAAsLIAAgAS0AACICOgAAIAJFDQADQCAAIAEtAAEiAjoAASAAQQFqIQAgAUEBaiEBIAINAAsLCzEBAn8CfyAAEENBAWohAQNAQQAgAUUNARogACABQQFrIgFqIgItAABBL0cNAAsgAgsLyAYBBX9BASEHIAJBAXRBkN0Cai8BACECIAVFBEAgACACNgIAQQEPCyACQYDoAmohBkESIQkCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAFQQFrDiIAAAAAAAAAAQECAgICAgQDAwMDAwMFBQUFBQUFBQYHCAkJCwtBACECIAVBACAFQQBKGyEEIAYgASADayAFbEEBdGohAQNAIAIgBEYEQCAFDwsgACACQQJ0aiABIAJBAXRqLwAAIgM2AgAgAkEBaiECIAMNAAsMCwtBACECIAVBB2siCEEAIAhBAEobIQUgCCABIANrbCEHIAQgCGxBAXQhAQNAIAIgBUYNCiAGIAdBAnYgAWpqLQAAIAdBAXQiA0EGcXZBEHRBgIAMcSADIAZqLwAAciIDRQ0LIAAgAkECdGogAzYCACACQQFqIQIgB0EBaiEHDAALAAtBACECIAVBCWsiCEEAIAhBAEobIQQgBiAIIAEgA2tsaiEBA0AgAiAERg0JIAAgAkECdGogASACai0AABCyAyIDNgIAIAJBAWohAiADDQALDAkLIAVBAXEgBUEQa0EBdiICQQBHaiEKIAJBAmohBwsgASADayEBQQAhAgNAIAIgB0YEQCAHDwUgACACQQJ0aiAGIAJBAXRqLwAAIAFBACACIApGG2o2AgAgAkEBaiECDAELAAsACyAFQRVrIQkLQQAhAiAJQQAgCUEAShshBCAJIAEgA2tsIAZqQQJqIQEgBi8AACEDA0AgAiAERgRAIAkPBSAAIAJBAnRqQSAgASACai0AACIFIANqIAVB/wFGGzYCACACQQFqIQIMAQsACwALIAAgBiABIANrQQNsaiIBLwAAIgI2AgAgAkUNAyAAIAEtAAIQsgM2AgQMAgsgACAGLwAANgIAIAAgBi8AAjYCCCAAIAEgA2tBAXQgBmovAAQ2AgRBAw8LIAEgA2shAiAAAn8gBUEhRgRAIAYgAkF+cWoiAUEBaiEHIAEtAAAQsgMMAQsgBiACQQF2QQNsaiIBQQJqIQcgAS8AAAsiAUEgQSBBASABQZAIa0EgSRsgAUGAAkkbaiABIAJBAXEbNgIAIAAgBy0AABCyAzYCBAtBAiEICyAIDwtBAAsjAQF/IAEgACgCQEkEfyAAKAJEIAFBGGxqKAIAQQBHBUEACwvpAgEFfiADKQMIIQggACADKQMAIgUQgwQiA0EATgRAAkAgARAQRQ0AIAAQggQhASADRQ0AIAgQEEUNACAAIAVBPCAFQQAQEiIGEAsEQCAGDwsgACAGIAEQWCECIAAgBhAKIAJFDQAgBRANDwsCQAJAAkACQCAAIAVBABDbASICBEAgAjUCAEKAgICAkH+EEA0hBCAIEBBFDQEgAjUCBEKAgICAkH+EEA0hBgwDCwJAAkAgAwRAQoCAgIAwIQcgACAFQewAIAVBABASIgQQCw0GIAgQEEUNASAAIAVB7QAgBUEAEBIiBxALRQ0CDAYLIAUQDSEECyAIEA0hBwsgBBAQBEAgAEEvEDEhBAwCCyAAIAQQKyEGIAAgBBAKIAYiBBALDQMMAQsgACAIECsiBxALDQILIAAgBCAHEIQEIgYQCw0BIAAgBxAKCyAAIAEgBCAGEMsFDwsgACAEEAogACAHEAoLQoCAgIDgAAviDQIIfwF+IwBB0ABrIggkACAAIAggAiADIAQQtAUjAEEQayIDJAAgAyAIKAI4IgI2AgwCQCACLQAAQSNHDQAgAi0AAUEhRw0AIAMgAkECaiICNgIMA0ACQAJAAkAgAiAIKAI8Tw0AAkAgAi0AACIHQQprDgQBAAABAAsgB0EYdEEYdUF/Sg0CIAJBBiADQQxqEF8iB0F+cUGowABHDQEgAygCDCECCyAIIAI2AjgMAwsgAygCDCECIAdBf0cNAQsgAyACQQFqIgI2AgwMAAsACyADQRBqJAACQAJAAkACQAJAAkACQAJAIAVBA3EiB0ECRgRAIAAoAhAoAowBIgxFDQIgDCkDCCIPQv////9vWA0DIA+nIgIvAQYQ9wFFDQQgAigCJCENIAIoAiAiAy0AECEJQQAhAgwBCyAFQQN2IQkgB0EBRwRAIAlBA3EhCUEAIQNBACECDAELQoCAgIDgACEPIAAgBBDHASICRQ0HAn8gAEHwABBqIgNFBEAgACACEBFBAAwBCyADQoCAgIAwNwNoIANCgICAgDA3A2AgA0KAgICAMDcDSCADQoCAgIAwNwNAIAMgAjYCBCADQQE2AgAgA0EIaiAAQeABahBMIAMLIgJFDQcgCUECcUEBciEJQQAhAwsgAEEAQQFBACAEQQEQ+AMiBEUNAyAIIAQ2AkAgBCAHQQJHIgs2AkwgBCAHNgIkIAQgBUEGdkEBcTYCaAJ/IAtFBEAgBCADLwARQQZ2QQFxNgJQIAQgAy8AEUEHdkEBcTYCVCAEIAMtABJBAXE2AlggAy8AEUEJdkEBcQwBCyAEQQA2AlggBEIANwJQQQELIQcgBCAJOgBuIAQgBzYCXCAAQdAAEBcaIARB0AA2AnACQAJAIAMEQEEAIQsgAygCPCEHIAMvASohCSADLwEoIQogBEEANgLAAiAEQQA2AsgCIAQgByAJIApqaiIHNgLEAgJAIAdFDQAgBCAAIAdBA3QQLSIHNgLIAiAHRQRAQX8hCwwBCwNAIAZBAE4EQCADKAIgIAYgAy8BKGpBBHRqIgcoAgRBAU4EQCAEIAQoAsACIglBAWo2AsACIAAgBCgCyAIgCUEDdGogByAGENoDCyAHKAIIIQYMAQsLQQAhBwJAIAZBfkYEQANAIAcgAy8BKk8NAgJAIAMoAiAgByADLwEoakEEdGoiBigCBA0AIAYQ+QRFDQAgBCAEKALAAiIJQQFqNgLAAiAAIAQoAsgCIAlBA3RqIAYgBxDaAwsgB0EBaiEHDAALAAsDQCADLwEoIAdNBEBBACEHA0AgByADLwEqTw0DAkAgAygCICAHIAMvAShqQQR0aiIGKAIEDQAgBigCAEHRAEYNACAEIAQoAsACIglBAWo2AsACIAAgBCgCyAIgCUEDdGogBiAHENoDCyAHQQFqIQcMAAsABSAEIAQoAsACIgZBAWo2AsACIAMoAiAhCSAEKALIAiAGQQN0aiIGIAc7AQIgBkEDOgAAIAYgACAJIAdBBHRqKAIAEBc2AgQgB0EBaiEHDAELAAsAC0EAIQYDQCAGIAMoAjxODQEgAygCJCEJIAQgBCgCwAIiB0EBajYCwAIgBCgCyAIgB0EDdGoiByAHLQAAIgpB/gFxOgAAIAcgCSAGQQN0aiIJLQAAQQJxIApB/AFxciIKOgAAIAcgCkH6AXEgCS0AAEEEcXIiCjoAACAHIApB9gFxIAktAABBCHFyIgo6AAAgCS0AACEOIAcgBjsBAiAHIApBDnEgDkHwAXFyOgAAIAcgACAJKAIEEBc2AgQgBkEBaiEGDAALAAsgCw0BCyAEIAI2ApQDIAggAkU2AkggCCACQQBHNgJEIAgQggEaIAQgBCgCvAE2AvABIAgoAkAhA0F/IQYCQCAIEA8NACAIEPgEDQAgAyADKAIkQQJPBH8gAy0AbkF/c0EBcQVBAQs2AiggCCgCREUEQCADIAgoAgAgA0HRABBWIgc2AqQBIAdBAEgNAQsDQCAIKAIQQap/RwRAIAgQ9wRFDQEMAgsLAkAgCCgCREUEQCAIQdgAEAwgCCADLwGkARAWIAhBKBAMDAELIAhBKRAMC0EAIQYLIAZFDQELIAggCEEQahCPAiAAIAQQiwMMBAsgACAEEKgFIg8QCw0DIAIEQCACIA83A0ggACACEIYEQQBIDQUgAq1CgICAgFCEEA0hDwsgBUEgcQ0GIAAgDyABIA0gDBC7BSEPDAYLQeD4AEGhDUG9hgJB6/gAEAAAC0H9+ABBoQ1BvoYCQev4ABAAAAtBrfkAQaENQcCGAkHr+AAQAAALIAJFDQELIAAgAhDqBQtCgICAgOAAIQ8LIAhB0ABqJAAgDwvEBAMCfgZ/AXwjAEHQAGsiBiQAAkAgBgJ8AkACQAJAAkACQEEAIAIgARAQIgobIgIOAgABAgsQqwW5DAQLAkAgAykDACIEQoCAgIBwVA0AIASnIgIvAQZBCkcNACACKQMgIgUQjgFFDQAgACAGQUBrIAUQRw0CDAMLIAYgACAEQQIQmwMiBDcDACAEEJsBBEAgAEKAgICAMEEBIAYQqgUhBSAAIAQQCiAFEAsNAiAAIAZBQGsgBRBZRQ0DDAILIAAgBkFAayAEEFlFDQIMAQsgBkEAQTgQSyIHQoCAgICAgID4PzcDECACQQcgAkEHSBsiCUEAIAlBAEobIQIDQAJARAAAAAAAAPh/IAIgCEcEfyAAIAdByABqIAMgCEEDdCILaikDABBHDQMgBysDSCIMvUKAgICAgICA+P8Ag0KAgICAgICA+P8AUg0BIAgFIAILIAlHDQQaIAdBARCMAwwECyAHIAtqIAydOQMAAkAgCA0AIAcrAwAiDEQAAAAAAAAAAGZFIAxEAAAAAAAAWUBjRXINACAHIAxEAAAAAACwnUCgOQMACyAIQQFqIQgMAAsAC0KAgICA4AAhAQwCCyAGKwNAEPkDCyIMOQNAAkAgACABQQoQbCIEEAtFBEAgACAEAn4gDL0CfyAMmUQAAAAAAADgQWMEQCAMqgwBC0GAgICAeAsiAre9UQRAIAKtDAELIAwQFQsQzQEgCg0BCyAEIQEMAQsgACAEQQBBAEETEKkFIQEgACAEEAoLIAZB0ABqJAAgAQsWACAAIAApA8ABIAMpAwBBA0F/EJkDCzsBAX8DQCACBEAgAC0AACEDIAAgAS0AADoAACABIAM6AAAgAUEBaiEBIABBAWohACACQQFrIQIMAQsLCxoAIAAtAAAhAiAAIAEtAAA6AAAgASACOgAAC0IBAX8gAkEBdiECA0AgAgRAIAAvAQAhAyAAIAEvAQA7AQAgASADOwEAIAFBAmohASAAQQJqIQAgAkEBayECDAELCwsaACAALwEAIQIgACABLwEAOwEAIAEgAjsBAAtCAQF/IAJBAnYhAgNAIAIEQCAAKAIAIQMgACABKAIANgIAIAEgAzYCACABQQRqIQEgAEEEaiEAIAJBAWshAgwBCwsLGgAgACgCACECIAAgASgCADYCACABIAI2AgALQgEBfiACQQN2IQIDQCACBEAgACkDACEDIAAgASkDADcDACABIAM3AwAgAUEIaiEBIABBCGohACACQQFrIQIMAQsLCxwBAX4gACkDACEDIAAgASkDADcDACABIAM3AwALWgECfiACQQR2IQIDQCACBEAgACkDACEDIAAgASkDADcDACAAKQMIIQQgACABKQMINwMIIAEgBDcDCCABIAM3AwAgAUEQaiEBIABBEGohACACQQFrIQIMAQsLCzQBAn4gACkDACEDIAAgASkDADcDACAAKQMIIQQgACABKQMINwMIIAEgBDcDCCABIAM3AwALmwMCA38CfiMAQSBrIgUkAEKAgICA4AAhCAJAIAAgAUEeEGgiB0UNACAAIAVBEGogAykDABDBAQ0AIAMpAwghASAFQQA2AhwCfgJAIARBG0wEQCAAIAVBHGogARDEAQ0DDAELIAAgBUEIaiABEEcNAiAEQRxGBEAgBSAFKwMItjgCHAwBCyAFKQMIDAELQgALIQFBASEGIAJBA04EQCAAIAMpAxAQ+AFBAXMhBgsgBygCDCgCICICLQAEBEAgABBwDAELIAc1AhQgBSkDECIJQQEgBEGZHmotAAB0rHxUBEAgAEGg2wEQaQwBCyAJpyACKAIIIAcoAhBqaiEAAkACQAJAAkACQAJAIARBFmsOCAQEAAABAQECAwsgBSgCHCEDIAYEQCAFIANB//8DcRDkAyIDNgIcCyAAIANB//8DcRCEAwwECyAFKAIcIQMgBgRAIAUgAxCDAyIDNgIcCyAAIAMQWwwDCyAAIAYEfiABEJMFBSABCzcAAAwCCxABAAsgACAFKAIcOgAAC0KAgICAMCEICyAFQSBqJAAgCAunAwIBfgN/IwBBEGsiByQAQoCAgIDgACEFAkAgACABQR4QaCIIRQ0AIAAgB0EIaiADKQMAEMEBDQBBASEGIAJBAk4EQCAAIAMpAwgQ+AFBAXMhBgsgCCgCDCgCICICLQAEBEAgABBwDAELIAg1AhQgBykDCCIBQQEgBEGZHmotAAB0rHxUBEAgAEGg2wEQaQwBCyABpyACKAIIIAgoAhBqaiEAAkACQAJAAkACQAJAAkACQAJAIARBFmsOCAgAAQIDBAUGBwsgADEAACEFDAgLIAAvAAAhACAGBH8gABDkAwUgAAtBEHRBEHWtIQUMBwsgAC8AACEAIAYEfyAAEOQDBSAAC60hBQwGCyAAKAAAIQAgBgR/IAAQgwMFIAALrSEFDAULIAAoAAAhAAJ/IAYEQCAAEIMDIQALIABBAE4LBEAgAK0hBQwFCyAAuBAVIQUMBAsgACgAACEAIAYEfyAAEIMDBSAAC767EBUhBQwDCyAAKQAAIQEgBgR+IAEQkwUFIAELvxAVIQUMAgsQAQALIAAwAABC/////w+DIQULIAdBEGokACAFC4ABAQN/IwBBEGsiBSQAIAUgAq03AwgCQCAAIAFBASAFQQhqEMUDIgEQCw0AIAJBACACQQBKGyECA0AgAiAERg0BIAAgASAEIAMgBEEDdGopAwAQDRCWAiEGIARBAWohBCAGQX9KDQALIAAgARAKQoCAgIDgACEBCyAFQRBqJAAgAQumBQIJfgJ/IwBBMGsiDSQAIAMpAwAhBUKAgICAMCEGIA1CgICAgDA3AxhBASEOAkACQAJAAkACfiACQQJIBEBCgICAgDAhCkKAgICAMAwBCwJAIAMpAwgiChAQDQAgACAKEGcNAkEAIQ4gAkEDSA0AIAMpAxAMAQtCgICAgDALIQsgACAFQcMBIAVBABASIgQQCw0AAkAgBBAQRQRAIAAgBBAKIAAQTiIHEAsEQEKAgICAMCEJQoCAgIAwIQQMBAsgDSAFEA03AxAgACANQRBqQQhyQQAQlwMhAiANKQMYIQkgDSkDECEEIAINA0IAIQUDQCAAIAQgCSANQQRqEKsBIggQC0UEQCANKAIEBEAgBCEIDAQLIAAgByAFIAgQbSECIAVCAXwhBSACQQBODQELCyAEEBANBCAAIARBARCvARoMAwtCgICAgDAhCUKAgICAMCEIQoCAgIAwIQQgACAFECkiBxALDQMLIAAgDUEIaiAHEEBBAEgEQCAIIQQMAgsgDQJ+IA0pAwgiBEKAgICACHxC/////w9YBEAgBEL/////D4MMAQsgBLkQFQsiBTcDICAAIAFBASANQSBqEMUDIQYgACAFEAoCQCAGEAsNAEIAIQUgBEIAIARCAFUbIQwDQCAFIAxRBEAgCCEEDAYLIAAgByAFEGIiBBALDQECQCAOBEAgBCEBDAELIA0gBDcDICANIAVC/////w+DNwMoIAAgCiALQQIgDUEgahAiIQEgACAEEAogARALDQILIAAgBiAFIAEQjwEhAiAFQgF8IQUgAkEATg0ACwsgCCEEDAILQoCAgIAwIQlCgICAgDAhBEKAgICAMCEHCwsgACAGEApCgICAgOAAIQYLIAAgBxAKIAAgBBAKIAAgCRAKIA1BMGokACAGCw8AIAArAwAgASsDABDHBAsJACABKwMAEBULVgEBfyABEBBFBEAgAEHJzABBABAUQoCAgIDgAA8LAn4CQCACRQ0AIAMpAwAiARAQDQBCgICAgOAAIAAgARArIgEQCw0BGiABpyEECyAAIARBAxD2AwsLEQAgACoCALsgASoCALsQxwQLCgAgASoCALsQFQsXACABKAIAIgEgACgCACIASSAAIAFJawsYACABKAIAIgBBAE4EQCAArQ8LIAC4EBULFwAgASgCACIBIAAoAgAiAEggACABSGsLBwAgATUCAAsNACAALwEAIAEvAQBrCwcAIAEzAQALDQAgAC4BACABLgEAawsOACABMgEAQv////8PgwsNACAALQAAIAEtAABrCwcAIAExAAALDQAgACwAACABLAAAawsOACABMAAAQv////8PgwvhCQQEfwF8AX4BfSMAQRBrIgYkAEKAgICA4AAhCgJAIAAgARCWASIIQQBIDQBBfyEFAkACQAJAIAhFDQBBASEHAkACQCAEQQFGBEBBfyEHIAYgCEEBazYCDCACQQJIDQEgACAGIAMpAwgQRw0GIAYrAwAiCb1C////////////AINCgYCAgICAgPj/AFoEQCAGQQA2AgwMAgsgCUQAAAAA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CGoQwAIhASACQQE2AgAgARALBEAgACACEMADIAEPCyACKAJEQQhrIgMpAwAhBiADQoCAgIAwNwMAIAFC/////w9YBEAgAadBAkYEQCACQQI2AgAgBEECNgIAIAYPCyAEQQA2AgAgBg8LIAAgARAKIAAgAhDAAyAGDwsgAykDABANDwsgACADKQMAEA0QkgEMAQsgAEHgzwFBABAUC0KAgICA4AAhAQsgAQtmAQF+IAMpAwAiARD3A0UEQCAAQeTJAEEAEBRCgICAgOAADwtCgICAgDAhBCABpykCBEKAgICAgICAgECDQoCAgICAgICAgH9RBH4gAUL/////D4NCgICAgJB/hBANBUKAgICAMAsLLwEBfkKAgICA4AAhASAAIAMpAwAQKyIEEAsEfkKAgICA4AAFIAAgBKdBAhD2AwsLSQIBfgF/IAAgARDBAyIBEAsEQCABDwtCgICAgDAhAiABpyIDKAIEQYCAgIB4RwRAIAAgACgCECADENMCEDEhAgsgACABEAogAgsJACAAIAEQwQMLTgEBfiMAQRBrIgIkACACIAAgARDBAyIBNwMIAkAgARALBEAgASEEDAELIABCgICAgDBBASACQQhqEMgEIQQgACABEAoLIAJBEGokACAECy0AQoCAgIDgACAAIAMpAwAgAykDCEEAEJsCIgBBAEetQoCAgIAQhCAAQQBIGwuGAQEDfiADKQMAIgEhBCACQQROBEAgAykDGCEECyABQv////9vWARAIAAQKEKAgICA4AAPCyADKQMQIQZCgICAgOAAIQUCQCAAIAMpAwgQOSICRQ0AIAAgASACIAYQDSAEQQAQiAQhAyAAIAIQESADQQBIDQAgA0EAR61CgICAgBCEIQULIAULKgAgAykDACIBQv////9vWARAIAAQKEKAgICA4AAPCyAAIAFBA0EAEP8CC2MBAX4gAykDACIEQv////9vWARAIAAQKEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBA5IgJFDQAgACAEIAIQdyEDIAAgAhARIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQtjAQJ+AkACQCADKQMAIgFC/////29YBEAgABAoDAELIAMpAwghBSABIQQgAkEDTgRAIAMpAxAhBAsgACAFEDkiAg0BC0KAgICA4AAPCyAAIAEgAiAEQQAQEiEBIAAgAhARIAELZgEBfiADKQMAIgRC/////29YBEAgABAoQoCAgIDgAA8LQoCAgIDgACEBAkAgACADKQMIEDkiAkUNACAAIAQgAkEAEN0BIQMgACACEBEgA0EASA0AIANBAEetQoCAgIAQhCEBCyABC4sBAgF/An4jAEEQayIEJAAgAykDCCEFIAMpAwAiBiEBAkACQAJAAkAgAkEDSA0AIAMpAxAiARCxAQ0AIABBycwAQQAQFAwBCyAAIARBDGogBRCLBCICDQELQoCAgIDgACEBDAELIAAgBiABIAQoAgwiAyACEI4DIQEgACACIAMQmAMLIARBEGokACABCxwAIAAgAykDAEEAIAJBAWsQSiADQQhqQQIQmgMLQwAjAEEQayICJAACfkKAgICA4AAgACACQQxqIAMpAwAQxAENABpCICACKAIMIgBFDQAaIABnrQshASACQRBqJAAgAQtQACMAQRBrIgIkAEKAgICA4AAhAQJAIAAgAkEMaiADKQMAEJMCDQAgACACQQhqIAMpAwgQkwINACACKAIIIAIoAgxsrSEBCyACQRBqJAAgAQsGACAAtrsLUwACfCAAIAApA9ABIgFCDIggAYUiAUIZhiABhSIBQhuIIAGFIgE3A9ABIAFCnbqz+5SS/aIlfkIMiEKAgICAgICA+D+Ev0QAAAAAAADwv6ALEBUL9QMDA3wFfwN+IwBBEGsiCCQAIAhCADcDCAJAAkAgAkEBSA0AQoCAgIDgACEBIAAgCEEIaiADKQMAEEcNAUEBIQkgCCsDCCEEIAJBAUcEQANAIAIgCUYNAiAAIAggAyAJQQN0aikDABBHDQMgCUEBaiEJIAgrAwAhBSMAQSBrIgckACAEvUL///////////8AgyINIAW9Qv///////////wCDIgwgDCANVhsiDr8hBAJAIA5CNIinIgpB/w9GDQAgDSAMIAwgDVQbIgy/IQUCQCAOUA0AIAxCNIinIgtB/w9GDQAgCyAKa0HBAE4EQCAFIASgIQQMAgsCfCALQf4LTwRAIAREAAAAAAAAMBSiIQQgBUQAAAAAAAAwFKIhBUQAAAAAAACwawwBC0QAAAAAAADwPyAKQbwESw0AGiAERAAAAAAAALBroiEEIAVEAAAAAAAAsGuiIQVEAAAAAAAAMBQLIQYgB0EYaiAHQRBqIAUQhgYgB0EIaiAHIAQQhgYgBiAHKwMAIAcrAxCgIAcrAwigIAcrAxign6IhBAwBCyAFIQQLIAdBIGokAAwACwALIASZIQQLIAS9An8gBJlEAAAAAAAA4EFjBEAgBKoMAQtBgICAgHgLIgC3vVEEQCAArSEBDAELIAQQFSEBCyAIQRBqJAAgAQtbAQF/AkAgAL1C////////////AINCgICAgICAgPj/AFYgAEQAAAAAAAAAAGFyDQAgAEQAAAAAAAAAAGMhAUQAAAAAAADwvyEAIAENAEQAAAAAAADwPyEACyAAC4MBAgJ+AX8gAL0iAUI0iKdB/w9xIgNB/gdNBEAgAUKAgICAgICAgIB/gyECIANB/gdHIAFCgICAgICAgPC/f1FyRQRAIAJCgICAgICAgPg/hL8PCyACvw8LIANBsghNBHwgAUI/hyABfEIBQbMIIANrrYYiAUIBiHxCACABfYO/BSAACwvjBAICfAV/IwBBEGsiCCQAAn4gAkUEQEQAAAAAAADw/0QAAAAAAADwfyAEGxAVDAELAnwgAykDACIBQv////8PWARAIAJBASACQQFKGyELIAGnIQlBASEHA0AgByALRwRAIAm3IAMgB0EDdGopAwAiAUKAgICAEFoNAxogAachCgJ/IAQEQCAJIAoQSgwBCyAJIAoQsAELIQkgB0EBaiEHDAELCyAJrQwCC0KAgICA4AAgACAIQQhqIAEQRw0BGkEBIQcgCCsDCAshBSAHIAIgAiAHSBshAgNAIAIgB0cEQEKAgICA4AAgACAIIAMgB0EDdGopAwAQRw0CGgJAIAW9Qv///////////wCDQoCAgICAgID4/wBWDQAgCCsDACIGvUL///////////8Ag0KAgICAgICA+P8AVgRAIAYhBQwBCyAEBEAgBb1C////////////AINCgICAgICAgPj/AFgEfCAFIAUgBqUgBr1C////////////AINCgICAgICAgPj/AFYbBSAGCyAGvSAFvYO/IAVEAAAAAAAAAABiIAZEAAAAAAAAAABichshBQwBCyAFvUL///////////8Ag0KAgICAgICA+P8AWAR8IAUgBSAGpCAGvUL///////////8Ag0KAgICAgICA+P8AVhsFIAYLIAa9IAW9hL8gBUQAAAAAAAAAAGIgBkQAAAAAAAAAAGJyGyEFCyAHQQFqIQcMAQsL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QANAIANBAUgNAiAFQQhqIAZBACADIAYoAgRB/////wdxELABIgIQVw0DIAUgAyACayIDNgIEDAALAAsgBUEIaiAKIAMQywQNAQsgBEUEQCAFQQhqIAlBACAIEFcNAQsgACALEAogACABEAogBUEIahA3IQwMBAsgBUEIahBECyAAIAsQCgsgACABEAoMAQsgASEMCyAFQSBqJAAgDAv3BAIEfgV/IwBB0ABrIgIkACADKQMIIQggAykDACEFAkACQAJAIAEQEEUEQCABECZFDQELIABBk84AQQAQFAwBCwJAIAUQEA0AIAUQJg0AIAQEQCAAIAUQzQRBAEgNAgtCgICAgOAAIQYgACAFQcYBIAVBABASIgcQCw0CIAcQEA0AIAcQJg0AIAIgCDcDKCACIAE3AyAgACAHIAVBAiACQSBqEDUhBgwCCyAAIAJBCGpBABBCGkKAgICAMCEHAkAgACABECsiBhALBEBCgICAgDAhBQwBCyAAIAUQKyIFEAsNACAAIAgQOiINRQRAIAAgCBArIgcQCw0BCyAGpyEKIAWnIgwpAgQhAQNAAkACQCABQv////8Hg1AEQEEAIQMgC0UNASAJIAooAgRB/////wdxTg0CIAlBAWohAwwBCyAKIAwgCRDMBCIDQX9KDQAgCw0BIAJBCGoQRCAAIAUQCiAAIAcQCgwFCyACIAU3AyACfiANBEAgAiAGNwMwIAIgA603AyggACAAIAhCgICAgDBBAyACQSBqECIQPgwBCyACIAc3A0ggAkKAgICAMDcDQCACQoCAgIAwNwM4IAIgBjcDKCACIAOtNwMwIAAgAkEgahCQBQsiARALDQIgAkEIaiAKIAkgAxBXGiACQQhqIAEQjQEaIAwpAgQiAadB/////wdxIANqIQlBASELIAQNAQsLIAJBCGogCiAJIAooAgRB/////wdxEFcaIAAgBRAKIAAgBxAKIAAgBhAKIAJBCGoQNyEGDAILIAJBCGoQRCAAIAUQCiAAIAcQCiAAIAYQCgtCgICAgOAAIQYLIAJB0ABqJAAgBguDAgIDfwF+IwBBIGsiAiQAAkACQCAAIAEQYSIBEAsNACAAIAIgAykDABCOBA0AIAIpAwAiB0KAgICACFoEQCAAQaTCARBpDAELIAenIgNBAUYNASABpyIFKQIEpyIGQf////8HcSIERQ0BIAcgBK1+QoCAgIAEWQRAIABB9A1BABBBDAELIAAgAkEIaiADIARsIAZBH3YQqgMNAAJAIARBAUcEQANAIANBAUgNAiACQQhqIAVBACAEEFcaIANBAWshAwwACwALIAJBCGogBUEAEC8gAxDLBBoLIAAgARAKIAJBCGoQNyEBDAELIAAgARAKQoCAgIDgACEBCyACQSBqJAAgAQulAQICfwJ+IwBBEGsiAiQAAkAgACABEGEiARALBEAgASEGDAELQoCAgIDgACEGAkAgACACQQxqIAMpAwAgAaciBSgCBEH/////B3EiBCAEEGMNACACIAQ2AgggAykDCCIHEBBFBEAgACACQQhqIAcgBCAEEGMNASACKAIIIQQLIAAgBSACKAIMIgMgBCADEEoQmgEhBgsgACABEAoLIAJBEGokACAGC6cBAgN/An4jAEEQayICJAACQCAAIAEQYSIBEAsEQCABIQcMAQtCgICAgOAAIQcCQCAAIAJBDGogAykDACABpyIGKAIEQf////8HcSIEIAQQYw0AIAIgBCACKAIMIgVrIgQ2AgggACAGIAUgAykDCCIIEBAEfyAEBSAAIAJBCGogCCAEQQAQYw0BIAIoAggLIAVqEJoBIQcLIAAgARAKCyACQRBqJAAgBwu6AQICfwJ+IwBBEGsiAiQAAkAgACABEGEiARALBEAgASEGDAELQoCAgIDgACEGAkAgACACQQxqIAMpAwAgAaciBSgCBEH/////B3FBABBjDQAgAiAFKAIEQf////8HcSIENgIIIAMpAwgiBxAQRQRAIAAgAkEIaiAHIARBABBjDQEgAigCCCEECyAAIAUgAigCDCIDIAQgAyAESCIFGyAEIAMgBRsQmgEhBgsgACABEAoLIAJBEGokACAGC5gEAgl+A38jAEEQayINJAAgAykDCCEHIAMpAwAhBAJAAkACQCABEBBFBEAgARAmRQ0BCyAAQZPOAEEAEBQMAQsCQCAEEBAiAg0AIAQQJg0AQoCAgIDgACEFIAAgBEHIASAEQQAQEiIIEAsNAiAIEBANACAIECYNACANIAc3AwggDSABNwMAIAAgCCAEQQIgDRA1IQUMAgtCgICAgDAhCQJAIAAgARArIgwQCwRAQoCAgIAwIQUMAQsgABBOIgUQCw0AAkAgBxAQBEAgDUF/NgIADAELIAAgDSAHEMQBQQBIDQELIAynIg4pAgQhASAAIAQQKyIJEAsNAAJAIA0oAgAiA0UNACABp0H/////B3EhDyAAIA4CfwJAIAINACAJpyICKQIEQv////8HgyEKAkAgDwRAIAFC/////weDIAp9IApQrSIEfSEHIAOtIQgDQCAEIAt8IgEgB1UNAiAOIAIgAacQzAQiA0EASA0CIAAgDiALpyADEJoBIgEQCw0GIAAgBSAGIAFBABCqAUEASA0GIAogA6x8IQsgBkIBfCIGIAhSDQALDAQLIApQRQ0BDAMLIAZC/////w+DIQYgC6cMAQtBAAsgDxCaASIBEAsNASAAIAUgBiABQQAQqgFBAEgNAQsgACAMEAogACAJEAoMAgsgACAFEAogACAMEAogACAJEAoLQoCAgIDgACEFCyANQRBqJAAgBQvTAgEDfiMAQTBrIgIkACACIAE3AyggAykDACEFAkACQCABEBBFBEAgARAmRQ0BCyAAQZPOAEEAEBRCgICAgOAAIQcMAQsCQCAFEBANACAFECYNAEKAgICA4AAhByAAIAUgBCAFQQAQEiIGEAsNAQJAIARBxQFHDQAgACAFEM0EQX9KDQAgACAGEAoMAgsgBhAQDQAgBhAmDQAgACAGIAVBASACQShqEDUhBwwBCyACIAAgARArIgY3AwhCgICAgOAAIQcgBhALDQAgAiAFNwMQAkACQAJ/IARBxQFHBEBCgICAgDAhAUEBDAELIABBhMIBEHEiARALDQEgAiABNwMYQQILIQMgACAAKQNIIAMgAkEQahCuASEFIAAgARAKIAUQC0UNAQsgACAGEAoMAQsgACAFIARBASACQQhqELkCIQcgACACKQMIEAoLIAJBMGokACAHC/kCAgV/A34jAEEQayIFJAACQCAAIAEQYSIKEAsEQCAKIQEMAQsCQCAAIAMpAwAQgwQiBgRAQoCAgIDgACEBQoCAgIAwIQsgBkEBSA0BIABB8MEBQQAQFAwBC0KAgICA4AAhASAAIAMpAwAQKyILEAsNACALpyIHKAIEIQggBSAKpyIJKAIEQf////8HcSIGQQAgBEECRhs2AgwCQCACQQJIDQAgAykDCCIMEBANACAAIAVBDGogDCAGQQAQYw0BCyAGIAhB/////wdxIgZrIQICQAJAAkACQCAEDgIAAQILIAUoAgwhAwwCCyAFKAIMIgMgAkoh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IQQgACABECkiARALRQRAAn5CgICAgOAAIAAgAUHbACABQQAQEiIEEAsNABogACAEEDpFBEAgACAEEAogACABQQBBABDXBAwBCyAAIAQgAUEAQQAQNQshBCAAIAEQCgsgBAvWAgICfwR+IwBBIGsiBSQAAn4CQCAAIAUgACABECkiCRBADQBBLCEGQoCAgIAwIQgCQCACQQFIIARyRQRAQQAhAiADKQMAIgEQEA0BIAAgARArIggQCw0CQX8hBiAIpyICKAIEQQFHDQEgAi0AECEGDAELQQAhAgsgACAFQQhqQQAQQhpCACEBIAUpAwAiB0IAIAdCAFUbIQoCQANAIAEgClIEQAJAIAFQDQAgBkEATgRAIAVBCGogBhA7GgwBCyAFQQhqIAJBACACKAIEQf////8HcRBXGgsgACAJIAGnEHgiBxALDQICQCAHECYNACAHEBANACAFQQhqIAQEfiAAIAcQ1QQFIAcLEI0BDQMLIAFCAXwhAQwBCwsgACAIEAogACAJEAogBUEIahA3DAILIAVBCGoQRCAAIAgQCgsgACAJEApCgICAgOAACyEBIAVBIGokACABC/MBAgF/An4jAEEgayIEJAACfgJAAkACQCAAIARBEGogACABECkiBRBADQAgBCkDECIGQgFTDQEgBCAGQgF9IgE3AwggAkECTgRAIAAgBEEIaiADKQMIQn8gASAGEH4NASAEKQMIIQELA0AgAUIAUw0CIAAgBSABIARBGGoQiQEiAkEASA0BIAIEQCAAIAMpAwAQDSAEKQMYQQAQ3gENBAsgAUIBfSEBDAALAAsgACAFEApCgICAgOAADAILQn8hAQsgACAFEAogAUL/////D4MgAUKAgICACHxC/////w9YDQAaIAG5EBULIQEgBEEgaiQAIAEL9QICAX8EfiMAQSBrIgQkAAJ+AkACQCAAIARBEGogACABECkiBxBADQBCfyEGIAQpAxAiCEIBUw0BIARCADcDCCACQQJOBEAgACAEQQhqIAMpAwhCACAIIAgQfg0BCwJAIAcgBEEEaiAEEI4CRQRAIAQpAwghAQwBCyAEKQMIIgUgBDUCACIBIAEgBVMbIQEgBCgCBCECA0AgASAFUgRAIAAgAykDABANIAIgBadBA3RqKQMAEA1BABDeAQRAIAUhBgwFBSAFQgF8IQUMAgsACwsgBCABNwMICyABIAggASAIVRshBQNAIAEgBVENAiAAIAcgASAEQRhqEIkBIgJBAEgNAQJAIAJFDQAgACADKQMAEA0gBCkDGEEAEN4BRQ0AIAEhBgwDCyABQgF8IQEMAAsACyAAIAcQCkKAgICA4AAMAQsgACAHEAogBkL/////D4MgBkKAgICACHxC/////w9YDQAaIAa5EBULIQEgBEEgaiQAIAEL3AICCH4BfyMAQTBrIg0kAEKAgICAMCEGAkACQCAAIA1BCGogACABECkiBxBABEBCgICAgDAhBQwBC0KAgICAMCEFIAAgAykDACIKEGcNAEKAgICAMCEJIAJBAk4EQCADKQMIIQkLIA0pAwgiBUIAIAVCAFUbIQsDQCAIIAtSBEACfiAIIgVCgICAgAhaBEAgCLkQFSEFCyAFCxALDQIgACAHIAUQngEiBhALDQIgDSABNwMgIA0gBTcDGCANIAY3AxAgACAKIAlBAyANQRBqECIiDBALDQIgACAMECwEQCAEBEAgACAGEAogACAHEAoMBQsgACAFEAogACAHEAogBiEFDAQFIAAgBhAKIAAgBRAKIAhCAXwhCAwCCwALCyAAIAcQCkL/////D0KAgICAMCAEGyEFDAELIAAgBRAKIAAgBhAKIAAgBxAKQoCAgIDgACEFCyANQTBqJAAgBQv1AQIBfwJ+IwBBIGsiBCQAAkACQCAAIARBGGogACABECkiBhBADQAgBEIANwMQAkAgAkEBTARAIAQgBCkDGCIFNwMIDAELIAQpAxghBSADKQMIIgEQEEUEQCAAIARBEGogAUIAIAUgBRB+DQILIAQgBTcDCCACQQNIDQAgAykDECIBEBANACAAIARBCGogAUIAIAUgBRB+DQEgBCkDCCEFCyAEKQMQIgEgBSABIAVVGyEFA0AgASAFUQ0CIAAgBiABIAMpAwAQDRCPASECIAFCAXwhASACQX9KDQALCyAAIAYQCkKAgICA4AAhBgsgBEEgaiQAIAYL0gQCA38IfiMAQUBqIgUkAEKAgICAMCEKIAVCgICAgDA3AzggBUKAgICAMDcDMAJAAkACQCAEQQhxIgYEQCAFIAAgARANIgsQlgEiB6w3AwggB0EATg0BDAILIAAgBUEIaiAAIAEQKSILEEANAQsgACADKQMAIg0QZw0AAkAgAkEBTARAQgAhASAFKQMI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BgRAQoCAgIAwIQUgAi0AAEEQcQRAIAJBGGogAkEQaiAEGykDABANIQULIAAgAhBNDAMLIAAgARCZAiIBEAsNAiABECYEQEKAgICAMCEFDAMLIAAQf0UNAAsMAQtBACEDCyAAIAMQESAAIAEQCiACQSBqJAAgBQuVAQECfiADKQMIIQUgAykDACEGAkAgACABECkiARALRQRAIAAgBRBnRQRAIAAgBhA5IgINAgsgACABEAoLQoCAgIDgAA8LIAAgASACQoCAgIAwQoCAgIAwIAUgBBsgBUKAgICAMCAEG0GFqgFBhZoBIAQbEHUhAyAAIAEQCiAAIAIQEUKAgICA4ABCgICAgDAgA0EASBsLUgACQCABEBBFBEAgARAmRQ0BCyAAEChCgICAgOAADwsCQCACECANACACECYNAEKAgICAMA8LQoCAgIDgAEKAgICAMCAAIAEgAkEBEJsCQQBIGwslAQF+IAAgARApIgEQCwRAIAEPCyAAIAEQ+wEhAiAAIAEQCiACC5MBAgF+AX8jAEEgayICJABCgICAgOAAIQQCQAJAIAAgARApIgEQCw0AIAAgAykDABA5IgNFDQAgACACIAGnIAMQUyIFQQBIDQEgBUUEQEKAgICAECEEDAILIAI1AgAhBCAAIAIQTSAEQgKIQgGDQoCAgIAQhCEEDAELQQAhAwsgACADEBEgACABEAogAkEgaiQAIAQLhwEBAn4gAykDACIFECBFBEBCgICAgBAPCwJAIAAgARApIgQQC0UEQCAEpyECIAUQDSEBA0AgACABEJkCIgEQC0UEQCABECYiAyACIAGnRnINAyAAEH9FDQELCyAAIAEQCiAAIAQQCgtCgICAgOAADwsgACABEAogACAEEAogA0WtQoCAgIAQhAtlAQF+QoCAgIDgACEEAkAgACADKQMAEDkiAkUNACAAIAEQKSIBEAsEQCAAIAIQESABDwsgAEEAIAGnIAIQUyEDIAAgAhARIAAgARAKIANBAEgNACADQQBHrUKAgICAEIQhBAsgBAsIACAAIAEQKQsPACAAIAFBN0EAQQAQwwILnAIBBX4jAEEQayICJAAgAykDACEFAkAgABA9IgEQCwRAIAEhBQwBC0KAgICAMCEHAkACQCAAIAVBABD1ASIEEAsNACAAIARB6gAgBEEAEBIiBxALDQADQCAAIAQgByACQQxqEKsBIgYQCw0BIAIoAgwEQCABIQUMAwsCQAJAIAYQIEUEQCAAECgMAQsgACAGQQAQeCIIEAsNACAAIAZBARB4IgUQCwRAIAAgCBAKDAELIAAgASAIIAVBh4ABEMoCQX9KDQELIAAgBhAKDAILIAAgBhAKDAALAAtCgICAgOAAIQUgBBAgBEAgACAEQQEQrwEaCyAHIQYgBCEHIAEhBAsgACAGEAogACAHEAogACAEEAoLIAJBEGokACAFC0AAAn4CQCABEKgDIgJFDQAgAi0AEEEBcQ0AQoCAgIAwIAItABFBAXENARoLIAAgAUEAQQAQ3AQaQoCAgIDgAAsLSABBLyECIAAgAykDACIBEFRBf0YEfyABpy8BBiICQSlGBEBBDUEpIAAgARA6GyECCyAAKAIQKAJEIAJBGGxqKAIEBUEvCxAxC/MBAgR/AX4jAEEwayICJAACQCADKQMAIgkQIEUEQEKBgICAECEBDAELQoCAgIDgACEBIAAgAkEsaiACQShqIAmnIghBAxCQAQ0AIAIoAiwhBiACKAIoIQdBACEDAkADQCADIAdHBEAgACACQQhqIAggBiADQQN0aigCBBBTIgVBAEgNAgJAIAVFDQAgACACQQhqEE0gAigCCCIFQQFxRUEAIARFIAVBAnFFchsNAEKAgICAECEBDAMLIANBAWohAwwBCwsgACAJEJ8BIgNBAEgNASADQQFHrUKAgICAEIQhAQsgACAGIAcQZAsgAkEwaiQAIAELnQECAX4Bf0KAgICAMCEBAkACQCAAIAMpAwAQKSIEEAsNACACQQEgAkEBShshBUEBIQIDQCACIAVGDQICQCADIAJBA3RqKQMAIgEQJg0AIAEQEA0AIAAgARApIgEQCw0CIAAgBCABQoCAgIAwQQEQxgUNAiAAIAEQCgsgAkEBaiECDAALAAsgACAEEAogACABEApCgICAgOAAIQQLIAQLGwAgACADKQMAIAMpAwgQWEEAR61CgICAgBCEC5sCAgN+A38jAEEgayICJABCgICAgOAAIQQgACADKQMAECkiBRALRQRAQoCAgIAwIQECfgJAIAAgAkEcaiACQRhqIAWnQQMQkAENACAAED0iARALDQAgAigCHCEHIAIoAhghCEEAIQMDQCADIAhHBEAgACAHIANBA3RqIgkoAgQQXiIGEAsNAiACIAY3AwggAiAFNwMAIABCgICAgDBBAiACQQAQ2AQhBCAAIAYQCiAEEAsNAiAEEBBFBEAgACABIAkoAgQgBEGHgAEQGUF/TA0DCyADQQFqIQMMAQsLIAAgByAIEGQgAQwBCyAAIAIoAhwgAigCGBBkIAAgBRAKIAEhBUKAgICA4AALIQQgACAFEAoLIAJBIGokACAEC20AAn4CQCADKQMAIgFC/////29YBEAgBEUNASAAEChCgICAgOAADwtCgICAgOAAIAAgARCZBCICQQBIDQEaIAQEQCACQQBHrUKAgICAEIQPCyACDQAgAEGrnAFBABAUQoCAgIDgAA8LIAEQDQsLTwACQAJAIAMpAwAiAUL/////b1gEQCAERQRAQoCAgIAQDwsgABAoDAELIAAgARCfASIAQQBODQELQoCAgIDgAA8LIABBAEetQoCAgIAQhAsQACAAIAMpAwBBAkEAEP8CCxAAIAAgAykDAEEBQQAQ/wILLQEBfkKAgICA4AAhASAAIAMpAwAiBCADKQMIENoEBH5CgICAgOAABSAEEA0LC30BAn4gAykDACIBQv////9vWARAIAAQKEKAgICA4AAPCyADKQMQIQZCgICAgOAAIQUCQCAAIAMpAwgQOSICRQ0AIAAgASACIAYgBEVBDnQQ2QQhAyAAIAIQESADQQBIDQAgBARAIANBAEetQoCAgIAQhA8LIAEQDSEFCyAFCycAIAAgAykDACIBIAMpAwhBARCbAkEASARAQoCAgIDgAA8LIAEQDQs4ACADKQMAIgFCIIinIgJBf0YgBEVBACACQX5xQQJHG3JFBEAgABAoQoCAgIDgAA8LIAAgARD7AQtiAQF+AkAgAykDACIBECANACABECYNACAAQcChAUEAEBRCgICAgOAADwsCQCAAIAEQUiIBEAtFBEAgAykDCCIEEBANASAAIAEgBBDaBEUNASAAIAEQCgtCgICAgOAADwsgAQu4AQECfiABECBFBEAgABAoQoCAgIDgAA8LQoCAgIDgACEFAn4gACABQTYgAUEAEBIiBBAQBEAgAEGOARAxDAELIAAgBBA+CyIEEAsEfkKAgICA4AAFAn4gACABQTMgAUEAEBIiARAQBEAgAEEvEDEMAQsgACABED4LIgEQCwRAIAAgBBAKQoCAgIDgAA8LAkAgBBD2AQ0AIAEQ9gENACAAQb4V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BUEIaiADIAJBH3YQqgMaIAcoAgRB/////wdxIQhBACEAA0ACQAJAIAAgCEgEQCAAQQFqIQJBfyEGAkACfwJAAkACQAJAAkACQAJAIAcgABAvIgNB2wBrDgMDAQIACyACIQACQCADQQprDgQECwsFAAsgA0EvRw0HIARFDQVBASEEQS8hAwwHC0HcACEDIAIgCE4NBiAAQQJqIQAgByACEC8hBgwJC0EAIQRB3QAhAwwFC0HbACEDIAQgAiAITnINBiAAQQJqIAIgByACEC9B3QBGIgIbIQBB3QBBfyACGyEGQQEhBAwHC0HuAAwCC0HyAAwBC0EAIQRBLwshBkHcACEDCyACIQAMAgsgBUEIahA3IQEMAwsgAiEAQQEhBAsgBUEIaiADEJQBGiAGQQBIDQAgBUEIaiAGEJQBGgwACwALIAVBIGokACABC9gCAgN/AX4jAEEQayIEJAACQCABQv////9vWARAIAAQKEKAgICA4AAhBQwBC0KAgICA4AAhBSAAIAAgAUHuACABQQAQEhAsIgJBAEgNACACBH8gBEHnADoACCAEQQlqBSAEQQhqCyECIAAgACABQZ/PABDMAhAsIgNBAEgNACADBEAgAkHpADoAACACQQFqIQILIAAgACABQarPABDMAhAsIgNBAEgNACADBEAgAkHtADoAACACQQFqIQILIAAgACABQbTPABDMAhAsIgNBAEgNACADBEAgAkHzADoAACACQQFqIQILIAAgACABQe8AIAFBABASECwiA0EASA0AIAMEQCACQfUAOgAAIAJBAWohAgsgACAAIAFBw88AEMwCECwiA0EASA0AIAAgBEEIaiADBH8gAkH5ADoAACACQQFqBSACCyAEQQhqaxD+ASEFCyAEQRBqJAAgBQv6CgIRfwF+IwBBEGsiByQAAkAgACABEGEiARALDQAjAEEQayIFJABBfyEEAkAgACIGIAEQKyIVEAsNACAGIBWnIgooAgRB/////wdxIgBBARBKQQJ0EC0iCUUEQCAGIBUQCiAHQQA2AggMAQtBACEEIAVBADYCDCAAQQBHIQsDQCALBEAgCSAEQQJ0aiAKIAVBDGoQ2QE2AgAgBEEBaiEEIAUoAgwgAEghCwwBCwsgBiAVEAogByAJNgIICyAFQRBqJAAgBiABEApCgICAgOAAIQEgBCIAQQBIDQACQCAC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CyACRQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARDpAQwDC0EAIAAoAgggACgCBCACakkNARogASACEPUFDwsgACACEKUFCw8LQQALJgAgAQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARDpAQsLKAEBfwJAIAGnKAIgIgNFDQAgAygCAEEERg0AIAAgA0EIaiACEPADCwscAQF/IAFBKBA/IgIEQCAAIAIQ7gMgACACEB8LCyUBAX8gAacoAiAiAwRAIAAgAykDACACECEgACADKQMIIAIQIQsLJwEBfyABpygCICICBEAgACACKQMAECUgACACKQMIECUgACACEB8LCx4BAX8gAacoAiAiAgRAIAAgAikDABAlIAAgAhAfCwtDAQJ/IAGnKAIgIgIEQAJAIAIpAwAiARDeBUUNACACKAIMIgNFDQAgACADEPIDIAIpAwAhAQsgACABECUgACACEB8LC1gBA38CQCABpygCICIERQ0AIARBCGohAyAEQQRqIQUDQCADKAIAIgMgBUYNASAEKAIARQRAIAAgAykDECACECELIAAgAykDGCACECEgA0EEaiEDDAALAAsLgQEBBX8gAacoAiAiAwRAIANBBGohBSADKAIIIQIDQCACIAVHBEAgAigCBCEGIAJBEGshBCACQQxrKAIARQRAAkAgAygCAARAIAQQpgUMAQsgACACKQMQECULIAAgAikDGBAlCyAAIAQQHyAGIQIMAQsLIAAgAygCEBAfIAAgAxAfCwshAQF/IAGnKAIgIgMEQCAAIAM1AgxCgICAgHCEIAIQIQsLQAEBfyABpygCICICBEAgACACNQIMQoCAgIBwhCIBEN4FBH4gAhBGIAI1AgxCgICAgHCEBSABCxAlIAAgAhAfCwtbAQJ/IAGnKAIgIgIEQAJAAkAgAi0ABUUNACAAKAK8ASIDRQ0AIAAoAsQBIAIoAgggAxEDAAwBCyACKAIYIgNFDQAgACACKAIUIAIoAgggAxEGAAsgACACEB8LCykBAX8gACABpyICNQIkQoCAgICQf4QQJSAAIAI1AiBCgICAgJB/hBAlCxEAIAAgAacoAiApAwAgAhAhCxkBAX8gACABpygCICICKQMAECUgACACEB8LQQEDfwJAIAFBDxA/IgRFDQAgBEEIaiEFA0AgAyAELQAFTw0BIAAgBSADQQN0aikDACACECEgA0EBaiEDDAALAAsLQwEDfyABQQ8QPyIDBEAgA0EIaiEEA0AgAiADLQAFT0UEQCAAIAQgAkEDdGopAwAQJSACQQFqIQIMAQsLIAAgAxAfCwtJAQJ/IAAgAacoAiAiBCkDACACECEgACAEKQMIIAIQIQNAIAMgBCgCEE5FBEAgACAEIANBA3RqKQMYIAIQISADQQFqIQMMAQsLC0kBAn8gACABpygCICICKQMAECUgACACKQMIECUDQCADIAIoAhBORQRAIAAgAiADQQN0aikDGBAlIANBAWohAwwBCwsgACACEB8LjgEBBH8gAaciAygCJCEFIAMoAiAhBCADKAIoIgMEQCAAIAOtQoCAgIBwhCACECELIAQEQAJAIAVFDQBBACEDA0AgAyAEKAI8Tg0BAkAgBSADQQJ0aigCACIGRQ0AIAYtAAVBAXFFDQAgACAGIAIRAwALIANBAWohAwwACwALIAAgBK1CgICAgGCEIAIQIQsLcwEDfyABpyICKAIoIgMEQCAAIAOtQoCAgIBwhBAlCyACKAIgIgMEQCACKAIkIgQEQEEAIQIDQCACIAMoAjxORQRAIAAgBCACQQJ0aigCABD5ASACQQFqIQIMAQsLIAAgBBAfCyAAIAOtQoCAgIBghBAlCwsSACABpygCICIABEAgABCtAwsLDgAgACABpykDICACECELGQAgACABpyIAKQMgECUgAEKAgICAMDcDIAs1AQJ/IAGnIQQDQCADIAQoAihPRQRAIAAgBCgCJCADQQN0aikDACACECEgA0EBaiEDDAELCws8AQJ/IAGnIQMDQCACIAMoAihPRQRAIAAgAygCJCACQQN0aikDABAlIAJBAWohAgwBCwsgACADKAIkEB8LCAAgACACEB8LtwECAX8CfiMAQSBrIgMkACABQQNGBEAgAikDECEEIAIpAwghBQJAIAAgA0EQaiACKQMAEKwFQQBIBEBCgICAgOAAIQQMAQsgACAEIAVBAiADQRBqECIiBBALBEAgAyAAEJEBNwMIIAAgAykDGEKAgICAMEEBIANBCGoQIiEEIAAgAykDCBAKCyAAIAMpAxAQCiAAIAMpAxgQCgsgA0EgaiQAIAQPC0H24wBBoQ1Bu+oCQYDkABAAAAvoAQEIfyMAIgchCyABpygCICIIKAIQIglB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TwRAIAAgAKEhAAwBCyAAIAEQsAQhAiABKwMAIAErAwggAkEBcRCEBiEACyABQRBqJAAgAAutAwIBfgV/IAG9Qv///////////wCDQoCAgICAgID4/wBYQQAgAL1C////////////AINCgYCAgICAgPj/AFQbRQRAIAAgAaAPCyABvSICQiCIpyIDQYCAwP8DayACpyIGckUEQCAAEK8EDwsgAkI+iKdBAnEiByAAvSICQj+Ip3IhBAJAAkAgAkIgiKdB/////wdxIgUgAqdyRQRAAkAgBEECaw4CAgADC0QYLURU+yEJwA8LIANB/////wdxIgMgBnJFBEBEGC1EVPsh+T8gAKYPCwJAIANBgIDA/wdGBEAgBUGAgMD/B0cNASAEQQN0QaCcBGorAwAPCyAFQYCAwP8HR0EAIANBgICAIGogBU8bRQRARBgtRFT7Ifk/IACmDwsCfCAHBEBEAAAAAAAAAAAgBUGAgIAgaiADSQ0BGgsgACABo5kQrwQLIQACQAJAAkAgBA4DBQABAgsgAJoPC0QYLURU+yEJQCAARAdcFDMmpqG8oKEPCyAARAdcFDMmpqG8oEQYLURU+yEJwKAPCyAEQQN0QcCcBGorAwAPC0QYLURU+yEJQCEACyAAC8cBAQJ/IwBBEGsiASQAAnwgAL1CIIinQf////8HcSICQfvDpP8DTQRARAAAAAAAAPA/IAJBnsGa8gNJDQEaIABEAAAAAAAAAAAQ2QIMAQsgACAAoSACQYCAwP8HTw0AGgJAAkACQAJAIAAgARCwBEEDcQ4DAAECAwsgASsDACABKwMIENkCDAMLIAErAwAgASsDCEEBENoCmgwCCyABKwMAIAErAwgQ2QKaDAELIAErAwAgASsDCEEBENoCCyEAIAFBEGokACAAC7ACAwF8AX4BfwJAIAC9IgJCIIinQf////8HcSIDQYCAwP8DTwRAIAKnIANBgIDA/wNrckUNAUQAAAAAAAAAACAAIAChow8LAnwgA0H////+A00EQEQYLURU+yH5PyADQYGAgOMDSQ0BGkQHXBQzJqaRPCAAIACiENsCIACioSAAoUQYLURU+yH5P6APCyACQn9XBEBEGC1EVPsh+T8gAEQAAAAAAADwP6BEAAAAAAAA4D+iIgCfIgEgASAAENsCokQHXBQzJqaRvKCgoSIAIACgDwtEAAAAAAAA8D8gAKFEAAAAAAAA4D+iIgCfIgEgABDbAqIgACABvUKAgICAcIO/IgAgAKKhIAEgAKCjoCAAoCIAIACgCw8LRAAAAAAAAAAARBgtRFT7IQlAIAJCf1UbC4cBAwF+AX8BfCAAvSIBQv///////////wCDvyEAAkACfCABQjSIp0H/D3EiAkH9B00EQCACQd8HSQ0CIAAgAKAiAyADIACiRAAAAAAAAPA/IACho6AMAQsgAEQAAAAAAADwPyAAoaMiACAAoAsQsANEAAAAAAAA4D+iIQALIAAgAJogAUJ/VRsLngEDAnwBfwF+RAAAAAAAAOA/IACmIQIgAL1C////////////AIMiBL8hAQJAIARCIIinIgNBwdyYhARNBEAgARCkAiEBIANB//+//wNNBEAgA0GAgMDyA0kNAiACIAEgAaAgASABoiABRAAAAAAAAPA/oKOhog8LIAIgASABIAFEAAAAAAAA8D+go6CiDwsgAiACoCABEIcGoiEACyAACwUAIACZCwUAIACfC94BAgF/An4gAL0iAkL///////////8AgyIDvyEAAkAgA0IgiKciAUHrp4b/A08EQCABQYGA0IEETwRARAAAAAAAAACAIACjRAAAAAAAAPA/oCEADAILRAAAAAAAAPA/RAAAAAAAAABAIAAgAKAQpAJEAAAAAAAAAECgo6EhAAwBCyABQa+xwf4DTwRAIAAgAKAQpAIiACAARAAAAAAAAABAoKMhAAwBCyABQYCAwABJDQAgAEQAAAAAAAAAwKIQpAIiAJogAEQAAAAAAAAAQKCjIQALIAAgAJogAkJ/VRsLgwIDAXwCfwF+IAC9IgRCIIinQf////8HcSICQYCAwP8HTwRAIAAgAKAPC0GT8f3UAiEDAkAgAkH//z9NBEBBk/H9ywIhAyAARAAAAAAAAFBDor0iBEIgiKdB/////wdxIgJFDQELIAAgBEKAgICAgICAgIB/gyACQQNuIANqrUIghoS/IgEgAaIgASAAo6IiACAAIACioiAARNft5NQAsMI/okTZUee+y0Tov6CiIAAgAETC1klKYPH5P6JEICTwkuAo/r+gokSS5mEP5gP+P6CgIAGivUKAgICACHxCgICAgHyDvyIAIACioyIBIAChIAAgAKAgAaCjIACiIACgIQALIAALngMCA34CfyMAQSBrIgkk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IG92ZXJoZWFkLCAlMC4xZiBhdmVyYWdlIHNsYWNrKQoAbWVtb3J5IHVzZWQAJS0yMHMgJThsbGQgJThsbGQgICglMC4xZiBwZXIgYXRvbSkKAGF0b21zACUtMjBzICU4bGxkICU4bGxkICAoJTAuMWYgcGVyIHN0cmluZykKAHN0cmluZ3MAJS0yMHMgJThsbGQgJThsbGQgICglMC4xZiBwZXIgb2JqZWN0KQoAb2JqZWN0cwAgIHByb3BlcnRpZXMAJS0yMHMgJThsbGQgJThsbGQgICglMC4xZiBwZXIgc2hhcGUpCgAgIHNoYXBlcwAlLTIwcyAlOGxsZCAlOGxsZAoAYnl0ZWNvZGUgZnVuY3Rpb25zACUtMjBzICU4bGxkICU4bGxkICAoJTAuMWYgcGVyIGZ1bmN0aW9uKQoAICBieXRlY29kZQAgIHBjMmxpbmUAJS0yMHMgJThsbGQKAEMgZnVuY3Rpb25zAGFycmF5cwAgIGZhc3QgYXJyYXlzACUtMjBzICU4bGxkICU4bGxkICAoJTAuMWYgcGVyIGZhc3QgYXJyYXkpCgAgIGVsZW1lbnRzAGJpbmFyeSBvYmplY3RzAG91dCBvZiBtZW1vcnkAaW52YWxpZCAnaW5zdGFuY2VvZicgcmlnaHQgb3BlcmFuZABjYW5ub3QgcmVhZCBwcm9wZXJ0eSAnJXMnIG9mIG51bGwAAGNhbm5vdCByZWFkIHByb3BlcnR5ICclcycgb2YgdW5kZWZpbmVkAGNhbm5vdCBzZXQgcHJvcGVydHkgJyVzJyBvZiBudWxsAGNhbm5vdCBzZXQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAcC0+Y2xhc3NfaWQgPT0gSlNfQ0xBU1NfQVJSQVkASlNfU2V0UHJvcGVydHlJbnRlcm5hbABwcm9wID09IEpTX0FUT01fbGVuZ3RoAG91dC1vZi1ib3VuZCBudW1lcmljIGluZGV4AG5vdCBhbiBvYmplY3QAb2JqZWN0IGlzIG5vdCBleHRlbnNpYmxlAHBycyAhPSBOVUxMAEpTX0RlZmluZVByb3BlcnR5AHByb3BlcnR5IGlzIG5vdCBjb25maWd1cmFibGUAbm9uIGludGVnZXIgaW5kZXggaW4gdHlwZWQgYXJyYXkAbmVnYXRpdmUgaW5kZXggaW4gdHlwZWQgYXJyYXkAb3V0LW9mLWJvdW5kIGluZGV4IGluIHR5cGVkIGFycmF5AGludmFsaWQgZGVzY3JpcHRvciBmbGFncwBjb3VsZCBub3QgZGVsZXRlIHByb3BlcnR5AGludmFsaWQgYXJyYXkgaW5kZXgAJWQAW2Z1bmN0aW9uIGJ5dGVjb2RlXQBjYW5ub3QgY29udmVydCBzeW1ib2wgdG8gc3RyaW5nAFt1bnN1cHBvcnRlZCB0eXBlXQBldmFsX3R5cGUgPT0gSlNfRVZBTF9UWVBFX0dMT0JBTCB8fCBldmFsX3R5cGUgPT0gSlNfRVZBTF9UWVBFX01PRFVMRQBKU19FdmFsVGhpcwBSZWdFeHAAdW5leHBlY3RlZCBkYXRhIGF0IHRoZSBlbmQAICAgICAgICAgIAAAAIwAAABeAAAAXwAAAGAAAABhAAAAYgAAAGMAAABkAAAAZQAAAGYAAABQcm94eQBBoBsL0wHALgAAkC8AAFAwAACwMAAAADEAAFAxAAAMCwUEAgIAALIAAABnAAAAaAAAALMAAABpAAAAagAAALQAAABpAAAAagAAALUAAABAAAAAQQAAALYAAABrAAAAbAAAALcAAABrAAAAbAAAAC8AAABtAAAAbgAAALgAAABAAAAAQQAAALkAAABvAAAAcAAAAFByb21pc2UAQXN5bmNGdW5jdGlvbgBBc3luY0dlbmVyYXRvckZ1bmN0aW9uAERhdGUAT2JqZWN0AEZ1bmN0aW9uAEVycm9yAEGAHQslJlMAADBTAAA7UwAASlMAAFZTAABgUwAAaVMAAHdTAABBcnJheQBBsB0LhTFjb3B5V2l0aGluAGVudHJpZXMAZmlsbABmaW5kAGZpbmRJbmRleABmbGF0AGZsYXRNYXAAaW5jbHVkZXMAa2V5cwB2YWx1ZXMAAE51bWJlcgBCb29sZWFuAFN0cmluZwBTeW1ib2wAR2VuZXJhdG9yRnVuY3Rpb24AZXZhbAAAAAABAQICAgNBcnJheUJ1ZmZlcgBTaGFyZWRBcnJheUJ1ZmZlcgBUeXBlZEFycmF5AEJZVEVTX1BFUl9FTEVNRU5UAERhdGFWaWV3AG1yMSAhPSBOVUxMAGRlbGV0ZV93ZWFrX3JlZgBtci0+ZW1wdHkAbWFwX2RlY3JlZl9yZWNvcmQAc2YtPmN1cl9zcCAhPSBOVUxMAGFzeW5jX2Z1bmNfZnJlZQBzaXplICE9IDAAanNfZGVmX21hbGxvYwAAAG51bGwAZmFsc2UAdHJ1ZQBpZgBlbHNlAHJldHVybgB2YXIAdGhpcwBkZWxldGUAdm9pZAB0eXBlb2YAbmV3AGluAGluc3RhbmNlb2YAZG8Ad2hpbGUAZm9yAGJyZWFrAGNvbnRpbnVlAHN3aXRjaABjYXNlAGRlZmF1bHQAdGhyb3cAdHJ5AGNhdGNoAGZpbmFsbHkAZnVuY3Rpb24AZGVidWdnZXIAd2l0aABjbGFzcwBjb25zdABlbnVtAGV4cG9ydABleHRlbmRzAGltcG9ydABzdXBlcgBpbXBsZW1lbnRzAGludGVyZmFjZQBsZXQAcGFja2FnZQBwcml2YXRlAHByb3RlY3RlZABwdWJsaWMAc3RhdGljAHlpZWxkAGF3YWl0AABsZW5ndGgAZmlsZU5hbWUAbGluZU51bWJlcgBtZXNzYWdlAGVycm9ycwBzdGFjawBuYW1lAHRvU3RyaW5nAHRvTG9jYWxlU3RyaW5nAHZhbHVlT2YAZXZhbABwcm90b3R5cGUAY29uc3RydWN0b3IAY29uZmlndXJhYmxlAHdyaXRhYmxlAGVudW1lcmFibGUAdmFsdWUAZ2V0AHNldABvZgBfX3Byb3RvX18AdW5kZWZpbmVkAG51bWJlcgBib29sZWFuAHN0cmluZwBvYmplY3QAc3ltYm9sAGludGVnZXIAdW5rbm93bgBhcmd1bWVudHMAY2FsbGVlAGNhbGxlcgA8ZXZhbD4APHJldD4APHZhcj4APGFyZ192YXI+ADx3aXRoPgBsYXN0SW5kZXgAdGFyZ2V0AGluZGV4AGlucHV0AGRlZmluZVByb3BlcnRpZXMAYXBwbHkAam9pbgBjb25jYXQAc3BsaXQAY29uc3RydWN0AGdldFByb3RvdHlwZU9mAHNldFByb3RvdHlwZU9mAGlzRXh0ZW5zaWJsZQBwcmV2ZW50RXh0ZW5zaW9ucwBoYXMAZGVsZXRlUHJvcGVydHkAZGVmaW5lUHJvcGVydHkAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAG93bktleXMAYWRkAGRvbmUAbmV4dAB2YWx1ZXMAc291cmNlAGZsYWdzAGdsb2JhbAB1bmljb2RlAHJhdwBuZXcudGFyZ2V0AHRoaXMuYWN0aXZlX2Z1bmMAPGhvbWVfb2JqZWN0PgA8Y29tcHV0ZWRfZmllbGQ+ADxzdGF0aWNfY29tcHV0ZWRfZmllbGQ+ADxjbGFzc19maWVsZHNfaW5pdD4APGJyYW5kPgAjY29uc3RydWN0b3IAYXMAZnJvbQBtZXRhACpkZWZhdWx0KgAqAE1vZHVsZQB0aGVuAHJlc29sdmUAcmVqZWN0AHByb21pc2UAcHJveHkAcmV2b2tlAGFzeW5jAGV4ZWMAZ3JvdXBzAHN0YXR1cwByZWFzb24AZ2xvYmFsVGhpcwB0b0pTT04AT2JqZWN0AEFycmF5AEVycm9yAE51bWJlcgBTdHJpbmcAQm9vbGVhbgBTeW1ib2wAQXJndW1lbnRzAE1hdGgASlNPTgBEYXRlAEZ1bmN0aW9uAEdlbmVyYXRvckZ1bmN0aW9uAEZvckluSXRlcmF0b3IAUmVnRXhwAEFycmF5QnVmZmVyAFNoYXJlZEFycmF5QnVmZmVyAFVpbnQ4Q2xhbXBlZEFycmF5AEludDhBcnJheQBVaW50OEFycmF5AEludDE2QXJyYXkAVWludDE2QXJyYXkASW50MzJBcnJheQBVaW50MzJBcnJheQBGbG9hdDMyQXJyYXkARmxvYXQ2NEFycmF5AERhdGFWaWV3AE1hcABTZXQAV2Vha01hcABXZWFrU2V0AE1hcCBJdGVyYXRvcgBTZXQgSXRlcmF0b3IAQXJyYXkgSXRlcmF0b3IAU3RyaW5nIEl0ZXJhdG9yAFJlZ0V4cCBTdHJpbmcgSXRlcmF0b3IAR2VuZXJhdG9yAFByb3h5AFByb21pc2UAUHJvbWlzZVJlc29sdmVGdW5jdGlvbgBQcm9taXNlUmVqZWN0RnVuY3Rpb24AQXN5bmNGdW5jdGlvbgBBc3luY0Z1bmN0aW9uUmVzb2x2ZQBBc3luY0Z1bmN0aW9uUmVqZWN0AEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24AQXN5bmNHZW5lcmF0b3IARXZhbEVycm9yAFJhbmdlRXJyb3IAUmVmZXJlbmNlRXJyb3IAU3ludGF4RXJyb3IAVHlwZUVycm9yAFVSSUVycm9yAEludGVybmFsRXJyb3IAPGJyYW5kPgBTeW1ib2wudG9QcmltaXRpdmUAU3lt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eTogaW5jb25zaXN0ZW50IHByb3RvdHlwZQByZXZva2VkIHByb3h5AG9wZXJhbmQgJ3Byb3RvdHlwZScgcHJvcGVydHkgaXMgbm90IGFuIG9iamVjdABpbnRlcnJ1cHRlZAAlcyBpcyBub3QgaW5pdGlhbGl6ZWQAbGV4aWNhbCB2YXJpYWJsZQAAAHEAAAByAAAAcwAAAENvdWxkIG5vdCBmaW5kIGV4cG9ydCAnJXMnIGluIG1vZHVsZSAnJXMnAGNpcmN1bGFyIHJlZmVyZW5jZSB3aGVuIGxvb2tpbmcgZm9yIGV4cG9ydCAnJXMnIGluIG1vZHVsZSAnJXMnAGV4cG9ydCAnJXMnIGluIG1vZHVsZSAnJXMnIGlzIGFtYmlndW91cwAocHItPnUuaW5pdC5yZWFsbV9hbmRfaWQgJiAzKSA9PSAwAEpTX0RlZmluZUF1dG9Jbml0UHJvcGVydHkAJyVzJyBpcyBub3QgZGVmaW5lZABudW1faW5kZXggPT0gbnVtX2tleXNfY291bnQASlNfR2V0T3duUHJvcGVydHlOYW1lc0ludGVybmFsAHN0cl9pbmRleCA9PSBudW1fa2V5c19jb3VudCArIHN0cl9rZXlzX2NvdW50AHN5bV9pbmRleCA9PSBhdG9tX2NvdW50AEpTX0F0b21Jc0FycmF5SW5kZXgAYXRvbTFfaXNfaW50ZWdlciAmJiBhdG9tMl9pc19pbnRlZ2VyAG51bV9rZXlzX2NtcABqc19nZXRfYXRvbV9pbmRleABub3QgY29uZmlndXJhYmxlAG5vIHNldHRlciBmb3IgcHJvcGVydHkAJyVzJyBpcyByZWFkLW9ubHkAcC0+c2hhcGUtPmhlYWRlci5yZWZfY291bnQgPT0gMQBhZGRfcHJvcGVydHkAJWxsZABjYW5ub3QgY3JlYXRlIG51bWVyaWMgaW5kZXggaW4gdHlwZWQgYXJyYXkAdmFyX3JlZi0+aGVhZGVyLnJlZl9jb3VudCA+IDAAZnJlZV92YXJfcmVmAEpTX0F0b21Jc051bWVyaWNJbmRleDEAAG4AZgBpAG4AaQB0AHkAbmZpbml0eQAhc2gtPmlzX2hhc2hlZABjb21wYWN0X3Byb3BlcnRpZXMAbmV3X3NpemUgPD0gc2gtPnByb3Bfc2l6ZQBqID09IChzaC0+cHJvcF9jb3VudCAtIHNoLT5kZWxldGVkX3Byb3BfY291bnQpACVzIG9iamVjdCBleHBlY3RlZABjYW5ub3QgY29udmVydCBzeW1ib2wgdG8gbnVtYmVyAHRvUHJpbWl0aXZlAEluZmluaXR5AGludmFsaWQgYXJyYXkgbGVuZ3RoAE5hTgAlLipmAG4gPCBidWZfc2l6ZQBqc19mY3Z0MQAlKy4qZQBtdXN0IGJlIGNhbGxlZCB3aXRoIG5ldwBub3QgYSBmdW5jdGlvbgBkZXJpdmVkIGNsYXNzIGNvbnN0cnVjdG9yIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciB1bmRlZmluZWQAY2xhc3MgY29uc3RydWN0b3JzIG11c3QgYmUgaW52b2tlZCB3aXRoICduZXcnAHVuc3VwcG9ydGVkIHJlZmVyZW5jZSB0byAnc3VwZXInAGl0ZXJhdG9yIGRvZXMgbm90IGhhdmUgYSB0aHJvdyBtZXRob2QAaW52YWxpZCB0aHJvdyB2YXIgdHlwZSAlZAAndGhpcycgY2FuIGJlIGluaXRpYWxpemVkIG9ubHkgb25jZQBpbnZhbGlkIHJldCB2YWx1ZQBpdGVyYXRvciBtdXN0IHJldHVybiBhbiBvYmplY3QAaXRlcmF0b3JfY2xvc2VfcmV0dXJuAHZhbHVlIGhhcyBubyBwcm9wZXJ0eQBpbnZhbGlkIG9wY29kZTogcGM9JXUgb3Bjb2RlPTB4JTAyeAAADQAQAC0AMQBpbXBvcnQubWV0YSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgY29udGV4dABleHBlY3RpbmcgPGJyYW5kPiBwcml2YXRlIGZpZWxkAGludmFsaWQgYnJhbmQgb24gb2JqZWN0AHJlZGVjbGFyYXRpb24gb2YgJyVzJwA8aW5wdXQ+AG5vdCBhIG9iamVjdAB0b28gbWFueSBhcmd1bWVudHMAc3RyaW5nIGV4cGVjdGVkAG5vIGZ1bmN0aW9uIGZpbGVuYW1lIGZvciBpbXBvcnQoKQBjYW5ub3QgZGVmaW5lIHZhcmlhYmxlICclcycAdmFsdWUgaXMgbm90IGl0ZXJhYmxlACFfX0pTX0F0b21Jc1RhZ2dlZEludChkZXNjcikASlNfTmV3U3ltYm9sRnJvbUF0b20AZGVzY3IgPCBydC0+YXRvbV9zaXplAG5vdCBhIHN5bWJvbABwcml2YXRlIGNsYXNzIGZpZWxkICclcycgZG9lcyBub3QgZXhpc3QAcHJpdmF0ZSBjbGFzcyBmaWVsZCAnJXMnIGFscmVhZHkgZXhpc3RzAFsAXQBnZXQgAHNldCAAcGFyZW50IGNsYXNzIG11c3QgYmUgY29uc3RydWN0b3IAcGFyZW50IHByb3RvdHlwZSBtdXN0IGJlIGFuIG9iamVjdCBvciBudWxsAGItPmZ1bmNfa2luZCA9PSBKU19GVU5DX05PUk1BTABqc19vcF9kZWZpbmVfY2xhc3MAcmVjZWl2ZXIgaXMgbm90IGFuIG9iamVjdABzZXR0ZXIgaXMgZm9yYmlkZGVuAGludmFsaWQgaW5kZXggZm9yIGFwcGVuZABudWxsIG9yIHVuZGVmaW5lZCBhcmUgZm9yYmlkZGVuAGludmFsaWQgJ2luJyBvcGVyYW5kAG5vdCBhIGNvbnN0cnVjdG9yACAgICBhdCAlcwA6JWQAPGFub255bW91cz4AICglcwAgKG5hdGl2ZSkAZHVwbGljYXRlIGV4cG9ydGVkIG5hbWUgJyVzJwBjb3VsZCBub3QgbG9hZCBtb2R1bGUgJyVzJwAuAC4uAGJ5dGVjb2RlIGZ1bmN0aW9uIGV4cGVjdGVkAGV2YWwgaXMgbm90IHN1cHBvcnRlZABjaXJjdWxhciByZWZlcmVuY2UAZ2V0ICVzAHNldCAlcwBjYW5ub3QgY29udmVydCB0byBvYmplY3QAbm9ybWFsaXplAEHAzgAL9QEsJwAAAwAAAAAAAAB0AAAAYmFkIG5vcm1hbGl6YXRpb24gZm9ybQBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFncwAlcwBmbGFncwBzb3VyY2UAZ2xvYmFsAGlnbm9yZUNhc2UAbXVsdGlsaW5lAGRvdEFsbAB1bmljb2RlAHN0aWNreQBleGVjAGNvbXBpbGUAdGVzdAB0b1N0cmluZwBbU3ltYm9sLnJlcGxhY2VdAFtTeW1ib2wubWF0Y2hdAFtTeW1ib2wubWF0Y2hBbGxdAFtTeW1ib2wuc2VhcmNoXQBbU3ltYm9sLnNwbGl0XQBBwNAAC+ADiycAAAEBAAB1AAAAAAAAAJEnAAABAQAAdgAAAAAAAACYJwAAAQIBAHcAAAAAAAAAnycAAAECAgB3AAAAAAAAAKonAAABAgQAdwAAAAAAAAC0JwAAAQIIAHcAAAAAAAAAuycAAAECEAB3AAAAAAAAAMMnAAABAiAAdwAAAAAAAADKJwAAAwAAAAEAAAAwAAAAzycAAAMAAAACAAAAeAAAANcnAAADAAAAAQAAAHkAAADcJwAAAwAAAAAAAAB6AAAA5ScAAAMAAAACAAAAewAAAPYnAAADAAAAAQAAAHwAAAAFKAAAAwAAAAEAAAB9AAAAFygAAAMAAAABAAAAfgAAACcoAAADAAAAAgAAAH8AAAAoPzopAG91dCBvZiBtZW1vcnkgaW4gcmVnZXhwIGV4ZWN1dGlvbgBmbGFncyBtdXN0IGJlIHVuZGVmaW5lZABSZWdFeHAgZXhlYyBtZXRob2QgbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwAbm90IGEgc3RyaW5nAHkAW1N5bWJvbC5zcGVjaWVzXQDPKQAAAQEAAIAAAAAAAAAAbmV4dABbU3ltYm9sLnRvU3RyaW5nVGFnXQBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAEGw1AAL1wrwKQAAAwAAAAAMAACBAAAA9SkAAAEDAAAKKgAAAAAAAHVuZXhwZWN0ZWQgZW5kIG9mIGNvbW1lbnQAdW5leHBlY3RlZCBjaGFyYWN0ZXIAaW52YWxpZCBjaGFyYWN0ZXIgaW4gYSBKU09OIHN0cmluZwBvY3RhbCBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZQBtYWxmb3JtZWQgZXNjYXBlIHNlcXVlbmNlIGluIHN0cmluZyBsaXRlcmFsAGludmFsaWQgVVRGLTggc2VxdWVuY2UAdW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nAGV4cGVjdGluZyBwcm9wZXJ0eSBuYW1lAHVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0AHVuZXhwZWN0ZWQgdG9rZW46ICclLipzJwBleHBlY3RpbmcgJyVjJwAgAFx1JTA0eABBcnJheSBsb28gbG9uZwBKU09OAAAAAAAAAACkKwAAAwgAANArAAADAAAAcGFyc2UAc3RyaW5naWZ5AMArAAADAAAAAgAAAIIAAADGKwAAAwAAAAMAAACDAAAA9SkAAAEDAACkKwAAAAAAAHByb3h5OiBpbmNvbnNpc3RlbnQgaXNFeHRlbnNpYmxlAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJldmVudEV4dGVuc2lvbnMAcHJveHk6IGluY29uc2lzdGVudCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IAaW52YWxpZCBnZXR0ZXIAaW52YWxpZCBzZXR0ZXIAY2Fubm90IGhhdmUgc2V0dGVyL2dldHRlciBhbmQgdmFsdWUgb3Igd3JpdGFibGUAcHJveHk6IHByb3BlcnRpZXMgbXVzdCBiZSBzdHJpbmdzIG9yIHN5bWJvbHMAcHJveHk6IGR1cGxpY2F0ZSBwcm9wZXJ0eQBwcm94eTogdGFyZ2V0IHByb3BlcnR5IG11c3QgYmUgcHJlc2VudCBpbiBwcm94eSBvd25LZXlzAHByb3h5OiBwcm9wZXJ0eSBub3QgcHJlc2VudCBpbiB0YXJnZXQgd2VyZSByZXR1cm5lZCBieSBub24gZXh0ZW5zaWJsZSBwcm94eQBwcm94eTogaW5jb25zaXN0ZW50IGRlbGV0ZVByb3BlcnR5AHByb3h5OiBkZWZpbmVQcm9wZXJ0eSBleGNlcHRpb24AcHJveHk6IGluY29uc2lzdGVudCBkZWZpbmVQcm9wZXJ0eQBwcm94eTogaW5jb25zaXN0ZW50IGhhcwBwcm94eTogaW5jb25zaXN0ZW50IGdldABwcm94eTogaW5jb25zaXN0ZW50IHNldABwcm94eTogY2Fubm90IHNldCBwcm9wZXJ0eQByZXZvY2FibGUAVi4AAAMAAAACAAAAhAAAAHNldABnZXQAaGFzAGRlbGV0ZQBjbGVhcgBzaXplAGZvckVhY2gAdmFsdWVzAGtleXMAZW50cmllcwBbU3ltYm9sLml0ZXJhdG9yXQBNYXAAcC4AAAMAAAACAQAAhQAAAHQuAAADAAAAAQEAAIYAAAB4LgAAAwAAAAEBAACHAAAAfC4AAAMAAAABAQAAiAAAAIMuAAADAAAAAAEAAIkAAACJLgAAAQIAAIoAAAAAAAAAji4AAAMAAAABAQAAiwAAAJYuAAADAAQAAAEAAIwAAACdLgAAAwAAAAABAACMAAAAoi4AAAMACAAAAQAAjAAAAKouAAADCQAAoi4AAP/////1KQAAAQMAALwuAAAAAAAAYWRkAFNldABBkN8AC7cBgC8AAAMAAQABAQAAhQAAAHguAAADAAEAAQEAAIcAAAB8LgAAAwABAAEBAACIAAAAgy4AAAMAAQAAAQAAiQAAAIkuAAABAgEAigAAAAAAAACOLgAAAwABAAEBAACLAAAAli4AAAMAAQAAAQAAjAAAAJ0uAAADCQAAli4AAP////+qLgAAAwkAAJYuAAD/////oi4AAAMACQAAAQAAjAAAAPUpAAABAwAAhC8AAAAAAABXZWFrTWFwAEHQ4AALV3AuAAADAAIAAgEAAIUAAAB0LgAAAwACAAEBAACGAAAAeC4AAAMAAgABAQAAhwAAAHwuAAADAAIAAQEAAIgAAAD1KQAAAQMAAEAwAAAAAAAAV2Vha1NldABBsOEAC4IDgC8AAAMAAwABAQAAhQAAAHguAAADAAMAAQEAAIcAAAB8LgAAAwADAAEBAACIAAAA9SkAAAEDAACgMAAAAAAAAE1hcCBJdGVyYXRvcgAAAADwKQAAAwAAAAAMAACNAAAA9SkAAAEDAADwMAAAAAAAAHMgIT0gTlVMTABqc19tYXBfaXRlcmF0b3JfbmV4dABTZXQgSXRlcmF0b3IAAAAAAPApAAADAAEAAAwAAI0AAAD1KQAAAQMAAD8xAAAAAAAAc2V0L2FkZCBpcyBub3QgYSBmdW5jdGlvbgAAAAAAAADPKQAAAQEAAIAAAAAAAAAAcmVzb2x2aW5nIGZ1bmN0aW9uIGFscmVhZHkgc2V0AHByb21pc2Ugc2VsZiByZXNvbHV0aW9uAGFyZ2MgPT0gNQBwcm9taXNlX3JlYWN0aW9uX2pvYgBhcmdjID09IDMAanNfcHJvbWlzZV9yZXNvbHZlX3RoZW5hYmxlX2pvYgB0aGVuAGNhdGNoAGZpbmFsbHkAQcDkAAtmIDIAAAMAAAACAAAAjgAAACUyAAADAAAAAQAAAI8AAAArMgAAAwAAAAEAAACQAAAA9SkAAAEDAAAsDgAAAAAAAHJlc29sdmUAcmVqZWN0AGFsbABhbGxTZXR0bGVkAGFueQByYWNlAEGw5QAL1gGAMgAAAwAAAAEBAACRAAAAiDIAAAMAAQABAQAAkQAAAI8yAAADAAAAAQEAAJIAAACTMgAAAwABAAEBAACSAAAAnjIAAAMAAgABAQAAkgAAAKIyAAADAAAAAQAAAJMAAADPKQAAAQEAAIAAAAAAAAAAcmVqZWN0ZWQAZnVsZmlsbGVkAGFzeW5jIABmdW5jdGlvbgAgYW5vbnltb3VzKAAKKSB7CgAKfSkAAAAAAAAAAPUpAAABAwAANA4AAAAAAABbU3ltYm9sLmFzeW5jSXRlcmF0b3JdAEGQ5wALkwhwMwAAAwAAAAAAAACUAAAAcmV0dXJuAHRocm93AAAAAPApAAADAAAAAQEAAJUAAACgMwAAAwABAAEBAACVAAAApzMAAAMAAgABAQAAlQAAAG5vdCBhbiBBc3luYy1mcm9tLVN5bmMgSXRlcmF0b3IAQXN5bmNHZW5lcmF0b3IAAPApAAADAAAAAQEAAJYAAACgMwAAAwABAAEBAACWAAAApzMAAAMAAgABAQAAlgAAAPUpAAABAwAAADQAAAAAAABub3QgYW4gQXN5bmNHZW5lcmF0b3Igb2JqZWN0AEpTX0lzVW5kZWZpbmVkKGZ1bmNfcmV0KQBqc19hc3luY19nZW5lcmF0b3JfcmVzdW1lX25leHQAcy0+c3RhdGUgPT0gSlNfQVNZTkNfR0VORVJBVE9SX1NUQVRFX0FXQUlUSU5HX1JFVFVSTiB8fCBzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfQ09NUExFVEVEAGpzX2FzeW5jX2dlbmVyYXRvcl9yZXNvbHZlX2Z1bmN0aW9uAHMtPnN0YXRlID09IEpTX0FTWU5DX0dFTkVSQVRPUl9TVEFURV9FWEVDVVRJTkcAAPUpAAABAwAAQg4AAAAAAAB2YWx1ZU9mAFtTeW1ib2wudG9QcmltaXRpdmVdAHRvVVRDU3RyaW5nAHRvR01UU3RyaW5nAHRvSVNPU3RyaW5nAHRvRGF0ZVN0cmluZwB0b1RpbWVTdHJpbmcAdG9Mb2NhbGVTdHJpbmcAdG9Mb2NhbGVEYXRlU3RyaW5nAHRvTG9jYWxlVGltZVN0cmluZwBnZXRUaW1lem9uZU9mZnNldABnZXRUaW1lAGdldFllYXIAZ2V0RnVsbFllYXIAZ2V0VVRDRnVsbFllYXIAZ2V0TW9udGgAZ2V0VVRDTW9udGgAZ2V0RGF0ZQBnZXRVVENEYXRlAGdldEhvdXJzAGdldFVUQ0hvdXJzAGdldE1pbnV0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b2JhbCBpZGVudGlmaWVyIGluIG1vZHVsZSBjb2RlAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIGdsb2JhbCBpZGVudGlmaWVyAG1pc3NpbmcgZm9ybWFsIHBhcmFtZXRlcgBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIGdldHRlciBvciBzZXR0ZXIAJyVzJyBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAaW52YWxpZCByZWRlZmluaXRpb24gb2YgbGV4aWNhbCBpZGVudGlmaWVyAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIHBhcmFtZXRlciBuYW1lAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIGEgdmFyaWFibGUAdW5leHBlY3RlZCBlbmQgb2YgcmVnZXhwAHVuZXhwZWN0ZWQgbGluZSB0ZXJtaW5hdG9yIGluIHJlZ2V4cAB1bmV4cGVjdGVkIGVsbGlwc2lzIHRva2VuAGFzc2lnbm1lbnQgcmVzdCBwcm9wZXJ0eSBtdXN0IGJlIGxhc3QAaW52YWxpZCBkZXN0cnVjdHVyaW5nIHRhcmdldABtaXNzaW5nIGJpbmRpbmcgcGF0dGVybi4uLgByZXN0IGVsZW1lbnQgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlAHJlc3QgZWxlbWVudCBtdXN0IGJlIHRoZSBsYXN0IG9uZQBpbnZhbGlkIGFzc2lnbm1lbnQgc3ludGF4AHRvbyBjb21wbGljYXRlZCBkZXN0cnVjdHVyaW5nIGV4cHJlc3Npb24AUmVnRXhwIGFyZSBub3Qgc3VwcG9ydGVkACdhcmd1bWVudHMnIGlkZW50aWZpZXIgaXMgbm90IGFsbG93ZWQgaW4gY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXIAZXhwZWN0aW5nIHRhcmdldABuZXcudGFyZ2V0IG9ubHkgYWxsb3dlZCB3aXRoaW4gZnVuY3Rpb25zAHN1cGVyKCkgaXMgb25seSB2YWxpZCBpbiBhIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IAJ3N1cGVyJyBpcyBvbmx5IHZhbGlkIGluIGEgbWV0aG9kAGludmFsaWQgdXNlIG9mICdzdXBlcicAbWV0YSBleHBlY3RlZABpbXBvcnQubWV0YSBvbmx5IHZhbGlkIGluIG1vZHVsZSBjb2RlAGludmFsaWQgdXNlIG9mICdpbXBvcnQoKScAdW5leHBlY3RlZCB0b2tlbiBpbiBleHByZXNzaW9uOiAnJS4qcycAdGVtcGxhdGUgbGl0ZXJhbCBjYW5ub3QgYXBwZWFyIGluIGFuIG9wdGlvbmFsIGNoYWluAFRvbyBtYW55IGNhbGwgYXJndW1lbnRzAHByaXZhdGUgY2xhc3MgZmllbGQgZm9yYmlkZGVuIGFmdGVyIHN1cGVyAGV4cGVjdGluZyBmaWVsZCBuYW1lAGV4cGVjdGVkICd9JyBhZnRlciB0ZW1wbGF0ZSBleHByZXNzaW9uAGNsYXNzIHN0YXRlbWVudCByZXF1aXJlcyBhIG5hbWUAaW52YWxpZCBtZXRob2QgbmFtZQBpbnZhbGlkIGZpZWxkIG5hbWUAcHJvcGVydHkgY29uc3RydWN0b3IgYXBwZWFycyBtb3JlIHRoYW4gb25jZQBwcml2YXRlIGNsYXNzIGZpZWxkIGlzIGFscmVhZHkgZGVmaW5lZAA8c2V0PgBmZC0+Ynl0ZV9jb2RlLmJ1ZltkZWZpbmVfY2xhc3NfcG9zXSA9PSBPUF9kZWZpbmVfY2xhc3MAc2V0X29iamVjdF9uYW1lX2NvbXB1dGVkACgpe3N1cGVyKC4uLmFyZ3VtZW50cyk7fQAoKXt9AGR1cGxpY2F0ZSBfX3Byb3RvX18gcHJvcGVydHkgbmFtZQB1bmV4cGVjdGVkICd5aWVsZCcga2V5d29yZAB5aWVsZCBpbiBkZWZhdWx0IGV4cHJlc3Npb24AmpucnZ6goaKtrq+fY2Fubm90IG1peCA/PyB3aXRoICYmIG9yIHx8AHVuZXhwZWN0ZWQgJ2F3YWl0JyBrZXl3b3JkAGF3YWl0IGluIGRlZmF1bHQgZXhwcmVzc2lvbgB1bnBhcmVudGhlc2l6ZWQgdW5hcnkgZXhwcmVzc2lvbiBjYW4ndCBhcHBlYXIgb24gdGhlIGxlZnQtaGFuZCBzaWRlIG9mICcqKicAY2Fubm90IGRlbGV0ZSBhIGRpcmVjdCByZWZlcmVuY2UgaW4gc3RyaWN0IG1vZGUAY2Fubm90IGRlbGV0ZSBhIHByaXZhdGUgY2xhc3MgZmllbGQAaW52YWxpZCBsdmFsdWUgaW4gc3RyaWN0IG1vZGUAaW52YWxpZCBmb3IgaW4vb2YgbGVmdCBoYW5kLXNpZGUAaW52YWxpZCBpbmNyZW1lbnQvZGVjcmVtZW50IG9wZXJhbmQAaW52YWxpZCBhc3NpZ25tZW50IGxlZnQtaGFuZCBzaWRlAGxhYmVsID49IDAgJiYgbGFiZWwgPCBzLT5sYWJlbF9jb3VudAB1cGRhdGVfbGFiZWwAbHMtPnJlZl9jb3VudCA+PSAwAGludmFsaWQgcHJvcGVydHkgbmFtZQBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzIG5vdCBhbGxvd2VkIGluIHRoaXMgY29udGV4dAB5aWVsZCBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAaW52YWxpZCB2YXJpYWJsZSBuYW1lIGluIHN0cmljdCBtb2RlAGludmFsaWQgbGV4aWNhbCB2YXJpYWJsZSBuYW1lAHNwZWNpYWwgPT0gUFVUX0xWQUxVRV9OT0tFRVAgfHwgc3BlY2lhbCA9PSBQVVRfTFZBTFVFX05PS0VFUF9ERVBUSABwdXRfbHZhbHVlAHNldF9vYmplY3RfbmFtZQAidXNlIHN0cmljdCIgbm90IGFsbG93ZWQgaW4gZnVuY3Rpb24gd2l0aCBkZWZhdWx0IG9yIGRlc3RydWN0dXJpbmcgcGFyYW1ldGVyAGludmFsaWQgZnVuY3Rpb24gbmFtZSBpbiBzdHJpY3QgY29kZQBpbnZhbGlkIGFyZ3VtZW50IG5hbWUgaW4gc3RyaWN0IGNvZGUAZHVwbGljYXRlIGFyZ3VtZW50IG5hbWVzIG5vdCBhbGxvd2VkIGluIHRoaXMgY29udGV4dABpZGVudGlmaWVyIGV4cGVjdGVkAGludmFsaWQgZXhwb3J0IHN5bnRheABmcm9tIGNsYXVzZSBleHBlY3RlZAAnbGV0JyBpcyBub3QgYSB2YWxpZCBsZXhpY2FsIGlkZW50aWZpZXIAbWlzc2luZyBpbml0aWFsaXplciBmb3IgY29uc3QgdmFyaWFibGUAdmFyaWFibGUgbmFtZSBleHBlY3RlZABleHBlY3RpbmcgJ2FzJwBpbnZhbGlkIGltcG9ydCBiaW5kaW5nAGR1cGxpY2F0ZSBpbXBvcnQgYmluZGluZwB0b28gbWFueSBjbG9zdXJlIHZhcmlhYmxlcwBkdXBsaWNhdGUgbGFiZWwgbmFtZQByZXR1cm4gbm90IGluIGEgZnVuY3Rpb24AbGluZSB0ZXJtaW5hdG9yIG5vdCBhbGxvd2VkIGFmdGVyIHRocm93AGxleGljYWwgZGVjbGFyYXRpb25zIGNhbid0IGFwcGVhciBpbiBzaW5nbGUtc3RhdGVtZW50IGNvbnRleHQAZm9yIGF3YWl0IGlzIG9ubHkgdmFsaWQgaW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9ucwBkdXBsaWNhdGUgZGVmYXVsdABpbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQAZXhwZWN0aW5nIGNhdGNoIG9yIGZpbmFsbHkAaW52YWxpZCBrZXl3b3JkOiB3aXRoAGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBjYW4ndCBhcHBlYXIgaW4gc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0AGNsYXNzIGRlY2xhcmF0aW9ucyBjYW4ndCBhcHBlYXIgaW4gc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0ACdmb3IgYXdhaXQnIGxvb3Agc2hvdWxkIGJlIHVzZWQgd2l0aCAnb2YnAGEgZGVjbGFyYXRpb24gaW4gdGhlIGhlYWQgb2YgYSBmb3ItJXMgbG9vcCBjYW4ndCBoYXZlIGFuIGluaXRpYWxpemVyAG9mAGluAGV4cGVjdGVkICdvZicgb3IgJ2luJyBpbiBmb3IgY29udHJvbCBleHByZXNzaW9uAGNvbnRpbnVlIG11c3QgYmUgaW5zaWRlIGxvb3AAYnJlYWsgbXVzdCBiZSBpbnNpZGUgbG9vcCBvciBzd2l0Y2gAYnJlYWsvY29udGludWUgbGFiZWwgbm90IGZvdW5kAHVuc3VwcG9ydGVkIGtleXdvcmQ6ICVzAGNwb29sX2lkeCA+PSAwAGpzX2NyZWF0ZV9mdW5jdGlvbgBzLT5pc19ldmFsIHx8IHMtPmNsb3N1cmVfdmFyX2NvdW50ID09IDAAYWRkX2V2YWxfdmFyaWFibGVzAGV4cG9ydGVkIHZhcmlhYmxlICclcycgZG9lcyBub3QgZXhpc3QAcmVzb2x2ZV92YXJpYWJsZXMAbGFiMSA+PSAwICYmIGxhYjEgPCBzLT5sYWJlbF9jb3VudABiY19idWZbcG9zXSA9PSBPUF9sYWJlbABvcHRpbWl6ZV9zY29wZV9tYWtlX3JlZgBvcHRpbWl6ZV9zY29wZV9tYWtlX2dsb2JhbF9yZWYAdmFyX2tpbmQgIT0gSlNfVkFSX05PUk1BTAByZXNvbHZlX3Njb3BlX3ByaXZhdGVfZmllbGQAdmFyX2tpbmQgPT0gSlNfVkFSX1BSSVZBVEVfU0VUVEVSAHVuZGVmaW5lZCBwcml2YXRlIGZpZWxkICclcycAcy0+bGFiZWxfc2xvdHNbbGFiZWxdLmZpcnN0X3JlbG9jID09IE5VTEwAc2tpcF9kZWFkX2NvZGUAcmVzb2x2ZV9sYWJlbHMAbHMtPmFkZHIgPT0gLTEAZGlmZiA9PSAoaW50MTZfdClkaWZmAGRpZmYgPT0gKGludDhfdClkaWZmAGxhYmVsX3Nsb3RzW2ldLmZpcnN0X3JlbG9jID09IE5VTEwAZmluZF9qdW1wX3RhcmdldABpbnZhbGlkIG9wY29kZSAob3A9JWQsIHBjPSVkKQBieXRlY29kZSBidWZmZXIgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgdW5kZXJmbG93IChvcD0lZCwgcGM9JWQpAHN0YWNrIG92ZXJmbG93IChvcD0lZCwgcGM9JWQpAHVuY29uc2lzdGVudCBzdGFjayBzaXplOiAlZCAlZCAocGM9JWQpAG5hbWUAbWVzc2FnZQAAAADcJwAAAwAAAAAAAACjAAAA0E0AAAMDAABuDgAAAAAAANVNAAADAwAAvgoAAAAAAAA6IABpbnZhbGlkIHByb3BlcnR5IGFjY2VzcwBwcm94eSBwcmV2ZW50RXh0ZW5zaW9ucyBoYW5kbGVyIHJldHVybmVkIGZhbHNlAGNyZWF0ZQBnZXRQcm90b3R5cGVPZgBzZXRQcm90b3R5cGVPZgBkZWZpbmVQcm9wZXJ0eQBkZWZpbmVQcm9wZXJ0aWVzAGdldE93blByb3BlcnR5TmFtZXMAZ2V0T3duUHJvcGVydHlTeW1ib2xzAGlzRXh0ZW5zaWJsZQBwcmV2ZW50RXh0ZW5zaW9ucwBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycwBpcwBhc3NpZ24Ac2VhbABmcmVlemUAaXNT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AQAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAQAAAAEAAAABAAAAAQAAAAFAAAABQAAAAAAAAAKAAkADgAgACEAoAChAIAWgRYAIAsgKCAqIC8gMCBfIGAgADABMP/+AP8AQdTfAQuRBBAAAAD+//+H/v//BwAAAAAQAP8D/v//h/7//wdleHRyYW5lb3VzIGNoYXJhY3RlcnMgYXQgdGhlIGVuZAB0b28gbWFueSBpbWJyaWNhdGVkIHF1YW50aWZpZXJzAHN0YWNrIG92ZXJmbG93AHN5bnRheCBlcnJvcgBub3RoaW5nIHRvIHJlcGVhdABpbnZhbGlkIGdyb3VwIG5hbWUAZHVwbGljYXRlIGdyb3VwIG5hbWUAaW52YWxpZCBncm91cAB0b28gbWFueSBjYXB0dXJlcwBleHBlY3RpbmcgZ3JvdXAgbmFtZQBncm91cCBuYW1lIG5vdCBkZWZpbmVkAGludmFsaWQgZGVjaW1hbCBlc2NhcGUgaW4gcmVndWxhciBleHByZXNzaW9uAGJhY2sgcmVmZXJlbmNlIG91dCBvZiByYW5nZSBpbiByZWd1bGFyIGV4cHJlc3Npb24AaW52YWxpZCByZXBldGl0aW9uIGNvdW50AGV4cGVjdGluZyAnJWMnAGludmFsaWQgY2xhc3MgcmFuZ2UAXiRcLiorPygpW117fXwvAGludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgB1bmV4cGVjdGVkIGVuZABtYWxmb3JtZWQgdW5pY29kZSBjaGFyAAAA4HEAAKBvAADwcQAAAQAwADoAQfDjAQvFAwQAMAA6AEEAWwBfAGAAYQB7AGV4cGVjdGluZyAneycgYWZ0ZXIgXHAAdW5rbm93biB1bmljb2RlIHByb3BlcnR5IHZhbHVlAGV4cGVjdGluZyAnfScAU2NyaXB0AHNjAFNjcmlwdF9FeHRlbnNpb25zAHVua25vd24gdW5pY29kZSBzY3JpcHQAR2VuZXJhbF9DYXRlZ29yeQBnYwB1bmtub3duIHVuaWNvZGUgZ2VuZXJhbCBjYXRlZ29yeQB1bmtub3duIHVuaWNvZGUgcHJvcGVydHkgbmFtZQB0b28gbWFueSByYW5nZXMAAAAAAAEDBQEBAQEFBQUBAgIDBQUBAQECAgMDBQUBBQERb3V0IG9mIG1lbW9yeQBvcGNvZGUgPCBSRU9QX0NPVU5UAC90bXAvcXVpY2tqcy9saWJyZWdleHAuYwBjb21wdXRlX3N0YWNrX3NpemUAKHBvcyArIGxlbikgPD0gYmNfYnVmX2xlbgBzdGFja19zaXplID4gMAB2YWwgPCBzLT5jYXB0dXJlX2NvdW50AGxyZV9leGVjX2JhY2t0cmFjawB2YWwyIDwgcy0+Y2FwdHVyZV9jb3VudABBwOcBC6QLMJogAACaMABzgVoAMBdgADAHbACzgW8AABdwAAAHfAAAgX8AQDCAAMMBmACQgZgAQAaZAECQnAC0gaQAQC6lADABvABAhrwAcIG/AAABwAAwgcAAQATBADABwwBAgsMAMILEAECCxQAwAccAMIHHADAByABAgsgAMIHJADABygAAgcoAMAHLADCBywBAAswAAAHNADABzgAwgc4AAAHPADCBzwBABtAAMAHTAECC0wAwgdQAQALWADAB1wBAgtcAMILYAECE2QAwgdsAQALcAEAC3gAAgd8AUAPiAFCD4wBQA+UAQJDmAACB7gBAEu8AtAH4AFCD+ABAAvoAMAH7ADCB+wBAKPwAMAEQAUASEQExAR0BQIIdATCBHgExAR8BAYIfAUCCIAEwgSEBMAEiATCBIgFACiMBAQEoAQGBKAEBASkBAIEpAQABKgEAAisBAIEsAQCBLQEBAS4BAAEwAQGBMAEAgTEBAYEyAQEBMwEAATQBAIE0AQEBNQEBgTUBAQE2AQCBNwEBgTgBAAE5AQCBOgEBgT4BAAFAAQEBQQEAgUEBAYFDAQABRAEAgUQBAAJFAQABRgEAAUkBAYFOAQEBTwFzgaIBQAS4AUACuwEAg70BMIG/ATABwwEwA8QBMAHGATACxwHQAcgBMJHIATCJ0QEAAdYBAIPWAdMB2AEAkdgBcwHhAQCJ4QEAAeYBAILmATCB5wFzAegBc4HoAXOB6gFzAesBAIHrAUAY7AFzAfgBc4H4AQAB+QEAgfkBoAH6AXOB+gFAgvsBMIH8AUAC/QEwg/4BMBAAAjAgCAIAIBgCABAoAkAiMAJANkUC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LFp5eXkAQ29wdGljLENvcHQsUWFhYwBDdW5laWZvcm0sWHN1eABDeXByaW90LENwcnQAQ3lyaWxsaWMsQ3lybABEZXNlcmV0LERzcnQARGV2YW5hZ2FyaSxEZXZhAERpdmVzX0FrdXJ1LERpYWsARG9ncmEsRG9ncgBEdXBsb3lhbixEdXBsAEVneXB0aWFuX0hpZXJvZ2x5cGhzLEVneXAARWxiYXNhbixFbGJhAEVseW1haWMsRWx5bQBFdGhpb3BpYyxFdGhpAEdlb3JnaWFuLEdlb3IAR2xhZ29saXRpYyxHbGFnAEdvdGhpYyxHb3RoAEdyYW50aGEsR3JhbgBHcmVlayxHcmVrAEd1amFyYXRpLEd1anIAR3VuamFsYV9Hb25kaSxHb25nAEd1cm11a2hpLEd1cnUASGFuLEhhbmkASGFuZ3VsLEhhbmcASGFuaWZpX1JvaGluZ3lhLFJvaGcASGFudW5vbyxIYW5vAEhhdHJhbixIYXRyAEhlYnJldyxIZWJyAEhpcmFnYW5hLEhpcmEASW1wZXJpYWxfQXJhbWFpYyxBcm1pAEluaGVyaXRlZCxaaW5oLFFhYWkASW5zY3JpcHRpb25hbF9QYWhsYXZpLFBobGkASW5zY3JpcHRpb25hbF9QYXJ0aGlhbixQcnRpAEphdmFuZXNlLEphdmEAS2FpdGhpLEt0aGkAS2FubmFkYSxLbmRhAEthdGFrYW5hLEthbmEAS2F5YWhfTGksS2FsaQBLaGFyb3NodGhpLEtoYXIAS2htZXIsS2htcgBLaG9qa2ksS2hvagBLaGl0YW5fU21hbGxfU2NyaXB0LEtpdHMAS2h1ZGF3YWRpLFNpbmQATGFvLExhb28ATGF0aW4sTGF0bgBMZXBjaGEsTGVwYwBMaW1idSxMaW1iAExpbmVhcl9BLExpbmEATGluZWFyX0IsTGluYgBMaXN1LExpc3UATHljaWFuLEx5Y2kATHlkaWFuLEx5ZGkATWFrYXNhcixNYWthAE1haGFqYW5pLE1haGoATWFsYXlhbGFtLE1seW0ATWFuZGFpYyxNYW5kAE1hbmljaGFlYW4sTWFuaQBNYXJjaGVuLE1hcmMATWFzYXJhbV9Hb25kaSxHb25tAE1lZGVmYWlkcmluLE1lZGYATWVldGVpX01heWVrLE10ZWkATWVuZGVfS2lrYWt1aSxNZW5kAE1lcm9pdGljX0N1cnNpdmUsTWVyYwBNZXJvaXRpY19IaWVyb2dseXBocyxNZXJvAE1pYW8sUGxyZABNb2RpLE1vZGkATW9uZ29saWFuLE1vbmcATXJvLE1yb28ATXVsdGFuaSxNdWx0AE15YW5tYXIsTXltcgBOYWJhdGFlYW4sTmJhdABOYW5kaW5hZ2FyaSxOYW5kAE5ld19UYWlfTHVlLFRhbHUATmV3YSxOZXdhAE5rbyxOa29vAE51c2h1LE5zaHUATnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyxIbW5wAE9naGFtLE9nYW0AT2xfQ2hpa2ksT2xjawBPbGRfSHVuZ2FyaWFuLEh1bmcAT2xkX0l0YWxpYyxJdGFsAE9sZF9Ob3J0aF9BcmFiaWFuLE5hcmIAT2xkX1Blcm1pYyxQZXJtAE9sZF9QZXJzaWFuLFhwZW8AT2xkX1NvZ2RpYW4sU29nbwBPbGRfU291dGhfQXJhYmlhbixTYXJiAE9sZF9UdXJraWMsT3JraABPcml5YSxPcnlhAE9zYWdlLE9zZ2UAT3NtYW55YSxPc21hAFBhaGF3aF9IbW9uZyxIbW5nAFBhbG15cmVuZSxQYWxtAFBhdV9DaW5fSGF1LFBhdWMAUGhhZ3NfUGEsUGhhZwBQaG9lbmljaWFuLFBobngAUHNhbHRlcl9QYWhsYXZpLFBobHAAUmVqYW5nLFJqbmcAUnVuaWMsUnVucgBTYW1hcml0YW4sU2FtcgBTYXVyYXNodHJhLFNhdXIAU2hhcmFkYSxTaHJkAFNoYXZpYW4sU2hhdwBTaWRkaGFtLFNpZGQAU2lnbldyaXRpbmcsU2dudwBTaW5oYWxhLFNpbmgAU29nZGlhbixTb2dkAFNvcmFfU29tcGVuZyxTb3JhAFNveW9tYm8sU295bwBTdW5kYW5lc2UsU3VuZABTeWxvdGlfTmFncmksU3lsbwBTeXJpYWMsU3lyYwBUYWdhbG9nLFRnbGcAVGFnYmFud2EsVGFnYgBUYWlfTGUsVGFsZQBUYWlfVGhhbSxMYW5hAFRhaV9WaWV0LFRhdnQAVGFrcmksVGFrcgBUYW1pbCxUYW1sAFRhbmd1dCxUYW5nAFRlbHVndSxUZWx1AFRoYWFuYSxUaGFhAFRoYWksVGhhaQBUaWJldGFu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dHRlcgBMdCxUaXRsZWNhc2VfTGV0dGVyAExtLE1vZGlmaWVyX0xldHRlcgBMbyxPdGhlcl9MZXR0ZXIATW4sTm9uc3BhY2luZ19NYXJrAE1jLFNwYWNpbmdfTWFyawBNZSxFbmNsb3NpbmdfTWFyawBOZCxEZWNpbWFsX051bWJlcixkaWdpdABObCxMZXR0ZXJfTnVtYmVyAE5vLE90aGVyX051bWJlcgBTbSxNYXRoX1N5bWJvbABTYyxDdXJyZW5jeV9TeW1ib2wAU2ssTW9kaWZpZXJfU3ltYm9sAFNvLE90aGVyX1N5bWJvbABQYyxDb25uZWN0b3JfUHVuY3R1YXRpb24AUGQsRGFzaF9QdW5jdHVhdGlvbgBQcyxPcGVuX1B1bmN0dWF0aW9uAFBlLENsb3NlX1B1bmN0dWF0aW9uAFBpLEluaXRpYWxfUHVuY3R1YXRpb24AUGYsRmluYWxfUHVuY3R1YXRpb24AUG8sT3RoZXJfUHVuY3R1YXRpb24AWnMsU3BhY2VfU2VwYXJhdG9yAFpsLExpbmVfU2VwYXJhdG9yAFpwLFBhcmFncmFwaF9TZXBhcmF0b3IAQ2MsQ29udHJvbCxjbnRybABDZixGb3JtYXQAQ3MsU3Vycm9nYXRlAENvLFByaXZhdGVfVXNlAExDLENhc2VkX0xldHRlcgBMLExldHRlcgBNLE1hcmssQ29tYmluaW5nX01hcmsATixOdW1iZXIAUyxTeW1ib2wAUCxQdW5jdHVhdGlvbixwdW5jdABaLFNlcGFyYXRvcgBDLE90aGVyAEGAvwILsAgOAAAAPgAAAMABAAAADgAAAPAAAAAAfwAAAIADAQAAPEFTQ0lJX0hleF9EaWdpdCxBSGV4AEJpZGlfQ29udHJvbCxCaWRpX0MARGFzaABEZXByZWNhdGVkLERlcABEaWFjcml0aWMsRGlhAEV4dGVuZGVyLEV4dABIZXhfRGlnaXQsSGV4AElEU19CaW5hcnlfT3BlcmF0b3IsSURTQgBJRFNfVHJpbmFyeV9PcGVyYXRvcixJRFNUAElkZW9ncmFwaGljLElkZW8ASm9pbl9Db250cm9sLEpvaW5fQwBMb2dpY2FsX09yZGVyX0V4Y2VwdGlvbixMT0UATm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQsTkNoYXIAUGF0dGVybl9TeW50YXgsUGF0X1N5bgBQYXR0ZXJuX1doaXRlX1NwYWNlLFBhdF9XUwBRdW90YXRpb25fTWFyayxRTWFyawBSYWRpY2FsAFJlZ2lvbmFsX0luZGljYXRvcixSSQBTZW50ZW5jZV9UZXJtaW5hbCxTVGVybQBTb2Z0X0RvdHRlZCxTRABUZXJtaW5hbF9QdW5jdHVhdGlvbixUZXJtAFVuaWZpZWRfSWRlb2dyYXBoLFVJZGVvAFZhcmlhdGlvbl9TZWxlY3RvcixWUwBXaGl0ZV9TcGFjZSxzcGFjZQBCaWRpX01pcnJvcmVkLEJpZGlfTQBFbW9qaQBFbW9qaV9Db21wb25lbnQsRUNvbXAARW1vamlfTW9kaWZpZXIsRU1vZABFbW9qaV9Nb2RpZmllcl9CYXNlLEVCYXNlAEVtb2ppX1ByZXNlbnRhdGlvbixFUHJlcwBFeHRlbmRlZF9QaWN0b2dyYXBoaWMsRXh0UGljdABEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50LERJAElEX1N0YXJ0LElEUwBDYXNlX0lnbm9yYWJsZSxDSQBBU0NJSQBBbHBoYWJldGljLEFscGhhAEFueQBBc3NpZ25lZABDYXNlZABDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCxDV0NGAENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkLENXQ00AQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQsQ1dMAENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQsQ1dLQ0YAQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQsQ1dUAENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkLENXVQBHcmFwaGVtZV9CYXNlLEdyX0Jhc2UAR3JhcGhlbWVfRXh0ZW5kLEdyX0V4dABJRF9Db250aW51ZSxJREMATG93ZXJjYXNlLExvd2VyAE1hdGgAVXBwZXJjYXNlLFVwcGVyAFhJRF9Db250aW51ZSxYSURDAFhJRF9TdGFydCxYSURTAEHAxwILtCCBACgAlwAqAIGAKgCXwCsAFYEsAJcALQCBQC0AlwAuABVBLgCZAS8AFiAwAEIIQABCikQAQgRKAJYATAAXgUwAQgJNAEJDTgAvwU8AQsNQAL9AUgBCA1MAQglVAEIIWgCWAF4AQkNe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ANEA1wDdAOAA5gD4AAgBCgFzABABEgEUASABLAFEAU0BUwFiAWgBagF2AZIBlAGpAbsBxwHRAdUBuQLXATsA2QHbAbcA4QH8AQwCGAIdAiMCJwKjAzMCPwJCAksCTgJRAl0CYAJpAmwCbwJ1AngCgQKKApwCnwKjAq8CuQLFAskCzQLRAtUC5wLtAvEC9QL5Av0CBQMJAw0DEwMXAxsDIwMnAysDLwM1Az0DQQNJA00DUQMLD1cDWwNfA2MDZwNrA28DcwN5A30DgQOFA4kDjQORA5UDmQOdA6ED3BClA8kDzQPZA90D4QPvA/EDPQRPBJkE8AQCBUoFZAVsBXAFcwWaBfoF/gUHBgsGFAYYBh4GIgYoBo4GlAaYBp4GogarBqwD8watA/YGrgP5Bq8D/AbMA/8GzQMCB84DBQcJBw0HEQeGAzIHNQe5AzcHOweIA1MHiQNWB5ADaweKA3cHsAOJB44DmQefB6MHjAO4B48Duwe0AL4HwAfCBxAgywcuAM0HzwcgANIH1gfbB98H5AfqB/AHIAD2BxIiAQgFCAcIHQglCCcIQwAtCDAIkAE2CDkITgBFCEcITAhOCFEIWgCpA1oAUwhXCGAIaQBiCGUIbwh0CHoIfgiiCEkApAimCKkIVgCrCK0IsAi0CFgAtgi4CLsIwAjCCMUIdgDHCMkIzAjQCHgA0gjUCNcI2wjeCOQI5wjwCPMI9gj5CAIJBgkLCQ8JFAkXCRoJIwksCTsJPglBCUQJRwlKCVYJXAlgCWIJZAloCWoJcAl4CXwJgAmGCYkJjwmRCTAAkwmZCZwJngmhCaQJYS3Na5+fpgmxCbwJxwmVCqEKFQsgACcLMQuNC6ELpQupC60LsQu1C7kLvQvBC8ULIQw1DDkMPQxBDEUMSQxNDFEMVQxZDG8McQxzDKAMvAzcDOQM7Az0DPwMBA0MDRQNIg0uDXoNgg2FDYkNjQ2dDbENtQ28DcINxg0oDiwOMA4yDjYOPA4+DkEOQw5GDncOew6JDo4OlA6cDqMOqQ60Dr4Oxg7KDs8O2Q7dDuQO7A7zDvgOBA8KDxUPGw8iDygPMw89D0UPTA9RD1cPXg9jD2kPcA92D30Pgg+JD40Png+kD6kPrQ+4D74PyQ/QD9YP2g/hD+UP7w/6DwAQBBAJEA8QExAaEB8QIxApEC8QMhA2EDkQPxBFEFkQYRB5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";if(!S(T)){var ka=T;T=b.locateFile?b.locateFile(ka,t):t+ka;}function la(){var a=T;try{if(a==T&&v)return new Uint8Array(v);if(S(a))try{var c=ma(a.slice(37)),d=new Uint8Array(c.length);for(a=0;a<c.length;++a)d[a]=c.charCodeAt(a);var e=d;}catch(g){throw Error("Converting base64 string to bytes failed.");}else e=void 0;var f=e;if(f)return f;throw"both async and sync fetching of the wasm failed";}catch(g){w(g);}}function na(){return v||"function"!==typeof fetch?Promise.resolve().then(function(){return la();}):fetch(T,{credentials:"same-origin"}).then(function(a){if(!a.ok)throw"failed to load wasm binary file at '"+T+"'";return a.arrayBuffer();}).catch(function(){return la();});}function V(a){for(;0<a.length;){var c=a.shift();if("function"==typeof c)c(b);else{var d=c.B;"number"===typeof d?void 0===c.A?O.get(d)():O.get(d)(c.A):d(void 0===c.A?null:c.A);}}}function W(a){var c=L(a)+1,d=M(c);D(a,E,d,c);return d;}function oa(){}var pa=[null,[],[]];function qa(){function a(k){return(k=k.toTimeString().match(/\(([A-Za-z ]+)\)$/))?k[1]:"GMT";}if(!ra){ra=!0;var c=new Date().getFullYear(),d=new Date(c,0,1),e=new Date(c,6,1);c=d.getTimezoneOffset();var f=e.getTimezoneOffset(),g=Math.max(c,f);N[sa()>>2]=60*g;N[ta()>>2]=Number(c!=f);d=a(d);e=a(e);d=ba(d);e=ba(e);f<c?(N[X()>>2]=d,N[X()+4>>2]=e):(N[X()>>2]=e,N[X()+4>>2]=d);}}var ra;oa=(a,c,d)=>{a=H(a);c=null!==c?JSON.parse(H(c)):[];try{const e=b.externalCall(a,c);return e?W(e):null;}catch(e){return b.HEAPU8[d]=1,W(e.message);}};var ma="function"===typeof atob?atob:function(a){var c="",d=0;a=a.replace(/[^A-Za-z0-9\+\/=]/g,"");do{var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));var f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));var g="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));var k="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));e=e<<2|f>>4;f=(f&15)<<4|g>>2;var m=(g&3)<<6|k;c+=String.fromCharCode(e);64!==g&&(c+=String.fromCharCode(f));64!==k&&(c+=String.fromCharCode(m));}while(d<a.length);return c;},ua={a:function(a,c,d,e){w("Assertion failed: "+H(a)+", at: "+[c?H(c):"unknown filename",d,e?H(e):"unknown function"]);},b:function(){w();},g:oa,f:function(a,c){a=H(a);let d;try{d=window.JSON.parse(a);}catch(e){d=a;}0!==c?window.alert(a):window.console.log("DUMP",d);},e:function(a){var c=E.length;a>>>=0;if(2147483648<a)return!1;for(var d=1;4>=d;d*=2){var e=c*(1+.2/d);e=Math.min(e,a+100663296);e=Math.max(a,e);0<e%65536&&(e+=65536-e%65536);a:{try{x.grow(Math.min(2147483648,e)-ca.byteLength+65535>>>16);da();var f=1;break a;}catch(g){}f=void 0;}if(f)return!0;}return!1;},d:function(a,c,d,e){for(var f=0,g=0;g<d;g++){for(var k=N[c+8*g>>2],m=N[c+(8*g+4)>>2],y=0;y<m;y++){var l=E[k+y],p=pa[a];0===l||10===l?((1===a?aa:u)(K(p,0)),p.length=0):p.push(l);}f+=m;}N[e>>2]=f;return 0;},c:function(a){var c=Date.now();N[a>>2]=c/1E3|0;N[a+4>>2]=c%1E3*1E3|0;return 0;},h:function(a,c){qa();a=new Date(1E3*N[a>>2]);N[c>>2]=a.getSeconds();N[c+4>>2]=a.getMinutes();N[c+8>>2]=a.getHours();N[c+12>>2]=a.getDate();N[c+16>>2]=a.getMonth();N[c+20>>2]=a.getFullYear()-1900;N[c+24>>2]=a.getDay();var d=new Date(a.getFullYear(),0,1);N[c+28>>2]=(a.getTime()-d.getTime())/864E5|0;N[c+36>>2]=-(60*a.getTimezoneOffset());var e=new Date(a.getFullYear(),6,1).getTimezoneOffset();d=d.getTimezoneOffset();a=(e!=d&&a.getTimezoneOffset()==Math.min(d,e))|0;N[c+32>>2]=a;a=N[X()+(a?4:0)>>2];N[c+40>>2]=a;return c;},i:function(a){a=H(a);window.console.log(a);},j:function(a,c,d,e){a=H(a);c=H(c);d=H(d);d=`Quickjs -- ${a}: ${c}\n${d}`;0!==e?window.alert(d):window.console.error(d);}};(function(){function a(f){b.asm=f.exports;x=b.asm.k;da();O=b.asm.t;fa.unshift(b.asm.l);P--;b.monitorRunDependencies&&b.monitorRunDependencies(P);0==P&&(null!==Q&&(clearInterval(Q),Q=null),R&&(f=R,R=null,f()));}function c(f){a(f.instance);}function d(f){return na().then(function(g){return WebAssembly.instantiate(g,e);}).then(f,function(g){u("failed to asynchronously prepare wasm: "+g);w(g);});}var e={a:ua};P++;b.monitorRunDependencies&&b.monitorRunDependencies(P);if(b.instantiateWasm)try{return b.instantiateWasm(e,a);}catch(f){return u("Module.instantiateWasm callback failed with error: "+f),!1;}(function(){return v||"function"!==typeof WebAssembly.instantiateStreaming||S(T)||"function"!==typeof fetch?d(c):fetch(T,{credentials:"same-origin"}).then(function(f){return WebAssembly.instantiateStreaming(f,e).then(c,function(g){u("wasm streaming compile failed: "+g);u("falling back to ArrayBuffer instantiation");return d(c);});});})().catch(n);return{};})();b.___wasm_call_ctors=function(){return(b.___wasm_call_ctors=b.asm.l).apply(null,arguments);};b._evalInSandbox=function(){return(b._evalInSandbox=b.asm.m).apply(null,arguments);};b._nukeSandbox=function(){return(b._nukeSandbox=b.asm.n).apply(null,arguments);};b._init=function(){return(b._init=b.asm.o).apply(null,arguments);};b._commFun=function(){return(b._commFun=b.asm.p).apply(null,arguments);};b._dumpMemoryUse=function(){return(b._dumpMemoryUse=b.asm.q).apply(null,arguments);};var M=b._malloc=function(){return(M=b._malloc=b.asm.r).apply(null,arguments);};b._free=function(){return(b._free=b.asm.s).apply(null,arguments);};var X=b.__get_tzname=function(){return(X=b.__get_tzname=b.asm.u).apply(null,arguments);},ta=b.__get_daylight=function(){return(ta=b.__get_daylight=b.asm.v).apply(null,arguments);},sa=b.__get_timezone=function(){return(sa=b.__get_timezone=b.asm.w).apply(null,arguments);},G=b.stackSave=function(){return(G=b.stackSave=b.asm.x).apply(null,arguments);},I=b.stackRestore=function(){return(I=b.stackRestore=b.asm.y).apply(null,arguments);},C=b.stackAlloc=function(){return(C=b.stackAlloc=b.asm.z).apply(null,arguments);};b.ccall=B;b.cwrap=function(a,c,d,e){d=d||[];var f=d.every(function(g){return"number"===g;});return"string"!==c&&f&&!e?A(a):function(){return B(a,c,d,arguments,e);};};b.stringToNewUTF8=W;var Y;R=function va(){Y||Z();Y||(R=va);};function Z(){function a(){if(!Y&&(Y=!0,b.calledRun=!0,!z)){V(fa);V(ha);h(b);if(b.onRuntimeInitialized)b.onRuntimeInitialized();if(b.postRun)for("function"==typeof b.postRun&&(b.postRun=[b.postRun]);b.postRun.length;){var c=b.postRun.shift();ia.unshift(c);}V(ia);}}if(!(0<P)){if(b.preRun)for("function"==typeof b.preRun&&(b.preRun=[b.preRun]);b.preRun.length;)ja();V(ea);0<P||(b.setStatus?(b.setStatus("Running..."),setTimeout(function(){setTimeout(function(){b.setStatus("");},1);a();},1)):a());}}b.run=Z;if(b.preInit)for("function"==typeof b.preInit&&(b.preInit=[b.preInit]);0<b.preInit.length;)b.preInit.pop()();Z();return Module.ready;};}();var _default=Module;exports.default=_default;

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports) => {



class SandboxSupportBase {
  constructor(win) {
    this.win = win;
    this.timeoutIds = new Map();
    this.commFun = null;
  }

  destroy() {
    this.commFunc = null;
    this.timeoutIds.forEach(([_, id]) => this.win.clearTimeout(id));
    this.timeoutIds = null;
  }

  exportValueToSandbox(val) {
    throw new Error("Not implemented");
  }

  importValueFromSandbox(val) {
    throw new Error("Not implemented");
  }

  createErrorForSandbox(errorMessage) {
    throw new Error("Not implemented");
  }

  callSandboxFunction(name, args) {
    try {
      args = this.exportValueToSandbox(args);
      this.commFun(name, args);
    } catch (e) {
      this.win.console.error(e);
    }
  }

  createSandboxExternals() {
    const externals = {
      setTimeout: (callbackId, nMilliseconds) => {
        if (typeof callbackId !== "number" || typeof nMilliseconds !== "number") {
          return;
        }

        const id = this.win.setTimeout(() => {
          this.timeoutIds.delete(callbackId);
          this.callSandboxFunction("timeoutCb", {
            callbackId,
            interval: false
          });
        }, nMilliseconds);
        this.timeoutIds.set(callbackId, id);
      },
      clearTimeout: id => {
        this.win.clearTimeout(this.timeoutIds.get(id));
        this.timeoutIds.delete(id);
      },
      setInterval: (callbackId, nMilliseconds) => {
        if (typeof callbackId !== "number" || typeof nMilliseconds !== "number") {
          return;
        }

        const id = this.win.setInterval(() => {
          this.callSandboxFunction("timeoutCb", {
            callbackId,
            interval: true
          });
        }, nMilliseconds);
        this.timeoutIds.set(callbackId, id);
      },
      clearInterval: id => {
        this.win.clearInterval(this.timeoutIds.get(id));
        this.timeoutIds.delete(id);
      },
      alert: cMsg => {
        if (typeof cMsg !== "string") {
          return;
        }

        this.win.alert(cMsg);
      },
      confirm: cMsg => {
        if (typeof cMsg !== "string") {
          return false;
        }

        return this.win.confirm(cMsg);
      },
      prompt: (cQuestion, cDefault) => {
        if (typeof cQuestion !== "string" || typeof cDefault !== "string") {
          return null;
        }

        return this.win.prompt(cQuestion, cDefault);
      },
      parseURL: cUrl => {
        const url = new this.win.URL(cUrl);
        const props = ["hash", "host", "hostname", "href", "origin", "password", "pathname", "port", "protocol", "search", "searchParams", "username"];
        return Object.fromEntries(props.map(name => [name, url[name].toString()]));
      },
      send: data => {
        if (!data) {
          return;
        }

        const event = new this.win.CustomEvent("updatefromsandbox", {
          detail: this.importValueFromSandbox(data)
        });
        this.win.dispatchEvent(event);
      }
    };
    Object.setPrototypeOf(externals, null);
    return (name, args) => {
      try {
        const result = externals[name](...args);
        return this.exportValueToSandbox(result);
      } catch (error) {
        throw this.createErrorForSandbox(error?.toString() ?? "");
      }
    };
  }

}

{
  exports.SandboxSupportBase = SandboxSupportBase;
}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.QuickJSSandbox = QuickJSSandbox;

var _quickjsEval = _interopRequireDefault(__w_pdfjs_require__(1));

var _pdfSandboxExternal = __w_pdfjs_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pdfjsVersion = '2.9.0';
const pdfjsBuild = '3538ef0';

class SandboxSupport extends _pdfSandboxExternal.SandboxSupportBase {
  exportValueToSandbox(val) {
    return JSON.stringify(val);
  }

  importValueFromSandbox(val) {
    return val;
  }

  createErrorForSandbox(errorMessage) {
    return new Error(errorMessage);
  }

}

class Sandbox {
  constructor(win, module) {
    this.support = new SandboxSupport(win, this);
    module.externalCall = this.support.createSandboxExternals();
    this._module = module;
    this._alertOnError = 0;
  }

  create(data) {
    const code = ['(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === \'object\' && typeof module === \'object\')\n\t\tmodule.exports = factory();\n\telse if(typeof define === \'function\' && define.amd)\n\t\tdefine("pdfjs-dist/build/pdf.scripting", [], factory);\n\telse if(typeof exports === \'object\')\n\t\texports["pdfjs-dist/build/pdf.scripting"] = factory();\n\telse\n\t\troot.pdfjsScripting = factory();\n})(this, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t"use strict";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.initSandbox = initSandbox;\n\nvar _constants = __w_pdfjs_require__(2);\n\nvar _field = __w_pdfjs_require__(3);\n\nvar _aform = __w_pdfjs_require__(8);\n\nvar _app = __w_pdfjs_require__(9);\n\nvar _color = __w_pdfjs_require__(5);\n\nvar _console = __w_pdfjs_require__(13);\n\nvar _doc = __w_pdfjs_require__(14);\n\nvar _proxy = __w_pdfjs_require__(16);\n\nvar _util = __w_pdfjs_require__(17);\n\nfunction initSandbox(params) {\n  delete globalThis.pdfjsScripting;\n  const externalCall = globalThis.callExternalFunction;\n  delete globalThis.callExternalFunction;\n\n  const globalEval = code => globalThis.eval(code);\n\n  const send = data => externalCall("send", [data]);\n\n  const proxyHandler = new _proxy.ProxyHandler();\n  const {\n    data\n  } = params;\n  const doc = new _doc.Doc({\n    send,\n    globalEval,\n    ...data.docInfo\n  });\n  const _document = {\n    obj: doc,\n    wrapped: new Proxy(doc, proxyHandler)\n  };\n  const app = new _app.App({\n    send,\n    globalEval,\n    externalCall,\n    _document,\n    calculationOrder: data.calculationOrder,\n    proxyHandler,\n    ...data.appInfo\n  });\n  const util = new _util.Util({\n    externalCall\n  });\n  const appObjects = app._objects;\n\n  if (data.objects) {\n    const annotations = [];\n\n    for (const [name, objs] of Object.entries(data.objects)) {\n      annotations.length = 0;\n      let container = null;\n\n      for (const obj of objs) {\n        if (obj.type !== "") {\n          annotations.push(obj);\n        } else {\n          container = obj;\n        }\n      }\n\n      let obj = container;\n\n      if (annotations.length > 0) {\n        obj = annotations[0];\n        obj.send = send;\n      }\n\n      obj.globalEval = globalEval;\n      obj.doc = _document;\n      obj.fieldPath = name;\n      obj.appObjects = appObjects;\n      let field;\n\n      switch (obj.type) {\n        case "radiobutton":\n          {\n            const otherButtons = annotations.slice(1);\n            field = new _field.RadioButtonField(otherButtons, obj);\n            break;\n          }\n\n        case "checkbox":\n          {\n            const otherButtons = annotations.slice(1);\n            field = new _field.CheckboxField(otherButtons, obj);\n            break;\n          }\n\n        case "text":\n          if (annotations.length <= 1) {\n            field = new _field.Field(obj);\n            break;\n          }\n\n          obj.siblings = annotations.map(x => x.id).slice(1);\n          field = new _field.Field(obj);\n          break;\n\n        default:\n          field = new _field.Field(obj);\n      }\n\n      const wrapped = new Proxy(field, proxyHandler);\n\n      doc._addField(name, wrapped);\n\n      const _object = {\n        obj: field,\n        wrapped\n      };\n\n      for (const object of objs) {\n        appObjects[object.id] = _object;\n      }\n\n      if (container) {\n        appObjects[container.id] = _object;\n      }\n    }\n  }\n\n  const color = new _color.Color();\n  globalThis.event = null;\n  globalThis.global = Object.create(null);\n  globalThis.app = new Proxy(app, proxyHandler);\n  globalThis.color = new Proxy(color, proxyHandler);\n  globalThis.console = new Proxy(new _console.Console({\n    send\n  }), proxyHandler);\n  globalThis.util = new Proxy(util, proxyHandler);\n  globalThis.border = _constants.Border;\n  globalThis.cursor = _constants.Cursor;\n  globalThis.display = _constants.Display;\n  globalThis.font = _constants.Font;\n  globalThis.highlight = _constants.Highlight;\n  globalThis.position = _constants.Position;\n  globalThis.scaleHow = _constants.ScaleHow;\n  globalThis.scaleWhen = _constants.ScaleWhen;\n  globalThis.style = _constants.Style;\n  globalThis.trans = _constants.Trans;\n  globalThis.zoomtype = _constants.ZoomType;\n  globalThis.ADBE = {\n    Reader_Value_Asked: true,\n    Viewer_Value_Asked: true\n  };\n  const aform = new _aform.AForm(doc, app, util, color);\n\n  for (const name of Object.getOwnPropertyNames(_aform.AForm.prototype)) {\n    if (name !== "constructor" && !name.startsWith("_")) {\n      globalThis[name] = aform[name].bind(aform);\n    }\n  }\n\n  for (const [name, value] of Object.entries(_constants.GlobalConstants)) {\n    Object.defineProperty(globalThis, name, {\n      value,\n      writable: false\n    });\n  }\n\n  Object.defineProperties(globalThis, {\n    ColorConvert: {\n      value: color.convert.bind(color),\n      writable: true\n    },\n    ColorEqual: {\n      value: color.equal.bind(color),\n      writable: true\n    }\n  });\n  const properties = Object.create(null);\n\n  for (const name of Object.getOwnPropertyNames(_doc.Doc.prototype)) {\n    if (name === "constructor" || name.startsWith("_")) {\n      continue;\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(_doc.Doc.prototype, name);\n\n    if (descriptor.get) {\n      properties[name] = {\n        get: descriptor.get.bind(doc),\n        set: descriptor.set.bind(doc)\n      };\n    } else {\n      properties[name] = {\n        value: _doc.Doc.prototype[name].bind(doc)\n      };\n    }\n  }\n\n  Object.defineProperties(globalThis, properties);\n  const functions = {\n    dispatchEvent: app._dispatchEvent.bind(app),\n    timeoutCb: app._evalCallback.bind(app)\n  };\n  return (name, args) => {\n    try {\n      functions[name](args);\n    } catch (error) {\n      const value = `${error.toString()}\\n${error.stack}`;\n      send({\n        command: "error",\n        value\n      });\n    }\n  };\n}\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ZoomType = exports.Trans = exports.Style = exports.ScaleWhen = exports.ScaleHow = exports.Position = exports.Highlight = exports.GlobalConstants = exports.Font = exports.Display = exports.Cursor = exports.Border = void 0;\nconst Border = Object.freeze({\n  s: "solid",\n  d: "dashed",\n  b: "beveled",\n  i: "inset",\n  u: "underline"\n});\nexports.Border = Border;\nconst Cursor = Object.freeze({\n  visible: 0,\n  hidden: 1,\n  delay: 2\n});\nexports.Cursor = Cursor;\nconst Display = Object.freeze({\n  visible: 0,\n  hidden: 1,\n  noPrint: 2,\n  noView: 3\n});\nexports.Display = Display;\nconst Font = Object.freeze({\n  Times: "Times-Roman",\n  TimesB: "Times-Bold",\n  TimesI: "Times-Italic",\n  TimesBI: "Times-BoldItalic",\n  Helv: "Helvetica",\n  HelvB: "Helvetica-Bold",\n  HelvI: "Helvetica-Oblique",\n  HelvBI: "Helvetica-BoldOblique",\n  Cour: "Courier",\n  CourB: "Courier-Bold",\n  CourI: "Courier-Oblique",\n  CourBI: "Courier-BoldOblique",\n  Symbol: "Symbol",\n  ZapfD: "ZapfDingbats",\n  KaGo: "HeiseiKakuGo-W5-UniJIS-UCS2-H",\n  KaMi: "HeiseiMin-W3-UniJIS-UCS2-H"\n});\nexports.Font = Font;\nconst Highlight = Object.freeze({\n  n: "none",\n  i: "invert",\n  p: "push",\n  o: "outline"\n});\nexports.Highlight = Highlight;\nconst Position = Object.freeze({\n  textOnly: 0,\n  iconOnly: 1,\n  iconTextV: 2,\n  textIconV: 3,\n  iconTextH: 4,\n  textIconH: 5,\n  overlay: 6\n});\nexports.Position = Position;\nconst ScaleHow = Object.freeze({\n  proportional: 0,\n  anamorphic: 1\n});\nexports.ScaleHow = ScaleHow;\nconst ScaleWhen = Object.freeze({\n  always: 0,\n  never: 1,\n  tooBig: 2,\n  tooSmall: 3\n});\nexports.ScaleWhen = ScaleWhen;\nconst Style = Object.freeze({\n  ch: "check",\n  cr: "cross",\n  di: "diamond",\n  ci: "circle",\n  st: "star",\n  sq: "square"\n});\nexports.Style = Style;\nconst Trans = Object.freeze({\n  blindsH: "BlindsHorizontal",\n  blindsV: "BlindsVertical",\n  boxI: "BoxIn",\n  boxO: "BoxOut",\n  dissolve: "Dissolve",\n  glitterD: "GlitterDown",\n  glitterR: "GlitterRight",\n  glitterRD: "GlitterRightDown",\n  random: "Random",\n  replace: "Replace",\n  splitHI: "SplitHorizontalIn",\n  splitHO: "SplitHorizontalOut",\n  splitVI: "SplitVerticalIn",\n  splitVO: "SplitVerticalOut",\n  wipeD: "WipeDown",\n  wipeL: "WipeLeft",\n  wipeR: "WipeRight",\n  wipeU: "WipeUp"\n});\nexports.Trans = Trans;\nconst ZoomType = Object.freeze({\n  none: "NoVary",\n  fitP: "FitPage",\n  fitW: "FitWidth",\n  fitH: "FitHeight",\n  fitV: "FitVisibleWidth",\n  pref: "Preferred",\n  refW: "ReflowWidth"\n});\nexports.ZoomType = ZoomType;\nconst GlobalConstants = Object.freeze({\n  IDS_GREATER_THAN: "Invalid value: must be greater than or equal to % s.",\n  IDS_GT_AND_LT: "Invalid value: must be greater than or equal to % s " + "and less than or equal to % s.",\n  IDS_LESS_THAN: "Invalid value: must be less than or equal to % s.",\n  IDS_INVALID_MONTH: "** Invalid **",\n  IDS_INVALID_DATE: "Invalid date / time: please ensure that the date / time exists.Field",\n  IDS_INVALID_DATE2: " should match format ",\n  IDS_INVALID_VALUE: "The value entered does not match the format of the field",\n  IDS_AM: "am",\n  IDS_PM: "pm",\n  IDS_MONTH_INFO: "January[1] February[2] March[3] April[4] May[5] " + "June[6] July[7] August[8] September[9] October[10] " + "November[11] December[12] Sept[9] Jan[1] Feb[2] Mar[3] " + "Apr[4] Jun[6] Jul[7] Aug[8] Sep[9] Oct[10] Nov[11] Dec[12]",\n  IDS_STARTUP_CONSOLE_MSG: "** ^ _ ^ **",\n  RE_NUMBER_ENTRY_DOT_SEP: ["[+-]?\\\\d*\\\\.?\\\\d*"],\n  RE_NUMBER_COMMIT_DOT_SEP: ["[+-]?\\\\d+(\\\\.\\\\d+)?", "[+-]?\\\\.\\\\d+", "[+-]?\\\\d+\\\\."],\n  RE_NUMBER_ENTRY_COMMA_SEP: ["[+-]?\\\\d*,?\\\\d*"],\n  RE_NUMBER_COMMIT_COMMA_SEP: ["[+-]?\\\\d+([.,]\\\\d+)?", "[+-]?[.,]\\\\d+", "[+-]?\\\\d+[.,]"],\n  RE_ZIP_ENTRY: ["\\\\d{0,5}"],\n  RE_ZIP_COMMIT: ["\\\\d{5}"],\n  RE_ZIP4_ENTRY: ["\\\\d{0,5}(\\\\.|[- ])?\\\\d{0,4}"],\n  RE_ZIP4_COMMIT: ["\\\\d{5}(\\\\.|[- ])?\\\\d{4}"],\n  RE_PHONE_ENTRY: ["\\\\d{0,3}(\\\\.|[- ])?\\\\d{0,3}(\\\\.|[- ])?\\\\d{0,4}", "\\\\(\\\\d{0,3}", "\\\\(\\\\d{0,3}\\\\)(\\\\.|[- ])?\\\\d{0,3}(\\\\.|[- ])?\\\\d{0,4}", "\\\\(\\\\d{0,3}(\\\\.|[- ])?\\\\d{0,3}(\\\\.|[- ])?\\\\d{0,4}", "\\\\d{0,3}\\\\)(\\\\.|[- ])?\\\\d{0,3}(\\\\.|[- ])?\\\\d{0,4}", "011(\\\\.|[- \\\\d])*"],\n  RE_PHONE_COMMIT: ["\\\\d{3}(\\\\.|[- ])?\\\\d{4}", "\\\\d{3}(\\\\.|[- ])?\\\\d{3}(\\\\.|[- ])?\\\\d{4}", "\\\\(\\\\d{3}\\\\)(\\\\.|[- ])?\\\\d{3}(\\\\.|[- ])?\\\\d{4}", "011(\\\\.|[- \\\\d])*"],\n  RE_SSN_ENTRY: ["\\\\d{0,3}(\\\\.|[- ])?\\\\d{0,2}(\\\\.|[- ])?\\\\d{0,4}"],\n  RE_SSN_COMMIT: ["\\\\d{3}(\\\\.|[- ])?\\\\d{2}(\\\\.|[- ])?\\\\d{4}"]\n});\nexports.GlobalConstants = GlobalConstants;\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.RadioButtonField = exports.Field = exports.CheckboxField = void 0;\n\nvar _common = __w_pdfjs_require__(4);\n\nvar _color = __w_pdfjs_require__(5);\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nclass Field extends _pdf_object.PDFObject {\n  constructor(data) {\n    super(data);\n    this.alignment = data.alignment || "left";\n    this.borderStyle = data.borderStyle || "";\n    this.buttonAlignX = data.buttonAlignX || 50;\n    this.buttonAlignY = data.buttonAlignY || 50;\n    this.buttonFitBounds = data.buttonFitBounds;\n    this.buttonPosition = data.buttonPosition;\n    this.buttonScaleHow = data.buttonScaleHow;\n    this.ButtonScaleWhen = data.buttonScaleWhen;\n    this.calcOrderIndex = data.calcOrderIndex;\n    this.charLimit = data.charLimit;\n    this.comb = data.comb;\n    this.commitOnSelChange = data.commitOnSelChange;\n    this.currentValueIndices = data.currentValueIndices;\n    this.defaultStyle = data.defaultStyle;\n    this.defaultValue = data.defaultValue;\n    this.doNotScroll = data.doNotScroll;\n    this.doNotSpellCheck = data.doNotSpellCheck;\n    this.delay = data.delay;\n    this.display = data.display;\n    this.doc = data.doc.wrapped;\n    this.editable = data.editable;\n    this.exportValues = data.exportValues;\n    this.fileSelect = data.fileSelect;\n    this.hidden = data.hidden;\n    this.highlight = data.highlight;\n    this.lineWidth = data.lineWidth;\n    this.multiline = data.multiline;\n    this.multipleSelection = !!data.multipleSelection;\n    this.name = data.name;\n    this.password = data.password;\n    this.print = data.print;\n    this.radiosInUnison = data.radiosInUnison;\n    this.readonly = data.readonly;\n    this.rect = data.rect;\n    this.required = data.required;\n    this.richText = data.richText;\n    this.richValue = data.richValue;\n    this.rotation = data.rotation;\n    this.style = data.style;\n    this.submitName = data.submitName;\n    this.textFont = data.textFont;\n    this.textSize = data.textSize;\n    this.type = data.type;\n    this.userName = data.userName;\n    this._actions = (0, _common.createActionsMap)(data.actions);\n    this._browseForFileToSubmit = data.browseForFileToSubmit || null;\n    this._buttonCaption = null;\n    this._buttonIcon = null;\n    this._children = null;\n    this._currentValueIndices = data.currentValueIndices || 0;\n    this._document = data.doc;\n    this._fieldPath = data.fieldPath;\n    this._fillColor = data.fillColor || ["T"];\n    this._isChoice = Array.isArray(data.items);\n    this._items = data.items || [];\n    this._page = data.page || 0;\n    this._strokeColor = data.strokeColor || ["G", 0];\n    this._textColor = data.textColor || ["G", 0];\n    this._value = data.value || "";\n    this._kidIds = data.kidIds || null;\n    this._fieldType = (0, _common.getFieldType)(this._actions);\n    this._siblings = data.siblings || null;\n    this._globalEval = data.globalEval;\n    this._appObjects = data.appObjects;\n    this.valueAsString = data.valueAsString || this._value;\n  }\n\n  get currentValueIndices() {\n    if (!this._isChoice) {\n      return 0;\n    }\n\n    return this._currentValueIndices;\n  }\n\n  set currentValueIndices(indices) {\n    if (!this._isChoice) {\n      return;\n    }\n\n    if (!Array.isArray(indices)) {\n      indices = [indices];\n    }\n\n    if (!indices.every(i => typeof i === "number" && Number.isInteger(i) && i >= 0 && i < this.numItems)) {\n      return;\n    }\n\n    indices.sort();\n\n    if (this.multipleSelection) {\n      this._currentValueIndices = indices;\n      this._value = [];\n      indices.forEach(i => {\n        this._value.push(this._items[i].displayValue);\n      });\n    } else {\n      if (indices.length > 0) {\n        indices = indices.splice(1, indices.length - 1);\n        this._currentValueIndices = indices[0];\n        this._value = this._items[this._currentValueIndices];\n      }\n    }\n\n    this._send({\n      id: this._id,\n      indices\n    });\n  }\n\n  get fillColor() {\n    return this._fillColor;\n  }\n\n  set fillColor(color) {\n    if (_color.Color._isValidColor(color)) {\n      this._fillColor = color;\n    }\n  }\n\n  get bgColor() {\n    return this.fillColor;\n  }\n\n  set bgColor(color) {\n    this.fillColor = color;\n  }\n\n  get numItems() {\n    if (!this._isChoice) {\n      throw new Error("Not a choice widget");\n    }\n\n    return this._items.length;\n  }\n\n  set numItems(_) {\n    throw new Error("field.numItems is read-only");\n  }\n\n  get strokeColor() {\n    return this._strokeColor;\n  }\n\n  set strokeColor(color) {\n    if (_color.Color._isValidColor(color)) {\n      this._strokeColor = color;\n    }\n  }\n\n  get borderColor() {\n    return this.strokeColor;\n  }\n\n  set borderColor(color) {\n    this.strokeColor = color;\n  }\n\n  get page() {\n    return this._page;\n  }\n\n  set page(_) {\n    throw new Error("field.page is read-only");\n  }\n\n  get textColor() {\n    return this._textColor;\n  }\n\n  set textColor(color) {\n    if (_color.Color._isValidColor(color)) {\n      this._textColor = color;\n    }\n  }\n\n  get fgColor() {\n    return this.textColor;\n  }\n\n  set fgColor(color) {\n    this.textColor = color;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    if (value === "") {\n      this._value = "";\n    } else if (typeof value === "string") {\n      switch (this._fieldType) {\n        case _common.FieldType.number:\n        case _common.FieldType.percent:\n          value = parseFloat(value);\n\n          if (!isNaN(value)) {\n            this._value = value;\n          }\n\n          break;\n\n        default:\n          this._value = value;\n      }\n    } else {\n      this._value = value;\n    }\n\n    if (this._isChoice) {\n      if (this.multipleSelection) {\n        const values = new Set(value);\n        this._currentValueIndices.length = 0;\n\n        this._items.forEach(({\n          displayValue\n        }, i) => {\n          if (values.has(displayValue)) {\n            this._currentValueIndices.push(i);\n          }\n        });\n      } else {\n        this._currentValueIndices = this._items.findIndex(({\n          displayValue\n        }) => value === displayValue);\n      }\n    }\n  }\n\n  get valueAsString() {\n    if (this._valueAsString === undefined) {\n      this._valueAsString = this._value ? this._value.toString() : "";\n    }\n\n    return this._valueAsString;\n  }\n\n  set valueAsString(val) {\n    this._valueAsString = val ? val.toString() : "";\n  }\n\n  browseForFileToSubmit() {\n    if (this._browseForFileToSubmit) {\n      this._browseForFileToSubmit();\n    }\n  }\n\n  buttonGetCaption(nFace = 0) {\n    if (this._buttonCaption) {\n      return this._buttonCaption[nFace];\n    }\n\n    return "";\n  }\n\n  buttonGetIcon(nFace = 0) {\n    if (this._buttonIcon) {\n      return this._buttonIcon[nFace];\n    }\n\n    return null;\n  }\n\n  buttonImportIcon(cPath = null, nPave = 0) {}\n\n  buttonSetCaption(cCaption, nFace = 0) {\n    if (!this._buttonCaption) {\n      this._buttonCaption = ["", "", ""];\n    }\n\n    this._buttonCaption[nFace] = cCaption;\n  }\n\n  buttonSetIcon(oIcon, nFace = 0) {\n    if (!this._buttonIcon) {\n      this._buttonIcon = [null, null, null];\n    }\n\n    this._buttonIcon[nFace] = oIcon;\n  }\n\n  checkThisBox(nWidget, bCheckIt = true) {}\n\n  clearItems() {\n    if (!this._isChoice) {\n      throw new Error("Not a choice widget");\n    }\n\n    this._items = [];\n\n    this._send({\n      id: this._id,\n      clear: null\n    });\n  }\n\n  deleteItemAt(nIdx = null) {\n    if (!this._isChoice) {\n      throw new Error("Not a choice widget");\n    }\n\n    if (!this.numItems) {\n      return;\n    }\n\n    if (nIdx === null) {\n      nIdx = Array.isArray(this._currentValueIndices) ? this._currentValueIndices[0] : this._currentValueIndices;\n      nIdx = nIdx || 0;\n    }\n\n    if (nIdx < 0 || nIdx >= this.numItems) {\n      nIdx = this.numItems - 1;\n    }\n\n    this._items.splice(nIdx, 1);\n\n    if (Array.isArray(this._currentValueIndices)) {\n      let index = this._currentValueIndices.findIndex(i => i >= nIdx);\n\n      if (index !== -1) {\n        if (this._currentValueIndices[index] === nIdx) {\n          this._currentValueIndices.splice(index, 1);\n        }\n\n        for (const ii = this._currentValueIndices.length; index < ii; index++) {\n          --this._currentValueIndices[index];\n        }\n      }\n    } else {\n      if (this._currentValueIndices === nIdx) {\n        this._currentValueIndices = this.numItems > 0 ? 0 : -1;\n      } else if (this._currentValueIndices > nIdx) {\n        --this._currentValueIndices;\n      }\n    }\n\n    this._send({\n      id: this._id,\n      remove: nIdx\n    });\n  }\n\n  getItemAt(nIdx = -1, bExportValue = false) {\n    if (!this._isChoice) {\n      throw new Error("Not a choice widget");\n    }\n\n    if (nIdx < 0 || nIdx >= this.numItems) {\n      nIdx = this.numItems - 1;\n    }\n\n    const item = this._items[nIdx];\n    return bExportValue ? item.exportValue : item.displayValue;\n  }\n\n  getArray() {\n    if (this._kidIds) {\n      return this._kidIds.map(id => this._appObjects[id].wrapped);\n    }\n\n    if (this._children === null) {\n      this._children = this._document.obj._getChildren(this._fieldPath);\n    }\n\n    return this._children;\n  }\n\n  getLock() {\n    return undefined;\n  }\n\n  isBoxChecked(nWidget) {\n    return false;\n  }\n\n  isDefaultChecked(nWidget) {\n    return false;\n  }\n\n  insertItemAt(cName, cExport = undefined, nIdx = 0) {\n    if (!this._isChoice) {\n      throw new Error("Not a choice widget");\n    }\n\n    if (!cName) {\n      return;\n    }\n\n    if (nIdx < 0 || nIdx > this.numItems) {\n      nIdx = this.numItems;\n    }\n\n    if (this._items.some(({\n      displayValue\n    }) => displayValue === cName)) {\n      return;\n    }\n\n    if (cExport === undefined) {\n      cExport = cName;\n    }\n\n    const data = {\n      displayValue: cName,\n      exportValue: cExport\n    };\n\n    this._items.splice(nIdx, 0, data);\n\n    if (Array.isArray(this._currentValueIndices)) {\n      let index = this._currentValueIndices.findIndex(i => i >= nIdx);\n\n      if (index !== -1) {\n        for (const ii = this._currentValueIndices.length; index < ii; index++) {\n          ++this._currentValueIndices[index];\n        }\n      }\n    } else if (this._currentValueIndices >= nIdx) {\n      ++this._currentValueIndices;\n    }\n\n    this._send({\n      id: this._id,\n      insert: {\n        index: nIdx,\n        ...data\n      }\n    });\n  }\n\n  setAction(cTrigger, cScript) {\n    if (typeof cTrigger !== "string" || typeof cScript !== "string") {\n      return;\n    }\n\n    if (!(cTrigger in this._actions)) {\n      this._actions[cTrigger] = [];\n    }\n\n    this._actions[cTrigger].push(cScript);\n  }\n\n  setFocus() {\n    this._send({\n      id: this._id,\n      focus: true\n    });\n  }\n\n  setItems(oArray) {\n    if (!this._isChoice) {\n      throw new Error("Not a choice widget");\n    }\n\n    this._items.length = 0;\n\n    for (const element of oArray) {\n      let displayValue, exportValue;\n\n      if (Array.isArray(element)) {\n        displayValue = element[0]?.toString() || "";\n        exportValue = element[1]?.toString() || "";\n      } else {\n        displayValue = exportValue = element?.toString() || "";\n      }\n\n      this._items.push({\n        displayValue,\n        exportValue\n      });\n    }\n\n    this._currentValueIndices = 0;\n\n    this._send({\n      id: this._id,\n      items: this._items\n    });\n  }\n\n  setLock() {}\n\n  signatureGetModifications() {}\n\n  signatureGetSeedValue() {}\n\n  signatureInfo() {}\n\n  signatureSetSeedValue() {}\n\n  signatureSign() {}\n\n  signatureValidate() {}\n\n  _isButton() {\n    return false;\n  }\n\n  _runActions(event) {\n    const eventName = event.name;\n\n    if (!this._actions.has(eventName)) {\n      return false;\n    }\n\n    const actions = this._actions.get(eventName);\n\n    try {\n      for (const action of actions) {\n        this._globalEval(action);\n      }\n    } catch (error) {\n      event.rc = false;\n      throw error;\n    }\n\n    return true;\n  }\n\n}\n\nexports.Field = Field;\n\nclass RadioButtonField extends Field {\n  constructor(otherButtons, data) {\n    super(data);\n    this.exportValues = [this.exportValues];\n    this._radioIds = [this._id];\n    this._radioActions = [this._actions];\n\n    for (const radioData of otherButtons) {\n      this.exportValues.push(radioData.exportValues);\n\n      this._radioIds.push(radioData.id);\n\n      this._radioActions.push((0, _common.createActionsMap)(radioData.actions));\n\n      if (this._value === radioData.exportValues) {\n        this._id = radioData.id;\n      }\n    }\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    if (value === null || value === undefined) {\n      this._value = "";\n    }\n\n    const i = this.exportValues.indexOf(value);\n\n    if (0 <= i && i < this._radioIds.length) {\n      this._id = this._radioIds[i];\n      this._value = value;\n    } else if (value === "Off" && this._radioIds.length === 2) {\n      const nextI = (1 + this._radioIds.indexOf(this._id)) % 2;\n      this._id = this._radioIds[nextI];\n      this._value = this.exportValues[nextI];\n    }\n  }\n\n  checkThisBox(nWidget, bCheckIt = true) {\n    if (nWidget < 0 || nWidget >= this._radioIds.length || !bCheckIt) {\n      return;\n    }\n\n    this._id = this._radioIds[nWidget];\n    this._value = this.exportValues[nWidget];\n\n    this._send({\n      id: this._id,\n      value: this._value\n    });\n  }\n\n  isBoxChecked(nWidget) {\n    return nWidget >= 0 && nWidget < this._radioIds.length && this._id === this._radioIds[nWidget];\n  }\n\n  isDefaultChecked(nWidget) {\n    return nWidget >= 0 && nWidget < this.exportValues.length && this.defaultValue === this.exportValues[nWidget];\n  }\n\n  _getExportValue(state) {\n    const i = this._radioIds.indexOf(this._id);\n\n    return this.exportValues[i];\n  }\n\n  _runActions(event) {\n    const i = this._radioIds.indexOf(this._id);\n\n    this._actions = this._radioActions[i];\n    return super._runActions(event);\n  }\n\n  _isButton() {\n    return true;\n  }\n\n}\n\nexports.RadioButtonField = RadioButtonField;\n\nclass CheckboxField extends RadioButtonField {\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    if (!value || value === "Off") {\n      this._value = "Off";\n    } else {\n      super.value = value;\n    }\n  }\n\n  _getExportValue(state) {\n    return state ? super._getExportValue(state) : "Off";\n  }\n\n  isBoxChecked(nWidget) {\n    if (this._value === "Off") {\n      return false;\n    }\n\n    return super.isBoxChecked(nWidget);\n  }\n\n  isDefaultChecked(nWidget) {\n    if (this.defaultValue === "Off") {\n      return this._value === "Off";\n    }\n\n    return super.isDefaultChecked(nWidget);\n  }\n\n  checkThisBox(nWidget, bCheckIt = true) {\n    if (nWidget < 0 || nWidget >= this._radioIds.length) {\n      return;\n    }\n\n    this._id = this._radioIds[nWidget];\n    this._value = bCheckIt ? this.exportValues[nWidget] : "Off";\n\n    this._send({\n      id: this._id,\n      value: this._value\n    });\n  }\n\n}\n\nexports.CheckboxField = CheckboxField;\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.createActionsMap = createActionsMap;\nexports.getFieldType = getFieldType;\nexports.FieldType = void 0;\nconst FieldType = {\n  none: 0,\n  number: 1,\n  percent: 2,\n  date: 3,\n  time: 4\n};\nexports.FieldType = FieldType;\n\nfunction createActionsMap(actions) {\n  const actionsMap = new Map();\n\n  if (actions) {\n    for (const [eventType, actionsForEvent] of Object.entries(actions)) {\n      actionsMap.set(eventType, actionsForEvent);\n    }\n  }\n\n  return actionsMap;\n}\n\nfunction getFieldType(actions) {\n  let format = actions.get("Format");\n\n  if (!format) {\n    return FieldType.none;\n  }\n\n  format = format[0];\n  format = format.trim();\n\n  if (format.startsWith("AFNumber_")) {\n    return FieldType.number;\n  }\n\n  if (format.startsWith("AFPercent_")) {\n    return FieldType.percent;\n  }\n\n  if (format.startsWith("AFDate_")) {\n    return FieldType.date;\n  }\n\n  if (format.startsWith("AFTime__")) {\n    return FieldType.time;\n  }\n\n  return FieldType.none;\n}\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.Color = void 0;\n\nvar _scripting_utils = __w_pdfjs_require__(6);\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nclass Color extends _pdf_object.PDFObject {\n  constructor() {\n    super({});\n    this.transparent = ["T"];\n    this.black = ["G", 0];\n    this.white = ["G", 1];\n    this.red = ["RGB", 1, 0, 0];\n    this.green = ["RGB", 0, 1, 0];\n    this.blue = ["RGB", 0, 0, 1];\n    this.cyan = ["CMYK", 1, 0, 0, 0];\n    this.magenta = ["CMYK", 0, 1, 0, 0];\n    this.yellow = ["CMYK", 0, 0, 1, 0];\n    this.dkGray = ["G", 0.25];\n    this.gray = ["G", 0.5];\n    this.ltGray = ["G", 0.75];\n  }\n\n  static _isValidSpace(cColorSpace) {\n    return typeof cColorSpace === "string" && (cColorSpace === "T" || cColorSpace === "G" || cColorSpace === "RGB" || cColorSpace === "CMYK");\n  }\n\n  static _isValidColor(colorArray) {\n    if (!Array.isArray(colorArray) || colorArray.length === 0) {\n      return false;\n    }\n\n    const space = colorArray[0];\n\n    if (!Color._isValidSpace(space)) {\n      return false;\n    }\n\n    switch (space) {\n      case "T":\n        if (colorArray.length !== 1) {\n          return false;\n        }\n\n        break;\n\n      case "G":\n        if (colorArray.length !== 2) {\n          return false;\n        }\n\n        break;\n\n      case "RGB":\n        if (colorArray.length !== 4) {\n          return false;\n        }\n\n        break;\n\n      case "CMYK":\n        if (colorArray.length !== 5) {\n          return false;\n        }\n\n        break;\n\n      default:\n        return false;\n    }\n\n    return colorArray.slice(1).every(c => typeof c === "number" && c >= 0 && c <= 1);\n  }\n\n  static _getCorrectColor(colorArray) {\n    return Color._isValidColor(colorArray) ? colorArray : ["G", 0];\n  }\n\n  convert(colorArray, cColorSpace) {\n    if (!Color._isValidSpace(cColorSpace)) {\n      return this.black;\n    }\n\n    if (cColorSpace === "T") {\n      return ["T"];\n    }\n\n    colorArray = Color._getCorrectColor(colorArray);\n\n    if (colorArray[0] === cColorSpace) {\n      return colorArray;\n    }\n\n    if (colorArray[0] === "T") {\n      return this.convert(this.black, cColorSpace);\n    }\n\n    return _scripting_utils.ColorConverters[`${colorArray[0]}_${cColorSpace}`](colorArray.slice(1));\n  }\n\n  equal(colorArray1, colorArray2) {\n    colorArray1 = Color._getCorrectColor(colorArray1);\n    colorArray2 = Color._getCorrectColor(colorArray2);\n\n    if (colorArray1[0] === "T" || colorArray2[0] === "T") {\n      return colorArray1[0] === "T" && colorArray2[0] === "T";\n    }\n\n    if (colorArray1[0] !== colorArray2[0]) {\n      colorArray2 = this.convert(colorArray2, colorArray1[0]);\n    }\n\n    return colorArray1.slice(1).every((c, i) => c === colorArray2[i + 1]);\n  }\n\n}\n\nexports.Color = Color;\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\n\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");\n}\n\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n\n  static G_CMYK([g]) {\n    return ["CMYK", 0, 0, 0, 1 - g];\n  }\n\n  static G_RGB([g]) {\n    return ["RGB", g, g, g];\n  }\n\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n\n  static RGB_G([r, g, b]) {\n    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n\n  static RGB_HTML([r, g, b]) {\n    const R = makeColorComp(r);\n    const G = makeColorComp(g);\n    const B = makeColorComp(b);\n    return `#${R}${G}${B}`;\n  }\n\n  static T_HTML() {\n    return "#00000000";\n  }\n\n  static CMYK_RGB([c, y, m, k]) {\n    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n\n  static CMYK_HTML(components) {\n    return this.RGB_HTML(this.CMYK_RGB(components));\n  }\n\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return ["CMYK", c, m, y, k];\n  }\n\n}\n\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PDFObject = void 0;\n\nclass PDFObject {\n  constructor(data) {\n    this._expandos = Object.create(null);\n    this._send = data.send || null;\n    this._id = data.id || null;\n  }\n\n}\n\nexports.PDFObject = PDFObject;\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.AForm = void 0;\n\nvar _constants = __w_pdfjs_require__(2);\n\nclass AForm {\n  constructor(document, app, util, color) {\n    this._document = document;\n    this._app = app;\n    this._util = util;\n    this._color = color;\n    this._dateFormats = ["m/d", "m/d/yy", "mm/dd/yy", "mm/yy", "d-mmm", "d-mmm-yy", "dd-mmm-yy", "yy-mm-dd", "mmm-yy", "mmmm-yy", "mmm d, yyyy", "mmmm d, yyyy", "m/d/yy h:MM tt", "m/d/yy HH:MM"];\n    this._timeFormats = ["HH:MM", "h:MM tt", "HH:MM:ss", "h:MM:ss tt"];\n    this._emailRegex = new RegExp("^[a-zA-Z0-9.!#$%&\'*+\\\\/=?^_`{|}~-]+" + "@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?" + "(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$");\n  }\n\n  _mkTargetName(event) {\n    return event.target ? `[ ${event.target.name} ]` : "";\n  }\n\n  _parseDate(cFormat, cDate) {\n    const ddate = Date.parse(cDate);\n\n    if (isNaN(ddate)) {\n      try {\n        return this._util.scand(cFormat, cDate);\n      } catch (error) {\n        return null;\n      }\n    } else {\n      return new Date(ddate);\n    }\n  }\n\n  AFMergeChange(event = globalThis.event) {\n    if (event.willCommit) {\n      return event.value.toString();\n    }\n\n    return this._app._eventDispatcher.mergeChange(event);\n  }\n\n  AFParseDateEx(cString, cOrder) {\n    return this._parseDate(cOrder, cString);\n  }\n\n  AFExtractNums(str) {\n    if (typeof str === "number") {\n      return [str];\n    }\n\n    if (!str || typeof str !== "string") {\n      return null;\n    }\n\n    const first = str.charAt(0);\n\n    if (first === "." || first === ",") {\n      str = `0${str}`;\n    }\n\n    const numbers = str.match(/([0-9]+)/g);\n\n    if (numbers.length === 0) {\n      return null;\n    }\n\n    return numbers;\n  }\n\n  AFMakeNumber(str) {\n    if (typeof str === "number") {\n      return str;\n    }\n\n    if (typeof str !== "string") {\n      return null;\n    }\n\n    str = str.trim().replace(",", ".");\n    const number = parseFloat(str);\n\n    if (isNaN(number) || !isFinite(number)) {\n      return null;\n    }\n\n    return number;\n  }\n\n  AFMakeArrayFromList(string) {\n    if (typeof string === "string") {\n      return string.split(/, ?/g);\n    }\n\n    return string;\n  }\n\n  AFNumber_Format(nDec, sepStyle, negStyle, currStyle, strCurrency, bCurrencyPrepend) {\n    const event = globalThis.event;\n\n    if (!event.value) {\n      return;\n    }\n\n    let value = this.AFMakeNumber(event.value);\n\n    if (value === null) {\n      event.value = "";\n      return;\n    }\n\n    const sign = Math.sign(value);\n    const buf = [];\n    let hasParen = false;\n\n    if (sign === -1 && bCurrencyPrepend && negStyle === 0) {\n      buf.push("-");\n    }\n\n    if ((negStyle === 2 || negStyle === 3) && sign === -1) {\n      buf.push("(");\n      hasParen = true;\n    }\n\n    if (bCurrencyPrepend) {\n      buf.push(strCurrency);\n    }\n\n    sepStyle = Math.min(Math.max(0, Math.floor(sepStyle)), 4);\n    buf.push("%,");\n    buf.push(sepStyle);\n    buf.push(".");\n    buf.push(nDec.toString());\n    buf.push("f");\n\n    if (!bCurrencyPrepend) {\n      buf.push(strCurrency);\n    }\n\n    if (hasParen) {\n      buf.push(")");\n    }\n\n    if (negStyle === 1 || negStyle === 3) {\n      event.target.textColor = sign === 1 ? this._color.black : this._color.red;\n    }\n\n    if ((negStyle !== 0 || bCurrencyPrepend) && sign === -1) {\n      value = -value;\n    }\n\n    const formatStr = buf.join("");\n    event.value = this._util.printf(formatStr, value);\n  }\n\n  AFNumber_Keystroke(nDec, sepStyle, negStyle, currStyle, strCurrency, bCurrencyPrepend) {\n    const event = globalThis.event;\n    let value = this.AFMergeChange(event);\n\n    if (!value) {\n      return;\n    }\n\n    value = value.trim();\n    let pattern;\n\n    if (sepStyle > 1) {\n      pattern = event.willCommit ? /^[+-]?([0-9]+(,[0-9]*)?|,[0-9]+)$/ : /^[+-]?[0-9]*,?[0-9]*$/;\n    } else {\n      pattern = event.willCommit ? /^[+-]?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)$/ : /^[+-]?[0-9]*\\.?[0-9]*$/;\n    }\n\n    if (!pattern.test(value)) {\n      if (event.willCommit) {\n        const err = `${_constants.GlobalConstants.IDS_INVALID_VALUE} ${this._mkTargetName(event)}`;\n\n        this._app.alert(err);\n      }\n\n      event.rc = false;\n    }\n\n    if (event.willCommit && sepStyle > 1) {\n      event.value = parseFloat(value.replace(",", "."));\n    }\n  }\n\n  AFPercent_Format(nDec, sepStyle, percentPrepend = false) {\n    if (typeof nDec !== "number") {\n      return;\n    }\n\n    if (typeof sepStyle !== "number") {\n      return;\n    }\n\n    if (nDec < 0) {\n      throw new Error("Invalid nDec value in AFPercent_Format");\n    }\n\n    const event = globalThis.event;\n\n    if (nDec > 512) {\n      event.value = "%";\n      return;\n    }\n\n    nDec = Math.floor(nDec);\n    sepStyle = Math.min(Math.max(0, Math.floor(sepStyle)), 4);\n    let value = this.AFMakeNumber(event.value);\n\n    if (value === null) {\n      event.value = "%";\n      return;\n    }\n\n    const formatStr = `%,${sepStyle}.${nDec}f`;\n    value = this._util.printf(formatStr, value * 100);\n\n    if (percentPrepend) {\n      event.value = `%${value}`;\n    } else {\n      event.value = `${value}%`;\n    }\n  }\n\n  AFPercent_Keystroke(nDec, sepStyle) {\n    this.AFNumber_Keystroke(nDec, sepStyle, 0, 0, "", true);\n  }\n\n  AFDate_FormatEx(cFormat) {\n    const event = globalThis.event;\n    const value = event.value;\n\n    if (!value) {\n      return;\n    }\n\n    const date = this._parseDate(cFormat, value);\n\n    if (date !== null) {\n      event.value = this._util.printd(cFormat, date);\n    }\n  }\n\n  AFDate_Format(pdf) {\n    if (pdf >= 0 && pdf < this._dateFormats.length) {\n      this.AFDate_FormatEx(this._dateFormats[pdf]);\n    }\n  }\n\n  AFDate_KeystrokeEx(cFormat) {\n    const event = globalThis.event;\n\n    if (!event.willCommit) {\n      return;\n    }\n\n    const value = this.AFMergeChange(event);\n\n    if (!value) {\n      return;\n    }\n\n    if (this._parseDate(cFormat, value) === null) {\n      const invalid = _constants.GlobalConstants.IDS_INVALID_DATE;\n      const invalid2 = _constants.GlobalConstants.IDS_INVALID_DATE2;\n      const err = `${invalid} ${this._mkTargetName(event)}${invalid2}${cFormat}`;\n\n      this._app.alert(err);\n\n      event.rc = false;\n    }\n  }\n\n  AFDate_Keystroke(pdf) {\n    if (pdf >= 0 && pdf < this._dateFormats.length) {\n      this.AFDate_KeystrokeEx(this._dateFormats[pdf]);\n    }\n  }\n\n  AFRange_Validate(bGreaterThan, nGreaterThan, bLessThan, nLessThan) {\n    const event = globalThis.event;\n\n    if (!event.value) {\n      return;\n    }\n\n    const value = this.AFMakeNumber(event.value);\n\n    if (value === null) {\n      return;\n    }\n\n    bGreaterThan = !!bGreaterThan;\n    bLessThan = !!bLessThan;\n\n    if (bGreaterThan) {\n      nGreaterThan = this.AFMakeNumber(nGreaterThan);\n\n      if (nGreaterThan === null) {\n        return;\n      }\n    }\n\n    if (bLessThan) {\n      nLessThan = this.AFMakeNumber(nLessThan);\n\n      if (nLessThan === null) {\n        return;\n      }\n    }\n\n    let err = "";\n\n    if (bGreaterThan && bLessThan) {\n      if (value < nGreaterThan || value > nLessThan) {\n        err = this._util.printf(_constants.GlobalConstants.IDS_GT_AND_LT, nGreaterThan, nLessThan);\n      }\n    } else if (bGreaterThan) {\n      if (value < nGreaterThan) {\n        err = this._util.printf(_constants.GlobalConstants.IDS_GREATER_THAN, nGreaterThan);\n      }\n    } else if (value > nLessThan) {\n      err = this._util.printf(_constants.GlobalConstants.IDS_LESS_THAN, nLessThan);\n    }\n\n    if (err) {\n      this._app.alert(err);\n\n      event.rc = false;\n    }\n  }\n\n  AFSimple(cFunction, nValue1, nValue2) {\n    const value1 = this.AFMakeNumber(nValue1);\n\n    if (value1 === null) {\n      throw new Error("Invalid nValue1 in AFSimple");\n    }\n\n    const value2 = this.AFMakeNumber(nValue2);\n\n    if (value2 === null) {\n      throw new Error("Invalid nValue2 in AFSimple");\n    }\n\n    switch (cFunction) {\n      case "AVG":\n        return (value1 + value2) / 2;\n\n      case "SUM":\n        return value1 + value2;\n\n      case "PRD":\n        return value1 * value2;\n\n      case "MIN":\n        return Math.min(value1, value2);\n\n      case "MAX":\n        return Math.max(value1, value2);\n    }\n\n    throw new Error("Invalid cFunction in AFSimple");\n  }\n\n  AFSimple_Calculate(cFunction, cFields) {\n    const actions = {\n      AVG: args => args.reduce((acc, value) => acc + value, 0) / args.length,\n      SUM: args => args.reduce((acc, value) => acc + value, 0),\n      PRD: args => args.reduce((acc, value) => acc * value, 1),\n      MIN: args => args.reduce((acc, value) => Math.min(acc, value), Number.MAX_VALUE),\n      MAX: args => args.reduce((acc, value) => Math.max(acc, value), Number.MIN_VALUE)\n    };\n\n    if (!(cFunction in actions)) {\n      throw new TypeError("Invalid function in AFSimple_Calculate");\n    }\n\n    const event = globalThis.event;\n    const values = [];\n\n    for (const cField of cFields) {\n      const field = this._document.getField(cField);\n\n      const number = this.AFMakeNumber(field.value);\n\n      if (number !== null) {\n        values.push(number);\n      }\n    }\n\n    if (values.length === 0) {\n      event.value = cFunction === "PRD" ? 1 : 0;\n      return;\n    }\n\n    const res = actions[cFunction](values);\n    event.value = Math.round(1e6 * res) / 1e6;\n  }\n\n  AFSpecial_Format(psf) {\n    const event = globalThis.event;\n\n    if (!event.value) {\n      return;\n    }\n\n    psf = this.AFMakeNumber(psf);\n\n    if (psf === null) {\n      throw new Error("Invalid psf in AFSpecial_Format");\n    }\n\n    let formatStr = "";\n\n    switch (psf) {\n      case 0:\n        formatStr = "99999";\n        break;\n\n      case 1:\n        formatStr = "99999-9999";\n        break;\n\n      case 2:\n        if (this._util.printx("9999999999", event.value).length >= 10) {\n          formatStr = "(999) 999-9999";\n        } else {\n          formatStr = "999-9999";\n        }\n\n        break;\n\n      case 3:\n        formatStr = "999-99-9999";\n        break;\n\n      default:\n        throw new Error("Invalid psf in AFSpecial_Format");\n    }\n\n    event.value = this._util.printx(formatStr, event.value);\n  }\n\n  AFSpecial_KeystrokeEx(cMask) {\n    if (!cMask) {\n      return;\n    }\n\n    const event = globalThis.event;\n    const value = this.AFMergeChange(event);\n    const checkers = new Map([["9", char => char >= "0" && char <= "9"], ["A", char => "a" <= char && char <= "z" || "A" <= char && char <= "Z"], ["O", char => "a" <= char && char <= "z" || "A" <= char && char <= "Z" || "0" <= char && char <= "9"], ["X", char => true]]);\n\n    function _checkValidity(_value, _cMask) {\n      for (let i = 0, ii = value.length; i < ii; i++) {\n        const mask = _cMask.charAt(i);\n\n        const char = _value.charAt(i);\n\n        const checker = checkers.get(mask);\n\n        if (checker) {\n          if (!checker(char)) {\n            return false;\n          }\n        } else if (mask !== char) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (!value) {\n      return;\n    }\n\n    const err = `${_constants.GlobalConstants.IDS_INVALID_VALUE} = "${cMask}"`;\n\n    if (value.length > cMask.length) {\n      this._app.alert(err);\n\n      event.rc = false;\n      return;\n    }\n\n    if (event.willCommit) {\n      if (value.length < cMask.length) {\n        this._app.alert(err);\n\n        event.rc = false;\n        return;\n      }\n\n      if (!_checkValidity(value, cMask)) {\n        this._app.alert(err);\n\n        event.rc = false;\n        return;\n      }\n\n      event.value += cMask.substring(value.length);\n      return;\n    }\n\n    if (value.length < cMask.length) {\n      cMask = cMask.substring(0, value.length);\n    }\n\n    if (!_checkValidity(value, cMask)) {\n      this._app.alert(err);\n\n      event.rc = false;\n    }\n  }\n\n  AFSpecial_Keystroke(psf) {\n    const event = globalThis.event;\n\n    if (!event.value) {\n      return;\n    }\n\n    psf = this.AFMakeNumber(psf);\n\n    if (psf === null) {\n      throw new Error("Invalid psf in AFSpecial_Keystroke");\n    }\n\n    let formatStr;\n\n    switch (psf) {\n      case 0:\n        formatStr = "99999";\n        break;\n\n      case 1:\n        formatStr = "99999-9999";\n        break;\n\n      case 2:\n        const finalLen = event.value.length + event.change.length + event.selStart - event.selEnd;\n\n        if (finalLen >= 8) {\n          formatStr = "(999) 999-9999";\n        } else {\n          formatStr = "999-9999";\n        }\n\n        break;\n\n      case 3:\n        formatStr = "999-99-9999";\n        break;\n\n      default:\n        throw new Error("Invalid psf in AFSpecial_Keystroke");\n    }\n\n    this.AFSpecial_KeystrokeEx(formatStr);\n  }\n\n  AFTime_FormatEx(cFormat) {\n    this.AFDate_FormatEx(cFormat);\n  }\n\n  AFTime_Format(pdf) {\n    if (pdf >= 0 && pdf < this._timeFormats.length) {\n      this.AFDate_FormatEx(this._timeFormats[pdf]);\n    }\n  }\n\n  AFTime_KeystrokeEx(cFormat) {\n    this.AFDate_KeystrokeEx(cFormat);\n  }\n\n  AFTime_Keystroke(pdf) {\n    if (pdf >= 0 && pdf < this._timeFormats.length) {\n      this.AFDate_KeystrokeEx(this._timeFormats[pdf]);\n    }\n  }\n\n  eMailValidate(str) {\n    return this._emailRegex.test(str);\n  }\n\n}\n\nexports.AForm = AForm;\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.App = void 0;\n\nvar _color = __w_pdfjs_require__(5);\n\nvar _event = __w_pdfjs_require__(10);\n\nvar _fullscreen = __w_pdfjs_require__(11);\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nvar _thermometer = __w_pdfjs_require__(12);\n\nconst VIEWER_TYPE = "PDF.js";\nconst VIEWER_VARIATION = "Full";\nconst VIEWER_VERSION = "10.0";\nconst FORMS_VERSION = undefined;\n\nclass App extends _pdf_object.PDFObject {\n  constructor(data) {\n    super(data);\n    this._constants = null;\n    this._focusRect = true;\n    this._fs = null;\n    this._language = App._getLanguage(data.language);\n    this._openInPlace = false;\n    this._platform = App._getPlatform(data.platform);\n    this._runtimeHighlight = false;\n    this._runtimeHighlightColor = ["T"];\n    this._thermometer = null;\n    this._toolbar = false;\n    this._document = data._document;\n    this._proxyHandler = data.proxyHandler;\n    this._objects = Object.create(null);\n    this._eventDispatcher = new _event.EventDispatcher(this._document, data.calculationOrder, this._objects);\n    this._timeoutIds = new WeakMap();\n\n    if (typeof FinalizationRegistry !== "undefined") {\n      this._timeoutIdsRegistry = new FinalizationRegistry(this._cleanTimeout.bind(this));\n    } else {\n      this._timeoutIdsRegistry = null;\n    }\n\n    this._timeoutCallbackIds = new Map();\n    this._timeoutCallbackId = 0;\n    this._globalEval = data.globalEval;\n    this._externalCall = data.externalCall;\n    this._document = data._document;\n  }\n\n  _dispatchEvent(pdfEvent) {\n    this._eventDispatcher.dispatch(pdfEvent);\n  }\n\n  _registerTimeoutCallback(cExpr) {\n    const id = this._timeoutCallbackId++;\n\n    this._timeoutCallbackIds.set(id, cExpr);\n\n    return id;\n  }\n\n  _unregisterTimeoutCallback(id) {\n    this._timeoutCallbackIds.delete(id);\n  }\n\n  _evalCallback({\n    callbackId,\n    interval\n  }) {\n    const expr = this._timeoutCallbackIds.get(callbackId);\n\n    if (!interval) {\n      this._unregisterTimeoutCallback(callbackId);\n    }\n\n    if (expr) {\n      this._globalEval(expr);\n    }\n  }\n\n  _registerTimeout(callbackId, interval) {\n    const timeout = Object.create(null);\n    const id = {\n      callbackId,\n      interval\n    };\n\n    this._timeoutIds.set(timeout, id);\n\n    if (this._timeoutIdsRegistry) {\n      this._timeoutIdsRegistry.register(timeout, id);\n    }\n\n    return timeout;\n  }\n\n  _unregisterTimeout(timeout) {\n    if (this._timeoutIdsRegistry) {\n      this._timeoutIdsRegistry.unregister(timeout);\n    }\n\n    const data = this._timeoutIds.get(timeout);\n\n    if (!data) {\n      return;\n    }\n\n    this._timeoutIds.delete(timeout);\n\n    this._cleanTimeout(data);\n  }\n\n  _cleanTimeout({\n    callbackId,\n    interval\n  }) {\n    this._unregisterTimeoutCallback(callbackId);\n\n    if (interval) {\n      this._externalCall("clearInterval", [callbackId]);\n    } else {\n      this._externalCall("clearTimeout", [callbackId]);\n    }\n  }\n\n  static _getPlatform(platform) {\n    if (typeof platform === "string") {\n      platform = platform.toLowerCase();\n\n      if (platform.includes("win")) {\n        return "WIN";\n      } else if (platform.includes("mac")) {\n        return "MAC";\n      }\n    }\n\n    return "UNIX";\n  }\n\n  static _getLanguage(language) {\n    const [main, sub] = language.toLowerCase().split(/[-_]/);\n\n    switch (main) {\n      case "zh":\n        if (sub === "cn" || sub === "sg") {\n          return "CHS";\n        }\n\n        return "CHT";\n\n      case "da":\n        return "DAN";\n\n      case "de":\n        return "DEU";\n\n      case "es":\n        return "ESP";\n\n      case "fr":\n        return "FRA";\n\n      case "it":\n        return "ITA";\n\n      case "ko":\n        return "KOR";\n\n      case "ja":\n        return "JPN";\n\n      case "nl":\n        return "NLD";\n\n      case "no":\n        return "NOR";\n\n      case "pt":\n        if (sub === "br") {\n          return "PTB";\n        }\n\n        return "ENU";\n\n      case "fi":\n        return "SUO";\n\n      case "SV":\n        return "SVE";\n\n      default:\n        return "ENU";\n    }\n  }\n\n  get activeDocs() {\n    return [this._document.wrapped];\n  }\n\n  set activeDocs(_) {\n    throw new Error("app.activeDocs is read-only");\n  }\n\n  get calculate() {\n    return this._document.obj.calculate;\n  }\n\n  set calculate(calculate) {\n    this._document.obj.calculate = calculate;\n  }\n\n  get constants() {\n    if (!this._constants) {\n      this._constants = Object.freeze({\n        align: Object.freeze({\n          left: 0,\n          center: 1,\n          right: 2,\n          top: 3,\n          bottom: 4\n        })\n      });\n    }\n\n    return this._constants;\n  }\n\n  set constants(_) {\n    throw new Error("app.constants is read-only");\n  }\n\n  get focusRect() {\n    return this._focusRect;\n  }\n\n  set focusRect(val) {\n    this._focusRect = val;\n  }\n\n  get formsVersion() {\n    return FORMS_VERSION;\n  }\n\n  set formsVersion(_) {\n    throw new Error("app.formsVersion is read-only");\n  }\n\n  get fromPDFConverters() {\n    return [];\n  }\n\n  set fromPDFConverters(_) {\n    throw new Error("app.fromPDFConverters is read-only");\n  }\n\n  get fs() {\n    if (this._fs === null) {\n      this._fs = new Proxy(new _fullscreen.FullScreen({\n        send: this._send\n      }), this._proxyHandler);\n    }\n\n    return this._fs;\n  }\n\n  set fs(_) {\n    throw new Error("app.fs is read-only");\n  }\n\n  get language() {\n    return this._language;\n  }\n\n  set language(_) {\n    throw new Error("app.language is read-only");\n  }\n\n  get media() {\n    return undefined;\n  }\n\n  set media(_) {\n    throw new Error("app.media is read-only");\n  }\n\n  get monitors() {\n    return [];\n  }\n\n  set monitors(_) {\n    throw new Error("app.monitors is read-only");\n  }\n\n  get numPlugins() {\n    return 0;\n  }\n\n  set numPlugins(_) {\n    throw new Error("app.numPlugins is read-only");\n  }\n\n  get openInPlace() {\n    return this._openInPlace;\n  }\n\n  set openInPlace(val) {\n    this._openInPlace = val;\n  }\n\n  get platform() {\n    return this._platform;\n  }\n\n  set platform(_) {\n    throw new Error("app.platform is read-only");\n  }\n\n  get plugins() {\n    return [];\n  }\n\n  set plugins(_) {\n    throw new Error("app.plugins is read-only");\n  }\n\n  get printColorProfiles() {\n    return [];\n  }\n\n  set printColorProfiles(_) {\n    throw new Error("app.printColorProfiles is read-only");\n  }\n\n  get printerNames() {\n    return [];\n  }\n\n  set printerNames(_) {\n    throw new Error("app.printerNames is read-only");\n  }\n\n  get runtimeHighlight() {\n    return this._runtimeHighlight;\n  }\n\n  set runtimeHighlight(val) {\n    this._runtimeHighlight = val;\n  }\n\n  get runtimeHighlightColor() {\n    return this._runtimeHighlightColor;\n  }\n\n  set runtimeHighlightColor(val) {\n    if (_color.Color._isValidColor(val)) {\n      this._runtimeHighlightColor = val;\n    }\n  }\n\n  get thermometer() {\n    if (this._thermometer === null) {\n      this._thermometer = new Proxy(new _thermometer.Thermometer({\n        send: this._send\n      }), this._proxyHandler);\n    }\n\n    return this._thermometer;\n  }\n\n  set thermometer(_) {\n    throw new Error("app.thermometer is read-only");\n  }\n\n  get toolbar() {\n    return this._toolbar;\n  }\n\n  set toolbar(val) {\n    this._toolbar = val;\n  }\n\n  get toolbarHorizontal() {\n    return this.toolbar;\n  }\n\n  set toolbarHorizontal(value) {\n    this.toolbar = value;\n  }\n\n  get toolbarVertical() {\n    return this.toolbar;\n  }\n\n  set toolbarVertical(value) {\n    this.toolbar = value;\n  }\n\n  get viewerType() {\n    return VIEWER_TYPE;\n  }\n\n  set viewerType(_) {\n    throw new Error("app.viewerType is read-only");\n  }\n\n  get viewerVariation() {\n    return VIEWER_VARIATION;\n  }\n\n  set viewerVariation(_) {\n    throw new Error("app.viewerVariation is read-only");\n  }\n\n  get viewerVersion() {\n    return VIEWER_VERSION;\n  }\n\n  set viewerVersion(_) {\n    throw new Error("app.viewerVersion is read-only");\n  }\n\n  addMenuItem() {}\n\n  addSubMenu() {}\n\n  addToolButton() {}\n\n  alert(cMsg, nIcon = 0, nType = 0, cTitle = "PDF.js", oDoc = null, oCheckbox = null) {\n    if (typeof cMsg === "object") {\n      nType = cMsg.nType;\n      cMsg = cMsg.cMsg;\n    }\n\n    cMsg = (cMsg || "").toString();\n    nType = typeof nType !== "number" || isNaN(nType) || nType < 0 || nType > 3 ? 0 : nType;\n\n    if (nType >= 2) {\n      return this._externalCall("confirm", [cMsg]) ? 4 : 3;\n    }\n\n    this._externalCall("alert", [cMsg]);\n\n    return 1;\n  }\n\n  beep() {}\n\n  beginPriv() {}\n\n  browseForDoc() {}\n\n  clearInterval(oInterval) {\n    this._unregisterTimeout(oInterval);\n  }\n\n  clearTimeOut(oTime) {\n    this._unregisterTimeout(oTime);\n  }\n\n  endPriv() {}\n\n  execDialog() {}\n\n  execMenuItem() {}\n\n  getNthPlugInName() {}\n\n  getPath() {}\n\n  goBack() {}\n\n  goForward() {}\n\n  hideMenuItem() {}\n\n  hideToolbarButton() {}\n\n  launchURL() {}\n\n  listMenuItems() {}\n\n  listToolbarButtons() {}\n\n  loadPolicyFile() {}\n\n  mailGetAddrs() {}\n\n  mailMsg() {}\n\n  newDoc() {}\n\n  newCollection() {}\n\n  newFDF() {}\n\n  openDoc() {}\n\n  openFDF() {}\n\n  popUpMenu() {}\n\n  popUpMenuEx() {}\n\n  removeToolButton() {}\n\n  response(cQuestion, cTitle = "", cDefault = "", bPassword = "", cLabel = "") {\n    if (typeof cQuestion === "object") {\n      cDefault = cQuestion.cDefault;\n      cQuestion = cQuestion.cQuestion;\n    }\n\n    cQuestion = (cQuestion || "").toString();\n    cDefault = (cDefault || "").toString();\n    return this._externalCall("prompt", [cQuestion, cDefault || ""]);\n  }\n\n  setInterval(cExpr, nMilliseconds = 0) {\n    if (typeof cExpr === "object") {\n      nMilliseconds = cExpr.nMilliseconds || 0;\n      cExpr = cExpr.cExpr;\n    }\n\n    if (typeof cExpr !== "string") {\n      throw new TypeError("First argument of app.setInterval must be a string");\n    }\n\n    if (typeof nMilliseconds !== "number") {\n      throw new TypeError("Second argument of app.setInterval must be a number");\n    }\n\n    const callbackId = this._registerTimeoutCallback(cExpr);\n\n    this._externalCall("setInterval", [callbackId, nMilliseconds]);\n\n    return this._registerTimeout(callbackId, true);\n  }\n\n  setTimeOut(cExpr, nMilliseconds = 0) {\n    if (typeof cExpr === "object") {\n      nMilliseconds = cExpr.nMilliseconds || 0;\n      cExpr = cExpr.cExpr;\n    }\n\n    if (typeof cExpr !== "string") {\n      throw new TypeError("First argument of app.setTimeOut must be a string");\n    }\n\n    if (typeof nMilliseconds !== "number") {\n      throw new TypeError("Second argument of app.setTimeOut must be a number");\n    }\n\n    const callbackId = this._registerTimeoutCallback(cExpr);\n\n    this._externalCall("setTimeout", [callbackId, nMilliseconds]);\n\n    return this._registerTimeout(callbackId, false);\n  }\n\n  trustedFunction() {}\n\n  trustPropagatorFunction() {}\n\n}\n\nexports.App = App;\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.EventDispatcher = exports.Event = void 0;\n\nclass Event {\n  constructor(data) {\n    this.change = data.change || "";\n    this.changeEx = data.changeEx || null;\n    this.commitKey = data.commitKey || 0;\n    this.fieldFull = data.fieldFull || false;\n    this.keyDown = data.keyDown || false;\n    this.modifier = data.modifier || false;\n    this.name = data.name;\n    this.rc = true;\n    this.richChange = data.richChange || [];\n    this.richChangeEx = data.richChangeEx || [];\n    this.richValue = data.richValue || [];\n    this.selEnd = data.selEnd || -1;\n    this.selStart = data.selStart || -1;\n    this.shift = data.shift || false;\n    this.source = data.source || null;\n    this.target = data.target || null;\n    this.targetName = "";\n    this.type = "Field";\n    this.value = data.value || "";\n    this.willCommit = data.willCommit || false;\n  }\n\n}\n\nexports.Event = Event;\n\nclass EventDispatcher {\n  constructor(document, calculationOrder, objects) {\n    this._document = document;\n    this._calculationOrder = calculationOrder;\n    this._objects = objects;\n    this._document.obj._eventDispatcher = this;\n  }\n\n  mergeChange(event) {\n    let value = event.value;\n\n    if (typeof value !== "string") {\n      value = value.toString();\n    }\n\n    const prefix = event.selStart >= 0 ? value.substring(0, event.selStart) : "";\n    const postfix = event.selEnd >= 0 && event.selEnd <= value.length ? value.substring(event.selEnd) : "";\n    return `${prefix}${event.change}${postfix}`;\n  }\n\n  dispatch(baseEvent) {\n    const id = baseEvent.id;\n\n    if (!(id in this._objects)) {\n      let event;\n\n      if (id === "doc" || id === "page") {\n        event = globalThis.event = new Event(baseEvent);\n        event.source = event.target = this._document.wrapped;\n        event.name = baseEvent.name;\n      }\n\n      if (id === "doc") {\n        this._document.obj._dispatchDocEvent(event.name);\n      } else if (id === "page") {\n        this._document.obj._dispatchPageEvent(event.name, baseEvent.actions, baseEvent.pageNumber);\n      }\n\n      return;\n    }\n\n    const name = baseEvent.name;\n    const source = this._objects[id];\n    const event = globalThis.event = new Event(baseEvent);\n    let savedChange;\n\n    if (source.obj._isButton()) {\n      source.obj._id = id;\n      event.value = source.obj._getExportValue(event.value);\n\n      if (name === "Action") {\n        source.obj._value = event.value;\n      }\n    }\n\n    switch (name) {\n      case "Keystroke":\n        savedChange = {\n          value: event.value,\n          change: event.change,\n          selStart: event.selStart,\n          selEnd: event.selEnd\n        };\n        break;\n\n      case "Blur":\n      case "Focus":\n        Object.defineProperty(event, "value", {\n          configurable: false,\n          writable: false,\n          enumerable: true,\n          value: event.value\n        });\n        break;\n\n      case "Validate":\n        this.runValidation(source, event);\n        return;\n\n      case "Action":\n        this.runActions(source, source, event, name);\n\n        if (this._document.obj.calculate) {\n          this.runCalculate(source, event);\n        }\n\n        return;\n    }\n\n    this.runActions(source, source, event, name);\n\n    if (name === "Keystroke") {\n      if (event.rc) {\n        if (event.willCommit) {\n          this.runValidation(source, event);\n        } else if (event.change !== savedChange.change || event.selStart !== savedChange.selStart || event.selEnd !== savedChange.selEnd) {\n          source.wrapped.value = this.mergeChange(event);\n        }\n      } else if (!event.willCommit) {\n        source.obj._send({\n          id: source.obj._id,\n          value: savedChange.value,\n          selRange: [savedChange.selStart, savedChange.selEnd]\n        });\n      }\n    }\n  }\n\n  runValidation(source, event) {\n    const hasRan = this.runActions(source, source, event, "Validate");\n\n    if (event.rc) {\n      if (hasRan) {\n        source.wrapped.value = event.value;\n        source.wrapped.valueAsString = event.value;\n      } else {\n        source.obj.value = event.value;\n        source.obj.valueAsString = event.value;\n      }\n\n      if (this._document.obj.calculate) {\n        this.runCalculate(source, event);\n      }\n\n      event.value = source.obj.value;\n      this.runActions(source, source, event, "Format");\n      source.wrapped.valueAsString = event.value;\n    }\n  }\n\n  runActions(source, target, event, eventName) {\n    event.source = source.wrapped;\n    event.target = target.wrapped;\n    event.name = eventName;\n    event.targetName = target.obj.name;\n    event.rc = true;\n    return target.obj._runActions(event);\n  }\n\n  calculateNow() {\n    if (!this._calculationOrder) {\n      return;\n    }\n\n    const first = this._calculationOrder[0];\n    const source = this._objects[first];\n    globalThis.event = new Event({});\n    this.runCalculate(source, globalThis.event);\n  }\n\n  runCalculate(source, event) {\n    if (!this._calculationOrder) {\n      return;\n    }\n\n    for (const targetId of this._calculationOrder) {\n      if (!(targetId in this._objects)) {\n        continue;\n      }\n\n      if (!this._document.obj.calculate) {\n        continue;\n      }\n\n      event.value = null;\n      const target = this._objects[targetId];\n      this.runActions(source, target, event, "Calculate");\n\n      if (!event.rc) {\n        continue;\n      }\n\n      if (event.value !== null) {\n        target.wrapped.value = event.value;\n      }\n\n      event.value = target.obj.value;\n      this.runActions(target, target, event, "Validate");\n\n      if (!event.rc) {\n        continue;\n      }\n\n      event.value = target.obj.value;\n      this.runActions(target, target, event, "Format");\n\n      if (event.value !== null) {\n        target.wrapped.valueAsString = event.value;\n      }\n    }\n  }\n\n}\n\nexports.EventDispatcher = EventDispatcher;\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.FullScreen = void 0;\n\nvar _constants = __w_pdfjs_require__(2);\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nclass FullScreen extends _pdf_object.PDFObject {\n  constructor(data) {\n    super(data);\n    this._backgroundColor = [];\n    this._clickAdvances = true;\n    this._cursor = _constants.Cursor.hidden;\n    this._defaultTransition = "";\n    this._escapeExits = true;\n    this._isFullScreen = true;\n    this._loop = false;\n    this._timeDelay = 3600;\n    this._usePageTiming = false;\n    this._useTimer = false;\n  }\n\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n\n  set backgroundColor(_) {}\n\n  get clickAdvances() {\n    return this._clickAdvances;\n  }\n\n  set clickAdvances(_) {}\n\n  get cursor() {\n    return this._cursor;\n  }\n\n  set cursor(_) {}\n\n  get defaultTransition() {\n    return this._defaultTransition;\n  }\n\n  set defaultTransition(_) {}\n\n  get escapeExits() {\n    return this._escapeExits;\n  }\n\n  set escapeExits(_) {}\n\n  get isFullScreen() {\n    return this._isFullScreen;\n  }\n\n  set isFullScreen(_) {}\n\n  get loop() {\n    return this._loop;\n  }\n\n  set loop(_) {}\n\n  get timeDelay() {\n    return this._timeDelay;\n  }\n\n  set timeDelay(_) {}\n\n  get transitions() {\n    return ["Replace", "WipeRight", "WipeLeft", "WipeDown", "WipeUp", "SplitHorizontalIn", "SplitHorizontalOut", "SplitVerticalIn", "SplitVerticalOut", "BlindsHorizontal", "BlindsVertical", "BoxIn", "BoxOut", "GlitterRight", "GlitterDown", "GlitterRightDown", "Dissolve", "Random"];\n  }\n\n  set transitions(_) {\n    throw new Error("fullscreen.transitions is read-only");\n  }\n\n  get usePageTiming() {\n    return this._usePageTiming;\n  }\n\n  set usePageTiming(_) {}\n\n  get useTimer() {\n    return this._useTimer;\n  }\n\n  set useTimer(_) {}\n\n}\n\nexports.FullScreen = FullScreen;\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.Thermometer = void 0;\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nclass Thermometer extends _pdf_object.PDFObject {\n  constructor(data) {\n    super(data);\n    this._cancelled = false;\n    this._duration = 100;\n    this._text = "";\n    this._value = 0;\n  }\n\n  get cancelled() {\n    return this._cancelled;\n  }\n\n  set cancelled(_) {\n    throw new Error("thermometer.cancelled is read-only");\n  }\n\n  get duration() {\n    return this._duration;\n  }\n\n  set duration(val) {\n    this._duration = val;\n  }\n\n  get text() {\n    return this._text;\n  }\n\n  set text(val) {\n    this._text = val;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(val) {\n    this._value = val;\n  }\n\n  begin() {}\n\n  end() {}\n\n}\n\nexports.Thermometer = Thermometer;\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.Console = void 0;\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nclass Console extends _pdf_object.PDFObject {\n  clear() {\n    this._send({\n      id: "clear"\n    });\n  }\n\n  hide() {}\n\n  println(msg) {\n    if (typeof msg === "string") {\n      this._send({\n        command: "println",\n        value: "PDF.js Console:: " + msg\n      });\n    }\n  }\n\n  show() {}\n\n}\n\nexports.Console = Console;\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.Doc = void 0;\n\nvar _common = __w_pdfjs_require__(4);\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nvar _print_params = __w_pdfjs_require__(15);\n\nvar _constants = __w_pdfjs_require__(2);\n\nclass InfoProxyHandler {\n  static get(obj, prop) {\n    return obj[prop.toLowerCase()];\n  }\n\n  static set(obj, prop, value) {\n    throw new Error(`doc.info.${prop} is read-only`);\n  }\n\n}\n\nclass Doc extends _pdf_object.PDFObject {\n  constructor(data) {\n    super(data);\n    this._expandos = globalThis;\n    this._baseURL = data.baseURL || "";\n    this._calculate = true;\n    this._delay = false;\n    this._dirty = false;\n    this._disclosed = false;\n    this._media = undefined;\n    this._metadata = data.metadata || "";\n    this._noautocomplete = undefined;\n    this._nocache = undefined;\n    this._spellDictionaryOrder = [];\n    this._spellLanguageOrder = [];\n    this._printParams = null;\n    this._fields = new Map();\n    this._fieldNames = [];\n    this._event = null;\n    this._author = data.Author || "";\n    this._creator = data.Creator || "";\n    this._creationDate = this._getDate(data.CreationDate) || null;\n    this._docID = data.docID || ["", ""];\n    this._documentFileName = data.filename || "";\n    this._filesize = data.filesize || 0;\n    this._keywords = data.Keywords || "";\n    this._layout = data.layout || "";\n    this._modDate = this._getDate(data.ModDate) || null;\n    this._numFields = 0;\n    this._numPages = data.numPages || 1;\n    this._pageNum = data.pageNum || 0;\n    this._producer = data.Producer || "";\n    this._subject = data.Subject || "";\n    this._title = data.Title || "";\n    this._URL = data.URL || "";\n    this._info = new Proxy({\n      title: this._title,\n      author: this._author,\n      authors: data.authors || [this._author],\n      subject: this._subject,\n      keywords: this._keywords,\n      creator: this._creator,\n      producer: this._producer,\n      creationdate: this._creationDate,\n      moddate: this._modDate,\n      trapped: data.Trapped || "Unknown"\n    }, InfoProxyHandler);\n    this._zoomType = _constants.ZoomType.none;\n    this._zoom = data.zoom || 100;\n    this._actions = (0, _common.createActionsMap)(data.actions);\n    this._globalEval = data.globalEval;\n    this._pageActions = new Map();\n  }\n\n  _dispatchDocEvent(name) {\n    if (name === "Open") {\n      const dontRun = new Set(["WillClose", "WillSave", "DidSave", "WillPrint", "DidPrint", "OpenAction"]);\n\n      for (const actionName of this._actions.keys()) {\n        if (!dontRun.has(actionName)) {\n          this._runActions(actionName);\n        }\n      }\n\n      this._runActions("OpenAction");\n    } else {\n      this._runActions(name);\n    }\n  }\n\n  _dispatchPageEvent(name, actions, pageNumber) {\n    if (name === "PageOpen") {\n      if (!this._pageActions.has(pageNumber)) {\n        this._pageActions.set(pageNumber, (0, _common.createActionsMap)(actions));\n      }\n\n      this._pageNum = pageNumber - 1;\n    }\n\n    actions = this._pageActions.get(pageNumber)?.get(name);\n\n    if (actions) {\n      for (const action of actions) {\n        this._globalEval(action);\n      }\n    }\n  }\n\n  _runActions(name) {\n    const actions = this._actions.get(name);\n\n    if (actions) {\n      for (const action of actions) {\n        this._globalEval(action);\n      }\n    }\n  }\n\n  _addField(name, field) {\n    this._fields.set(name, field);\n\n    this._fieldNames.push(name);\n\n    this._numFields++;\n  }\n\n  _getDate(date) {\n    if (!date || date.length < 15 || !date.startsWith("D:")) {\n      return date;\n    }\n\n    date = date.substring(2);\n    const year = date.substring(0, 4);\n    const month = date.substring(4, 6);\n    const day = date.substring(6, 8);\n    const hour = date.substring(8, 10);\n    const minute = date.substring(10, 12);\n    const o = date.charAt(12);\n    let second, offsetPos;\n\n    if (o === "Z" || o === "+" || o === "-") {\n      second = "00";\n      offsetPos = 12;\n    } else {\n      second = date.substring(12, 14);\n      offsetPos = 14;\n    }\n\n    const offset = date.substring(offsetPos).replaceAll("\'", "");\n    return new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}${offset}`);\n  }\n\n  get author() {\n    return this._author;\n  }\n\n  set author(_) {\n    throw new Error("doc.author is read-only");\n  }\n\n  get baseURL() {\n    return this._baseURL;\n  }\n\n  set baseURL(baseURL) {\n    this._baseURL = baseURL;\n  }\n\n  get bookmarkRoot() {\n    return undefined;\n  }\n\n  set bookmarkRoot(_) {\n    throw new Error("doc.bookmarkRoot is read-only");\n  }\n\n  get calculate() {\n    return this._calculate;\n  }\n\n  set calculate(calculate) {\n    this._calculate = calculate;\n  }\n\n  get creator() {\n    return this._creator;\n  }\n\n  set creator(_) {\n    throw new Error("doc.creator is read-only");\n  }\n\n  get dataObjects() {\n    return [];\n  }\n\n  set dataObjects(_) {\n    throw new Error("doc.dataObjects is read-only");\n  }\n\n  get delay() {\n    return this._delay;\n  }\n\n  set delay(delay) {\n    this._delay = delay;\n  }\n\n  get dirty() {\n    return this._dirty;\n  }\n\n  set dirty(dirty) {\n    this._dirty = dirty;\n  }\n\n  get disclosed() {\n    return this._disclosed;\n  }\n\n  set disclosed(disclosed) {\n    this._disclosed = disclosed;\n  }\n\n  get docID() {\n    return this._docID;\n  }\n\n  set docID(_) {\n    throw new Error("doc.docID is read-only");\n  }\n\n  get documentFileName() {\n    return this._documentFileName;\n  }\n\n  set documentFileName(_) {\n    throw new Error("doc.documentFileName is read-only");\n  }\n\n  get dynamicXFAForm() {\n    return false;\n  }\n\n  set dynamicXFAForm(_) {\n    throw new Error("doc.dynamicXFAForm is read-only");\n  }\n\n  get external() {\n    return true;\n  }\n\n  set external(_) {\n    throw new Error("doc.external is read-only");\n  }\n\n  get filesize() {\n    return this._filesize;\n  }\n\n  set filesize(_) {\n    throw new Error("doc.filesize is read-only");\n  }\n\n  get hidden() {\n    return false;\n  }\n\n  set hidden(_) {\n    throw new Error("doc.hidden is read-only");\n  }\n\n  get hostContainer() {\n    return undefined;\n  }\n\n  set hostContainer(_) {\n    throw new Error("doc.hostContainer is read-only");\n  }\n\n  get icons() {\n    return undefined;\n  }\n\n  set icons(_) {\n    throw new Error("doc.icons is read-only");\n  }\n\n  get info() {\n    return this._info;\n  }\n\n  set info(_) {\n    throw new Error("doc.info is read-only");\n  }\n\n  get innerAppWindowRect() {\n    return [0, 0, 0, 0];\n  }\n\n  set innerAppWindowRect(_) {\n    throw new Error("doc.innerAppWindowRect is read-only");\n  }\n\n  get innerDocWindowRect() {\n    return [0, 0, 0, 0];\n  }\n\n  set innerDocWindowRect(_) {\n    throw new Error("doc.innerDocWindowRect is read-only");\n  }\n\n  get isModal() {\n    return false;\n  }\n\n  set isModal(_) {\n    throw new Error("doc.isModal is read-only");\n  }\n\n  get keywords() {\n    return this._keywords;\n  }\n\n  set keywords(_) {\n    throw new Error("doc.keywords is read-only");\n  }\n\n  get layout() {\n    return this._layout;\n  }\n\n  set layout(value) {\n    if (typeof value !== "string") {\n      return;\n    }\n\n    if (value !== "SinglePage" && value !== "OneColumn" && value !== "TwoColumnLeft" && value !== "TwoPageLeft" && value !== "TwoColumnRight" && value !== "TwoPageRight") {\n      value = "SinglePage";\n    }\n\n    this._send({\n      command: "layout",\n      value\n    });\n\n    this._layout = value;\n  }\n\n  get media() {\n    return this._media;\n  }\n\n  set media(media) {\n    this._media = media;\n  }\n\n  get metadata() {\n    return this._metadata;\n  }\n\n  set metadata(metadata) {\n    this._metadata = metadata;\n  }\n\n  get modDate() {\n    return this._modDate;\n  }\n\n  set modDate(_) {\n    throw new Error("doc.modDate is read-only");\n  }\n\n  get mouseX() {\n    return 0;\n  }\n\n  set mouseX(_) {\n    throw new Error("doc.mouseX is read-only");\n  }\n\n  get mouseY() {\n    return 0;\n  }\n\n  set mouseY(_) {\n    throw new Error("doc.mouseY is read-only");\n  }\n\n  get noautocomplete() {\n    return this._noautocomplete;\n  }\n\n  set noautocomplete(noautocomplete) {\n    this._noautocomplete = noautocomplete;\n  }\n\n  get nocache() {\n    return this._nocache;\n  }\n\n  set nocache(nocache) {\n    this._nocache = nocache;\n  }\n\n  get numFields() {\n    return this._numFields;\n  }\n\n  set numFields(_) {\n    throw new Error("doc.numFields is read-only");\n  }\n\n  get numPages() {\n    return this._numPages;\n  }\n\n  set numPages(_) {\n    throw new Error("doc.numPages is read-only");\n  }\n\n  get numTemplates() {\n    return 0;\n  }\n\n  set numTemplates(_) {\n    throw new Error("doc.numTemplates is read-only");\n  }\n\n  get outerAppWindowRect() {\n    return [0, 0, 0, 0];\n  }\n\n  set outerAppWindowRect(_) {\n    throw new Error("doc.outerAppWindowRect is read-only");\n  }\n\n  get outerDocWindowRect() {\n    return [0, 0, 0, 0];\n  }\n\n  set outerDocWindowRect(_) {\n    throw new Error("doc.outerDocWindowRect is read-only");\n  }\n\n  get pageNum() {\n    return this._pageNum;\n  }\n\n  set pageNum(value) {\n    if (typeof value !== "number" || value < 0 || value >= this._numPages) {\n      return;\n    }\n\n    this._send({\n      command: "page-num",\n      value\n    });\n\n    this._pageNum = value;\n  }\n\n  get pageWindowRect() {\n    return [0, 0, 0, 0];\n  }\n\n  set pageWindowRect(_) {\n    throw new Error("doc.pageWindowRect is read-only");\n  }\n\n  get path() {\n    return "";\n  }\n\n  set path(_) {\n    throw new Error("doc.path is read-only");\n  }\n\n  get permStatusReady() {\n    return true;\n  }\n\n  set permStatusReady(_) {\n    throw new Error("doc.permStatusReady is read-only");\n  }\n\n  get producer() {\n    return this._producer;\n  }\n\n  set producer(_) {\n    throw new Error("doc.producer is read-only");\n  }\n\n  get requiresFullSave() {\n    return false;\n  }\n\n  set requiresFullSave(_) {\n    throw new Error("doc.requiresFullSave is read-only");\n  }\n\n  get securityHandler() {\n    return null;\n  }\n\n  set securityHandler(_) {\n    throw new Error("doc.securityHandler is read-only");\n  }\n\n  get selectedAnnots() {\n    return [];\n  }\n\n  set selectedAnnots(_) {\n    throw new Error("doc.selectedAnnots is read-only");\n  }\n\n  get sounds() {\n    return [];\n  }\n\n  set sounds(_) {\n    throw new Error("doc.sounds is read-only");\n  }\n\n  get spellDictionaryOrder() {\n    return this._spellDictionaryOrder;\n  }\n\n  set spellDictionaryOrder(spellDictionaryOrder) {\n    this._spellDictionaryOrder = spellDictionaryOrder;\n  }\n\n  get spellLanguageOrder() {\n    return this._spellLanguageOrder;\n  }\n\n  set spellLanguageOrder(spellLanguageOrder) {\n    this._spellLanguageOrder = spellLanguageOrder;\n  }\n\n  get subject() {\n    return this._subject;\n  }\n\n  set subject(_) {\n    throw new Error("doc.subject is read-only");\n  }\n\n  get templates() {\n    return [];\n  }\n\n  set templates(_) {\n    throw new Error("doc.templates is read-only");\n  }\n\n  get title() {\n    return this._title;\n  }\n\n  set title(_) {\n    throw new Error("doc.title is read-only");\n  }\n\n  get URL() {\n    return this._URL;\n  }\n\n  set URL(_) {\n    throw new Error("doc.URL is read-only");\n  }\n\n  get viewState() {\n    return undefined;\n  }\n\n  set viewState(_) {\n    throw new Error("doc.viewState is read-only");\n  }\n\n  get xfa() {\n    return this._xfa;\n  }\n\n  set xfa(_) {\n    throw new Error("doc.xfa is read-only");\n  }\n\n  get XFAForeground() {\n    return false;\n  }\n\n  set XFAForeground(_) {\n    throw new Error("doc.XFAForeground is read-only");\n  }\n\n  get zoomType() {\n    return this._zoomType;\n  }\n\n  set zoomType(type) {\n    if (typeof type !== "string") {\n      return;\n    }\n\n    switch (type) {\n      case _constants.ZoomType.none:\n        this._send({\n          command: "zoom",\n          value: 1\n        });\n\n        break;\n\n      case _constants.ZoomType.fitP:\n        this._send({\n          command: "zoom",\n          value: "page-fit"\n        });\n\n        break;\n\n      case _constants.ZoomType.fitW:\n        this._send({\n          command: "zoom",\n          value: "page-width"\n        });\n\n        break;\n\n      case _constants.ZoomType.fitH:\n        this._send({\n          command: "zoom",\n          value: "page-height"\n        });\n\n        break;\n\n      case _constants.ZoomType.fitV:\n        this._send({\n          command: "zoom",\n          value: "auto"\n        });\n\n        break;\n\n      case _constants.ZoomType.pref:\n      case _constants.ZoomType.refW:\n        break;\n\n      default:\n        return;\n    }\n\n    this._zoomType = type;\n  }\n\n  get zoom() {\n    return this._zoom;\n  }\n\n  set zoom(value) {\n    if (typeof value !== "number" || value < 8.33 || value > 6400) {\n      return;\n    }\n\n    this._send({\n      command: "zoom",\n      value: value / 100\n    });\n  }\n\n  addAnnot() {}\n\n  addField() {}\n\n  addIcon() {}\n\n  addLink() {}\n\n  addRecipientListCryptFilter() {}\n\n  addRequirement() {}\n\n  addScript() {}\n\n  addThumbnails() {}\n\n  addWatermarkFromFile() {}\n\n  addWatermarkFromText() {}\n\n  addWeblinks() {}\n\n  bringToFront() {}\n\n  calculateNow() {\n    this._eventDispatcher.calculateNow();\n  }\n\n  closeDoc() {}\n\n  colorConvertPage() {}\n\n  createDataObject() {}\n\n  createTemplate() {}\n\n  deletePages() {}\n\n  deleteSound() {}\n\n  embedDocAsDataObject() {}\n\n  embedOutputIntent() {}\n\n  encryptForRecipients() {}\n\n  encryptUsingPolicy() {}\n\n  exportAsFDF() {}\n\n  exportAsFDFStr() {}\n\n  exportAsText() {}\n\n  exportAsXFDF() {}\n\n  exportAsXFDFStr() {}\n\n  exportDataObject() {}\n\n  exportXFAData() {}\n\n  extractPages() {}\n\n  flattenPages() {}\n\n  getAnnot() {}\n\n  getAnnots() {}\n\n  getAnnot3D() {}\n\n  getAnnots3D() {}\n\n  getColorConvertAction() {}\n\n  getDataObject() {}\n\n  getDataObjectContents() {}\n\n  getField(cName) {\n    if (typeof cName === "object") {\n      cName = cName.cName;\n    }\n\n    if (typeof cName !== "string") {\n      throw new TypeError("Invalid field name: must be a string");\n    }\n\n    const searchedField = this._fields.get(cName);\n\n    if (searchedField) {\n      return searchedField;\n    }\n\n    const parts = cName.split("#");\n    let childIndex = NaN;\n\n    if (parts.length === 2) {\n      childIndex = Math.floor(parseFloat(parts[1]));\n      cName = parts[0];\n    }\n\n    for (const [name, field] of this._fields.entries()) {\n      if (name.endsWith(cName)) {\n        if (!isNaN(childIndex)) {\n          const children = this._getChildren(name);\n\n          if (childIndex < 0 || childIndex >= children.length) {\n            childIndex = 0;\n          }\n\n          if (childIndex < children.length) {\n            this._fields.set(cName, children[childIndex]);\n\n            return children[childIndex];\n          }\n        }\n\n        this._fields.set(cName, field);\n\n        return field;\n      }\n    }\n\n    return null;\n  }\n\n  _getChildren(fieldName) {\n    const len = fieldName.length;\n    const children = [];\n    const pattern = /^\\.[^.]+$/;\n\n    for (const [name, field] of this._fields.entries()) {\n      if (name.startsWith(fieldName)) {\n        const finalPart = name.slice(len);\n\n        if (finalPart.match(pattern)) {\n          children.push(field);\n        }\n      }\n    }\n\n    return children;\n  }\n\n  getIcon() {}\n\n  getLegalWarnings() {}\n\n  getLinks() {}\n\n  getNthFieldName(nIndex) {\n    if (typeof nIndex === "object") {\n      nIndex = nIndex.nIndex;\n    }\n\n    if (typeof nIndex !== "number") {\n      throw new TypeError("Invalid field index: must be a number");\n    }\n\n    if (0 <= nIndex && nIndex < this.numFields) {\n      return this._fieldNames[Math.trunc(nIndex)];\n    }\n\n    return null;\n  }\n\n  getNthTemplate() {\n    return null;\n  }\n\n  getOCGs() {}\n\n  getOCGOrder() {}\n\n  getPageBox() {}\n\n  getPageLabel() {}\n\n  getPageNthWord() {}\n\n  getPageNthWordQuads() {}\n\n  getPageNumWords() {}\n\n  getPageRotation() {}\n\n  getPageTransition() {}\n\n  getPrintParams() {\n    if (!this._printParams) {\n      this._printParams = new _print_params.PrintParams({\n        lastPage: this._numPages - 1\n      });\n    }\n\n    return this._printParams;\n  }\n\n  getSound() {}\n\n  getTemplate() {}\n\n  getURL() {}\n\n  gotoNamedDest() {}\n\n  importAnFDF() {}\n\n  importAnXFDF() {}\n\n  importDataObject() {}\n\n  importIcon() {}\n\n  importSound() {}\n\n  importTextData() {}\n\n  importXFAData() {}\n\n  insertPages() {}\n\n  mailDoc() {}\n\n  mailForm() {}\n\n  movePage() {}\n\n  newPage() {}\n\n  openDataObject() {}\n\n  print(bUI = true, nStart = 0, nEnd = -1, bSilent = false, bShrinkToFit = false, bPrintAsImage = false, bReverse = false, bAnnotations = true, printParams = null) {\n    if (typeof bUI === "object") {\n      nStart = bUI.nStart;\n      nEnd = bUI.nEnd;\n      bSilent = bUI.bSilent;\n      bShrinkToFit = bUI.bShrinkToFit;\n      bPrintAsImage = bUI.bPrintAsImage;\n      bReverse = bUI.bReverse;\n      bAnnotations = bUI.bAnnotations;\n      printParams = bUI.printParams;\n      bUI = bUI.bUI;\n    }\n\n    if (printParams) {\n      nStart = printParams.firstPage;\n      nEnd = printParams.lastPage;\n    }\n\n    if (typeof nStart === "number") {\n      nStart = Math.max(0, Math.trunc(nStart));\n    } else {\n      nStart = 0;\n    }\n\n    if (typeof nEnd === "number") {\n      nEnd = Math.max(0, Math.trunc(nEnd));\n    } else {\n      nEnd = -1;\n    }\n\n    this._send({\n      command: "print",\n      start: nStart,\n      end: nEnd\n    });\n  }\n\n  removeDataObject() {}\n\n  removeField() {}\n\n  removeIcon() {}\n\n  removeLinks() {}\n\n  removeRequirement() {}\n\n  removeScript() {}\n\n  removeTemplate() {}\n\n  removeThumbnails() {}\n\n  removeWeblinks() {}\n\n  replacePages() {}\n\n  resetForm(aFields = null) {\n    if (aFields && !Array.isArray(aFields) && typeof aFields === "object") {\n      aFields = aFields.aFields;\n    }\n\n    let mustCalculate = false;\n\n    if (aFields) {\n      for (const fieldName of aFields) {\n        if (!fieldName) {\n          continue;\n        }\n\n        const field = this.getField(fieldName);\n\n        if (!field) {\n          continue;\n        }\n\n        field.value = field.defaultValue;\n        field.valueAsString = field.value;\n        mustCalculate = true;\n      }\n    } else {\n      mustCalculate = this._fields.size !== 0;\n\n      for (const field of this._fields.values()) {\n        field.value = field.defaultValue;\n        field.valueAsString = field.value;\n      }\n    }\n\n    if (mustCalculate) {\n      this.calculateNow();\n    }\n  }\n\n  saveAs() {}\n\n  scroll() {}\n\n  selectPageNthWord() {}\n\n  setAction() {}\n\n  setDataObjectContents() {}\n\n  setOCGOrder() {}\n\n  setPageAction() {}\n\n  setPageBoxes() {}\n\n  setPageLabels() {}\n\n  setPageRotations() {}\n\n  setPageTabOrder() {}\n\n  setPageTransitions() {}\n\n  spawnPageFromTemplate() {}\n\n  submitForm() {}\n\n  syncAnnotScan() {}\n\n}\n\nexports.Doc = Doc;\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PrintParams = void 0;\n\nclass PrintParams {\n  constructor(data) {\n    this.binaryOk = true;\n    this.bitmapDPI = 150;\n    this.booklet = {\n      binding: 0,\n      duplexMode: 0,\n      subsetFrom: 0,\n      subsetTo: -1\n    };\n    this.colorOverride = 0;\n    this.colorProfile = "";\n    this.constants = Object.freeze({\n      bookletBindings: Object.freeze({\n        Left: 0,\n        Right: 1,\n        LeftTall: 2,\n        RightTall: 3\n      }),\n      bookletDuplexMode: Object.freeze({\n        BothSides: 0,\n        FrontSideOnly: 1,\n        BasicSideOnly: 2\n      }),\n      colorOverrides: Object.freeze({\n        auto: 0,\n        gray: 1,\n        mono: 2\n      }),\n      fontPolicies: Object.freeze({\n        everyPage: 0,\n        jobStart: 1,\n        pageRange: 2\n      }),\n      handling: Object.freeze({\n        none: 0,\n        fit: 1,\n        shrink: 2,\n        tileAll: 3,\n        tileLarge: 4,\n        nUp: 5,\n        booklet: 6\n      }),\n      interactionLevel: Object.freeze({\n        automatic: 0,\n        full: 1,\n        silent: 2\n      }),\n      nUpPageOrders: Object.freeze({\n        Horizontal: 0,\n        HorizontalReversed: 1,\n        Vertical: 2\n      }),\n      printContents: Object.freeze({\n        doc: 0,\n        docAndComments: 1,\n        formFieldsOnly: 2\n      }),\n      flagValues: Object.freeze({\n        applyOverPrint: 1,\n        applySoftProofSettings: 1 << 1,\n        applyWorkingColorSpaces: 1 << 2,\n        emitHalftones: 1 << 3,\n        emitPostScriptXObjects: 1 << 4,\n        emitFormsAsPSForms: 1 << 5,\n        maxJP2KRes: 1 << 6,\n        setPageSize: 1 << 7,\n        suppressBG: 1 << 8,\n        suppressCenter: 1 << 9,\n        suppressCJKFontSubst: 1 << 10,\n        suppressCropClip: 1 << 1,\n        suppressRotate: 1 << 12,\n        suppressTransfer: 1 << 13,\n        suppressUCR: 1 << 14,\n        useTrapAnnots: 1 << 15,\n        usePrintersMarks: 1 << 16\n      }),\n      rasterFlagValues: Object.freeze({\n        textToOutline: 1,\n        strokesToOutline: 1 << 1,\n        allowComplexClip: 1 << 2,\n        preserveOverprint: 1 << 3\n      }),\n      subsets: Object.freeze({\n        all: 0,\n        even: 1,\n        odd: 2\n      }),\n      tileMarks: Object.freeze({\n        none: 0,\n        west: 1,\n        east: 2\n      }),\n      usages: Object.freeze({\n        auto: 0,\n        use: 1,\n        noUse: 2\n      })\n    });\n    this.downloadFarEastFonts = false;\n    this.fileName = "";\n    this.firstPage = 0;\n    this.flags = 0;\n    this.fontPolicy = 0;\n    this.gradientDPI = 150;\n    this.interactive = 1;\n    this.lastPage = data.lastPage;\n    this.npUpAutoRotate = false;\n    this.npUpNumPagesH = 2;\n    this.npUpNumPagesV = 2;\n    this.npUpPageBorder = false;\n    this.npUpPageOrder = 0;\n    this.pageHandling = 0;\n    this.pageSubset = 0;\n    this.printAsImage = false;\n    this.printContent = 0;\n    this.printerName = "";\n    this.psLevel = 0;\n    this.rasterFlags = 0;\n    this.reversePages = false;\n    this.tileLabel = false;\n    this.tileMark = 0;\n    this.tileOverlap = 0;\n    this.tileScale = 1.0;\n    this.transparencyLevel = 75;\n    this.usePrinterCRD = 0;\n    this.useT1Conversion = 0;\n  }\n\n}\n\nexports.PrintParams = PrintParams;\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ProxyHandler = void 0;\n\nclass ProxyHandler {\n  constructor() {\n    this.nosend = new Set(["delay"]);\n  }\n\n  get(obj, prop) {\n    if (prop in obj._expandos) {\n      const val = obj._expandos[prop];\n\n      if (typeof val === "function") {\n        return val.bind(obj);\n      }\n\n      return val;\n    }\n\n    if (typeof prop === "string" && !prop.startsWith("_") && prop in obj) {\n      const val = obj[prop];\n\n      if (typeof val === "function") {\n        return val.bind(obj);\n      }\n\n      return val;\n    }\n\n    return undefined;\n  }\n\n  set(obj, prop, value) {\n    if (obj._kidIds) {\n      obj._kidIds.forEach(id => {\n        obj._appObjects[id].wrapped[prop] = value;\n      });\n    }\n\n    if (typeof prop === "string" && !prop.startsWith("_") && prop in obj) {\n      const old = obj[prop];\n      obj[prop] = value;\n\n      if (!this.nosend.has(prop) && obj._send && obj._id !== null && typeof old !== "function") {\n        const data = {\n          id: obj._id\n        };\n        data[prop] = obj[prop];\n\n        if (!obj._siblings) {\n          obj._send(data);\n        } else {\n          data.siblings = obj._siblings;\n\n          obj._send(data);\n        }\n      }\n    } else {\n      obj._expandos[prop] = value;\n    }\n\n    return true;\n  }\n\n  has(obj, prop) {\n    return prop in obj._expandos || typeof prop === "string" && !prop.startsWith("_") && prop in obj;\n  }\n\n  getPrototypeOf(obj) {\n    return null;\n  }\n\n  setPrototypeOf(obj, proto) {\n    return false;\n  }\n\n  isExtensible(obj) {\n    return true;\n  }\n\n  preventExtensions(obj) {\n    return false;\n  }\n\n  getOwnPropertyDescriptor(obj, prop) {\n    if (prop in obj._expandos) {\n      return {\n        configurable: true,\n        enumerable: true,\n        value: obj._expandos[prop]\n      };\n    }\n\n    if (typeof prop === "string" && !prop.startsWith("_") && prop in obj) {\n      return {\n        configurable: true,\n        enumerable: true,\n        value: obj[prop]\n      };\n    }\n\n    return undefined;\n  }\n\n  defineProperty(obj, key, descriptor) {\n    Object.defineProperty(obj._expandos, key, descriptor);\n    return true;\n  }\n\n  deleteProperty(obj, prop) {\n    if (prop in obj._expandos) {\n      delete obj._expandos[prop];\n    }\n  }\n\n  ownKeys(obj) {\n    const fromExpandos = Reflect.ownKeys(obj._expandos);\n    const fromObj = Reflect.ownKeys(obj).filter(k => !k.startsWith("_"));\n    return fromExpandos.concat(fromObj);\n  }\n\n}\n\nexports.ProxyHandler = ProxyHandler;\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.Util = void 0;\n\nvar _pdf_object = __w_pdfjs_require__(7);\n\nclass Util extends _pdf_object.PDFObject {\n  constructor(data) {\n    super(data);\n    this._scandCache = new Map();\n    this._months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];\n    this._days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];\n    this.MILLISECONDS_IN_DAY = 86400000;\n    this.MILLISECONDS_IN_WEEK = 604800000;\n    this._externalCall = data.externalCall;\n  }\n\n  printf(...args) {\n    if (args.length === 0) {\n      throw new Error("Invalid number of params in printf");\n    }\n\n    if (typeof args[0] !== "string") {\n      throw new TypeError("First argument of printf must be a string");\n    }\n\n    const pattern = /%(,[0-4])?([+ 0#]+)?([0-9]+)?(\\.[0-9]+)?(.)/g;\n    const PLUS = 1;\n    const SPACE = 2;\n    const ZERO = 4;\n    const HASH = 8;\n    let i = 0;\n    return args[0].replace(pattern, function (match, nDecSep, cFlags, nWidth, nPrecision, cConvChar) {\n      if (cConvChar !== "d" && cConvChar !== "f" && cConvChar !== "s" && cConvChar !== "x") {\n        const buf = ["%"];\n\n        for (const str of [nDecSep, cFlags, nWidth, nPrecision, cConvChar]) {\n          if (str) {\n            buf.push(str);\n          }\n        }\n\n        return buf.join("");\n      }\n\n      i++;\n\n      if (i === args.length) {\n        throw new Error("Not enough arguments in printf");\n      }\n\n      const arg = args[i];\n\n      if (cConvChar === "s") {\n        return arg.toString();\n      }\n\n      let flags = 0;\n\n      if (cFlags) {\n        for (const flag of cFlags) {\n          switch (flag) {\n            case "+":\n              flags |= PLUS;\n              break;\n\n            case " ":\n              flags |= SPACE;\n              break;\n\n            case "0":\n              flags |= ZERO;\n              break;\n\n            case "#":\n              flags |= HASH;\n              break;\n          }\n        }\n      }\n\n      cFlags = flags;\n\n      if (nWidth) {\n        nWidth = parseInt(nWidth);\n      }\n\n      let intPart = Math.trunc(arg);\n\n      if (cConvChar === "x") {\n        let hex = Math.abs(intPart).toString(16).toUpperCase();\n\n        if (nWidth !== undefined) {\n          hex = hex.padStart(nWidth, cFlags & ZERO ? "0" : " ");\n        }\n\n        if (cFlags & HASH) {\n          hex = `0x${hex}`;\n        }\n\n        return hex;\n      }\n\n      if (nPrecision) {\n        nPrecision = parseInt(nPrecision.substring(1));\n      }\n\n      nDecSep = nDecSep ? nDecSep.substring(1) : "0";\n      const separators = {\n        0: [",", "."],\n        1: ["", "."],\n        2: [".", ","],\n        3: ["", ","],\n        4: ["\'", "."]\n      };\n      const [thousandSep, decimalSep] = separators[nDecSep];\n      let decPart = "";\n\n      if (cConvChar === "f") {\n        if (nPrecision !== undefined) {\n          decPart = Math.abs(arg - intPart).toFixed(nPrecision);\n        } else {\n          decPart = Math.abs(arg - intPart).toString();\n        }\n\n        if (decPart.length > 2) {\n          decPart = `${decimalSep}${decPart.substring(2)}`;\n        } else if (cFlags & HASH) {\n          decPart = ".";\n        } else {\n          decPart = "";\n        }\n      }\n\n      let sign = "";\n\n      if (intPart < 0) {\n        sign = "-";\n        intPart = -intPart;\n      } else if (cFlags & PLUS) {\n        sign = "+";\n      } else if (cFlags & SPACE) {\n        sign = " ";\n      }\n\n      if (thousandSep && intPart >= 1000) {\n        const buf = [];\n\n        while (true) {\n          buf.push((intPart % 1000).toString().padStart(3, "0"));\n          intPart = Math.trunc(intPart / 1000);\n\n          if (intPart < 1000) {\n            buf.push(intPart.toString());\n            break;\n          }\n        }\n\n        intPart = buf.reverse().join(thousandSep);\n      } else {\n        intPart = intPart.toString();\n      }\n\n      let n = `${intPart}${decPart}`;\n\n      if (nWidth !== undefined) {\n        n = n.padStart(nWidth - sign.length, cFlags & ZERO ? "0" : " ");\n      }\n\n      return `${sign}${n}`;\n    });\n  }\n\n  iconStreamFromIcon() {}\n\n  printd(cFormat, oDate) {\n    switch (cFormat) {\n      case 0:\n        return this.printd("D:yyyymmddHHMMss", oDate);\n\n      case 1:\n        return this.printd("yyyy.mm.dd HH:MM:ss", oDate);\n\n      case 2:\n        return this.printd("m/d/yy h:MM:ss tt", oDate);\n    }\n\n    const handlers = {\n      mmmm: data => {\n        return this._months[data.month];\n      },\n      mmm: data => {\n        return this._months[data.month].substring(0, 3);\n      },\n      mm: data => {\n        return (data.month + 1).toString().padStart(2, "0");\n      },\n      m: data => {\n        return (data.month + 1).toString();\n      },\n      dddd: data => {\n        return this._days[data.dayOfWeek];\n      },\n      ddd: data => {\n        return this._days[data.dayOfWeek].substring(0, 3);\n      },\n      dd: data => {\n        return data.day.toString().padStart(2, "0");\n      },\n      d: data => {\n        return data.day.toString();\n      },\n      yyyy: data => {\n        return data.year.toString();\n      },\n      yy: data => {\n        return (data.year % 100).toString().padStart(2, "0");\n      },\n      HH: data => {\n        return data.hours.toString().padStart(2, "0");\n      },\n      H: data => {\n        return data.hours.toString();\n      },\n      hh: data => {\n        return (1 + (data.hours + 11) % 12).toString().padStart(2, "0");\n      },\n      h: data => {\n        return (1 + (data.hours + 11) % 12).toString();\n      },\n      MM: data => {\n        return data.minutes.toString().padStart(2, "0");\n      },\n      M: data => {\n        return data.minutes.toString();\n      },\n      ss: data => {\n        return data.seconds.toString().padStart(2, "0");\n      },\n      s: data => {\n        return data.seconds.toString();\n      },\n      tt: data => {\n        return data.hours < 12 ? "am" : "pm";\n      },\n      t: data => {\n        return data.hours < 12 ? "a" : "p";\n      }\n    };\n    const data = {\n      year: oDate.getFullYear(),\n      month: oDate.getMonth(),\n      day: oDate.getDate(),\n      dayOfWeek: oDate.getDay(),\n      hours: oDate.getHours(),\n      minutes: oDate.getMinutes(),\n      seconds: oDate.getSeconds()\n    };\n    const patterns = /(mmmm|mmm|mm|m|dddd|ddd|dd|d|yyyy|yy|HH|H|hh|h|MM|M|ss|s|tt|t|\\\\.)/g;\n    return cFormat.replace(patterns, function (match, pattern) {\n      if (pattern in handlers) {\n        return handlers[pattern](data);\n      }\n\n      return pattern.charCodeAt(1);\n    });\n  }\n\n  printx(cFormat, cSource) {\n    const handlers = [x => x, x => x.toUpperCase(), x => x.toLowerCase()];\n    const buf = [];\n    let i = 0;\n    const ii = cSource.length;\n    let currCase = handlers[0];\n    let escaped = false;\n\n    for (const command of cFormat) {\n      if (escaped) {\n        buf.push(command);\n        escaped = false;\n        continue;\n      }\n\n      if (i >= ii) {\n        break;\n      }\n\n      switch (command) {\n        case "?":\n          buf.push(currCase(cSource.charAt(i++)));\n          break;\n\n        case "X":\n          while (i < ii) {\n            const char = cSource.charAt(i++);\n\n            if ("a" <= char && char <= "z" || "A" <= char && char <= "Z" || "0" <= char && char <= "9") {\n              buf.push(currCase(char));\n              break;\n            }\n          }\n\n          break;\n\n        case "A":\n          while (i < ii) {\n            const char = cSource.charAt(i++);\n\n            if ("a" <= char && char <= "z" || "A" <= char && char <= "Z") {\n              buf.push(currCase(char));\n              break;\n            }\n          }\n\n          break;\n\n        case "9":\n          while (i < ii) {\n            const char = cSource.charAt(i++);\n\n            if ("0" <= char && char <= "9") {\n              buf.push(char);\n              break;\n            }\n          }\n\n          break;\n\n        case "*":\n          while (i < ii) {\n            buf.push(currCase(cSource.charAt(i++)));\n          }\n\n          break;\n\n        case "\\\\":\n          escaped = true;\n          break;\n\n        case ">":\n          currCase = handlers[1];\n          break;\n\n        case "<":\n          currCase = handlers[2];\n          break;\n\n        case "=":\n          currCase = handlers[0];\n          break;\n\n        default:\n          buf.push(command);\n      }\n    }\n\n    return buf.join("");\n  }\n\n  scand(cFormat, cDate) {\n    if (cDate === "") {\n      return new Date();\n    }\n\n    switch (cFormat) {\n      case 0:\n        return this.scand("D:yyyymmddHHMMss", cDate);\n\n      case 1:\n        return this.scand("yyyy.mm.dd HH:MM:ss", cDate);\n\n      case 2:\n        return this.scand("m/d/yy h:MM:ss tt", cDate);\n    }\n\n    if (!this._scandCache.has(cFormat)) {\n      const months = this._months;\n      const days = this._days;\n      const handlers = {\n        mmmm: {\n          pattern: `(${months.join("|")})`,\n          action: (value, data) => {\n            data.month = months.indexOf(value);\n          }\n        },\n        mmm: {\n          pattern: `(${months.map(month => month.substring(0, 3)).join("|")})`,\n          action: (value, data) => {\n            data.month = months.findIndex(month => month.substring(0, 3) === value);\n          }\n        },\n        mm: {\n          pattern: `([0-9]{2})`,\n          action: (value, data) => {\n            data.month = parseInt(value) - 1;\n          }\n        },\n        m: {\n          pattern: `([0-9]{1,2})`,\n          action: (value, data) => {\n            data.month = parseInt(value) - 1;\n          }\n        },\n        dddd: {\n          pattern: `(${days.join("|")})`,\n          action: (value, data) => {\n            data.day = days.indexOf(value);\n          }\n        },\n        ddd: {\n          pattern: `(${days.map(day => day.substring(0, 3)).join("|")})`,\n          action: (value, data) => {\n            data.day = days.findIndex(day => day.substring(0, 3) === value);\n          }\n        },\n        dd: {\n          pattern: "([0-9]{2})",\n          action: (value, data) => {\n            data.day = parseInt(value);\n          }\n        },\n        d: {\n          pattern: "([0-9]{1,2})",\n          action: (value, data) => {\n            data.day = parseInt(value);\n          }\n        },\n        yyyy: {\n          pattern: "([0-9]{4})",\n          action: (value, data) => {\n            data.year = parseInt(value);\n          }\n        },\n        yy: {\n          pattern: "([0-9]{2})",\n          action: (value, data) => {\n            data.year = 2000 + parseInt(value);\n          }\n        },\n        HH: {\n          pattern: "([0-9]{2})",\n          action: (value, data) => {\n            data.hours = parseInt(value);\n          }\n        },\n        H: {\n          pattern: "([0-9]{1,2})",\n          action: (value, data) => {\n            data.hours = parseInt(value);\n          }\n        },\n        hh: {\n          pattern: "([0-9]{2})",\n          action: (value, data) => {\n            data.hours = parseInt(value);\n          }\n        },\n        h: {\n          pattern: "([0-9]{1,2})",\n          action: (value, data) => {\n            data.hours = parseInt(value);\n          }\n        },\n        MM: {\n          pattern: "([0-9]{2})",\n          action: (value, data) => {\n            data.minutes = parseInt(value);\n          }\n        },\n        M: {\n          pattern: "([0-9]{1,2})",\n          action: (value, data) => {\n            data.minutes = parseInt(value);\n          }\n        },\n        ss: {\n          pattern: "([0-9]{2})",\n          action: (value, data) => {\n            data.seconds = parseInt(value);\n          }\n        },\n        s: {\n          pattern: "([0-9]{1,2})",\n          action: (value, data) => {\n            data.seconds = parseInt(value);\n          }\n        },\n        tt: {\n          pattern: "([aApP][mM])",\n          action: (value, data) => {\n            const char = value.charAt(0);\n            data.am = char === "a" || char === "A";\n          }\n        },\n        t: {\n          pattern: "([aApP])",\n          action: (value, data) => {\n            data.am = value === "a" || value === "A";\n          }\n        }\n      };\n      const escapedFormat = cFormat.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, "\\\\$&");\n      const patterns = /(mmmm|mmm|mm|m|dddd|ddd|dd|d|yyyy|yy|HH|H|hh|h|MM|M|ss|s|tt|t)/g;\n      const actions = [];\n      const re = escapedFormat.replace(patterns, function (match, patternElement) {\n        const {\n          pattern,\n          action\n        } = handlers[patternElement];\n        actions.push(action);\n        return pattern;\n      });\n\n      this._scandCache.set(cFormat, [re, actions]);\n    }\n\n    const [re, actions] = this._scandCache.get(cFormat);\n\n    const matches = new RegExp(re, "g").exec(cDate);\n\n    if (!matches || matches.length !== actions.length + 1) {\n      return null;\n    }\n\n    const data = {\n      year: 0,\n      month: 0,\n      day: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      am: null\n    };\n    actions.forEach((action, i) => action(matches[i + 1], data));\n\n    if (data.am !== null) {\n      data.hours = data.hours % 12 + (data.am ? 0 : 12);\n    }\n\n    return new Date(data.year, data.month, data.day, data.hours, data.minutes, data.seconds);\n  }\n\n  spansToXML() {}\n\n  stringFromStream() {}\n\n  xmlToSpans() {}\n\n}\n\nexports.Util = Util;\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\nvar exports = __webpack_exports__;\n\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "initSandbox", ({\n  enumerable: true,\n  get: function () {\n    return _initialization.initSandbox;\n  }\n}));\n\nvar _initialization = __w_pdfjs_require__(1);\n\nconst pdfjsVersion = \'2.9.0\';\nconst pdfjsBuild = \'3538ef0\';\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});'];
    code.push("delete dump;");
    let success = false;
    let buf = 0;

    try {
      const sandboxData = JSON.stringify(data);
      code.push(`pdfjsScripting.initSandbox({ data: ${sandboxData} })`);
      buf = this._module.stringToNewUTF8(code.join("\n"));
      success = !!this._module.ccall("init", "number", ["number", "number"], [buf, this._alertOnError]);
    } catch (error) {
      console.error(error);
    } finally {
      if (buf) {
        this._module.ccall("free", "number", ["number"], [buf]);
      }
    }

    if (success) {
      this.support.commFun = this._module.cwrap("commFun", null, ["string", "string"]);
    } else {
      this.nukeSandbox();
      throw new Error("Cannot start sandbox");
    }
  }

  dispatchEvent(event) {
    this.support.callSandboxFunction("dispatchEvent", event);
  }

  dumpMemoryUse() {
    if (this._module) {
      this._module.ccall("dumpMemoryUse", null, []);
    }
  }

  nukeSandbox() {
    if (this._module !== null) {
      this.support.destroy();
      this.support = null;

      this._module.ccall("nukeSandbox", null, []);

      this._module = null;
    }
  }

  evalForTesting(code, key) {
    throw new Error("Not implemented: evalForTesting");
  }

}

function QuickJSSandbox() {
  return (0, _quickjsEval.default)().then(module => {
    return new Sandbox(window, module);
  });
}
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.sandbox.js.map]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pdf/build/pdf.worker.js</url>
    <content><![CDATA[/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf.worker", [], factory);
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf.worker"] = factory();
	else
		root["pdfjs-dist/build/pdf.worker"] = root.pdfjsWorker = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerTask = exports.WorkerMessageHandler = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _pdf_manager = __w_pdfjs_require__(7);

var _writer = __w_pdfjs_require__(64);

var _is_node = __w_pdfjs_require__(4);

var _message_handler = __w_pdfjs_require__(88);

var _worker_stream = __w_pdfjs_require__(89);

var _core_utils = __w_pdfjs_require__(9);

class WorkerTask {
  constructor(name) {
    this.name = name;
    this.terminated = false;
    this._capability = (0, _util.createPromiseCapability)();
  }

  get finished() {
    return this._capability.promise;
  }

  finish() {
    this._capability.resolve();
  }

  terminate() {
    this.terminated = true;
  }

  ensureNotTerminated() {
    if (this.terminated) {
      throw new Error("Worker task was terminated");
    }
  }

}

exports.WorkerTask = WorkerTask;

class WorkerMessageHandler {
  static setup(handler, port) {
    let testMessageProcessed = false;
    handler.on("test", function wphSetupTest(data) {
      if (testMessageProcessed) {
        return;
      }

      testMessageProcessed = true;

      if (!(data instanceof Uint8Array)) {
        handler.send("test", null);
        return;
      }

      const supportTransfers = data[0] === 255;
      handler.postMessageTransfers = supportTransfers;
      handler.send("test", {
        supportTransfers
      });
    });
    handler.on("configure", function wphConfigure(data) {
      (0, _util.setVerbosityLevel)(data.verbosity);
    });
    handler.on("GetDocRequest", function wphSetupDoc(data) {
      return WorkerMessageHandler.createDocumentHandler(data, port);
    });
  }

  static createDocumentHandler(docParams, port) {
    let pdfManager;
    let terminated = false;
    let cancelXHRs = null;
    const WorkerTasks = [];
    const verbosity = (0, _util.getVerbosityLevel)();
    const apiVersion = docParams.apiVersion;
    const workerVersion = '2.9.0';

    if (apiVersion !== workerVersion) {
      throw new Error(`The API version "${apiVersion}" does not match ` + `the Worker version "${workerVersion}".`);
    }

    const enumerableProperties = [];

    for (const property in []) {
      enumerableProperties.push(property);
    }

    if (enumerableProperties.length) {
      throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
    }

    if (typeof ReadableStream === "undefined") {
      throw new Error("The browser/environment lacks native support for critical " + "functionality used by the PDF.js library (e.g. `ReadableStream`); " + "please use a `legacy`-build instead.");
    }

    const docId = docParams.docId;
    const docBaseUrl = docParams.docBaseUrl;
    const workerHandlerName = docParams.docId + "_worker";
    let handler = new _message_handler.MessageHandler(workerHandlerName, docId, port);
    handler.postMessageTransfers = docParams.postMessageTransfers;

    function ensureNotTerminated() {
      if (terminated) {
        throw new Error("Worker was terminated");
      }
    }

    function startWorkerTask(task) {
      WorkerTasks.push(task);
    }

    function finishWorkerTask(task) {
      task.finish();
      const i = WorkerTasks.indexOf(task);
      WorkerTasks.splice(i, 1);
    }

    async function loadDocument(recoveryMode) {
      await pdfManager.ensureDoc("checkHeader");
      await pdfManager.ensureDoc("parseStartXRef");
      await pdfManager.ensureDoc("parse", [recoveryMode]);

      if (!recoveryMode) {
        await pdfManager.ensureDoc("checkFirstPage");
      }

      const [numPages, fingerprint, isPureXfa] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprint"), pdfManager.ensureDoc("isPureXfa")]);

      if (isPureXfa) {
        const task = new WorkerTask("loadXfaFonts");
        startWorkerTask(task);
        await pdfManager.loadXfaFonts(handler, task).catch(reason => {}).then(() => finishWorkerTask(task));
      }

      return {
        numPages,
        fingerprint,
        isPureXfa
      };
    }

    function getPdfManager(data, evaluatorOptions, enableXfa) {
      const pdfManagerCapability = (0, _util.createPromiseCapability)();
      let newPdfManager;
      const source = data.source;

      if (source.data) {
        try {
          newPdfManager = new _pdf_manager.LocalPdfManager(docId, source.data, source.password, evaluatorOptions, enableXfa, docBaseUrl);
          pdfManagerCapability.resolve(newPdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }

        return pdfManagerCapability.promise;
      }

      let pdfStream,
          cachedChunks = [];

      try {
        pdfStream = new _worker_stream.PDFWorkerStream(handler);
      } catch (ex) {
        pdfManagerCapability.reject(ex);
        return pdfManagerCapability.promise;
      }

      const fullRequest = pdfStream.getFullReader();
      fullRequest.headersReady.then(function () {
        if (!fullRequest.isRangeSupported) {
          return;
        }

        const disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
        newPdfManager = new _pdf_manager.NetworkPdfManager(docId, pdfStream, {
          msgHandler: handler,
          password: source.password,
          length: fullRequest.contentLength,
          disableAutoFetch,
          rangeChunkSize: source.rangeChunkSize
        }, evaluatorOptions, enableXfa, docBaseUrl);

        for (let i = 0; i < cachedChunks.length; i++) {
          newPdfManager.sendProgressiveData(cachedChunks[i]);
        }

        cachedChunks = [];
        pdfManagerCapability.resolve(newPdfManager);
        cancelXHRs = null;
      }).catch(function (reason) {
        pdfManagerCapability.reject(reason);
        cancelXHRs = null;
      });
      let loaded = 0;

      const flushChunks = function () {
        const pdfFile = (0, _util.arraysToBytes)(cachedChunks);

        if (source.length && pdfFile.length !== source.length) {
          (0, _util.warn)("reported HTTP length is different from actual");
        }

        try {
          newPdfManager = new _pdf_manager.LocalPdfManager(docId, pdfFile, source.password, evaluatorOptions, enableXfa, docBaseUrl);
          pdfManagerCapability.resolve(newPdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }

        cachedChunks = [];
      };

      const readPromise = new Promise(function (resolve, reject) {
        const readChunk = function ({
          value,
          done
        }) {
          try {
            ensureNotTerminated();

            if (done) {
              if (!newPdfManager) {
                flushChunks();
              }

              cancelXHRs = null;
              return;
            }

            loaded += (0, _util.arrayByteLength)(value);

            if (!fullRequest.isStreamingSupported) {
              handler.send("DocProgress", {
                loaded,
                total: Math.max(loaded, fullRequest.contentLength || 0)
              });
            }

            if (newPdfManager) {
              newPdfManager.sendProgressiveData(value);
            } else {
              cachedChunks.push(value);
            }

            fullRequest.read().then(readChunk, reject);
          } catch (e) {
            reject(e);
          }
        };

        fullRequest.read().then(readChunk, reject);
      });
      readPromise.catch(function (e) {
        pdfManagerCapability.reject(e);
        cancelXHRs = null;
      });

      cancelXHRs = function (reason) {
        pdfStream.cancelAllRequests(reason);
      };

      return pdfManagerCapability.promise;
    }

    function setupDoc(data) {
      function onSuccess(doc) {
        ensureNotTerminated();
        handler.send("GetDoc", {
          pdfInfo: doc
        });
      }

      function onFailure(ex) {
        ensureNotTerminated();

        if (ex instanceof _util.PasswordException) {
          const task = new WorkerTask(`PasswordException: response ${ex.code}`);
          startWorkerTask(task);
          handler.sendWithPromise("PasswordRequest", ex).then(function ({
            password
          }) {
            finishWorkerTask(task);
            pdfManager.updatePassword(password);
            pdfManagerReady();
          }).catch(function () {
            finishWorkerTask(task);
            handler.send("DocException", ex);
          });
        } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) {
          handler.send("DocException", ex);
        } else {
          handler.send("DocException", new _util.UnknownErrorException(ex.message, ex.toString()));
        }
      }

      function pdfManagerReady() {
        ensureNotTerminated();
        loadDocument(false).then(onSuccess, function (reason) {
          ensureNotTerminated();

          if (!(reason instanceof _core_utils.XRefParseException)) {
            onFailure(reason);
            return;
          }

          pdfManager.requestLoadedStream();
          pdfManager.onLoadedStream().then(function () {
            ensureNotTerminated();
            loadDocument(true).then(onSuccess, onFailure);
          });
        });
      }

      ensureNotTerminated();
      const evaluatorOptions = {
        maxImageSize: data.maxImageSize,
        disableFontFace: data.disableFontFace,
        ignoreErrors: data.ignoreErrors,
        isEvalSupported: data.isEvalSupported,
        fontExtraProperties: data.fontExtraProperties
      };
      getPdfManager(data, evaluatorOptions, data.enableXfa).then(function (newPdfManager) {
        if (terminated) {
          newPdfManager.terminate(new _util.AbortException("Worker was terminated."));
          throw new Error("Worker was terminated");
        }

        pdfManager = newPdfManager;
        pdfManager.onLoadedStream().then(function (stream) {
          handler.send("DataLoaded", {
            length: stream.bytes.byteLength
          });
        });
      }).then(pdfManagerReady, onFailure);
    }

    handler.on("GetPage", function wphSetupGetPage(data) {
      return pdfManager.getPage(data.pageIndex).then(function (page) {
        return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function ([rotate, ref, userUnit, view]) {
          return {
            rotate,
            ref,
            userUnit,
            view
          };
        });
      });
    });
    handler.on("GetPageIndex", function wphSetupGetPageIndex({
      ref
    }) {
      const pageRef = _primitives.Ref.get(ref.num, ref.gen);

      return pdfManager.ensureCatalog("getPageIndex", [pageRef]);
    });
    handler.on("GetDestinations", function wphSetupGetDestinations(data) {
      return pdfManager.ensureCatalog("destinations");
    });
    handler.on("GetDestination", function wphSetupGetDestination(data) {
      return pdfManager.ensureCatalog("getDestination", [data.id]);
    });
    handler.on("GetPageLabels", function wphSetupGetPageLabels(data) {
      return pdfManager.ensureCatalog("pageLabels");
    });
    handler.on("GetPageLayout", function wphSetupGetPageLayout(data) {
      return pdfManager.ensureCatalog("pageLayout");
    });
    handler.on("GetPageMode", function wphSetupGetPageMode(data) {
      return pdfManager.ensureCatalog("pageMode");
    });
    handler.on("GetViewerPreferences", function (data) {
      return pdfManager.ensureCatalog("viewerPreferences");
    });
    handler.on("GetOpenAction", function (data) {
      return pdfManager.ensureCatalog("openAction");
    });
    handler.on("GetAttachments", function wphSetupGetAttachments(data) {
      return pdfManager.ensureCatalog("attachments");
    });
    handler.on("GetJavaScript", function wphSetupGetJavaScript(data) {
      return pdfManager.ensureCatalog("javaScript");
    });
    handler.on("GetDocJSActions", function wphSetupGetDocJSActions(data) {
      return pdfManager.ensureCatalog("jsActions");
    });
    handler.on("GetPageJSActions", function ({
      pageIndex
    }) {
      return pdfManager.getPage(pageIndex).then(function (page) {
        return pdfManager.ensure(page, "jsActions");
      });
    });
    handler.on("GetPageXfa", function wphSetupGetXfa({
      pageIndex
    }) {
      return pdfManager.getPage(pageIndex).then(function (page) {
        return pdfManager.ensure(page, "xfaData");
      });
    });
    handler.on("GetOutline", function wphSetupGetOutline(data) {
      return pdfManager.ensureCatalog("documentOutline");
    });
    handler.on("GetOptionalContentConfig", function (data) {
      return pdfManager.ensureCatalog("optionalContentConfig");
    });
    handler.on("GetPermissions", function (data) {
      return pdfManager.ensureCatalog("permissions");
    });
    handler.on("GetMetadata", function wphSetupGetMetadata(data) {
      return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
    });
    handler.on("GetMarkInfo", function wphSetupGetMarkInfo(data) {
      return pdfManager.ensureCatalog("markInfo");
    });
    handler.on("GetData", function wphSetupGetData(data) {
      pdfManager.requestLoadedStream();
      return pdfManager.onLoadedStream().then(function (stream) {
        return stream.bytes;
      });
    });
    handler.on("GetStats", function wphSetupGetStats(data) {
      return pdfManager.ensureXRef("stats");
    });
    handler.on("GetAnnotations", function ({
      pageIndex,
      intent
    }) {
      return pdfManager.getPage(pageIndex).then(function (page) {
        return page.getAnnotationsData(intent);
      });
    });
    handler.on("GetFieldObjects", function (data) {
      return pdfManager.ensureDoc("fieldObjects");
    });
    handler.on("HasJSActions", function (data) {
      return pdfManager.ensureDoc("hasJSActions");
    });
    handler.on("GetCalculationOrderIds", function (data) {
      return pdfManager.ensureDoc("calculationOrderIds");
    });
    handler.on("SaveDocument", function ({
      numPages,
      annotationStorage,
      filename
    }) {
      pdfManager.requestLoadedStream();
      const promises = [pdfManager.onLoadedStream(), pdfManager.ensureCatalog("acroForm"), pdfManager.ensureDoc("xref"), pdfManager.ensureDoc("startXRef")];

      for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
        promises.push(pdfManager.getPage(pageIndex).then(function (page) {
          const task = new WorkerTask(`Save: page ${pageIndex}`);
          startWorkerTask(task);
          return page.save(handler, task, annotationStorage).finally(function () {
            finishWorkerTask(task);
          });
        }));
      }

      return Promise.all(promises).then(function ([stream, acroForm, xref, startXRef, ...refs]) {
        let newRefs = [];

        for (const ref of refs) {
          newRefs = ref.filter(x => x !== null).reduce((a, b) => a.concat(b), newRefs);
        }

        if (newRefs.length === 0) {
          return stream.bytes;
        }

        const xfa = acroForm instanceof _primitives.Dict && acroForm.get("XFA") || [];
        let xfaDatasets = null;

        if (Array.isArray(xfa)) {
          for (let i = 0, ii = xfa.length; i < ii; i += 2) {
            if (xfa[i] === "datasets") {
              xfaDatasets = xfa[i + 1];
            }
          }
        } else {
          (0, _util.warn)("Unsupported XFA type.");
        }

        let newXrefInfo = Object.create(null);

        if (xref.trailer) {
          const infoObj = Object.create(null);
          const xrefInfo = xref.trailer.get("Info") || null;

          if (xrefInfo instanceof _primitives.Dict) {
            xrefInfo.forEach((key, value) => {
              if ((0, _util.isString)(key) && (0, _util.isString)(value)) {
                infoObj[key] = (0, _util.stringToPDFString)(value);
              }
            });
          }

          newXrefInfo = {
            rootRef: xref.trailer.getRaw("Root") || null,
            encryptRef: xref.trailer.getRaw("Encrypt") || null,
            newRef: xref.getNewRef(),
            infoRef: xref.trailer.getRaw("Info") || null,
            info: infoObj,
            fileIds: xref.trailer.get("ID") || null,
            startXRef,
            filename
          };
        }

        xref.resetNewRef();
        return (0, _writer.incrementalUpdate)({
          originalData: stream.bytes,
          xrefInfo: newXrefInfo,
          newRefs,
          xref,
          datasetsRef: xfaDatasets
        });
      });
    });
    handler.on("GetOperatorList", function wphSetupRenderPage(data, sink) {
      const pageIndex = data.pageIndex;
      pdfManager.getPage(pageIndex).then(function (page) {
        const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);
        startWorkerTask(task);
        const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
        page.getOperatorList({
          handler,
          sink,
          task,
          intent: data.intent,
          renderInteractiveForms: data.renderInteractiveForms,
          annotationStorage: data.annotationStorage
        }).then(function (operatorListInfo) {
          finishWorkerTask(task);

          if (start) {
            (0, _util.info)(`page=${pageIndex + 1} - getOperatorList: time=` + `${Date.now() - start}ms, len=${operatorListInfo.length}`);
          }

          sink.close();
        }, function (reason) {
          finishWorkerTask(task);

          if (task.terminated) {
            return;
          }

          handler.send("UnsupportedFeature", {
            featureId: _util.UNSUPPORTED_FEATURES.errorOperatorList
          });
          sink.error(reason);
        });
      });
    });
    handler.on("GetTextContent", function wphExtractText(data, sink) {
      const pageIndex = data.pageIndex;

      sink.onPull = function (desiredSize) {};

      sink.onCancel = function (reason) {};

      pdfManager.getPage(pageIndex).then(function (page) {
        const task = new WorkerTask("GetTextContent: page " + pageIndex);
        startWorkerTask(task);
        const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0;
        page.extractTextContent({
          handler,
          task,
          sink,
          normalizeWhitespace: data.normalizeWhitespace,
          includeMarkedContent: data.includeMarkedContent,
          combineTextItems: data.combineTextItems
        }).then(function () {
          finishWorkerTask(task);

          if (start) {
            (0, _util.info)(`page=${pageIndex + 1} - getTextContent: time=` + `${Date.now() - start}ms`);
          }

          sink.close();
        }, function (reason) {
          finishWorkerTask(task);

          if (task.terminated) {
            return;
          }

          sink.error(reason);
        });
      });
    });
    handler.on("GetStructTree", function wphGetStructTree(data) {
      return pdfManager.getPage(data.pageIndex).then(function (page) {
        return pdfManager.ensure(page, "getStructTree");
      });
    });
    handler.on("FontFallback", function (data) {
      return pdfManager.fontFallback(data.id, handler);
    });
    handler.on("Cleanup", function wphCleanup(data) {
      return pdfManager.cleanup(true);
    });
    handler.on("Terminate", function wphTerminate(data) {
      terminated = true;
      const waitOn = [];

      if (pdfManager) {
        pdfManager.terminate(new _util.AbortException("Worker was terminated."));
        const cleanupPromise = pdfManager.cleanup();
        waitOn.push(cleanupPromise);
        pdfManager = null;
      } else {
        (0, _primitives.clearPrimitiveCaches)();
      }

      if (cancelXHRs) {
        cancelXHRs(new _util.AbortException("Worker was terminated."));
      }

      for (const task of WorkerTasks) {
        waitOn.push(task.finished);
        task.terminate();
      }

      return Promise.all(waitOn).then(function () {
        handler.destroy();
        handler = null;
      });
    });
    handler.on("Ready", function wphReady(data) {
      setupDoc(docParams);
      docParams = null;
    });
    return workerHandlerName;
  }

  static initializeFromPort(port) {
    const handler = new _message_handler.MessageHandler("worker", "main", port);
    WorkerMessageHandler.setup(handler, port);
    handler.send("ready", null);
  }

}

exports.WorkerMessageHandler = WorkerMessageHandler;

function isMessagePort(maybePort) {
  return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
}

if (typeof window === "undefined" && !_is_node.isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
  WorkerMessageHandler.initializeFromPort(self);
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createObjectURL = createObjectURL;
exports.createPromiseCapability = createPromiseCapability;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.escapeString = escapeString;
exports.getModificationDate = getModificationDate;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isAscii = isAscii;
exports.isBool = isBool;
exports.isNum = isNum;
exports.isSameOrigin = isSameOrigin;
exports.isString = isString;
exports.objectFromMap = objectFromMap;
exports.objectSize = objectSize;
exports.removeNullCharacters = removeNullCharacters;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF16BEString = stringToUTF16BEString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
exports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;

__w_pdfjs_require__(3);

const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
const ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
const AnnotationStateModelType = {
  MARKED: "Marked",
  REVIEW: "Review"
};
exports.AnnotationStateModelType = AnnotationStateModelType;
const AnnotationMarkedState = {
  MARKED: "Marked",
  UNMARKED: "Unmarked"
};
exports.AnnotationMarkedState = AnnotationMarkedState;
const AnnotationReviewState = {
  ACCEPTED: "Accepted",
  REJECTED: "Rejected",
  CANCELLED: "Cancelled",
  COMPLETED: "Completed",
  NONE: "None"
};
exports.AnnotationReviewState = AnnotationReviewState;
const AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
const StreamType = {
  UNKNOWN: "UNKNOWN",
  FLATE: "FLATE",
  LZW: "LZW",
  DCT: "DCT",
  JPX: "JPX",
  JBIG: "JBIG",
  A85: "A85",
  AHX: "AHX",
  CCF: "CCF",
  RLX: "RLX"
};
exports.StreamType = StreamType;
const FontType = {
  UNKNOWN: "UNKNOWN",
  TYPE1: "TYPE1",
  TYPE1C: "TYPE1C",
  CIDFONTTYPE0: "CIDFONTTYPE0",
  CIDFONTTYPE0C: "CIDFONTTYPE0C",
  TRUETYPE: "TRUETYPE",
  CIDFONTTYPE2: "CIDFONTTYPE2",
  TYPE3: "TYPE3",
  OPENTYPE: "OPENTYPE",
  TYPE0: "TYPE0",
  MMTYPE1: "MMTYPE1"
};
exports.FontType = FontType;
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
exports.CMapCompressionType = CMapCompressionType;
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
const UNSUPPORTED_FEATURES = {
  unknown: "unknown",
  forms: "forms",
  javaScript: "javaScript",
  signatures: "signatures",
  smask: "smask",
  shadingPattern: "shadingPattern",
  font: "font",
  errorTilingPattern: "errorTilingPattern",
  errorExtGState: "errorExtGState",
  errorXObject: "errorXObject",
  errorFontLoadType3: "errorFontLoadType3",
  errorFontState: "errorFontState",
  errorFontMissing: "errorFontMissing",
  errorFontTranslate: "errorFontTranslate",
  errorColorSpace: "errorColorSpace",
  errorOperatorList: "errorOperatorList",
  errorFontToUnicode: "errorFontToUnicode",
  errorFontLoadNative: "errorFontLoadNative",
  errorFontBuildPath: "errorFontBuildPath",
  errorFontGetPath: "errorFontGetPath",
  errorMarkedContent: "errorMarkedContent"
};
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
let verbosity = VerbosityLevel.WARNINGS;

function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}

function getVerbosityLevel() {
  return verbosity;
}

function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function isSameOrigin(baseUrl, otherUrl) {
  let base;

  try {
    base = new URL(baseUrl);

    if (!base.origin || base.origin === "null") {
      return false;
    }
  } catch (e) {
    return false;
  }

  const other = new URL(otherUrl, base);
  return base.origin === other.origin;
}

function _isValidProtocol(url) {
  if (!url) {
    return false;
  }

  switch (url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;

    default:
      return false;
  }
}

function createValidAbsoluteUrl(url, baseUrl) {
  if (!url) {
    return null;
  }

  try {
    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}

  return null;
}

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}

const BaseException = function BaseExceptionClosure() {
  function BaseException(message) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }

    this.message = message;
    this.name = this.constructor.name;
  }

  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();

exports.BaseException = BaseException;

class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg);
    this.code = code;
  }

}

exports.PasswordException = PasswordException;

class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg);
    this.details = details;
  }

}

exports.UnknownErrorException = UnknownErrorException;

class InvalidPDFException extends BaseException {}

exports.InvalidPDFException = InvalidPDFException;

class MissingPDFException extends BaseException {}

exports.MissingPDFException = MissingPDFException;

class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg);
    this.status = status;
  }

}

exports.UnexpectedResponseException = UnexpectedResponseException;

class FormatError extends BaseException {}

exports.FormatError = FormatError;

class AbortException extends BaseException {}

exports.AbortException = AbortException;
const NullCharactersRegExp = /\x00/g;

function removeNullCharacters(str) {
  if (typeof str !== "string") {
    warn("The argument for removeNullCharacters must be a string.");
    return str;
  }

  return str.replace(NullCharactersRegExp, "");
}

function bytesToString(bytes) {
  assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;

  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }

  const strBuf = [];

  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }

  return strBuf.join("");
}

function stringToBytes(str) {
  assert(typeof str === "string", "Invalid argument for stringToBytes");
  const length = str.length;
  const bytes = new Uint8Array(length);

  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }

  return bytes;
}

function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }

  assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
  return arr.byteLength;
}

function arraysToBytes(arr) {
  const length = arr.length;

  if (length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }

  let resultLength = 0;

  for (let i = 0; i < length; i++) {
    resultLength += arrayByteLength(arr[i]);
  }

  let pos = 0;
  const data = new Uint8Array(resultLength);

  for (let i = 0; i < length; i++) {
    let item = arr[i];

    if (!(item instanceof Uint8Array)) {
      if (typeof item === "string") {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }

    const itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }

  return data;
}

function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}

function objectSize(obj) {
  return Object.keys(obj).length;
}

function objectFromMap(map) {
  const obj = Object.create(null);

  for (const [key, value] of map) {
    obj[key] = value;
  }

  return obj;
}

function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}

const IsLittleEndianCached = {
  get value() {
    return shadow(this, "value", isLittleEndian());
  }

};
exports.IsLittleEndianCached = IsLittleEndianCached;

function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch (e) {
    return false;
  }
}

const IsEvalSupportedCached = {
  get value() {
    return shadow(this, "value", isEvalSupported());
  }

};
exports.IsEvalSupportedCached = IsEvalSupportedCached;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }

  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }

  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }

  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }

  static getAxialAlignedBoundingBox(r, m) {
    const p1 = Util.applyTransform(r, m);
    const p2 = Util.applyTransform(r.slice(2, 4), m);
    const p3 = Util.applyTransform([r[0], r[3]], m);
    const p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }

  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }

  static apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  }

  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }

  static normalizeRect(rect) {
    const r = rect.slice(0);

    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }

    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }

    return r;
  }

  static intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
    const result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return null;
    }

    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return null;
    }

    return result;
  }

}

exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

function stringToPDFString(str) {
  const length = str.length,
        strBuf = [];

  if (str[0] === "\xFE" && str[1] === "\xFF") {
    for (let i = 2; i < length; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
    for (let i = 2; i < length; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
    }
  } else {
    for (let i = 0; i < length; ++i) {
      const code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }

  return strBuf.join("");
}

function escapeString(str) {
  return str.replace(/([()\\\n\r])/g, match => {
    if (match === "\n") {
      return "\\n";
    } else if (match === "\r") {
      return "\\r";
    }

    return `\\${match}`;
  });
}

function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}

function stringToUTF16BEString(str) {
  const buf = ["\xFE\xFF"];

  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push(String.fromCharCode(char >> 8 & 0xff));
    buf.push(String.fromCharCode(char & 0xff));
  }

  return buf.join("");
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}

function isBool(v) {
  return typeof v === "boolean";
}

function isNum(v) {
  return typeof v === "number";
}

function isString(v) {
  return typeof v === "string";
}

function isArrayBuffer(v) {
  return typeof v === "object" && v !== null && v.byteLength !== undefined;
}

function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0, ii = arr1.length; i < ii; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}

function getModificationDate(date = new Date()) {
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}

function createPromiseCapability() {
  const capability = Object.create(null);
  let isSettled = false;
  Object.defineProperty(capability, "settled", {
    get() {
      return isSettled;
    }

  });
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = function (data) {
      isSettled = true;
      resolve(data);
    };

    capability.reject = function (reason) {
      isSettled = true;
      reject(reason);
    };
  });
  return capability;
}

function createObjectURL(data, contentType = "", forceDataSchema = false) {
  if (URL.createObjectURL && !forceDataSchema) {
    return URL.createObjectURL(new Blob([data], {
      type: contentType
    }));
  }

  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let buffer = `data:${contentType};base64,`;

  for (let i = 0, ii = data.length; i < ii; i += 3) {
    const b1 = data[i] & 0xff;
    const b2 = data[i + 1] & 0xff;
    const b3 = data[i + 2] & 0xff;
    const d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
    const d4 = i + 2 < ii ? b3 & 0x3f : 64;
    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
  }

  return buffer;
}

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {



var _is_node = __w_pdfjs_require__(4);

;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNodeJS = void 0;
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearPrimitiveCaches = clearPrimitiveCaches;
exports.isCmd = isCmd;
exports.isDict = isDict;
exports.isEOF = isEOF;
exports.isName = isName;
exports.isRef = isRef;
exports.isRefsEqual = isRefsEqual;
exports.isStream = isStream;
exports.RefSetCache = exports.RefSet = exports.Ref = exports.Name = exports.EOF = exports.Dict = exports.Cmd = void 0;

var _util = __w_pdfjs_require__(2);

var _base_stream = __w_pdfjs_require__(6);

const EOF = {};
exports.EOF = EOF;

const Name = function NameClosure() {
  let nameCache = Object.create(null);

  class Name {
    constructor(name) {
      this.name = name;
    }

    static get(name) {
      const nameValue = nameCache[name];
      return nameValue ? nameValue : nameCache[name] = new Name(name);
    }

    static _clearCache() {
      nameCache = Object.create(null);
    }

  }

  return Name;
}();

exports.Name = Name;

const Cmd = function CmdClosure() {
  let cmdCache = Object.create(null);

  class Cmd {
    constructor(cmd) {
      this.cmd = cmd;
    }

    static get(cmd) {
      const cmdValue = cmdCache[cmd];
      return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd(cmd);
    }

    static _clearCache() {
      cmdCache = Object.create(null);
    }

  }

  return Cmd;
}();

exports.Cmd = Cmd;

const nonSerializable = function nonSerializableClosure() {
  return nonSerializable;
};

class Dict {
  constructor(xref = null) {
    this._map = Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = nonSerializable;
  }

  assignXref(newXref) {
    this.xref = newXref;
  }

  get size() {
    return Object.keys(this._map).length;
  }

  get(key1, key2, key3) {
    let value = this._map[key1];

    if (value === undefined && key2 !== undefined) {
      value = this._map[key2];

      if (value === undefined && key3 !== undefined) {
        value = this._map[key3];
      }
    }

    if (value instanceof Ref && this.xref) {
      return this.xref.fetch(value, this.suppressEncryption);
    }

    return value;
  }

  async getAsync(key1, key2, key3) {
    let value = this._map[key1];

    if (value === undefined && key2 !== undefined) {
      value = this._map[key2];

      if (value === undefined && key3 !== undefined) {
        value = this._map[key3];
      }
    }

    if (value instanceof Ref && this.xref) {
      return this.xref.fetchAsync(value, this.suppressEncryption);
    }

    return value;
  }

  getArray(key1, key2, key3) {
    let value = this._map[key1];

    if (value === undefined && key2 !== undefined) {
      value = this._map[key2];

      if (value === undefined && key3 !== undefined) {
        value = this._map[key3];
      }
    }

    if (value instanceof Ref && this.xref) {
      value = this.xref.fetch(value, this.suppressEncryption);
    }

    if (Array.isArray(value)) {
      value = value.slice();

      for (let i = 0, ii = value.length; i < ii; i++) {
        if (value[i] instanceof Ref && this.xref) {
          value[i] = this.xref.fetch(value[i], this.suppressEncryption);
        }
      }
    }

    return value;
  }

  getRaw(key) {
    return this._map[key];
  }

  getKeys() {
    return Object.keys(this._map);
  }

  getRawValues() {
    return Object.values(this._map);
  }

  set(key, value) {
    this._map[key] = value;
  }

  has(key) {
    return this._map[key] !== undefined;
  }

  forEach(callback) {
    for (const key in this._map) {
      callback(key, this.get(key));
    }
  }

  static get empty() {
    const emptyDict = new Dict(null);

    emptyDict.set = (key, value) => {
      (0, _util.unreachable)("Should not call `set` on the empty dictionary.");
    };

    return (0, _util.shadow)(this, "empty", emptyDict);
  }

  static merge({
    xref,
    dictArray,
    mergeSubDicts = false
  }) {
    const mergedDict = new Dict(xref);

    if (!mergeSubDicts) {
      for (const dict of dictArray) {
        if (!(dict instanceof Dict)) {
          continue;
        }

        for (const [key, value] of Object.entries(dict._map)) {
          if (mergedDict._map[key] === undefined) {
            mergedDict._map[key] = value;
          }
        }
      }

      return mergedDict.size > 0 ? mergedDict : Dict.empty;
    }

    const properties = new Map();

    for (const dict of dictArray) {
      if (!(dict instanceof Dict)) {
        continue;
      }

      for (const [key, value] of Object.entries(dict._map)) {
        let property = properties.get(key);

        if (property === undefined) {
          property = [];
          properties.set(key, property);
        }

        property.push(value);
      }
    }

    for (const [name, values] of properties) {
      if (values.length === 1 || !(values[0] instanceof Dict)) {
        mergedDict._map[name] = values[0];
        continue;
      }

      const subDict = new Dict(xref);

      for (const dict of values) {
        if (!(dict instanceof Dict)) {
          continue;
        }

        for (const [key, value] of Object.entries(dict._map)) {
          if (subDict._map[key] === undefined) {
            subDict._map[key] = value;
          }
        }
      }

      if (subDict.size > 0) {
        mergedDict._map[name] = subDict;
      }
    }

    properties.clear();
    return mergedDict.size > 0 ? mergedDict : Dict.empty;
  }

}

exports.Dict = Dict;

const Ref = function RefClosure() {
  let refCache = Object.create(null);

  class Ref {
    constructor(num, gen) {
      this.num = num;
      this.gen = gen;
    }

    toString() {
      if (this.gen === 0) {
        return `${this.num}R`;
      }

      return `${this.num}R${this.gen}`;
    }

    static get(num, gen) {
      const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
      const refValue = refCache[key];
      return refValue ? refValue : refCache[key] = new Ref(num, gen);
    }

    static _clearCache() {
      refCache = Object.create(null);
    }

  }

  return Ref;
}();

exports.Ref = Ref;

class RefSet {
  constructor(parent = null) {
    this._set = new Set(parent && parent._set);
  }

  has(ref) {
    return this._set.has(ref.toString());
  }

  put(ref) {
    this._set.add(ref.toString());
  }

  remove(ref) {
    this._set.delete(ref.toString());
  }

  forEach(callback) {
    for (const ref of this._set.values()) {
      callback(ref);
    }
  }

  clear() {
    this._set.clear();
  }

}

exports.RefSet = RefSet;

class RefSetCache {
  constructor() {
    this._map = new Map();
  }

  get size() {
    return this._map.size;
  }

  get(ref) {
    return this._map.get(ref.toString());
  }

  has(ref) {
    return this._map.has(ref.toString());
  }

  put(ref, obj) {
    this._map.set(ref.toString(), obj);
  }

  putAlias(ref, aliasRef) {
    this._map.set(ref.toString(), this.get(aliasRef));
  }

  forEach(callback) {
    for (const value of this._map.values()) {
      callback(value);
    }
  }

  clear() {
    this._map.clear();
  }

}

exports.RefSetCache = RefSetCache;

function isEOF(v) {
  return v === EOF;
}

function isName(v, name) {
  return v instanceof Name && (name === undefined || v.name === name);
}

function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}

function isDict(v, type) {
  return v instanceof Dict && (type === undefined || isName(v.get("Type"), type));
}

function isRef(v) {
  return v instanceof Ref;
}

function isRefsEqual(v1, v2) {
  return v1.num === v2.num && v1.gen === v2.gen;
}

function isStream(v) {
  return v instanceof _base_stream.BaseStream;
}

function clearPrimitiveCaches() {
  Cmd._clearCache();

  Name._clearCache();

  Ref._clearCache();
}

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseStream = void 0;

var _util = __w_pdfjs_require__(2);

class BaseStream {
  constructor() {
    if (this.constructor === BaseStream) {
      (0, _util.unreachable)("Cannot initialize BaseStream.");
    }
  }

  get length() {
    (0, _util.unreachable)("Abstract getter `length` accessed");
  }

  get isEmpty() {
    (0, _util.unreachable)("Abstract getter `isEmpty` accessed");
  }

  get isDataLoaded() {
    return (0, _util.shadow)(this, "isDataLoaded", true);
  }

  getByte() {
    (0, _util.unreachable)("Abstract method `getByte` called");
  }

  getBytes(length, forceClamped = false) {
    (0, _util.unreachable)("Abstract method `getBytes` called");
  }

  peekByte() {
    const peekedByte = this.getByte();

    if (peekedByte !== -1) {
      this.pos--;
    }

    return peekedByte;
  }

  peekBytes(length, forceClamped = false) {
    const bytes = this.getBytes(length, forceClamped);
    this.pos -= bytes.length;
    return bytes;
  }

  getUint16() {
    const b0 = this.getByte();
    const b1 = this.getByte();

    if (b0 === -1 || b1 === -1) {
      return -1;
    }

    return (b0 << 8) + b1;
  }

  getInt32() {
    const b0 = this.getByte();
    const b1 = this.getByte();
    const b2 = this.getByte();
    const b3 = this.getByte();
    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
  }

  getByteRange(begin, end) {
    (0, _util.unreachable)("Abstract method `getByteRange` called");
  }

  getString(length) {
    return (0, _util.bytesToString)(this.getBytes(length, false));
  }

  skip(n) {
    this.pos += n || 1;
  }

  reset() {
    (0, _util.unreachable)("Abstract method `reset` called");
  }

  moveStart() {
    (0, _util.unreachable)("Abstract method `moveStart` called");
  }

  makeSubStream(start, length, dict = null) {
    (0, _util.unreachable)("Abstract method `makeSubStream` called");
  }

  getBaseStreams() {
    return null;
  }

}

exports.BaseStream = BaseStream;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NetworkPdfManager = exports.LocalPdfManager = void 0;

var _util = __w_pdfjs_require__(2);

var _chunked_stream = __w_pdfjs_require__(8);

var _core_utils = __w_pdfjs_require__(9);

var _document = __w_pdfjs_require__(11);

var _stream = __w_pdfjs_require__(10);

function parseDocBaseUrl(url) {
  if (url) {
    const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url);

    if (absoluteUrl) {
      return absoluteUrl.href;
    }

    (0, _util.warn)(`Invalid absolute docBaseUrl: "${url}".`);
  }

  return null;
}

class BasePdfManager {
  constructor() {
    if (this.constructor === BasePdfManager) {
      (0, _util.unreachable)("Cannot initialize BasePdfManager.");
    }
  }

  get docId() {
    return this._docId;
  }

  get password() {
    return this._password;
  }

  get docBaseUrl() {
    return this._docBaseUrl;
  }

  onLoadedStream() {
    (0, _util.unreachable)("Abstract method `onLoadedStream` called");
  }

  ensureDoc(prop, args) {
    return this.ensure(this.pdfDocument, prop, args);
  }

  ensureXRef(prop, args) {
    return this.ensure(this.pdfDocument.xref, prop, args);
  }

  ensureCatalog(prop, args) {
    return this.ensure(this.pdfDocument.catalog, prop, args);
  }

  getPage(pageIndex) {
    return this.pdfDocument.getPage(pageIndex);
  }

  fontFallback(id, handler) {
    return this.pdfDocument.fontFallback(id, handler);
  }

  loadXfaFonts(handler, task) {
    return this.pdfDocument.loadXfaFonts(handler, task);
  }

  cleanup(manuallyTriggered = false) {
    return this.pdfDocument.cleanup(manuallyTriggered);
  }

  async ensure(obj, prop, args) {
    (0, _util.unreachable)("Abstract method `ensure` called");
  }

  requestRange(begin, end) {
    (0, _util.unreachable)("Abstract method `requestRange` called");
  }

  requestLoadedStream() {
    (0, _util.unreachable)("Abstract method `requestLoadedStream` called");
  }

  sendProgressiveData(chunk) {
    (0, _util.unreachable)("Abstract method `sendProgressiveData` called");
  }

  updatePassword(password) {
    this._password = password;
  }

  terminate(reason) {
    (0, _util.unreachable)("Abstract method `terminate` called");
  }

}

class LocalPdfManager extends BasePdfManager {
  constructor(docId, data, password, evaluatorOptions, enableXfa, docBaseUrl) {
    super();
    this._docId = docId;
    this._password = password;
    this._docBaseUrl = parseDocBaseUrl(docBaseUrl);
    this.evaluatorOptions = evaluatorOptions;
    this.enableXfa = enableXfa;
    const stream = new _stream.Stream(data);
    this.pdfDocument = new _document.PDFDocument(this, stream);
    this._loadedStreamPromise = Promise.resolve(stream);
  }

  async ensure(obj, prop, args) {
    const value = obj[prop];

    if (typeof value === "function") {
      return value.apply(obj, args);
    }

    return value;
  }

  requestRange(begin, end) {
    return Promise.resolve();
  }

  requestLoadedStream() {}

  onLoadedStream() {
    return this._loadedStreamPromise;
  }

  terminate(reason) {}

}

exports.LocalPdfManager = LocalPdfManager;

class NetworkPdfManager extends BasePdfManager {
  constructor(docId, pdfNetworkStream, args, evaluatorOptions, enableXfa, docBaseUrl) {
    super();
    this._docId = docId;
    this._password = args.password;
    this._docBaseUrl = parseDocBaseUrl(docBaseUrl);
    this.msgHandler = args.msgHandler;
    this.evaluatorOptions = evaluatorOptions;
    this.enableXfa = enableXfa;
    this.streamManager = new _chunked_stream.ChunkedStreamManager(pdfNetworkStream, {
      msgHandler: args.msgHandler,
      length: args.length,
      disableAutoFetch: args.disableAutoFetch,
      rangeChunkSize: args.rangeChunkSize
    });
    this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
  }

  async ensure(obj, prop, args) {
    try {
      const value = obj[prop];

      if (typeof value === "function") {
        return value.apply(obj, args);
      }

      return value;
    } catch (ex) {
      if (!(ex instanceof _core_utils.MissingDataException)) {
        throw ex;
      }

      await this.requestRange(ex.begin, ex.end);
      return this.ensure(obj, prop, args);
    }
  }

  requestRange(begin, end) {
    return this.streamManager.requestRange(begin, end);
  }

  requestLoadedStream() {
    this.streamManager.requestAllChunks();
  }

  sendProgressiveData(chunk) {
    this.streamManager.onReceiveData({
      chunk
    });
  }

  onLoadedStream() {
    return this.streamManager.onLoadedStream();
  }

  terminate(reason) {
    this.streamManager.abort(reason);
  }

}

exports.NetworkPdfManager = NetworkPdfManager;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChunkedStreamManager = exports.ChunkedStream = void 0;

var _util = __w_pdfjs_require__(2);

var _core_utils = __w_pdfjs_require__(9);

var _stream = __w_pdfjs_require__(10);

class ChunkedStream extends _stream.Stream {
  constructor(length, chunkSize, manager) {
    super(new Uint8Array(length), 0, length, null);
    this.chunkSize = chunkSize;
    this._loadedChunks = new Set();
    this.numChunks = Math.ceil(length / chunkSize);
    this.manager = manager;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }

  getMissingChunks() {
    const chunks = [];

    for (let chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
      if (!this._loadedChunks.has(chunk)) {
        chunks.push(chunk);
      }
    }

    return chunks;
  }

  get numChunksLoaded() {
    return this._loadedChunks.size;
  }

  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }

  onReceiveData(begin, chunk) {
    const chunkSize = this.chunkSize;

    if (begin % chunkSize !== 0) {
      throw new Error(`Bad begin offset: ${begin}`);
    }

    const end = begin + chunk.byteLength;

    if (end % chunkSize !== 0 && end !== this.bytes.length) {
      throw new Error(`Bad end offset: ${end}`);
    }

    this.bytes.set(new Uint8Array(chunk), begin);
    const beginChunk = Math.floor(begin / chunkSize);
    const endChunk = Math.floor((end - 1) / chunkSize) + 1;

    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }

  onReceiveProgressiveData(data) {
    let position = this.progressiveDataLength;
    const beginChunk = Math.floor(position / this.chunkSize);
    this.bytes.set(new Uint8Array(data), position);
    position += data.byteLength;
    this.progressiveDataLength = position;
    const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);

    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }

  ensureByte(pos) {
    if (pos < this.progressiveDataLength) {
      return;
    }

    const chunk = Math.floor(pos / this.chunkSize);

    if (chunk === this.lastSuccessfulEnsureByteChunk) {
      return;
    }

    if (!this._loadedChunks.has(chunk)) {
      throw new _core_utils.MissingDataException(pos, pos + 1);
    }

    this.lastSuccessfulEnsureByteChunk = chunk;
  }

  ensureRange(begin, end) {
    if (begin >= end) {
      return;
    }

    if (end <= this.progressiveDataLength) {
      return;
    }

    const chunkSize = this.chunkSize;
    const beginChunk = Math.floor(begin / chunkSize);
    const endChunk = Math.floor((end - 1) / chunkSize) + 1;

    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
      if (!this._loadedChunks.has(chunk)) {
        throw new _core_utils.MissingDataException(begin, end);
      }
    }
  }

  nextEmptyChunk(beginChunk) {
    const numChunks = this.numChunks;

    for (let i = 0; i < numChunks; ++i) {
      const chunk = (beginChunk + i) % numChunks;

      if (!this._loadedChunks.has(chunk)) {
        return chunk;
      }
    }

    return null;
  }

  hasChunk(chunk) {
    return this._loadedChunks.has(chunk);
  }

  getByte() {
    const pos = this.pos;

    if (pos >= this.end) {
      return -1;
    }

    if (pos >= this.progressiveDataLength) {
      this.ensureByte(pos);
    }

    return this.bytes[this.pos++];
  }

  getBytes(length, forceClamped = false) {
    const bytes = this.bytes;
    const pos = this.pos;
    const strEnd = this.end;

    if (!length) {
      if (strEnd > this.progressiveDataLength) {
        this.ensureRange(pos, strEnd);
      }

      const subarray = bytes.subarray(pos, strEnd);
      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
    }

    let end = pos + length;

    if (end > strEnd) {
      end = strEnd;
    }

    if (end > this.progressiveDataLength) {
      this.ensureRange(pos, end);
    }

    this.pos = end;
    const subarray = bytes.subarray(pos, end);
    return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
  }

  getByteRange(begin, end) {
    if (begin < 0) {
      begin = 0;
    }

    if (end > this.end) {
      end = this.end;
    }

    if (end > this.progressiveDataLength) {
      this.ensureRange(begin, end);
    }

    return this.bytes.subarray(begin, end);
  }

  makeSubStream(start, length, dict = null) {
    if (length) {
      if (start + length > this.progressiveDataLength) {
        this.ensureRange(start, start + length);
      }
    } else {
      if (start >= this.progressiveDataLength) {
        this.ensureByte(start);
      }
    }

    function ChunkedStreamSubstream() {}

    ChunkedStreamSubstream.prototype = Object.create(this);

    ChunkedStreamSubstream.prototype.getMissingChunks = function () {
      const chunkSize = this.chunkSize;
      const beginChunk = Math.floor(this.start / chunkSize);
      const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
      const missingChunks = [];

      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!this._loadedChunks.has(chunk)) {
          missingChunks.push(chunk);
        }
      }

      return missingChunks;
    };

    Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
      get() {
        if (this.numChunksLoaded === this.numChunks) {
          return true;
        }

        return this.getMissingChunks().length === 0;
      },

      configurable: true
    });
    const subStream = new ChunkedStreamSubstream();
    subStream.pos = subStream.start = start;
    subStream.end = start + length || this.end;
    subStream.dict = dict;
    return subStream;
  }

  getBaseStreams() {
    return [this];
  }

}

exports.ChunkedStream = ChunkedStream;

class ChunkedStreamManager {
  constructor(pdfNetworkStream, args) {
    this.length = args.length;
    this.chunkSize = args.rangeChunkSize;
    this.stream = new ChunkedStream(this.length, this.chunkSize, this);
    this.pdfNetworkStream = pdfNetworkStream;
    this.disableAutoFetch = args.disableAutoFetch;
    this.msgHandler = args.msgHandler;
    this.currRequestId = 0;
    this._chunksNeededByRequest = new Map();
    this._requestsByChunk = new Map();
    this._promisesByRequest = new Map();
    this.progressiveDataLength = 0;
    this.aborted = false;
    this._loadedStreamCapability = (0, _util.createPromiseCapability)();
  }

  onLoadedStream() {
    return this._loadedStreamCapability.promise;
  }

  sendRequest(begin, end) {
    const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);

    if (!rangeReader.isStreamingSupported) {
      rangeReader.onProgress = this.onProgress.bind(this);
    }

    let chunks = [],
        loaded = 0;
    const promise = new Promise((resolve, reject) => {
      const readChunk = chunk => {
        try {
          if (!chunk.done) {
            const data = chunk.value;
            chunks.push(data);
            loaded += (0, _util.arrayByteLength)(data);

            if (rangeReader.isStreamingSupported) {
              this.onProgress({
                loaded
              });
            }

            rangeReader.read().then(readChunk, reject);
            return;
          }

          const chunkData = (0, _util.arraysToBytes)(chunks);
          chunks = null;
          resolve(chunkData);
        } catch (e) {
          reject(e);
        }
      };

      rangeReader.read().then(readChunk, reject);
    });
    promise.then(data => {
      if (this.aborted) {
        return;
      }

      this.onReceiveData({
        chunk: data,
        begin
      });
    });
  }

  requestAllChunks() {
    const missingChunks = this.stream.getMissingChunks();

    this._requestChunks(missingChunks);

    return this._loadedStreamCapability.promise;
  }

  _requestChunks(chunks) {
    const requestId = this.currRequestId++;
    const chunksNeeded = new Set();

    this._chunksNeededByRequest.set(requestId, chunksNeeded);

    for (const chunk of chunks) {
      if (!this.stream.hasChunk(chunk)) {
        chunksNeeded.add(chunk);
      }
    }

    if (chunksNeeded.size === 0) {
      return Promise.resolve();
    }

    const capability = (0, _util.createPromiseCapability)();

    this._promisesByRequest.set(requestId, capability);

    const chunksToRequest = [];

    for (const chunk of chunksNeeded) {
      let requestIds = this._requestsByChunk.get(chunk);

      if (!requestIds) {
        requestIds = [];

        this._requestsByChunk.set(chunk, requestIds);

        chunksToRequest.push(chunk);
      }

      requestIds.push(requestId);
    }

    if (chunksToRequest.length > 0) {
      const groupedChunksToRequest = this.groupChunks(chunksToRequest);

      for (const groupedChunk of groupedChunksToRequest) {
        const begin = groupedChunk.beginChunk * this.chunkSize;
        const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
        this.sendRequest(begin, end);
      }
    }

    return capability.promise.catch(reason => {
      if (this.aborted) {
        return;
      }

      throw reason;
    });
  }

  getStream() {
    return this.stream;
  }

  requestRange(begin, end) {
    end = Math.min(end, this.length);
    const beginChunk = this.getBeginChunk(begin);
    const endChunk = this.getEndChunk(end);
    const chunks = [];

    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
      chunks.push(chunk);
    }

    return this._requestChunks(chunks);
  }

  requestRanges(ranges = []) {
    const chunksToRequest = [];

    for (const range of ranges) {
      const beginChunk = this.getBeginChunk(range.begin);
      const endChunk = this.getEndChunk(range.end);

      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!chunksToRequest.includes(chunk)) {
          chunksToRequest.push(chunk);
        }
      }
    }

    chunksToRequest.sort(function (a, b) {
      return a - b;
    });
    return this._requestChunks(chunksToRequest);
  }

  groupChunks(chunks) {
    const groupedChunks = [];
    let beginChunk = -1;
    let prevChunk = -1;

    for (let i = 0, ii = chunks.length; i < ii; ++i) {
      const chunk = chunks[i];

      if (beginChunk < 0) {
        beginChunk = chunk;
      }

      if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
        groupedChunks.push({
          beginChunk,
          endChunk: prevChunk + 1
        });
        beginChunk = chunk;
      }

      if (i + 1 === chunks.length) {
        groupedChunks.push({
          beginChunk,
          endChunk: chunk + 1
        });
      }

      prevChunk = chunk;
    }

    return groupedChunks;
  }

  onProgress(args) {
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
      total: this.length
    });
  }

  onReceiveData(args) {
    const chunk = args.chunk;
    const isProgressive = args.begin === undefined;
    const begin = isProgressive ? this.progressiveDataLength : args.begin;
    const end = begin + chunk.byteLength;
    const beginChunk = Math.floor(begin / this.chunkSize);
    const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);

    if (isProgressive) {
      this.stream.onReceiveProgressiveData(chunk);
      this.progressiveDataLength = end;
    } else {
      this.stream.onReceiveData(begin, chunk);
    }

    if (this.stream.isDataLoaded) {
      this._loadedStreamCapability.resolve(this.stream);
    }

    const loadedRequests = [];

    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      const requestIds = this._requestsByChunk.get(curChunk);

      if (!requestIds) {
        continue;
      }

      this._requestsByChunk.delete(curChunk);

      for (const requestId of requestIds) {
        const chunksNeeded = this._chunksNeededByRequest.get(requestId);

        if (chunksNeeded.has(curChunk)) {
          chunksNeeded.delete(curChunk);
        }

        if (chunksNeeded.size > 0) {
          continue;
        }

        loadedRequests.push(requestId);
      }
    }

    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      let nextEmptyChunk;

      if (this.stream.numChunksLoaded === 1) {
        const lastChunk = this.stream.numChunks - 1;

        if (!this.stream.hasChunk(lastChunk)) {
          nextEmptyChunk = lastChunk;
        }
      } else {
        nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
      }

      if (Number.isInteger(nextEmptyChunk)) {
        this._requestChunks([nextEmptyChunk]);
      }
    }

    for (const requestId of loadedRequests) {
      const capability = this._promisesByRequest.get(requestId);

      this._promisesByRequest.delete(requestId);

      capability.resolve();
    }

    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize,
      total: this.length
    });
  }

  onError(err) {
    this._loadedStreamCapability.reject(err);
  }

  getBeginChunk(begin) {
    return Math.floor(begin / this.chunkSize);
  }

  getEndChunk(end) {
    return Math.floor((end - 1) / this.chunkSize) + 1;
  }

  abort(reason) {
    this.aborted = true;

    if (this.pdfNetworkStream) {
      this.pdfNetworkStream.cancelAllRequests(reason);
    }

    for (const capability of this._promisesByRequest.values()) {
      capability.reject(reason);
    }
  }

}

exports.ChunkedStreamManager = ChunkedStreamManager;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.collectActions = collectActions;
exports.encodeToXmlString = encodeToXmlString;
exports.escapePDFName = escapePDFName;
exports.getArrayLookupTableFactory = getArrayLookupTableFactory;
exports.getInheritableProperty = getInheritableProperty;
exports.getLookupTableFactory = getLookupTableFactory;
exports.isWhiteSpace = isWhiteSpace;
exports.log2 = log2;
exports.parseXFAPath = parseXFAPath;
exports.readInt8 = readInt8;
exports.readUint16 = readUint16;
exports.readUint32 = readUint32;
exports.toRomanNumerals = toRomanNumerals;
exports.validateCSSFont = validateCSSFont;
exports.XRefParseException = exports.XRefEntryException = exports.MissingDataException = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

function getLookupTableFactory(initializer) {
  let lookup;
  return function () {
    if (initializer) {
      lookup = Object.create(null);
      initializer(lookup);
      initializer = null;
    }

    return lookup;
  };
}

function getArrayLookupTableFactory(initializer) {
  let lookup;
  return function () {
    if (initializer) {
      let arr = initializer();
      initializer = null;
      lookup = Object.create(null);

      for (let i = 0, ii = arr.length; i < ii; i += 2) {
        lookup[arr[i]] = arr[i + 1];
      }

      arr = null;
    }

    return lookup;
  };
}

class MissingDataException extends _util.BaseException {
  constructor(begin, end) {
    super(`Missing data [${begin}, ${end})`);
    this.begin = begin;
    this.end = end;
  }

}

exports.MissingDataException = MissingDataException;

class XRefEntryException extends _util.BaseException {}

exports.XRefEntryException = XRefEntryException;

class XRefParseException extends _util.BaseException {}

exports.XRefParseException = XRefParseException;

function getInheritableProperty({
  dict,
  key,
  getArray = false,
  stopWhenFound = true
}) {
  let values;
  const visited = new _primitives.RefSet();

  while (dict instanceof _primitives.Dict && !(dict.objId && visited.has(dict.objId))) {
    if (dict.objId) {
      visited.put(dict.objId);
    }

    const value = getArray ? dict.getArray(key) : dict.get(key);

    if (value !== undefined) {
      if (stopWhenFound) {
        return value;
      }

      if (!values) {
        values = [];
      }

      values.push(value);
    }

    dict = dict.get("Parent");
  }

  return values;
}

const ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];

function toRomanNumerals(number, lowerCase = false) {
  (0, _util.assert)(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
  const romanBuf = [];
  let pos;

  while (number >= 1000) {
    number -= 1000;
    romanBuf.push("M");
  }

  pos = number / 100 | 0;
  number %= 100;
  romanBuf.push(ROMAN_NUMBER_MAP[pos]);
  pos = number / 10 | 0;
  number %= 10;
  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
  romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
  const romanStr = romanBuf.join("");
  return lowerCase ? romanStr.toLowerCase() : romanStr;
}

function log2(x) {
  if (x <= 0) {
    return 0;
  }

  return Math.ceil(Math.log2(x));
}

function readInt8(data, offset) {
  return data[offset] << 24 >> 24;
}

function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}

function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}

function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
}

function parseXFAPath(path) {
  const positionPattern = /(.+)\[([0-9]+)\]$/;
  return path.split(".").map(component => {
    const m = component.match(positionPattern);

    if (m) {
      return {
        name: m[1],
        pos: parseInt(m[2], 10)
      };
    }

    return {
      name: component,
      pos: 0
    };
  });
}

function escapePDFName(str) {
  const buffer = [];
  let start = 0;

  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);

    if (char < 0x21 || char > 0x7e || char === 0x23 || char === 0x28 || char === 0x29 || char === 0x3c || char === 0x3e || char === 0x5b || char === 0x5d || char === 0x7b || char === 0x7d || char === 0x2f || char === 0x25) {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }

      buffer.push(`#${char.toString(16)}`);
      start = i + 1;
    }
  }

  if (buffer.length === 0) {
    return str;
  }

  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }

  return buffer.join("");
}

function _collectJS(entry, xref, list, parents) {
  if (!entry) {
    return;
  }

  let parent = null;

  if ((0, _primitives.isRef)(entry)) {
    if (parents.has(entry)) {
      return;
    }

    parent = entry;
    parents.put(parent);
    entry = xref.fetch(entry);
  }

  if (Array.isArray(entry)) {
    for (const element of entry) {
      _collectJS(element, xref, list, parents);
    }
  } else if (entry instanceof _primitives.Dict) {
    if ((0, _primitives.isName)(entry.get("S"), "JavaScript") && entry.has("JS")) {
      const js = entry.get("JS");
      let code;

      if ((0, _primitives.isStream)(js)) {
        code = js.getString();
      } else {
        code = js;
      }

      code = (0, _util.stringToPDFString)(code);

      if (code) {
        list.push(code);
      }
    }

    _collectJS(entry.getRaw("Next"), xref, list, parents);
  }

  if (parent) {
    parents.remove(parent);
  }
}

function collectActions(xref, dict, eventType) {
  const actions = Object.create(null);
  const additionalActionsDicts = getInheritableProperty({
    dict,
    key: "AA",
    stopWhenFound: false
  });

  if (additionalActionsDicts) {
    for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
      const additionalActions = additionalActionsDicts[i];

      if (!(additionalActions instanceof _primitives.Dict)) {
        continue;
      }

      for (const key of additionalActions.getKeys()) {
        const action = eventType[key];

        if (!action) {
          continue;
        }

        const actionDict = additionalActions.getRaw(key);
        const parents = new _primitives.RefSet();
        const list = [];

        _collectJS(actionDict, xref, list, parents);

        if (list.length > 0) {
          actions[action] = list;
        }
      }
    }
  }

  if (dict.has("A")) {
    const actionDict = dict.get("A");
    const parents = new _primitives.RefSet();
    const list = [];

    _collectJS(actionDict, xref, list, parents);

    if (list.length > 0) {
      actions.Action = list;
    }
  }

  return (0, _util.objectSize)(actions) > 0 ? actions : null;
}

const XMLEntities = {
  0x3c: "&lt;",
  0x3e: "&gt;",
  0x26: "&amp;",
  0x22: "&quot;",
  0x27: "&apos;"
};

function encodeToXmlString(str) {
  const buffer = [];
  let start = 0;

  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.codePointAt(i);

    if (0x20 <= char && char <= 0x7e) {
      const entity = XMLEntities[char];

      if (entity) {
        if (start < i) {
          buffer.push(str.substring(start, i));
        }

        buffer.push(entity);
        start = i + 1;
      }
    } else {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }

      buffer.push(`&#x${char.toString(16).toUpperCase()};`);

      if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
        i++;
      }

      start = i + 1;
    }
  }

  if (buffer.length === 0) {
    return str;
  }

  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }

  return buffer.join("");
}

function validateCSSFont(cssFontInfo) {
  const DEFAULT_CSS_FONT_OBLIQUE = "14";
  const DEFAULT_CSS_FONT_WEIGHT = "400";
  const CSS_FONT_WEIGHT_VALUES = new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]);
  const {
    fontFamily,
    fontWeight,
    italicAngle
  } = cssFontInfo;

  if (/^".*"$/.test(fontFamily)) {
    if (/[^\\]"/.test(fontFamily.slice(1, fontFamily.length - 1))) {
      (0, _util.warn)(`XFA - FontFamily contains some unescaped ": ${fontFamily}.`);
      return false;
    }
  } else if (/^'.*'$/.test(fontFamily)) {
    if (/[^\\]'/.test(fontFamily.slice(1, fontFamily.length - 1))) {
      (0, _util.warn)(`XFA - FontFamily contains some unescaped ': ${fontFamily}.`);
      return false;
    }
  } else {
    for (const ident of fontFamily.split(/[ \t]+/)) {
      if (/^([0-9]|(-([0-9]|-)))/.test(ident) || !/^[a-zA-Z0-9\-_\\]+$/.test(ident)) {
        (0, _util.warn)(`XFA - FontFamily contains some invalid <custom-ident>: ${fontFamily}.`);
        return false;
      }
    }
  }

  const weight = fontWeight ? fontWeight.toString() : "";
  cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight) ? weight : DEFAULT_CSS_FONT_WEIGHT;
  const angle = parseFloat(italicAngle);
  cssFontInfo.italicAngle = isNaN(angle) || angle < -90 || angle > 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString();
  return true;
}

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StringStream = exports.Stream = exports.NullStream = void 0;

var _base_stream = __w_pdfjs_require__(6);

var _util = __w_pdfjs_require__(2);

class Stream extends _base_stream.BaseStream {
  constructor(arrayBuffer, start, length, dict) {
    super();
    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
    this.start = start || 0;
    this.pos = this.start;
    this.end = start + length || this.bytes.length;
    this.dict = dict;
  }

  get length() {
    return this.end - this.start;
  }

  get isEmpty() {
    return this.length === 0;
  }

  getByte() {
    if (this.pos >= this.end) {
      return -1;
    }

    return this.bytes[this.pos++];
  }

  getBytes(length, forceClamped = false) {
    const bytes = this.bytes;
    const pos = this.pos;
    const strEnd = this.end;

    if (!length) {
      const subarray = bytes.subarray(pos, strEnd);
      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
    }

    let end = pos + length;

    if (end > strEnd) {
      end = strEnd;
    }

    this.pos = end;
    const subarray = bytes.subarray(pos, end);
    return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
  }

  getByteRange(begin, end) {
    if (begin < 0) {
      begin = 0;
    }

    if (end > this.end) {
      end = this.end;
    }

    return this.bytes.subarray(begin, end);
  }

  reset() {
    this.pos = this.start;
  }

  moveStart() {
    this.start = this.pos;
  }

  makeSubStream(start, length, dict = null) {
    return new Stream(this.bytes.buffer, start, length, dict);
  }

}

exports.Stream = Stream;

class StringStream extends Stream {
  constructor(str) {
    super((0, _util.stringToBytes)(str));
  }

}

exports.StringStream = StringStream;

class NullStream extends Stream {
  constructor() {
    super(new Uint8Array(0));
  }

}

exports.NullStream = NullStream;

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDocument = exports.Page = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

var _stream = __w_pdfjs_require__(10);

var _annotation = __w_pdfjs_require__(12);

var _base_stream = __w_pdfjs_require__(6);

var _crypto = __w_pdfjs_require__(65);

var _catalog = __w_pdfjs_require__(57);

var _parser = __w_pdfjs_require__(17);

var _object_loader = __w_pdfjs_require__(63);

var _operator_list = __w_pdfjs_require__(55);

var _evaluator = __w_pdfjs_require__(15);

var _decode_stream = __w_pdfjs_require__(19);

var _struct_tree = __w_pdfjs_require__(62);

var _factory = __w_pdfjs_require__(67);

var _xref = __w_pdfjs_require__(87);

const DEFAULT_USER_UNIT = 1.0;
const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];

class Page {
  constructor({
    pdfManager,
    xref,
    pageIndex,
    pageDict,
    ref,
    globalIdFactory,
    fontCache,
    builtInCMapCache,
    globalImageCache,
    nonBlendModesSet,
    xfaFactory
  }) {
    this.pdfManager = pdfManager;
    this.pageIndex = pageIndex;
    this.pageDict = pageDict;
    this.xref = xref;
    this.ref = ref;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.globalImageCache = globalImageCache;
    this.nonBlendModesSet = nonBlendModesSet;
    this.evaluatorOptions = pdfManager.evaluatorOptions;
    this.resourcesPromise = null;
    this.xfaFactory = xfaFactory;
    const idCounters = {
      obj: 0
    };
    this._localIdFactory = class extends globalIdFactory {
      static createObjId() {
        return `p${pageIndex}_${++idCounters.obj}`;
      }

      static getPageObjId() {
        return `page${ref.toString()}`;
      }

    };
  }

  _getInheritableProperty(key, getArray = false) {
    const value = (0, _core_utils.getInheritableProperty)({
      dict: this.pageDict,
      key,
      getArray,
      stopWhenFound: false
    });

    if (!Array.isArray(value)) {
      return value;
    }

    if (value.length === 1 || !(0, _primitives.isDict)(value[0])) {
      return value[0];
    }

    return _primitives.Dict.merge({
      xref: this.xref,
      dictArray: value
    });
  }

  get content() {
    return this.pageDict.getArray("Contents");
  }

  get resources() {
    return (0, _util.shadow)(this, "resources", this._getInheritableProperty("Resources") || _primitives.Dict.empty);
  }

  _getBoundingBox(name) {
    if (this.xfaData) {
      const {
        width,
        height
      } = this.xfaData.attributes.style;
      return [0, 0, parseInt(width), parseInt(height)];
    }

    const box = this._getInheritableProperty(name, true);

    if (Array.isArray(box) && box.length === 4) {
      if (box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
        return box;
      }

      (0, _util.warn)(`Empty /${name} entry.`);
    }

    return null;
  }

  get mediaBox() {
    return (0, _util.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
  }

  get cropBox() {
    return (0, _util.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }

  get userUnit() {
    let obj = this.pageDict.get("UserUnit");

    if (!(0, _util.isNum)(obj) || obj <= 0) {
      obj = DEFAULT_USER_UNIT;
    }

    return (0, _util.shadow)(this, "userUnit", obj);
  }

  get view() {
    const {
      cropBox,
      mediaBox
    } = this;
    let view;

    if (cropBox === mediaBox || (0, _util.isArrayEqual)(cropBox, mediaBox)) {
      view = mediaBox;
    } else {
      const box = _util.Util.intersect(cropBox, mediaBox);

      if (box && box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
        view = box;
      } else {
        (0, _util.warn)("Empty /CropBox and /MediaBox intersection.");
      }
    }

    return (0, _util.shadow)(this, "view", view || mediaBox);
  }

  get rotate() {
    let rotate = this._getInheritableProperty("Rotate") || 0;

    if (rotate % 90 !== 0) {
      rotate = 0;
    } else if (rotate >= 360) {
      rotate = rotate % 360;
    } else if (rotate < 0) {
      rotate = (rotate % 360 + 360) % 360;
    }

    return (0, _util.shadow)(this, "rotate", rotate);
  }

  getContentStream() {
    return this.pdfManager.ensure(this, "content").then(content => {
      if (content instanceof _base_stream.BaseStream) {
        return content;
      }

      if (Array.isArray(content)) {
        return new _decode_stream.StreamsSequenceStream(content);
      }

      return new _stream.NullStream();
    });
  }

  get xfaData() {
    if (this.xfaFactory) {
      return (0, _util.shadow)(this, "xfaData", this.xfaFactory.getPage(this.pageIndex));
    }

    return (0, _util.shadow)(this, "xfaData", null);
  }

  save(handler, task, annotationStorage) {
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      globalImageCache: this.globalImageCache,
      options: this.evaluatorOptions
    });
    return this._parsedAnnotations.then(function (annotations) {
      const newRefsPromises = [];

      for (const annotation of annotations) {
        if (!annotation.mustBePrinted(annotationStorage)) {
          continue;
        }

        newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function (reason) {
          (0, _util.warn)("save - ignoring annotation data during " + `"${task.name}" task: "${reason}".`);
          return null;
        }));
      }

      return Promise.all(newRefsPromises);
    });
  }

  loadResources(keys) {
    if (!this.resourcesPromise) {
      this.resourcesPromise = this.pdfManager.ensure(this, "resources");
    }

    return this.resourcesPromise.then(() => {
      const objectLoader = new _object_loader.ObjectLoader(this.resources, keys, this.xref);
      return objectLoader.load();
    });
  }

  getOperatorList({
    handler,
    sink,
    task,
    intent,
    renderInteractiveForms,
    annotationStorage
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]);
    const partialEvaluator = new _evaluator.PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      globalImageCache: this.globalImageCache,
      options: this.evaluatorOptions
    });
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    const pageListPromise = dataPromises.then(([contentStream]) => {
      const opList = new _operator_list.OperatorList(intent, sink);
      handler.send("StartRenderPage", {
        transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet),
        pageIndex: this.pageIndex,
        intent
      });
      return partialEvaluator.getOperatorList({
        stream: contentStream,
        task,
        resources: this.resources,
        operatorList: opList
      }).then(function () {
        return opList;
      });
    });
    return Promise.all([pageListPromise, this._parsedAnnotations]).then(function ([pageOpList, annotations]) {
      if (annotations.length === 0) {
        pageOpList.flush(true);
        return {
          length: pageOpList.totalLength
        };
      }

      const opListPromises = [];

      for (const annotation of annotations) {
        if (intent === "display" && annotation.mustBeViewed(annotationStorage) || intent === "print" && annotation.mustBePrinted(annotationStorage)) {
          opListPromises.push(annotation.getOperatorList(partialEvaluator, task, renderInteractiveForms, annotationStorage).catch(function (reason) {
            (0, _util.warn)("getOperatorList - ignoring annotation data during " + `"${task.name}" task: "${reason}".`);
            return null;
          }));
        }
      }

      return Promise.all(opListPromises).then(function (opLists) {
        pageOpList.addOp(_util.OPS.beginAnnotations, []);

        for (const opList of opLists) {
          pageOpList.addOpList(opList);
        }

        pageOpList.addOp(_util.OPS.endAnnotations, []);
        pageOpList.flush(true);
        return {
          length: pageOpList.totalLength
        };
      });
    });
  }

  extractTextContent({
    handler,
    task,
    normalizeWhitespace,
    includeMarkedContent,
    sink,
    combineTextItems
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    return dataPromises.then(([contentStream]) => {
      const partialEvaluator = new _evaluator.PartialEvaluator({
        xref: this.xref,
        handler,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        globalImageCache: this.globalImageCache,
        options: this.evaluatorOptions
      });
      return partialEvaluator.getTextContent({
        stream: contentStream,
        task,
        resources: this.resources,
        normalizeWhitespace,
        includeMarkedContent,
        combineTextItems,
        sink
      });
    });
  }

  async getStructTree() {
    const structTreeRoot = await this.pdfManager.ensureCatalog("structTreeRoot");

    if (!structTreeRoot) {
      return null;
    }

    const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [structTreeRoot]);
    return structTree.serializable;
  }

  _parseStructTree(structTreeRoot) {
    const tree = new _struct_tree.StructTreePage(structTreeRoot, this.pageDict);
    tree.parse();
    return tree;
  }

  getAnnotationsData(intent) {
    return this._parsedAnnotations.then(function (annotations) {
      const annotationsData = [];

      for (let i = 0, ii = annotations.length; i < ii; i++) {
        if (!intent || intent === "display" && annotations[i].viewable || intent === "print" && annotations[i].printable) {
          annotationsData.push(annotations[i].data);
        }
      }

      return annotationsData;
    });
  }

  get annotations() {
    const annots = this._getInheritableProperty("Annots");

    return (0, _util.shadow)(this, "annotations", Array.isArray(annots) ? annots : []);
  }

  get _parsedAnnotations() {
    const parsedAnnotations = this.pdfManager.ensure(this, "annotations").then(() => {
      const annotationPromises = [];

      for (const annotationRef of this.annotations) {
        annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRef, this.pdfManager, this._localIdFactory, false).catch(function (reason) {
          (0, _util.warn)(`_parsedAnnotations: "${reason}".`);
          return null;
        }));
      }

      return Promise.all(annotationPromises).then(function (annotations) {
        return annotations.filter(annotation => !!annotation);
      });
    });
    return (0, _util.shadow)(this, "_parsedAnnotations", parsedAnnotations);
  }

  get jsActions() {
    const actions = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType);
    return (0, _util.shadow)(this, "jsActions", actions);
  }

}

exports.Page = Page;
const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
const STARTXREF_SIGNATURE = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);
const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
const FINGERPRINT_FIRST_BYTES = 1024;
const EMPTY_FINGERPRINT = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
const PDF_HEADER_VERSION_REGEXP = /^[1-9]\.[0-9]$/;

function find(stream, signature, limit = 1024, backwards = false) {
  const signatureLength = signature.length;
  const scanBytes = stream.peekBytes(limit);
  const scanLength = scanBytes.length - signatureLength;

  if (scanLength <= 0) {
    return false;
  }

  if (backwards) {
    const signatureEnd = signatureLength - 1;
    let pos = scanBytes.length - 1;

    while (pos >= signatureEnd) {
      let j = 0;

      while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
        j++;
      }

      if (j >= signatureLength) {
        stream.pos += pos - signatureEnd;
        return true;
      }

      pos--;
    }
  } else {
    let pos = 0;

    while (pos <= scanLength) {
      let j = 0;

      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
        j++;
      }

      if (j >= signatureLength) {
        stream.pos += pos;
        return true;
      }

      pos++;
    }
  }

  return false;
}

class PDFDocument {
  constructor(pdfManager, arg) {
    let stream;

    if ((0, _primitives.isStream)(arg)) {
      stream = arg;
    } else if ((0, _util.isArrayBuffer)(arg)) {
      stream = new _stream.Stream(arg);
    } else {
      throw new Error("PDFDocument: Unknown argument type");
    }

    if (stream.length <= 0) {
      throw new _util.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
    }

    this.pdfManager = pdfManager;
    this.stream = stream;
    this.xref = new _xref.XRef(stream, pdfManager);
    this._pagePromises = [];
    this._version = null;
    const idCounters = {
      font: 0
    };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${pdfManager.docId}`;
      }

      static createFontId() {
        return `f${++idCounters.font}`;
      }

      static createObjId() {
        (0, _util.unreachable)("Abstract method `createObjId` called.");
      }

      static getPageObjId() {
        (0, _util.unreachable)("Abstract method `getPageObjId` called.");
      }

    };
  }

  parse(recoveryMode) {
    this.xref.parse(recoveryMode);
    this.catalog = new _catalog.Catalog(this.pdfManager, this.xref);

    if (this.catalog.version) {
      this._version = this.catalog.version;
    }
  }

  get linearization() {
    let linearization = null;

    try {
      linearization = _parser.Linearization.create(this.stream);
    } catch (err) {
      if (err instanceof _core_utils.MissingDataException) {
        throw err;
      }

      (0, _util.info)(err);
    }

    return (0, _util.shadow)(this, "linearization", linearization);
  }

  get startXRef() {
    const stream = this.stream;
    let startXRef = 0;

    if (this.linearization) {
      stream.reset();

      if (find(stream, ENDOBJ_SIGNATURE)) {
        startXRef = stream.pos + 6 - stream.start;
      }
    } else {
      const step = 1024;
      const startXRefLength = STARTXREF_SIGNATURE.length;
      let found = false,
          pos = stream.end;

      while (!found && pos > 0) {
        pos -= step - startXRefLength;

        if (pos < 0) {
          pos = 0;
        }

        stream.pos = pos;
        found = find(stream, STARTXREF_SIGNATURE, step, true);
      }

      if (found) {
        stream.skip(9);
        let ch;

        do {
          ch = stream.getByte();
        } while ((0, _core_utils.isWhiteSpace)(ch));

        let str = "";

        while (ch >= 0x20 && ch <= 0x39) {
          str += String.fromCharCode(ch);
          ch = stream.getByte();
        }

        startXRef = parseInt(str, 10);

        if (isNaN(startXRef)) {
          startXRef = 0;
        }
      }
    }

    return (0, _util.shadow)(this, "startXRef", startXRef);
  }

  checkHeader() {
    const stream = this.stream;
    stream.reset();

    if (!find(stream, PDF_HEADER_SIGNATURE)) {
      return;
    }

    stream.moveStart();
    const MAX_PDF_VERSION_LENGTH = 12;
    let version = "",
        ch;

    while ((ch = stream.getByte()) > 0x20) {
      if (version.length >= MAX_PDF_VERSION_LENGTH) {
        break;
      }

      version += String.fromCharCode(ch);
    }

    if (!this._version) {
      this._version = version.substring(5);
    }
  }

  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }

  get numPages() {
    if (this.xfaFactory) {
      return (0, _util.shadow)(this, "numPages", this.xfaFactory.numberPages);
    }

    const linearization = this.linearization;
    const num = linearization ? linearization.numPages : this.catalog.numPages;
    return (0, _util.shadow)(this, "numPages", num);
  }

  _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {
    const RECURSION_LIMIT = 10;

    if (!Array.isArray(fields)) {
      return false;
    }

    return fields.every(field => {
      field = this.xref.fetchIfRef(field);

      if (!(field instanceof _primitives.Dict)) {
        return false;
      }

      if (field.has("Kids")) {
        if (++recursionDepth > RECURSION_LIMIT) {
          (0, _util.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached");
          return false;
        }

        return this._hasOnlyDocumentSignatures(field.get("Kids"), recursionDepth);
      }

      const isSignature = (0, _primitives.isName)(field.get("FT"), "Sig");
      const rectangle = field.get("Rect");
      const isInvisible = Array.isArray(rectangle) && rectangle.every(value => value === 0);
      return isSignature && isInvisible;
    });
  }

  get xfaData() {
    const acroForm = this.catalog.acroForm;

    if (!acroForm) {
      return null;
    }

    const xfa = acroForm.get("XFA");
    const entries = {
      "xdp:xdp": "",
      template: "",
      datasets: "",
      config: "",
      connectionSet: "",
      localeSet: "",
      stylesheet: "",
      "/xdp:xdp": ""
    };

    if ((0, _primitives.isStream)(xfa) && !xfa.isEmpty) {
      try {
        entries["xdp:xdp"] = (0, _util.stringToUTF8String)(xfa.getString());
        return entries;
      } catch (_) {
        (0, _util.warn)("XFA - Invalid utf-8 string.");
        return null;
      }
    }

    if (!Array.isArray(xfa) || xfa.length === 0) {
      return null;
    }

    for (let i = 0, ii = xfa.length; i < ii; i += 2) {
      let name;

      if (i === 0) {
        name = "xdp:xdp";
      } else if (i === ii - 2) {
        name = "/xdp:xdp";
      } else {
        name = xfa[i];
      }

      if (!entries.hasOwnProperty(name)) {
        continue;
      }

      const data = this.xref.fetchIfRef(xfa[i + 1]);

      if (!(0, _primitives.isStream)(data) || data.isEmpty) {
        continue;
      }

      try {
        entries[name] = (0, _util.stringToUTF8String)(data.getString());
      } catch (_) {
        (0, _util.warn)("XFA - Invalid utf-8 string.");
        return null;
      }
    }

    return entries;
  }

  get xfaFactory() {
    if (this.pdfManager.enableXfa && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) {
      const data = this.xfaData;
      return (0, _util.shadow)(this, "xfaFactory", data ? new _factory.XFAFactory(data) : null);
    }

    return (0, _util.shadow)(this, "xfaFaxtory", null);
  }

  get isPureXfa() {
    return this.xfaFactory !== null;
  }

  async loadXfaFonts(handler, task) {
    const acroForm = await this.pdfManager.ensureCatalog("acroForm");

    if (!acroForm) {
      return;
    }

    const resources = await acroForm.getAsync("DR");

    if (!(resources instanceof _primitives.Dict)) {
      return;
    }

    const objectLoader = new _object_loader.ObjectLoader(resources, ["Font"], this.xref);
    await objectLoader.load();
    const fontRes = resources.get("Font");

    if (!(fontRes instanceof _primitives.Dict)) {
      return;
    }

    const partialEvaluator = new _evaluator.PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: -1,
      idFactory: this._globalIdFactory,
      fontCache: this.catalog.fontCache,
      builtInCMapCache: this.catalog.builtInCMapCache
    });
    const operatorList = new _operator_list.OperatorList();
    const initialState = {
      font: null,

      clone() {
        return this;
      }

    };
    const fonts = new Map();
    fontRes.forEach((fontName, font) => {
      fonts.set(fontName, font);
    });
    const promises = [];

    for (const [fontName, font] of fonts) {
      const descriptor = font.get("FontDescriptor");

      if (!(descriptor instanceof _primitives.Dict)) {
        continue;
      }

      const fontFamily = descriptor.get("FontFamily");
      const fontWeight = descriptor.get("FontWeight");
      const italicAngle = descriptor.get("ItalicAngle");
      const cssFontInfo = {
        fontFamily,
        fontWeight,
        italicAngle
      };

      if (!(0, _core_utils.validateCSSFont)(cssFontInfo)) {
        continue;
      }

      promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function (reason) {
        (0, _util.warn)(`loadXfaFonts: "${reason}".`);
        return null;
      }));
    }

    await Promise.all(promises);
  }

  get formInfo() {
    const formInfo = {
      hasFields: false,
      hasAcroForm: false,
      hasXfa: false,
      hasSignatures: false
    };
    const acroForm = this.catalog.acroForm;

    if (!acroForm) {
      return (0, _util.shadow)(this, "formInfo", formInfo);
    }

    try {
      const fields = acroForm.get("Fields");
      const hasFields = Array.isArray(fields) && fields.length > 0;
      formInfo.hasFields = hasFields;
      const xfa = acroForm.get("XFA");
      formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || (0, _primitives.isStream)(xfa) && !xfa.isEmpty;
      const sigFlags = acroForm.get("SigFlags");
      const hasSignatures = !!(sigFlags & 0x1);

      const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(fields);

      formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
      formInfo.hasSignatures = hasSignatures;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)(`Cannot fetch form information: "${ex}".`);
    }

    return (0, _util.shadow)(this, "formInfo", formInfo);
  }

  get documentInfo() {
    const DocumentInfoValidators = {
      Title: _util.isString,
      Author: _util.isString,
      Subject: _util.isString,
      Keywords: _util.isString,
      Creator: _util.isString,
      Producer: _util.isString,
      CreationDate: _util.isString,
      ModDate: _util.isString,
      Trapped: _primitives.isName
    };
    let version = this._version;

    if (typeof version !== "string" || !PDF_HEADER_VERSION_REGEXP.test(version)) {
      (0, _util.warn)(`Invalid PDF header version number: ${version}`);
      version = null;
    }

    const docInfo = {
      PDFFormatVersion: version,
      IsLinearized: !!this.linearization,
      IsAcroFormPresent: this.formInfo.hasAcroForm,
      IsXFAPresent: this.formInfo.hasXfa,
      IsCollectionPresent: !!this.catalog.collection,
      IsSignaturesPresent: this.formInfo.hasSignatures
    };
    let infoDict;

    try {
      infoDict = this.xref.trailer.get("Info");
    } catch (err) {
      if (err instanceof _core_utils.MissingDataException) {
        throw err;
      }

      (0, _util.info)("The document information dictionary is invalid.");
    }

    if ((0, _primitives.isDict)(infoDict)) {
      for (const key of infoDict.getKeys()) {
        const value = infoDict.get(key);

        if (DocumentInfoValidators[key]) {
          if (DocumentInfoValidators[key](value)) {
            docInfo[key] = typeof value !== "string" ? value : (0, _util.stringToPDFString)(value);
          } else {
            (0, _util.info)(`Bad value in document info for "${key}".`);
          }
        } else if (typeof key === "string") {
          let customValue;

          if ((0, _util.isString)(value)) {
            customValue = (0, _util.stringToPDFString)(value);
          } else if ((0, _primitives.isName)(value) || (0, _util.isNum)(value) || (0, _util.isBool)(value)) {
            customValue = value;
          } else {
            (0, _util.info)(`Unsupported value in document info for (custom) "${key}".`);
            continue;
          }

          if (!docInfo.Custom) {
            docInfo.Custom = Object.create(null);
          }

          docInfo.Custom[key] = customValue;
        }
      }
    }

    return (0, _util.shadow)(this, "documentInfo", docInfo);
  }

  get fingerprint() {
    let hash;
    const idArray = this.xref.trailer.get("ID");

    if (Array.isArray(idArray) && idArray[0] && (0, _util.isString)(idArray[0]) && idArray[0] !== EMPTY_FINGERPRINT) {
      hash = (0, _util.stringToBytes)(idArray[0]);
    } else {
      hash = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
    }

    const fingerprintBuf = [];

    for (let i = 0, ii = hash.length; i < ii; i++) {
      const hex = hash[i].toString(16);
      fingerprintBuf.push(hex.padStart(2, "0"));
    }

    return (0, _util.shadow)(this, "fingerprint", fingerprintBuf.join(""));
  }

  _getLinearizationPage(pageIndex) {
    const {
      catalog,
      linearization
    } = this;

    const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);

    return this.xref.fetchAsync(ref).then(obj => {
      if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Type") && obj.has("Contents")) {
        if (ref && !catalog.pageKidsCountCache.has(ref)) {
          catalog.pageKidsCountCache.put(ref, 1);
        }

        return [obj, ref];
      }

      throw new _util.FormatError("The Linearization dictionary doesn't point " + "to a valid Page dictionary.");
    }).catch(reason => {
      (0, _util.info)(reason);
      return catalog.getPageDict(pageIndex);
    });
  }

  getPage(pageIndex) {
    if (this._pagePromises[pageIndex] !== undefined) {
      return this._pagePromises[pageIndex];
    }

    const {
      catalog,
      linearization
    } = this;

    if (this.xfaFactory) {
      return Promise.resolve(new Page({
        pdfManager: this.pdfManager,
        xref: this.xref,
        pageIndex,
        pageDict: _primitives.Dict.empty,
        ref: null,
        globalIdFactory: this._globalIdFactory,
        fontCache: catalog.fontCache,
        builtInCMapCache: catalog.builtInCMapCache,
        globalImageCache: catalog.globalImageCache,
        nonBlendModesSet: catalog.nonBlendModesSet,
        xfaFactory: this.xfaFactory
      }));
    }

    const promise = linearization && linearization.pageFirst === pageIndex ? this._getLinearizationPage(pageIndex) : catalog.getPageDict(pageIndex);
    return this._pagePromises[pageIndex] = promise.then(([pageDict, ref]) => {
      return new Page({
        pdfManager: this.pdfManager,
        xref: this.xref,
        pageIndex,
        pageDict,
        ref,
        globalIdFactory: this._globalIdFactory,
        fontCache: catalog.fontCache,
        builtInCMapCache: catalog.builtInCMapCache,
        globalImageCache: catalog.globalImageCache,
        nonBlendModesSet: catalog.nonBlendModesSet,
        xfaFactory: null
      });
    });
  }

  checkFirstPage() {
    return this.getPage(0).catch(async reason => {
      if (reason instanceof _core_utils.XRefEntryException) {
        this._pagePromises.length = 0;
        await this.cleanup();
        throw new _core_utils.XRefParseException();
      }
    });
  }

  fontFallback(id, handler) {
    return this.catalog.fontFallback(id, handler);
  }

  async cleanup(manuallyTriggered = false) {
    return this.catalog ? this.catalog.cleanup(manuallyTriggered) : (0, _primitives.clearPrimitiveCaches)();
  }

  _collectFieldObjects(name, fieldRef, promises) {
    const field = this.xref.fetchIfRef(fieldRef);

    if (field.has("T")) {
      const partName = (0, _util.stringToPDFString)(field.get("T"));

      if (name === "") {
        name = partName;
      } else {
        name = `${name}.${partName}`;
      }
    }

    if (!promises.has(name)) {
      promises.set(name, []);
    }

    promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, this.pdfManager, this._localIdFactory, true).then(annotation => annotation && annotation.getFieldObject()).catch(function (reason) {
      (0, _util.warn)(`_collectFieldObjects: "${reason}".`);
      return null;
    }));

    if (field.has("Kids")) {
      const kids = field.get("Kids");

      for (const kid of kids) {
        this._collectFieldObjects(name, kid, promises);
      }
    }
  }

  get fieldObjects() {
    if (!this.formInfo.hasFields) {
      return (0, _util.shadow)(this, "fieldObjects", Promise.resolve(null));
    }

    const allFields = Object.create(null);
    const fieldPromises = new Map();

    for (const fieldRef of this.catalog.acroForm.get("Fields")) {
      this._collectFieldObjects("", fieldRef, fieldPromises);
    }

    const allPromises = [];

    for (const [name, promises] of fieldPromises) {
      allPromises.push(Promise.all(promises).then(fields => {
        fields = fields.filter(field => !!field);

        if (fields.length > 0) {
          allFields[name] = fields;
        }
      }));
    }

    return (0, _util.shadow)(this, "fieldObjects", Promise.all(allPromises).then(() => allFields));
  }

  get hasJSActions() {
    const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
    return (0, _util.shadow)(this, "hasJSActions", promise);
  }

  async _parseHasJSActions() {
    const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);

    if (catalogJsActions) {
      return true;
    }

    if (fieldObjects) {
      return Object.values(fieldObjects).some(fieldObject => fieldObject.some(object => object.actions !== null));
    }

    return false;
  }

  get calculationOrderIds() {
    const acroForm = this.catalog.acroForm;

    if (!acroForm || !acroForm.has("CO")) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }

    const calculationOrder = acroForm.get("CO");

    if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }

    const ids = calculationOrder.filter(_primitives.isRef).map(ref => ref.toString());

    if (ids.length === 0) {
      return (0, _util.shadow)(this, "calculationOrderIds", null);
    }

    return (0, _util.shadow)(this, "calculationOrderIds", ids);
  }

}

exports.PDFDocument = PDFDocument;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getQuadPoints = getQuadPoints;
exports.MarkupAnnotation = exports.AnnotationFactory = exports.AnnotationBorderStyle = exports.Annotation = void 0;

var _util = __w_pdfjs_require__(2);

var _core_utils = __w_pdfjs_require__(9);

var _default_appearance = __w_pdfjs_require__(13);

var _primitives = __w_pdfjs_require__(5);

var _catalog = __w_pdfjs_require__(57);

var _colorspace = __w_pdfjs_require__(14);

var _file_spec = __w_pdfjs_require__(59);

var _object_loader = __w_pdfjs_require__(63);

var _operator_list = __w_pdfjs_require__(55);

var _stream = __w_pdfjs_require__(10);

var _writer = __w_pdfjs_require__(64);

class AnnotationFactory {
  static create(xref, ref, pdfManager, idFactory, collectFields) {
    return Promise.all([pdfManager.ensureCatalog("acroForm"), collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1]).then(([acroForm, pageIndex]) => pdfManager.ensure(this, "_create", [xref, ref, pdfManager, idFactory, acroForm, collectFields, pageIndex]));
  }

  static _create(xref, ref, pdfManager, idFactory, acroForm, collectFields, pageIndex = -1) {
    const dict = xref.fetchIfRef(ref);

    if (!(0, _primitives.isDict)(dict)) {
      return undefined;
    }

    const id = (0, _primitives.isRef)(ref) ? ref.toString() : `annot_${idFactory.createObjId()}`;
    let subtype = dict.get("Subtype");
    subtype = (0, _primitives.isName)(subtype) ? subtype.name : null;
    const parameters = {
      xref,
      ref,
      dict,
      subtype,
      id,
      pdfManager,
      acroForm: acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty,
      collectFields,
      pageIndex
    };

    switch (subtype) {
      case "Link":
        return new LinkAnnotation(parameters);

      case "Text":
        return new TextAnnotation(parameters);

      case "Widget":
        let fieldType = (0, _core_utils.getInheritableProperty)({
          dict,
          key: "FT"
        });
        fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;

        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotation(parameters);

          case "Btn":
            return new ButtonWidgetAnnotation(parameters);

          case "Ch":
            return new ChoiceWidgetAnnotation(parameters);

          case "Sig":
            return new SignatureWidgetAnnotation(parameters);
        }

        (0, _util.warn)(`Unimplemented widget field type "${fieldType}", ` + "falling back to base field type.");
        return new WidgetAnnotation(parameters);

      case "Popup":
        return new PopupAnnotation(parameters);

      case "FreeText":
        return new FreeTextAnnotation(parameters);

      case "Line":
        return new LineAnnotation(parameters);

      case "Square":
        return new SquareAnnotation(parameters);

      case "Circle":
        return new CircleAnnotation(parameters);

      case "PolyLine":
        return new PolylineAnnotation(parameters);

      case "Polygon":
        return new PolygonAnnotation(parameters);

      case "Caret":
        return new CaretAnnotation(parameters);

      case "Ink":
        return new InkAnnotation(parameters);

      case "Highlight":
        return new HighlightAnnotation(parameters);

      case "Underline":
        return new UnderlineAnnotation(parameters);

      case "Squiggly":
        return new SquigglyAnnotation(parameters);

      case "StrikeOut":
        return new StrikeOutAnnotation(parameters);

      case "Stamp":
        return new StampAnnotation(parameters);

      case "FileAttachment":
        return new FileAttachmentAnnotation(parameters);

      default:
        if (!collectFields) {
          if (!subtype) {
            (0, _util.warn)("Annotation is missing the required /Subtype.");
          } else {
            (0, _util.warn)(`Unimplemented annotation type "${subtype}", ` + "falling back to base annotation.");
          }
        }

        return new Annotation(parameters);
    }
  }

  static async _getPageIndex(xref, ref, pdfManager) {
    try {
      const annotDict = await xref.fetchIfRefAsync(ref);

      if (!(0, _primitives.isDict)(annotDict)) {
        return -1;
      }

      const pageRef = annotDict.getRaw("P");

      if (!(0, _primitives.isRef)(pageRef)) {
        return -1;
      }

      const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [pageRef]);
      return pageIndex;
    } catch (ex) {
      (0, _util.warn)(`_getPageIndex: "${ex}".`);
      return -1;
    }
  }

}

exports.AnnotationFactory = AnnotationFactory;

function getRgbColor(color) {
  const rgbColor = new Uint8ClampedArray(3);

  if (!Array.isArray(color)) {
    return rgbColor;
  }

  switch (color.length) {
    case 0:
      return null;

    case 1:
      _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);

      return rgbColor;

    case 3:
      _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);

      return rgbColor;

    case 4:
      _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);

      return rgbColor;

    default:
      return rgbColor;
  }
}

function getQuadPoints(dict, rect) {
  if (!dict.has("QuadPoints")) {
    return null;
  }

  const quadPoints = dict.getArray("QuadPoints");

  if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {
    return null;
  }

  const quadPointsLists = [];

  for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
    quadPointsLists.push([]);

    for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
      const x = quadPoints[j];
      const y = quadPoints[j + 1];

      if (rect !== null && (x < rect[0] || x > rect[2] || y < rect[1] || y > rect[3])) {
        return null;
      }

      quadPointsLists[i].push({
        x,
        y
      });
    }
  }

  return quadPointsLists.map(quadPointsList => {
    const [minX, maxX, minY, maxY] = quadPointsList.reduce(([mX, MX, mY, MY], quadPoint) => [Math.min(mX, quadPoint.x), Math.max(MX, quadPoint.x), Math.min(mY, quadPoint.y), Math.max(MY, quadPoint.y)], [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]);
    return [{
      x: minX,
      y: maxY
    }, {
      x: maxX,
      y: maxY
    }, {
      x: minX,
      y: minY
    }, {
      x: maxX,
      y: minY
    }];
  });
}

function getTransformMatrix(rect, bbox, matrix) {
  const [minX, minY, maxX, maxY] = _util.Util.getAxialAlignedBoundingBox(bbox, matrix);

  if (minX === maxX || minY === maxY) {
    return [1, 0, 0, 1, rect[0], rect[1]];
  }

  const xRatio = (rect[2] - rect[0]) / (maxX - minX);
  const yRatio = (rect[3] - rect[1]) / (maxY - minY);
  return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
}

class Annotation {
  constructor(params) {
    const dict = params.dict;
    this.setContents(dict.get("Contents"));
    this.setModificationDate(dict.get("M"));
    this.setFlags(dict.get("F"));
    this.setRectangle(dict.getArray("Rect"));
    this.setColor(dict.getArray("C"));
    this.setBorderStyle(dict);
    this.setAppearance(dict);
    this._streams = [];

    if (this.appearance) {
      this._streams.push(this.appearance);
    }

    this.data = {
      annotationFlags: this.flags,
      borderStyle: this.borderStyle,
      color: this.color,
      contents: this.contents,
      hasAppearance: !!this.appearance,
      id: params.id,
      modificationDate: this.modificationDate,
      rect: this.rectangle,
      subtype: params.subtype
    };

    if (params.collectFields) {
      const kids = dict.get("Kids");

      if (Array.isArray(kids)) {
        const kidIds = [];

        for (const kid of kids) {
          if ((0, _primitives.isRef)(kid)) {
            kidIds.push(kid.toString());
          }
        }

        if (kidIds.length !== 0) {
          this.data.kidIds = kidIds;
        }
      }

      this.data.actions = (0, _core_utils.collectActions)(params.xref, dict, _util.AnnotationActionEventType);
      this.data.fieldName = this._constructFieldName(dict);
      this.data.pageIndex = params.pageIndex;
    }

    this._fallbackFontDict = null;
  }

  _hasFlag(flags, flag) {
    return !!(flags & flag);
  }

  _isViewable(flags) {
    return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW);
  }

  _isPrintable(flags) {
    return this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE);
  }

  mustBeViewed(annotationStorage) {
    const storageEntry = annotationStorage && annotationStorage.get(this.data.id);

    if (storageEntry && storageEntry.hidden !== undefined) {
      return !storageEntry.hidden;
    }

    return this.viewable && !this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN);
  }

  mustBePrinted(annotationStorage) {
    const storageEntry = annotationStorage && annotationStorage.get(this.data.id);

    if (storageEntry && storageEntry.print !== undefined) {
      return storageEntry.print;
    }

    return this.printable;
  }

  get viewable() {
    if (this.data.quadPoints === null) {
      return false;
    }

    if (this.flags === 0) {
      return true;
    }

    return this._isViewable(this.flags);
  }

  get printable() {
    if (this.data.quadPoints === null) {
      return false;
    }

    if (this.flags === 0) {
      return false;
    }

    return this._isPrintable(this.flags);
  }

  setContents(contents) {
    this.contents = (0, _util.stringToPDFString)(contents || "");
  }

  setModificationDate(modificationDate) {
    this.modificationDate = (0, _util.isString)(modificationDate) ? modificationDate : null;
  }

  setFlags(flags) {
    this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
  }

  hasFlag(flag) {
    return this._hasFlag(this.flags, flag);
  }

  setRectangle(rectangle) {
    if (Array.isArray(rectangle) && rectangle.length === 4) {
      this.rectangle = _util.Util.normalizeRect(rectangle);
    } else {
      this.rectangle = [0, 0, 0, 0];
    }
  }

  setColor(color) {
    this.color = getRgbColor(color);
  }

  setBorderStyle(borderStyle) {
    this.borderStyle = new AnnotationBorderStyle();

    if (!(0, _primitives.isDict)(borderStyle)) {
      return;
    }

    if (borderStyle.has("BS")) {
      const dict = borderStyle.get("BS");
      const dictType = dict.get("Type");

      if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
        this.borderStyle.setWidth(dict.get("W"), this.rectangle);
        this.borderStyle.setStyle(dict.get("S"));
        this.borderStyle.setDashArray(dict.getArray("D"));
      }
    } else if (borderStyle.has("Border")) {
      const array = borderStyle.getArray("Border");

      if (Array.isArray(array) && array.length >= 3) {
        this.borderStyle.setHorizontalCornerRadius(array[0]);
        this.borderStyle.setVerticalCornerRadius(array[1]);
        this.borderStyle.setWidth(array[2], this.rectangle);

        if (array.length === 4) {
          this.borderStyle.setDashArray(array[3]);
        }
      }
    } else {
      this.borderStyle.setWidth(0);
    }
  }

  setAppearance(dict) {
    this.appearance = null;
    const appearanceStates = dict.get("AP");

    if (!(0, _primitives.isDict)(appearanceStates)) {
      return;
    }

    const normalAppearanceState = appearanceStates.get("N");

    if ((0, _primitives.isStream)(normalAppearanceState)) {
      this.appearance = normalAppearanceState;
      return;
    }

    if (!(0, _primitives.isDict)(normalAppearanceState)) {
      return;
    }

    const as = dict.get("AS");

    if (!(0, _primitives.isName)(as) || !normalAppearanceState.has(as.name)) {
      return;
    }

    this.appearance = normalAppearanceState.get(as.name);
  }

  loadResources(keys) {
    return this.appearance.dict.getAsync("Resources").then(resources => {
      if (!resources) {
        return undefined;
      }

      const objectLoader = new _object_loader.ObjectLoader(resources, keys, resources.xref);
      return objectLoader.load().then(function () {
        return resources;
      });
    });
  }

  getOperatorList(evaluator, task, renderForms, annotationStorage) {
    if (!this.appearance) {
      return Promise.resolve(new _operator_list.OperatorList());
    }

    const appearance = this.appearance;
    const data = this.data;
    const appearanceDict = appearance.dict;
    const resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
    const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
    const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
    const transform = getTransformMatrix(data.rect, bbox, matrix);
    return resourcesPromise.then(resources => {
      const opList = new _operator_list.OperatorList();
      opList.addOp(_util.OPS.beginAnnotation, [data.rect, transform, matrix]);
      return evaluator.getOperatorList({
        stream: appearance,
        task,
        resources,
        operatorList: opList,
        fallbackFontDict: this._fallbackFontDict
      }).then(() => {
        opList.addOp(_util.OPS.endAnnotation, []);
        this.reset();
        return opList;
      });
    });
  }

  async save(evaluator, task, annotationStorage) {
    return null;
  }

  getFieldObject() {
    if (this.data.kidIds) {
      return {
        id: this.data.id,
        actions: this.data.actions,
        name: this.data.fieldName,
        type: "",
        kidIds: this.data.kidIds,
        page: this.data.pageIndex
      };
    }

    return null;
  }

  reset() {
    for (const stream of this._streams) {
      stream.reset();
    }
  }

  _constructFieldName(dict) {
    if (!dict.has("T") && !dict.has("Parent")) {
      (0, _util.warn)("Unknown field name, falling back to empty field name.");
      return "";
    }

    if (!dict.has("Parent")) {
      return (0, _util.stringToPDFString)(dict.get("T"));
    }

    const fieldName = [];

    if (dict.has("T")) {
      fieldName.unshift((0, _util.stringToPDFString)(dict.get("T")));
    }

    let loopDict = dict;
    const visited = new _primitives.RefSet();

    if (dict.objId) {
      visited.put(dict.objId);
    }

    while (loopDict.has("Parent")) {
      loopDict = loopDict.get("Parent");

      if (!(loopDict instanceof _primitives.Dict) || loopDict.objId && visited.has(loopDict.objId)) {
        break;
      }

      if (loopDict.objId) {
        visited.put(loopDict.objId);
      }

      if (loopDict.has("T")) {
        fieldName.unshift((0, _util.stringToPDFString)(loopDict.get("T")));
      }
    }

    return fieldName.join(".");
  }

}

exports.Annotation = Annotation;

class AnnotationBorderStyle {
  constructor() {
    this.width = 1;
    this.style = _util.AnnotationBorderStyleType.SOLID;
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
  }

  setWidth(width, rect = [0, 0, 0, 0]) {
    if ((0, _primitives.isName)(width)) {
      this.width = 0;
      return;
    }

    if (Number.isInteger(width)) {
      if (width > 0) {
        const maxWidth = (rect[2] - rect[0]) / 2;
        const maxHeight = (rect[3] - rect[1]) / 2;

        if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
          (0, _util.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
          width = 1;
        }
      }

      this.width = width;
    }
  }

  setStyle(style) {
    if (!(0, _primitives.isName)(style)) {
      return;
    }

    switch (style.name) {
      case "S":
        this.style = _util.AnnotationBorderStyleType.SOLID;
        break;

      case "D":
        this.style = _util.AnnotationBorderStyleType.DASHED;
        break;

      case "B":
        this.style = _util.AnnotationBorderStyleType.BEVELED;
        break;

      case "I":
        this.style = _util.AnnotationBorderStyleType.INSET;
        break;

      case "U":
        this.style = _util.AnnotationBorderStyleType.UNDERLINE;
        break;

      default:
        break;
    }
  }

  setDashArray(dashArray) {
    if (Array.isArray(dashArray) && dashArray.length > 0) {
      let isValid = true;
      let allZeros = true;

      for (const element of dashArray) {
        const validNumber = +element >= 0;

        if (!validNumber) {
          isValid = false;
          break;
        } else if (element > 0) {
          allZeros = false;
        }
      }

      if (isValid && !allZeros) {
        this.dashArray = dashArray;
      } else {
        this.width = 0;
      }
    } else if (dashArray) {
      this.width = 0;
    }
  }

  setHorizontalCornerRadius(radius) {
    if (Number.isInteger(radius)) {
      this.horizontalCornerRadius = radius;
    }
  }

  setVerticalCornerRadius(radius) {
    if (Number.isInteger(radius)) {
      this.verticalCornerRadius = radius;
    }
  }

}

exports.AnnotationBorderStyle = AnnotationBorderStyle;

class MarkupAnnotation extends Annotation {
  constructor(parameters) {
    super(parameters);
    const dict = parameters.dict;

    if (dict.has("IRT")) {
      const rawIRT = dict.getRaw("IRT");
      this.data.inReplyTo = (0, _primitives.isRef)(rawIRT) ? rawIRT.toString() : null;
      const rt = dict.get("RT");
      this.data.replyType = (0, _primitives.isName)(rt) ? rt.name : _util.AnnotationReplyType.REPLY;
    }

    if (this.data.replyType === _util.AnnotationReplyType.GROUP) {
      const parent = dict.get("IRT");
      this.data.title = (0, _util.stringToPDFString)(parent.get("T") || "");
      this.setContents(parent.get("Contents"));
      this.data.contents = this.contents;

      if (!parent.has("CreationDate")) {
        this.data.creationDate = null;
      } else {
        this.setCreationDate(parent.get("CreationDate"));
        this.data.creationDate = this.creationDate;
      }

      if (!parent.has("M")) {
        this.data.modificationDate = null;
      } else {
        this.setModificationDate(parent.get("M"));
        this.data.modificationDate = this.modificationDate;
      }

      this.data.hasPopup = parent.has("Popup");

      if (!parent.has("C")) {
        this.data.color = null;
      } else {
        this.setColor(parent.getArray("C"));
        this.data.color = this.color;
      }
    } else {
      this.data.title = (0, _util.stringToPDFString)(dict.get("T") || "");
      this.setCreationDate(dict.get("CreationDate"));
      this.data.creationDate = this.creationDate;
      this.data.hasPopup = dict.has("Popup");

      if (!dict.has("C")) {
        this.data.color = null;
      }
    }
  }

  setCreationDate(creationDate) {
    this.creationDate = (0, _util.isString)(creationDate) ? creationDate : null;
  }

  _setDefaultAppearance({
    xref,
    extra,
    strokeColor,
    fillColor,
    blendMode,
    pointsCallback
  }) {
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = Number.MIN_VALUE;
    let maxY = Number.MIN_VALUE;
    const buffer = ["q"];

    if (extra) {
      buffer.push(extra);
    }

    if (strokeColor) {
      buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
    }

    if (fillColor) {
      buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
    }

    let pointsArray = this.data.quadPoints;

    if (!pointsArray) {
      pointsArray = [[{
        x: this.rectangle[0],
        y: this.rectangle[3]
      }, {
        x: this.rectangle[2],
        y: this.rectangle[3]
      }, {
        x: this.rectangle[0],
        y: this.rectangle[1]
      }, {
        x: this.rectangle[2],
        y: this.rectangle[1]
      }]];
    }

    for (const points of pointsArray) {
      const [mX, MX, mY, MY] = pointsCallback(buffer, points);
      minX = Math.min(minX, mX);
      maxX = Math.max(maxX, MX);
      minY = Math.min(minY, mY);
      maxY = Math.max(maxY, MY);
    }

    buffer.push("Q");
    const formDict = new _primitives.Dict(xref);
    const appearanceStreamDict = new _primitives.Dict(xref);
    appearanceStreamDict.set("Subtype", _primitives.Name.get("Form"));
    const appearanceStream = new _stream.StringStream(buffer.join(" "));
    appearanceStream.dict = appearanceStreamDict;
    formDict.set("Fm0", appearanceStream);
    const gsDict = new _primitives.Dict(xref);

    if (blendMode) {
      gsDict.set("BM", _primitives.Name.get(blendMode));
    }

    const stateDict = new _primitives.Dict(xref);
    stateDict.set("GS0", gsDict);
    const resources = new _primitives.Dict(xref);
    resources.set("ExtGState", stateDict);
    resources.set("XObject", formDict);
    const appearanceDict = new _primitives.Dict(xref);
    appearanceDict.set("Resources", resources);
    const bbox = this.data.rect = [minX, minY, maxX, maxY];
    appearanceDict.set("BBox", bbox);
    this.appearance = new _stream.StringStream("/GS0 gs /Fm0 Do");
    this.appearance.dict = appearanceDict;

    this._streams.push(this.appearance, appearanceStream);
  }

}

exports.MarkupAnnotation = MarkupAnnotation;

class WidgetAnnotation extends Annotation {
  constructor(params) {
    super(params);
    const dict = params.dict;
    const data = this.data;
    this.ref = params.ref;
    data.annotationType = _util.AnnotationType.WIDGET;

    if (data.fieldName === undefined) {
      data.fieldName = this._constructFieldName(dict);
    }

    if (data.actions === undefined) {
      data.actions = (0, _core_utils.collectActions)(params.xref, dict, _util.AnnotationActionEventType);
    }

    const fieldValue = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "V",
      getArray: true
    });
    data.fieldValue = this._decodeFormValue(fieldValue);
    const defaultFieldValue = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "DV",
      getArray: true
    });
    data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
    data.alternativeText = (0, _util.stringToPDFString)(dict.get("TU") || "");
    const defaultAppearance = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "DA"
    }) || params.acroForm.get("DA");
    this._defaultAppearance = (0, _util.isString)(defaultAppearance) ? defaultAppearance : "";
    data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance);
    const fieldType = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "FT"
    });
    data.fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
    const localResources = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "DR"
    });
    const acroFormResources = params.acroForm.get("DR");
    const appearanceResources = this.appearance && this.appearance.dict.get("Resources");
    this._fieldResources = {
      localResources,
      acroFormResources,
      appearanceResources,
      mergedResources: _primitives.Dict.merge({
        xref: params.xref,
        dictArray: [localResources, appearanceResources, acroFormResources],
        mergeSubDicts: true
      })
    };
    data.fieldFlags = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "Ff"
    });

    if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
      data.fieldFlags = 0;
    }

    data.readOnly = this.hasFieldFlag(_util.AnnotationFieldFlag.READONLY);
    data.hidden = this._hasFlag(data.annotationFlags, _util.AnnotationFlag.HIDDEN);
  }

  _decodeFormValue(formValue) {
    if (Array.isArray(formValue)) {
      return formValue.filter(item => (0, _util.isString)(item)).map(item => (0, _util.stringToPDFString)(item));
    } else if ((0, _primitives.isName)(formValue)) {
      return (0, _util.stringToPDFString)(formValue.name);
    } else if ((0, _util.isString)(formValue)) {
      return (0, _util.stringToPDFString)(formValue);
    }

    return null;
  }

  hasFieldFlag(flag) {
    return !!(this.data.fieldFlags & flag);
  }

  getOperatorList(evaluator, task, renderForms, annotationStorage) {
    if (renderForms && !(this instanceof SignatureWidgetAnnotation)) {
      return Promise.resolve(new _operator_list.OperatorList());
    }

    if (!this._hasText) {
      return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
    }

    return this._getAppearance(evaluator, task, annotationStorage).then(content => {
      if (this.appearance && content === null) {
        return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
      }

      const operatorList = new _operator_list.OperatorList();

      if (!this._defaultAppearance || content === null) {
        return operatorList;
      }

      const matrix = [1, 0, 0, 1, 0, 0];
      const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
      const transform = getTransformMatrix(this.data.rect, bbox, matrix);
      operatorList.addOp(_util.OPS.beginAnnotation, [this.data.rect, transform, matrix]);
      const stream = new _stream.StringStream(content);
      return evaluator.getOperatorList({
        stream,
        task,
        resources: this._fieldResources.mergedResources,
        operatorList
      }).then(function () {
        operatorList.addOp(_util.OPS.endAnnotation, []);
        return operatorList;
      });
    });
  }

  async save(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }

    const storageEntry = annotationStorage.get(this.data.id);
    const value = storageEntry && storageEntry.value;

    if (value === this.data.fieldValue || value === undefined) {
      return null;
    }

    let appearance = await this._getAppearance(evaluator, task, annotationStorage);

    if (appearance === null) {
      return null;
    }

    const {
      xref
    } = evaluator;
    const dict = xref.fetchIfRef(this.ref);

    if (!(0, _primitives.isDict)(dict)) {
      return null;
    }

    const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
    const xfa = {
      path: (0, _util.stringToPDFString)(dict.get("T") || ""),
      value
    };
    const newRef = xref.getNewRef();
    const AP = new _primitives.Dict(xref);
    AP.set("N", newRef);
    const encrypt = xref.encrypt;
    let originalTransform = null;
    let newTransform = null;

    if (encrypt) {
      originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
      newTransform = encrypt.createCipherTransform(newRef.num, newRef.gen);
      appearance = newTransform.encryptString(appearance);
    }

    dict.set("V", (0, _util.isAscii)(value) ? value : (0, _util.stringToUTF16BEString)(value));
    dict.set("AP", AP);
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    const appearanceDict = new _primitives.Dict(xref);
    appearanceDict.set("Length", appearance.length);
    appearanceDict.set("Subtype", _primitives.Name.get("Form"));
    appearanceDict.set("Resources", this._getSaveFieldResources(xref));
    appearanceDict.set("BBox", bbox);
    const bufferOriginal = [`${this.ref.num} ${this.ref.gen} obj\n`];
    (0, _writer.writeDict)(dict, bufferOriginal, originalTransform);
    bufferOriginal.push("\nendobj\n");
    const bufferNew = [`${newRef.num} ${newRef.gen} obj\n`];
    (0, _writer.writeDict)(appearanceDict, bufferNew, newTransform);
    bufferNew.push(" stream\n");
    bufferNew.push(appearance);
    bufferNew.push("\nendstream\nendobj\n");
    return [{
      ref: this.ref,
      data: bufferOriginal.join(""),
      xfa
    }, {
      ref: newRef,
      data: bufferNew.join(""),
      xfa: null
    }];
  }

  async _getAppearance(evaluator, task, annotationStorage) {
    const isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD);

    if (!annotationStorage || isPassword) {
      return null;
    }

    const storageEntry = annotationStorage.get(this.data.id);
    let value = storageEntry && storageEntry.value;

    if (value === undefined) {
      return null;
    }

    value = value.trim();

    if (value === "") {
      return "";
    }

    let lineCount = -1;

    if (this.data.multiLine) {
      lineCount = value.split(/\r\n|\r|\n/).length;
    }

    const defaultPadding = 2;
    const hPadding = defaultPadding;
    const totalHeight = this.data.rect[3] - this.data.rect[1];
    const totalWidth = this.data.rect[2] - this.data.rect[0];

    if (!this._defaultAppearance) {
      this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
    }

    const [defaultAppearance, fontSize] = this._computeFontSize(totalHeight, lineCount);

    const font = await this._getFontData(evaluator, task);
    let descent = font.descent;

    if (isNaN(descent)) {
      descent = 0;
    }

    const vPadding = defaultPadding + Math.abs(descent) * fontSize;
    const alignment = this.data.textAlignment;

    if (this.data.multiLine) {
      return this._getMultilineAppearance(defaultAppearance, value, font, fontSize, totalWidth, totalHeight, alignment, hPadding, vPadding);
    }

    const encodedString = font.encodeString(value).join("");

    if (this.data.comb) {
      return this._getCombAppearance(defaultAppearance, font, encodedString, totalWidth, hPadding, vPadding);
    }

    if (alignment === 0 || alignment > 2) {
      return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm (${(0, _util.escapeString)(encodedString)}) Tj` + " ET Q EMC";
    }

    const renderedText = this._renderText(encodedString, font, fontSize, totalWidth, alignment, hPadding, vPadding);

    return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText}` + " ET Q EMC";
  }

  async _getFontData(evaluator, task) {
    const operatorList = new _operator_list.OperatorList();
    const initialState = {
      font: null,

      clone() {
        return this;
      }

    };
    const {
      fontName,
      fontSize
    } = this.data.defaultAppearanceData;
    await evaluator.handleSetFont(this._fieldResources.mergedResources, [fontName && _primitives.Name.get(fontName), fontSize], null, operatorList, task, initialState, null);
    return initialState.font;
  }

  _computeFontSize(height, lineCount) {
    let {
      fontSize
    } = this.data.defaultAppearanceData;

    if (!fontSize) {
      const roundWithOneDigit = x => Math.round(x * 10) / 10;

      const FONT_FACTOR = 0.8;

      if (lineCount === -1) {
        fontSize = roundWithOneDigit(FONT_FACTOR * height);
      } else {
        fontSize = 10;
        let lineHeight = fontSize / FONT_FACTOR;
        let numberOfLines = Math.round(height / lineHeight);
        numberOfLines = Math.max(numberOfLines, lineCount);
        lineHeight = height / numberOfLines;
        fontSize = roundWithOneDigit(FONT_FACTOR * lineHeight);
      }

      const {
        fontName,
        fontColor
      } = this.data.defaultAppearanceData;
      this._defaultAppearance = (0, _default_appearance.createDefaultAppearance)({
        fontSize,
        fontName,
        fontColor
      });
    }

    return [this._defaultAppearance, fontSize];
  }

  _renderText(text, font, fontSize, totalWidth, alignment, hPadding, vPadding) {
    const glyphs = font.charsToGlyphs(text);
    const scale = fontSize / 1000;
    let width = 0;

    for (const glyph of glyphs) {
      width += glyph.width * scale;
    }

    let shift;

    if (alignment === 1) {
      shift = (totalWidth - width) / 2;
    } else if (alignment === 2) {
      shift = totalWidth - width - hPadding;
    } else {
      shift = hPadding;
    }

    shift = shift.toFixed(2);
    vPadding = vPadding.toFixed(2);
    return `${shift} ${vPadding} Td (${(0, _util.escapeString)(text)}) Tj`;
  }

  _getSaveFieldResources(xref) {
    const {
      localResources,
      appearanceResources,
      acroFormResources
    } = this._fieldResources;
    const fontName = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName;

    if (!fontName) {
      return localResources || _primitives.Dict.empty;
    }

    for (const resources of [localResources, appearanceResources]) {
      if (resources instanceof _primitives.Dict) {
        const localFont = resources.get("Font");

        if (localFont instanceof _primitives.Dict && localFont.has(fontName)) {
          return resources;
        }
      }
    }

    if (acroFormResources instanceof _primitives.Dict) {
      const acroFormFont = acroFormResources.get("Font");

      if (acroFormFont instanceof _primitives.Dict && acroFormFont.has(fontName)) {
        const subFontDict = new _primitives.Dict(xref);
        subFontDict.set(fontName, acroFormFont.getRaw(fontName));
        const subResourcesDict = new _primitives.Dict(xref);
        subResourcesDict.set("Font", subFontDict);
        return _primitives.Dict.merge({
          xref,
          dictArray: [subResourcesDict, localResources],
          mergeSubDicts: true
        });
      }
    }

    return localResources || _primitives.Dict.empty;
  }

  getFieldObject() {
    return null;
  }

}

class TextWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this._hasText = true;
    const dict = params.dict;

    if (!(0, _util.isString)(this.data.fieldValue)) {
      this.data.fieldValue = "";
    }

    let alignment = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "Q"
    });

    if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
      alignment = null;
    }

    this.data.textAlignment = alignment;
    let maximumLength = (0, _core_utils.getInheritableProperty)({
      dict,
      key: "MaxLen"
    });

    if (!Number.isInteger(maximumLength) || maximumLength < 0) {
      maximumLength = null;
    }

    this.data.maxLen = maximumLength;
    this.data.multiLine = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE);
    this.data.comb = this.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== null;
  }

  _getCombAppearance(defaultAppearance, font, text, width, hPadding, vPadding) {
    const combWidth = (width / this.data.maxLen).toFixed(2);
    const buf = [];
    const positions = font.getCharPositions(text);

    for (const [start, end] of positions) {
      buf.push(`(${(0, _util.escapeString)(text.substring(start, end))}) Tj`);
    }

    const renderedComb = buf.join(` ${combWidth} 0 Td `);
    return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm ${renderedComb}` + " ET Q EMC";
  }

  _getMultilineAppearance(defaultAppearance, text, font, fontSize, width, height, alignment, hPadding, vPadding) {
    const lines = text.split(/\r\n|\r|\n/);
    const buf = [];
    const totalWidth = width - 2 * hPadding;

    for (const line of lines) {
      const chunks = this._splitLine(line, font, fontSize, totalWidth);

      for (const chunk of chunks) {
        const padding = buf.length === 0 ? hPadding : 0;
        buf.push(this._renderText(chunk, font, fontSize, width, alignment, padding, -fontSize));
      }
    }

    const renderedText = buf.join("\n");
    return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 0 ${height} Tm ${renderedText}` + " ET Q EMC";
  }

  _splitLine(line, font, fontSize, width) {
    line = font.encodeString(line).join("");
    const glyphs = font.charsToGlyphs(line);

    if (glyphs.length <= 1) {
      return [line];
    }

    const positions = font.getCharPositions(line);
    const scale = fontSize / 1000;
    const chunks = [];
    let lastSpacePosInStringStart = -1,
        lastSpacePosInStringEnd = -1,
        lastSpacePos = -1,
        startChunk = 0,
        currentWidth = 0;

    for (let i = 0, ii = glyphs.length; i < ii; i++) {
      const [start, end] = positions[i];
      const glyph = glyphs[i];
      const glyphWidth = glyph.width * scale;

      if (glyph.unicode === " ") {
        if (currentWidth + glyphWidth > width) {
          chunks.push(line.substring(startChunk, start));
          startChunk = start;
          currentWidth = glyphWidth;
          lastSpacePosInStringStart = -1;
          lastSpacePos = -1;
        } else {
          currentWidth += glyphWidth;
          lastSpacePosInStringStart = start;
          lastSpacePosInStringEnd = end;
          lastSpacePos = i;
        }
      } else {
        if (currentWidth + glyphWidth > width) {
          if (lastSpacePosInStringStart !== -1) {
            chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
            startChunk = lastSpacePosInStringEnd;
            i = lastSpacePos + 1;
            lastSpacePosInStringStart = -1;
            currentWidth = 0;
          } else {
            chunks.push(line.substring(startChunk, start));
            startChunk = start;
            currentWidth = glyphWidth;
          }
        } else {
          currentWidth += glyphWidth;
        }
      }
    }

    if (startChunk < line.length) {
      chunks.push(line.substring(startChunk, line.length));
    }

    return chunks;
  }

  getFieldObject() {
    return {
      id: this.data.id,
      value: this.data.fieldValue,
      defaultValue: this.data.defaultFieldValue,
      multiline: this.data.multiLine,
      password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD),
      charLimit: this.data.maxLen,
      comb: this.data.comb,
      editable: !this.data.readOnly,
      hidden: this.data.hidden,
      name: this.data.fieldName,
      rect: this.data.rect,
      actions: this.data.actions,
      page: this.data.pageIndex,
      type: "text"
    };
  }

}

class ButtonWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.checkedAppearance = null;
    this.uncheckedAppearance = null;
    this.data.checkBox = !this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.radioButton = this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.pushButton = this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON);
    this.data.isTooltipOnly = false;

    if (this.data.checkBox) {
      this._processCheckBox(params);
    } else if (this.data.radioButton) {
      this._processRadioButton(params);
    } else if (this.data.pushButton) {
      this._processPushButton(params);
    } else {
      (0, _util.warn)("Invalid field flags for button widget annotation");
    }
  }

  getOperatorList(evaluator, task, renderForms, annotationStorage) {
    if (this.data.pushButton) {
      return super.getOperatorList(evaluator, task, false, annotationStorage);
    }

    if (annotationStorage) {
      const storageEntry = annotationStorage.get(this.data.id);
      const value = storageEntry && storageEntry.value;

      if (value === undefined) {
        return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
      }

      let appearance;

      if (value) {
        appearance = this.checkedAppearance;
      } else {
        appearance = this.uncheckedAppearance;
      }

      if (appearance) {
        const savedAppearance = this.appearance;
        this.appearance = appearance;
        const operatorList = super.getOperatorList(evaluator, task, renderForms, annotationStorage);
        this.appearance = savedAppearance;
        return operatorList;
      }

      return Promise.resolve(new _operator_list.OperatorList());
    }

    return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
  }

  async save(evaluator, task, annotationStorage) {
    if (this.data.checkBox) {
      return this._saveCheckbox(evaluator, task, annotationStorage);
    }

    if (this.data.radioButton) {
      return this._saveRadioButton(evaluator, task, annotationStorage);
    }

    return null;
  }

  async _saveCheckbox(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }

    const storageEntry = annotationStorage.get(this.data.id);
    const value = storageEntry && storageEntry.value;

    if (value === undefined) {
      return null;
    }

    const defaultValue = this.data.fieldValue && this.data.fieldValue !== "Off";

    if (defaultValue === value) {
      return null;
    }

    const dict = evaluator.xref.fetchIfRef(this.ref);

    if (!(0, _primitives.isDict)(dict)) {
      return null;
    }

    const xfa = {
      path: (0, _util.stringToPDFString)(dict.get("T") || ""),
      value: value ? this.data.exportValue : ""
    };

    const name = _primitives.Name.get(value ? this.data.exportValue : "Off");

    dict.set("V", name);
    dict.set("AS", name);
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    const encrypt = evaluator.xref.encrypt;
    let originalTransform = null;

    if (encrypt) {
      originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
    }

    const buffer = [`${this.ref.num} ${this.ref.gen} obj\n`];
    (0, _writer.writeDict)(dict, buffer, originalTransform);
    buffer.push("\nendobj\n");
    return [{
      ref: this.ref,
      data: buffer.join(""),
      xfa
    }];
  }

  async _saveRadioButton(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }

    const storageEntry = annotationStorage.get(this.data.id);
    const value = storageEntry && storageEntry.value;

    if (value === undefined) {
      return null;
    }

    const defaultValue = this.data.fieldValue === this.data.buttonValue;

    if (defaultValue === value) {
      return null;
    }

    const dict = evaluator.xref.fetchIfRef(this.ref);

    if (!(0, _primitives.isDict)(dict)) {
      return null;
    }

    const xfa = {
      path: (0, _util.stringToPDFString)(dict.get("T") || ""),
      value: value ? this.data.buttonValue : ""
    };

    const name = _primitives.Name.get(value ? this.data.buttonValue : "Off");

    let parentBuffer = null;
    const encrypt = evaluator.xref.encrypt;

    if (value) {
      if ((0, _primitives.isRef)(this.parent)) {
        const parent = evaluator.xref.fetch(this.parent);
        let parentTransform = null;

        if (encrypt) {
          parentTransform = encrypt.createCipherTransform(this.parent.num, this.parent.gen);
        }

        parent.set("V", name);
        parentBuffer = [`${this.parent.num} ${this.parent.gen} obj\n`];
        (0, _writer.writeDict)(parent, parentBuffer, parentTransform);
        parentBuffer.push("\nendobj\n");
      } else if ((0, _primitives.isDict)(this.parent)) {
        this.parent.set("V", name);
      }
    }

    dict.set("AS", name);
    dict.set("M", `D:${(0, _util.getModificationDate)()}`);
    let originalTransform = null;

    if (encrypt) {
      originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
    }

    const buffer = [`${this.ref.num} ${this.ref.gen} obj\n`];
    (0, _writer.writeDict)(dict, buffer, originalTransform);
    buffer.push("\nendobj\n");
    const newRefs = [{
      ref: this.ref,
      data: buffer.join(""),
      xfa
    }];

    if (parentBuffer !== null) {
      newRefs.push({
        ref: this.parent,
        data: parentBuffer.join(""),
        xfa: null
      });
    }

    return newRefs;
  }

  _processCheckBox(params) {
    const customAppearance = params.dict.get("AP");

    if (!(0, _primitives.isDict)(customAppearance)) {
      return;
    }

    const normalAppearance = customAppearance.get("N");

    if (!(0, _primitives.isDict)(normalAppearance)) {
      return;
    }

    const exportValues = normalAppearance.getKeys();

    if (!exportValues.includes("Off")) {
      exportValues.push("Off");
    }

    if (exportValues.length !== 2) {
      return;
    }

    this.data.exportValue = exportValues[0] === "Off" ? exportValues[1] : exportValues[0];
    this.checkedAppearance = normalAppearance.get(this.data.exportValue);
    this.uncheckedAppearance = normalAppearance.get("Off") || null;

    this._streams.push(this.checkedAppearance);

    if (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }

    this._fallbackFontDict = this.fallbackFontDict;
  }

  _processRadioButton(params) {
    this.data.fieldValue = this.data.buttonValue = null;
    const fieldParent = params.dict.get("Parent");

    if ((0, _primitives.isDict)(fieldParent)) {
      this.parent = params.dict.getRaw("Parent");
      const fieldParentValue = fieldParent.get("V");

      if ((0, _primitives.isName)(fieldParentValue)) {
        this.data.fieldValue = this._decodeFormValue(fieldParentValue);
      }
    }

    const appearanceStates = params.dict.get("AP");

    if (!(0, _primitives.isDict)(appearanceStates)) {
      return;
    }

    const normalAppearance = appearanceStates.get("N");

    if (!(0, _primitives.isDict)(normalAppearance)) {
      return;
    }

    for (const key of normalAppearance.getKeys()) {
      if (key !== "Off") {
        this.data.buttonValue = this._decodeFormValue(key);
        break;
      }
    }

    this.checkedAppearance = normalAppearance.get(this.data.buttonValue);
    this.uncheckedAppearance = normalAppearance.get("Off") || null;

    this._streams.push(this.checkedAppearance);

    if (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }

    this._fallbackFontDict = this.fallbackFontDict;
  }

  _processPushButton(params) {
    if (!params.dict.has("A") && !params.dict.has("AA") && !this.data.alternativeText) {
      (0, _util.warn)("Push buttons without action dictionaries are not supported");
      return;
    }

    this.data.isTooltipOnly = !params.dict.has("A") && !params.dict.has("AA");

    _catalog.Catalog.parseDestDictionary({
      destDict: params.dict,
      resultObj: this.data,
      docBaseUrl: params.pdfManager.docBaseUrl
    });
  }

  getFieldObject() {
    let type = "button";
    let exportValues;

    if (this.data.checkBox) {
      type = "checkbox";
      exportValues = this.data.exportValue;
    } else if (this.data.radioButton) {
      type = "radiobutton";
      exportValues = this.data.buttonValue;
    }

    return {
      id: this.data.id,
      value: this.data.fieldValue || "Off",
      defaultValue: this.data.defaultFieldValue,
      exportValues,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      page: this.data.pageIndex,
      type
    };
  }

  get fallbackFontDict() {
    const dict = new _primitives.Dict();
    dict.set("BaseFont", _primitives.Name.get("ZapfDingbats"));
    dict.set("Type", _primitives.Name.get("FallbackType"));
    dict.set("Subtype", _primitives.Name.get("FallbackType"));
    dict.set("Encoding", _primitives.Name.get("ZapfDingbatsEncoding"));
    return (0, _util.shadow)(this, "fallbackFontDict", dict);
  }

}

class ChoiceWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.data.options = [];
    const options = (0, _core_utils.getInheritableProperty)({
      dict: params.dict,
      key: "Opt"
    });

    if (Array.isArray(options)) {
      const xref = params.xref;

      for (let i = 0, ii = options.length; i < ii; i++) {
        const option = xref.fetchIfRef(options[i]);
        const isOptionArray = Array.isArray(option);
        this.data.options[i] = {
          exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),
          displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)
        };
      }
    }

    if ((0, _util.isString)(this.data.fieldValue)) {
      this.data.fieldValue = [this.data.fieldValue];
    } else if (!this.data.fieldValue) {
      this.data.fieldValue = [];
    }

    this.data.combo = this.hasFieldFlag(_util.AnnotationFieldFlag.COMBO);
    this.data.multiSelect = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT);
    this._hasText = true;
  }

  getFieldObject() {
    const type = this.data.combo ? "combobox" : "listbox";
    const value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return {
      id: this.data.id,
      value,
      defaultValue: this.data.defaultFieldValue,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      numItems: this.data.fieldValue.length,
      multipleSelection: this.data.multiSelect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      items: this.data.options,
      page: this.data.pageIndex,
      type
    };
  }

}

class SignatureWidgetAnnotation extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.data.fieldValue = null;
  }

  getFieldObject() {
    return {
      id: this.data.id,
      value: null,
      page: this.data.pageIndex,
      type: "signature"
    };
  }

}

class TextAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    const DEFAULT_ICON_SIZE = 22;
    super(parameters);
    const dict = parameters.dict;
    this.data.annotationType = _util.AnnotationType.TEXT;

    if (this.data.hasAppearance) {
      this.data.name = "NoIcon";
    } else {
      this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
      this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
      this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
    }

    if (dict.has("State")) {
      this.data.state = dict.get("State") || null;
      this.data.stateModel = dict.get("StateModel") || null;
    } else {
      this.data.state = null;
      this.data.stateModel = null;
    }
  }

}

class LinkAnnotation extends Annotation {
  constructor(params) {
    super(params);
    this.data.annotationType = _util.AnnotationType.LINK;
    const quadPoints = getQuadPoints(params.dict, this.rectangle);

    if (quadPoints) {
      this.data.quadPoints = quadPoints;
    }

    _catalog.Catalog.parseDestDictionary({
      destDict: params.dict,
      resultObj: this.data,
      docBaseUrl: params.pdfManager.docBaseUrl
    });
  }

}

class PopupAnnotation extends Annotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.POPUP;
    let parentItem = parameters.dict.get("Parent");

    if (!parentItem) {
      (0, _util.warn)("Popup annotation has a missing or invalid parent annotation.");
      return;
    }

    const parentSubtype = parentItem.get("Subtype");
    this.data.parentType = (0, _primitives.isName)(parentSubtype) ? parentSubtype.name : null;
    const rawParent = parameters.dict.getRaw("Parent");
    this.data.parentId = (0, _primitives.isRef)(rawParent) ? rawParent.toString() : null;
    const parentRect = parentItem.getArray("Rect");

    if (Array.isArray(parentRect) && parentRect.length === 4) {
      this.data.parentRect = _util.Util.normalizeRect(parentRect);
    } else {
      this.data.parentRect = [0, 0, 0, 0];
    }

    const rt = parentItem.get("RT");

    if ((0, _primitives.isName)(rt, _util.AnnotationReplyType.GROUP)) {
      parentItem = parentItem.get("IRT");
    }

    if (!parentItem.has("M")) {
      this.data.modificationDate = null;
    } else {
      this.setModificationDate(parentItem.get("M"));
      this.data.modificationDate = this.modificationDate;
    }

    if (!parentItem.has("C")) {
      this.data.color = null;
    } else {
      this.setColor(parentItem.getArray("C"));
      this.data.color = this.color;
    }

    if (!this.viewable) {
      const parentFlags = parentItem.get("F");

      if (this._isViewable(parentFlags)) {
        this.setFlags(parentFlags);
      }
    }

    this.data.title = (0, _util.stringToPDFString)(parentItem.get("T") || "");
    this.data.contents = (0, _util.stringToPDFString)(parentItem.get("Contents") || "");
  }

}

class FreeTextAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.FREETEXT;
  }

}

class LineAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.LINE;
    const lineCoordinates = parameters.dict.getArray("L");
    this.data.lineCoordinates = _util.Util.normalizeRect(lineCoordinates);

    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];
      const borderWidth = this.borderStyle.width;

      if ((0, _util.isArrayEqual)(this.rectangle, [0, 0, 0, 0])) {
        this.rectangle = [this.data.lineCoordinates[0] - 2 * borderWidth, this.data.lineCoordinates[1] - 2 * borderWidth, this.data.lineCoordinates[2] + 2 * borderWidth, this.data.lineCoordinates[3] + 2 * borderWidth];
      }

      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${borderWidth} w`,
        strokeColor,
        pointsCallback: (buffer, points) => {
          buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`);
          buffer.push(`${lineCoordinates[2]} ${lineCoordinates[3]} l`);
          buffer.push("S");
          return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth];
        }
      });
    }
  }

}

class SquareAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.SQUARE;

    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];
      let fillColor = null;
      let interiorColor = parameters.dict.getArray("IC");

      if (interiorColor) {
        interiorColor = getRgbColor(interiorColor);
        fillColor = interiorColor ? Array.from(interiorColor).map(c => c / 255) : null;
      }

      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${this.borderStyle.width} w`,
        strokeColor,
        fillColor,
        pointsCallback: (buffer, points) => {
          const x = points[2].x + this.borderStyle.width / 2;
          const y = points[2].y + this.borderStyle.width / 2;
          const width = points[3].x - points[2].x - this.borderStyle.width;
          const height = points[1].y - points[3].y - this.borderStyle.width;
          buffer.push(`${x} ${y} ${width} ${height} re`);

          if (fillColor) {
            buffer.push("B");
          } else {
            buffer.push("S");
          }

          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }

}

class CircleAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.CIRCLE;

    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];
      let fillColor = null;
      let interiorColor = parameters.dict.getArray("IC");

      if (interiorColor) {
        interiorColor = getRgbColor(interiorColor);
        fillColor = interiorColor ? Array.from(interiorColor).map(c => c / 255) : null;
      }

      const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4));

      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${this.borderStyle.width} w`,
        strokeColor,
        fillColor,
        pointsCallback: (buffer, points) => {
          const x0 = points[0].x + this.borderStyle.width / 2;
          const y0 = points[0].y - this.borderStyle.width / 2;
          const x1 = points[3].x - this.borderStyle.width / 2;
          const y1 = points[3].y + this.borderStyle.width / 2;
          const xMid = x0 + (x1 - x0) / 2;
          const yMid = y0 + (y1 - y0) / 2;
          const xOffset = (x1 - x0) / 2 * controlPointsDistance;
          const yOffset = (y1 - y0) / 2 * controlPointsDistance;
          buffer.push(`${xMid} ${y1} m`);
          buffer.push(`${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`);
          buffer.push(`${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`);
          buffer.push(`${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`);
          buffer.push(`${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`);
          buffer.push("h");

          if (fillColor) {
            buffer.push("B");
          } else {
            buffer.push("S");
          }

          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }

}

class PolylineAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.POLYLINE;
    this.data.vertices = [];
    const rawVertices = parameters.dict.getArray("Vertices");

    if (!Array.isArray(rawVertices)) {
      return;
    }

    for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
      this.data.vertices.push({
        x: rawVertices[i],
        y: rawVertices[i + 1]
      });
    }

    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];
      const borderWidth = this.borderStyle.width || 1;

      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${borderWidth} w`,
        strokeColor,
        pointsCallback: (buffer, points) => {
          const vertices = this.data.vertices;

          for (let i = 0, ii = vertices.length; i < ii; i++) {
            buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`);
          }

          buffer.push("S");
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }

}

class PolygonAnnotation extends PolylineAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.POLYGON;
  }

}

class CaretAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.CARET;
  }

}

class InkAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.INK;
    this.data.inkLists = [];
    const rawInkLists = parameters.dict.getArray("InkList");

    if (!Array.isArray(rawInkLists)) {
      return;
    }

    const xref = parameters.xref;

    for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
      this.data.inkLists.push([]);

      for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
        this.data.inkLists[i].push({
          x: xref.fetchIfRef(rawInkLists[i][j]),
          y: xref.fetchIfRef(rawInkLists[i][j + 1])
        });
      }
    }

    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];
      const borderWidth = this.borderStyle.width || 1;

      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${borderWidth} w`,
        strokeColor,
        pointsCallback: (buffer, points) => {
          for (const inkList of this.data.inkLists) {
            for (let i = 0, ii = inkList.length; i < ii; i++) {
              buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`);
            }

            buffer.push("S");
          }

          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }

}

class HighlightAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.HIGHLIGHT;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!this.appearance) {
        const fillColor = this.color ? Array.from(this.color).map(c => c / 255) : [1, 1, 0];

        this._setDefaultAppearance({
          xref: parameters.xref,
          fillColor,
          blendMode: "Multiply",
          pointsCallback: (buffer, points) => {
            buffer.push(`${points[0].x} ${points[0].y} m`);
            buffer.push(`${points[1].x} ${points[1].y} l`);
            buffer.push(`${points[3].x} ${points[3].y} l`);
            buffer.push(`${points[2].x} ${points[2].y} l`);
            buffer.push("f");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }

}

class UnderlineAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.UNDERLINE;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];

        this._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          pointsCallback: (buffer, points) => {
            buffer.push(`${points[2].x} ${points[2].y} m`);
            buffer.push(`${points[3].x} ${points[3].y} l`);
            buffer.push("S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }

}

class SquigglyAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.SQUIGGLY;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];

        this._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          pointsCallback: (buffer, points) => {
            const dy = (points[0].y - points[2].y) / 6;
            let shift = dy;
            let x = points[2].x;
            const y = points[2].y;
            const xEnd = points[3].x;
            buffer.push(`${x} ${y + shift} m`);

            do {
              x += 2;
              shift = shift === 0 ? dy : 0;
              buffer.push(`${x} ${y + shift} l`);
            } while (x < xEnd);

            buffer.push("S");
            return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }

}

class StrikeOutAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.STRIKEOUT;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);

    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? Array.from(this.color).map(c => c / 255) : [0, 0, 0];

        this._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          pointsCallback: (buffer, points) => {
            buffer.push(`${(points[0].x + points[2].x) / 2}` + ` ${(points[0].y + points[2].y) / 2} m`);
            buffer.push(`${(points[1].x + points[3].x) / 2}` + ` ${(points[1].y + points[3].y) / 2} l`);
            buffer.push("S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }

}

class StampAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = _util.AnnotationType.STAMP;
  }

}

class FileAttachmentAnnotation extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    const file = new _file_spec.FileSpec(parameters.dict.get("FS"), parameters.xref);
    this.data.annotationType = _util.AnnotationType.FILEATTACHMENT;
    this.data.file = file.serializable;
  }

}

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createDefaultAppearance = createDefaultAppearance;
exports.parseDefaultAppearance = parseDefaultAppearance;

var _util = __w_pdfjs_require__(2);

var _colorspace = __w_pdfjs_require__(14);

var _core_utils = __w_pdfjs_require__(9);

var _evaluator = __w_pdfjs_require__(15);

var _primitives = __w_pdfjs_require__(5);

var _stream = __w_pdfjs_require__(10);

class DefaultAppearanceEvaluator extends _evaluator.EvaluatorPreprocessor {
  constructor(str) {
    super(new _stream.StringStream(str));
  }

  parse() {
    const operation = {
      fn: 0,
      args: []
    };
    const result = {
      fontSize: 0,
      fontName: "",
      fontColor: new Uint8ClampedArray(3)
    };

    try {
      while (true) {
        operation.args.length = 0;

        if (!this.read(operation)) {
          break;
        }

        if (this.savedStatesDepth !== 0) {
          continue;
        }

        const {
          fn,
          args
        } = operation;

        switch (fn | 0) {
          case _util.OPS.setFont:
            const [fontName, fontSize] = args;

            if (fontName instanceof _primitives.Name) {
              result.fontName = fontName.name;
            }

            if (typeof fontSize === "number" && fontSize > 0) {
              result.fontSize = fontSize;
            }

            break;

          case _util.OPS.setFillRGBColor:
            _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);

            break;

          case _util.OPS.setFillGray:
            _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);

            break;

          case _util.OPS.setFillColorSpace:
            _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);

            break;
        }
      }
    } catch (reason) {
      (0, _util.warn)(`parseDefaultAppearance - ignoring errors: "${reason}".`);
    }

    return result;
  }

}

function parseDefaultAppearance(str) {
  return new DefaultAppearanceEvaluator(str).parse();
}

function createDefaultAppearance({
  fontSize,
  fontName,
  fontColor
}) {
  let colorCmd;

  if (fontColor.every(c => c === 0)) {
    colorCmd = "0 g";
  } else {
    colorCmd = Array.from(fontColor).map(c => (c / 255).toFixed(2)).join(" ") + " rg";
  }

  return `/${(0, _core_utils.escapePDFName)(fontName)} ${fontSize} Tf ${colorCmd}`;
}

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorSpace = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
  const COMPONENTS = 3;
  alpha01 = alpha01 !== 1 ? 0 : alpha01;
  const xRatio = w1 / w2;
  const yRatio = h1 / h2;
  let newIndex = 0,
      oldIndex;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1 * COMPONENTS;

  for (let i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
  }

  for (let i = 0; i < h2; i++) {
    const py = Math.floor(i * yRatio) * w1Scanline;

    for (let j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      newIndex += alpha01;
    }
  }
}

class ColorSpace {
  constructor(name, numComps) {
    if (this.constructor === ColorSpace) {
      (0, _util.unreachable)("Cannot initialize ColorSpace.");
    }

    this.name = name;
    this.numComps = numComps;
  }

  getRgb(src, srcOffset) {
    const rgb = new Uint8ClampedArray(3);
    this.getRgbItem(src, srcOffset, rgb, 0);
    return rgb;
  }

  getRgbItem(src, srcOffset, dest, destOffset) {
    (0, _util.unreachable)("Should not call ColorSpace.getRgbItem");
  }

  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    (0, _util.unreachable)("Should not call ColorSpace.getRgbBuffer");
  }

  getOutputLength(inputLength, alpha01) {
    (0, _util.unreachable)("Should not call ColorSpace.getOutputLength");
  }

  isPassthrough(bits) {
    return false;
  }

  isDefaultDecode(decodeMap, bpc) {
    return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
  }

  fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
    const count = originalWidth * originalHeight;
    let rgbBuf = null;
    const numComponentColors = 1 << bpc;
    const needsResizing = originalHeight !== height || originalWidth !== width;

    if (this.isPassthrough(bpc)) {
      rgbBuf = comps;
    } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);

      for (let i = 0; i < numComponentColors; i++) {
        allColors[i] = i;
      }

      const colorMap = new Uint8ClampedArray(numComponentColors * 3);
      this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);

      if (!needsResizing) {
        let destPos = 0;

        for (let i = 0; i < count; ++i) {
          const key = comps[i] * 3;
          dest[destPos++] = colorMap[key];
          dest[destPos++] = colorMap[key + 1];
          dest[destPos++] = colorMap[key + 2];
          destPos += alpha01;
        }
      } else {
        rgbBuf = new Uint8Array(count * 3);
        let rgbPos = 0;

        for (let i = 0; i < count; ++i) {
          const key = comps[i] * 3;
          rgbBuf[rgbPos++] = colorMap[key];
          rgbBuf[rgbPos++] = colorMap[key + 1];
          rgbBuf[rgbPos++] = colorMap[key + 2];
        }
      }
    } else {
      if (!needsResizing) {
        this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
      } else {
        rgbBuf = new Uint8ClampedArray(count * 3);
        this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
      }
    }

    if (rgbBuf) {
      if (needsResizing) {
        resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
      } else {
        let destPos = 0,
            rgbPos = 0;

        for (let i = 0, ii = width * actualHeight; i < ii; i++) {
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          destPos += alpha01;
        }
      }
    }
  }

  get usesZeroToOneRange() {
    return (0, _util.shadow)(this, "usesZeroToOneRange", true);
  }

  static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {
    if (!localColorSpaceCache) {
      throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
    }

    if (!parsedColorSpace) {
      throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
    }

    let csName, csRef;

    if (cacheKey instanceof _primitives.Ref) {
      csRef = cacheKey;
      cacheKey = xref.fetch(cacheKey);
    }

    if (cacheKey instanceof _primitives.Name) {
      csName = cacheKey.name;
    }

    if (csName || csRef) {
      localColorSpaceCache.set(csName, csRef, parsedColorSpace);
    }
  }

  static getCached(cacheKey, xref, localColorSpaceCache) {
    if (!localColorSpaceCache) {
      throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
    }

    if (cacheKey instanceof _primitives.Ref) {
      const localColorSpace = localColorSpaceCache.getByRef(cacheKey);

      if (localColorSpace) {
        return localColorSpace;
      }

      try {
        cacheKey = xref.fetch(cacheKey);
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }
      }
    }

    if (cacheKey instanceof _primitives.Name) {
      const localColorSpace = localColorSpaceCache.getByName(cacheKey.name);

      if (localColorSpace) {
        return localColorSpace;
      }
    }

    return null;
  }

  static async parseAsync({
    cs,
    xref,
    resources = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);

    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);

    return parsedColorSpace;
  }

  static parse({
    cs,
    xref,
    resources = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);

    if (cachedColorSpace) {
      return cachedColorSpace;
    }

    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);

    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);

    return parsedColorSpace;
  }

  static _parse(cs, xref, resources = null, pdfFunctionFactory) {
    cs = xref.fetchIfRef(cs);

    if ((0, _primitives.isName)(cs)) {
      switch (cs.name) {
        case "DeviceGray":
        case "G":
          return this.singletons.gray;

        case "DeviceRGB":
        case "RGB":
          return this.singletons.rgb;

        case "DeviceCMYK":
        case "CMYK":
          return this.singletons.cmyk;

        case "Pattern":
          return new PatternCS(null);

        default:
          if ((0, _primitives.isDict)(resources)) {
            const colorSpaces = resources.get("ColorSpace");

            if ((0, _primitives.isDict)(colorSpaces)) {
              const resourcesCS = colorSpaces.get(cs.name);

              if (resourcesCS) {
                if ((0, _primitives.isName)(resourcesCS)) {
                  return this._parse(resourcesCS, xref, resources, pdfFunctionFactory);
                }

                cs = resourcesCS;
                break;
              }
            }
          }

          throw new _util.FormatError(`Unrecognized ColorSpace: ${cs.name}`);
      }
    }

    if (Array.isArray(cs)) {
      const mode = xref.fetchIfRef(cs[0]).name;
      let params, numComps, baseCS, whitePoint, blackPoint, gamma;

      switch (mode) {
        case "DeviceGray":
        case "G":
          return this.singletons.gray;

        case "DeviceRGB":
        case "RGB":
          return this.singletons.rgb;

        case "DeviceCMYK":
        case "CMYK":
          return this.singletons.cmyk;

        case "CalGray":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          gamma = params.get("Gamma");
          return new CalGrayCS(whitePoint, blackPoint, gamma);

        case "CalRGB":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          gamma = params.getArray("Gamma");
          const matrix = params.getArray("Matrix");
          return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);

        case "ICCBased":
          const stream = xref.fetchIfRef(cs[1]);
          const dict = stream.dict;
          numComps = dict.get("N");
          const alt = dict.get("Alternate");

          if (alt) {
            const altCS = this._parse(alt, xref, resources, pdfFunctionFactory);

            if (altCS.numComps === numComps) {
              return altCS;
            }

            (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }

          if (numComps === 1) {
            return this.singletons.gray;
          } else if (numComps === 3) {
            return this.singletons.rgb;
          } else if (numComps === 4) {
            return this.singletons.cmyk;
          }

          break;

        case "Pattern":
          baseCS = cs[1] || null;

          if (baseCS) {
            baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory);
          }

          return new PatternCS(baseCS);

        case "Indexed":
        case "I":
          baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory);
          const hiVal = xref.fetchIfRef(cs[2]) + 1;
          const lookup = xref.fetchIfRef(cs[3]);
          return new IndexedCS(baseCS, hiVal, lookup);

        case "Separation":
        case "DeviceN":
          const name = xref.fetchIfRef(cs[1]);
          numComps = Array.isArray(name) ? name.length : 1;
          baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory);
          const tintFn = pdfFunctionFactory.create(cs[3]);
          return new AlternateCS(numComps, baseCS, tintFn);

        case "Lab":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          const range = params.getArray("Range");
          return new LabCS(whitePoint, blackPoint, range);

        default:
          throw new _util.FormatError(`Unimplemented ColorSpace object: ${mode}`);
      }
    }

    throw new _util.FormatError(`Unrecognized ColorSpace object: ${cs}`);
  }

  static isDefaultDecode(decode, numComps) {
    if (!Array.isArray(decode)) {
      return true;
    }

    if (numComps * 2 !== decode.length) {
      (0, _util.warn)("The decode map is not the correct length");
      return true;
    }

    for (let i = 0, ii = decode.length; i < ii; i += 2) {
      if (decode[i] !== 0 || decode[i + 1] !== 1) {
        return false;
      }
    }

    return true;
  }

  static get singletons() {
    return (0, _util.shadow)(this, "singletons", {
      get gray() {
        return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
      },

      get rgb() {
        return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
      },

      get cmyk() {
        return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
      }

    });
  }

}

exports.ColorSpace = ColorSpace;

class AlternateCS extends ColorSpace {
  constructor(numComps, base, tintFn) {
    super("Alternate", numComps);
    this.base = base;
    this.tintFn = tintFn;
    this.tmpBuf = new Float32Array(base.numComps);
  }

  getRgbItem(src, srcOffset, dest, destOffset) {
    const tmpBuf = this.tmpBuf;
    this.tintFn(src, srcOffset, tmpBuf, 0);
    this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
  }

  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const tintFn = this.tintFn;
    const base = this.base;
    const scale = 1 / ((1 << bits) - 1);
    const baseNumComps = base.numComps;
    const usesZeroToOneRange = base.usesZeroToOneRange;
    const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
    let pos = isPassthrough ? destOffset : 0;
    const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
    const numComps = this.numComps;
    const scaled = new Float32Array(numComps);
    const tinted = new Float32Array(baseNumComps);
    let i, j;

    for (i = 0; i < count; i++) {
      for (j = 0; j < numComps; j++) {
        scaled[j] = src[srcOffset++] * scale;
      }

      tintFn(scaled, 0, tinted, 0);

      if (usesZeroToOneRange) {
        for (j = 0; j < baseNumComps; j++) {
          baseBuf[pos++] = tinted[j] * 255;
        }
      } else {
        base.getRgbItem(tinted, 0, baseBuf, pos);
        pos += baseNumComps;
      }
    }

    if (!isPassthrough) {
      base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
    }
  }

  getOutputLength(inputLength, alpha01) {
    return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
  }

}

class PatternCS extends ColorSpace {
  constructor(baseCS) {
    super("Pattern", null);
    this.base = baseCS;
  }

  isDefaultDecode(decodeMap, bpc) {
    (0, _util.unreachable)("Should not call PatternCS.isDefaultDecode");
  }

}

class IndexedCS extends ColorSpace {
  constructor(base, highVal, lookup) {
    super("Indexed", 1);
    this.base = base;
    this.highVal = highVal;
    const length = base.numComps * highVal;
    this.lookup = new Uint8Array(length);

    if ((0, _primitives.isStream)(lookup)) {
      const bytes = lookup.getBytes(length);
      this.lookup.set(bytes);
    } else if (typeof lookup === "string") {
      for (let i = 0; i < length; ++i) {
        this.lookup[i] = lookup.charCodeAt(i) & 0xff;
      }
    } else {
      throw new _util.FormatError(`IndexedCS - unrecognized lookup table: ${lookup}`);
    }
  }

  getRgbItem(src, srcOffset, dest, destOffset) {
    const numComps = this.base.numComps;
    const start = src[srcOffset] * numComps;
    this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
  }

  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const base = this.base;
    const numComps = base.numComps;
    const outputDelta = base.getOutputLength(numComps, alpha01);
    const lookup = this.lookup;

    for (let i = 0; i < count; ++i) {
      const lookupPos = src[srcOffset++] * numComps;
      base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
      destOffset += outputDelta;
    }
  }

  getOutputLength(inputLength, alpha01) {
    return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
  }

  isDefaultDecode(decodeMap, bpc) {
    if (!Array.isArray(decodeMap)) {
      return true;
    }

    if (decodeMap.length !== 2) {
      (0, _util.warn)("Decode map length is not correct");
      return true;
    }

    if (!Number.isInteger(bpc) || bpc < 1) {
      (0, _util.warn)("Bits per component is not correct");
      return true;
    }

    return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
  }

}

class DeviceGrayCS extends ColorSpace {
  constructor() {
    super("DeviceGray", 1);
  }

  getRgbItem(src, srcOffset, dest, destOffset) {
    const c = src[srcOffset] * 255;
    dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
  }

  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    const scale = 255 / ((1 << bits) - 1);
    let j = srcOffset,
        q = destOffset;

    for (let i = 0; i < count; ++i) {
      const c = scale * src[j++];
      dest[q++] = c;
      dest[q++] = c;
      dest[q++] = c;
      q += alpha01;
    }
  }

  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01);
  }

}

class DeviceRgbCS extends ColorSpace {
  constructor() {
    super("DeviceRGB", 3);
  }

  getRgbItem(src, srcOffset, dest, destOffset) {
    dest[destOffset] = src[srcOffset] * 255;
    dest[destOffset + 1] = src[srcOffset + 1] * 255;
    dest[destOffset + 2] = src[srcOffset + 2] * 255;
  }

  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    if (bits === 8 && alpha01 === 0) {
      dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
      return;
    }

    const scale = 255 / ((1 << bits) - 1);
    let j = srcOffset,
        q = destOffset;

    for (let i = 0; i < count; ++i) {
      dest[q++] = scale * src[j++];
      dest[q++] = scale * src[j++];
      dest[q++] = scale * src[j++];
      q += alpha01;
    }
  }

  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01) / 3 | 0;
  }

  isPassthrough(bits) {
    return bits === 8;
  }

}

const DeviceCmykCS = function DeviceCmykCSClosure() {
  function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
    const c = src[srcOffset] * srcScale;
    const m = src[srcOffset + 1] * srcScale;
    const y = src[srcOffset + 2] * srcScale;
    const k = src[srcOffset + 3] * srcScale;
    dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
    dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
    dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
  }

  class DeviceCmykCS extends ColorSpace {
    constructor() {
      super("DeviceCMYK", 4);
    }

    getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(src, srcOffset, 1, dest, destOffset);
    }

    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      const scale = 1 / ((1 << bits) - 1);

      for (let i = 0; i < count; i++) {
        convertToRgb(src, srcOffset, scale, dest, destOffset);
        srcOffset += 4;
        destOffset += 3 + alpha01;
      }
    }

    getOutputLength(inputLength, alpha01) {
      return inputLength / 4 * (3 + alpha01) | 0;
    }

  }

  return DeviceCmykCS;
}();

const CalGrayCS = function CalGrayCSClosure() {
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    const A = src[srcOffset] * scale;
    const AG = A ** cs.G;
    const L = cs.YW * AG;
    const val = Math.max(295.8 * L ** 0.333333333333333333 - 40.8, 0);
    dest[destOffset] = val;
    dest[destOffset + 1] = val;
    dest[destOffset + 2] = val;
  }

  class CalGrayCS extends ColorSpace {
    constructor(whitePoint, blackPoint, gamma) {
      super("CalGray", 1);

      if (!whitePoint) {
        throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
      }

      blackPoint = blackPoint || [0, 0, 0];
      gamma = gamma || 1;
      this.XW = whitePoint[0];
      this.YW = whitePoint[1];
      this.ZW = whitePoint[2];
      this.XB = blackPoint[0];
      this.YB = blackPoint[1];
      this.ZB = blackPoint[2];
      this.G = gamma;

      if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
        throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}` + ", no fallback available");
      }

      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
        (0, _util.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`);
        this.XB = this.YB = this.ZB = 0;
      }

      if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
        (0, _util.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ` + `ZB: ${this.ZB}, only default values are supported.`);
      }

      if (this.G < 1) {
        (0, _util.info)(`Invalid Gamma: ${this.G} for ${this.name}, ` + "falling back to default.");
        this.G = 1;
      }
    }

    getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    }

    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      const scale = 1 / ((1 << bits) - 1);

      for (let i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 1;
        destOffset += 3 + alpha01;
      }
    }

    getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01);
    }

  }

  return CalGrayCS;
}();

const CalRGBCS = function CalRGBCSClosure() {
  const BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  const BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
  const SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
  const FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
  const tempNormalizeMatrix = new Float32Array(3);
  const tempConvertMatrix1 = new Float32Array(3);
  const tempConvertMatrix2 = new Float32Array(3);
  const DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8.0;

  function matrixProduct(a, b, result) {
    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
  }

  function convertToFlat(sourceWhitePoint, LMS, result) {
    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
  }

  function convertToD65(sourceWhitePoint, LMS, result) {
    const D65X = 0.95047;
    const D65Y = 1;
    const D65Z = 1.08883;
    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
  }

  function sRGBTransferFunction(color) {
    if (color <= 0.0031308) {
      return adjustToRange(0, 1, 12.92 * color);
    }

    if (color >= 0.99554525) {
      return 1;
    }

    return adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);
  }

  function adjustToRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
  }

  function decodeL(L) {
    if (L < 0) {
      return -decodeL(-L);
    }

    if (L > 8.0) {
      return ((L + 16) / 116) ** 3;
    }

    return L * DECODE_L_CONSTANT;
  }

  function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
      result[0] = XYZ_Flat[0];
      result[1] = XYZ_Flat[1];
      result[2] = XYZ_Flat[2];
      return;
    }

    const zeroDecodeL = decodeL(0);
    const X_DST = zeroDecodeL;
    const X_SRC = decodeL(sourceBlackPoint[0]);
    const Y_DST = zeroDecodeL;
    const Y_SRC = decodeL(sourceBlackPoint[1]);
    const Z_DST = zeroDecodeL;
    const Z_SRC = decodeL(sourceBlackPoint[2]);
    const X_Scale = (1 - X_DST) / (1 - X_SRC);
    const X_Offset = 1 - X_Scale;
    const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
    const Y_Offset = 1 - Y_Scale;
    const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
    const Z_Offset = 1 - Z_Scale;
    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
  }

  function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
      result[0] = XYZ_In[0];
      result[1] = XYZ_In[1];
      result[2] = XYZ_In[2];
      return;
    }

    const LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_Flat = tempNormalizeMatrix;
    convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
  }

  function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
    const LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_D65 = tempNormalizeMatrix;
    convertToD65(sourceWhitePoint, LMS, LMS_D65);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
  }

  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    const A = adjustToRange(0, 1, src[srcOffset] * scale);
    const B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
    const C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
    const AGR = A === 1 ? 1 : A ** cs.GR;
    const BGG = B === 1 ? 1 : B ** cs.GG;
    const CGB = C === 1 ? 1 : C ** cs.GB;
    const X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
    const Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
    const Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
    const XYZ = tempConvertMatrix1;
    XYZ[0] = X;
    XYZ[1] = Y;
    XYZ[2] = Z;
    const XYZ_Flat = tempConvertMatrix2;
    normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
    const XYZ_Black = tempConvertMatrix1;
    compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
    const XYZ_D65 = tempConvertMatrix2;
    normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
    const SRGB = tempConvertMatrix1;
    matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
    dest[destOffset] = sRGBTransferFunction(SRGB[0]) * 255;
    dest[destOffset + 1] = sRGBTransferFunction(SRGB[1]) * 255;
    dest[destOffset + 2] = sRGBTransferFunction(SRGB[2]) * 255;
  }

  class CalRGBCS extends ColorSpace {
    constructor(whitePoint, blackPoint, gamma, matrix) {
      super("CalRGB", 3);

      if (!whitePoint) {
        throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
      }

      blackPoint = blackPoint || new Float32Array(3);
      gamma = gamma || new Float32Array([1, 1, 1]);
      matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      const XW = whitePoint[0];
      const YW = whitePoint[1];
      const ZW = whitePoint[2];
      this.whitePoint = whitePoint;
      const XB = blackPoint[0];
      const YB = blackPoint[1];
      const ZB = blackPoint[2];
      this.blackPoint = blackPoint;
      this.GR = gamma[0];
      this.GG = gamma[1];
      this.GB = gamma[2];
      this.MXA = matrix[0];
      this.MYA = matrix[1];
      this.MZA = matrix[2];
      this.MXB = matrix[3];
      this.MYB = matrix[4];
      this.MZB = matrix[5];
      this.MXC = matrix[6];
      this.MYC = matrix[7];
      this.MZC = matrix[8];

      if (XW < 0 || ZW < 0 || YW !== 1) {
        throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}` + ", no fallback available");
      }

      if (XB < 0 || YB < 0 || ZB < 0) {
        (0, _util.info)(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], ` + "falling back to default.");
        this.blackPoint = new Float32Array(3);
      }

      if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
        (0, _util.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ` + `${this.name}, falling back to default.`);
        this.GR = this.GG = this.GB = 1;
      }
    }

    getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    }

    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      const scale = 1 / ((1 << bits) - 1);

      for (let i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    }

    getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    }

  }

  return CalRGBCS;
}();

const LabCS = function LabCSClosure() {
  function fn_g(x) {
    let result;

    if (x >= 6 / 29) {
      result = x ** 3;
    } else {
      result = 108 / 841 * (x - 4 / 29);
    }

    return result;
  }

  function decode(value, high1, low2, high2) {
    return low2 + value * (high2 - low2) / high1;
  }

  function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
    let Ls = src[srcOffset];
    let as = src[srcOffset + 1];
    let bs = src[srcOffset + 2];

    if (maxVal !== false) {
      Ls = decode(Ls, maxVal, 0, 100);
      as = decode(as, maxVal, cs.amin, cs.amax);
      bs = decode(bs, maxVal, cs.bmin, cs.bmax);
    }

    if (as > cs.amax) {
      as = cs.amax;
    } else if (as < cs.amin) {
      as = cs.amin;
    }

    if (bs > cs.bmax) {
      bs = cs.bmax;
    } else if (bs < cs.bmin) {
      bs = cs.bmin;
    }

    const M = (Ls + 16) / 116;
    const L = M + as / 500;
    const N = M - bs / 200;
    const X = cs.XW * fn_g(L);
    const Y = cs.YW * fn_g(M);
    const Z = cs.ZW * fn_g(N);
    let r, g, b;

    if (cs.ZW < 1) {
      r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
      g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
      b = X * 0.072 + Y * -0.229 + Z * 1.4057;
    } else {
      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      b = X * 0.0557 + Y * -0.204 + Z * 1.057;
    }

    dest[destOffset] = Math.sqrt(r) * 255;
    dest[destOffset + 1] = Math.sqrt(g) * 255;
    dest[destOffset + 2] = Math.sqrt(b) * 255;
  }

  class LabCS extends ColorSpace {
    constructor(whitePoint, blackPoint, range) {
      super("Lab", 3);

      if (!whitePoint) {
        throw new _util.FormatError("WhitePoint missing - required for color space Lab");
      }

      blackPoint = blackPoint || [0, 0, 0];
      range = range || [-100, 100, -100, 100];
      this.XW = whitePoint[0];
      this.YW = whitePoint[1];
      this.ZW = whitePoint[2];
      this.amin = range[0];
      this.amax = range[1];
      this.bmin = range[2];
      this.bmax = range[3];
      this.XB = blackPoint[0];
      this.YB = blackPoint[1];
      this.ZB = blackPoint[2];

      if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
        throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
      }

      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
        (0, _util.info)("Invalid BlackPoint, falling back to default");
        this.XB = this.YB = this.ZB = 0;
      }

      if (this.amin > this.amax || this.bmin > this.bmax) {
        (0, _util.info)("Invalid Range, falling back to defaults");
        this.amin = -100;
        this.amax = 100;
        this.bmin = -100;
        this.bmax = 100;
      }
    }

    getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, false, dest, destOffset);
    }

    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      const maxVal = (1 << bits) - 1;

      for (let i = 0; i < count; i++) {
        convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    }

    getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    }

    isDefaultDecode(decodeMap, bpc) {
      return true;
    }

    get usesZeroToOneRange() {
      return (0, _util.shadow)(this, "usesZeroToOneRange", false);
    }

  }

  return LabCS;
}();

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PartialEvaluator = exports.EvaluatorPreprocessor = void 0;

var _util = __w_pdfjs_require__(2);

var _cmap = __w_pdfjs_require__(16);

var _primitives = __w_pdfjs_require__(5);

var _fonts = __w_pdfjs_require__(34);

var _fonts_utils = __w_pdfjs_require__(38);

var _encodings = __w_pdfjs_require__(37);

var _unicode = __w_pdfjs_require__(40);

var _standard_fonts = __w_pdfjs_require__(41);

var _pattern = __w_pdfjs_require__(48);

var _to_unicode_map = __w_pdfjs_require__(42);

var _function = __w_pdfjs_require__(49);

var _parser = __w_pdfjs_require__(17);

var _image_utils = __w_pdfjs_require__(51);

var _bidi = __w_pdfjs_require__(52);

var _colorspace = __w_pdfjs_require__(14);

var _decode_stream = __w_pdfjs_require__(19);

var _glyphlist = __w_pdfjs_require__(39);

var _core_utils = __w_pdfjs_require__(9);

var _metrics = __w_pdfjs_require__(53);

var _murmurhash = __w_pdfjs_require__(54);

var _stream = __w_pdfjs_require__(10);

var _operator_list = __w_pdfjs_require__(55);

var _image = __w_pdfjs_require__(56);

const DefaultPartialEvaluatorOptions = Object.freeze({
  maxImageSize: -1,
  disableFontFace: false,
  ignoreErrors: false,
  isEvalSupported: true,
  fontExtraProperties: false
});
const PatternType = {
  TILING: 1,
  SHADING: 2
};
const deferred = Promise.resolve();

function normalizeBlendMode(value, parsingArray = false) {
  if (Array.isArray(value)) {
    for (let i = 0, ii = value.length; i < ii; i++) {
      const maybeBM = normalizeBlendMode(value[i], true);

      if (maybeBM) {
        return maybeBM;
      }
    }

    (0, _util.warn)(`Unsupported blend mode Array: ${value}`);
    return "source-over";
  }

  if (!(0, _primitives.isName)(value)) {
    if (parsingArray) {
      return null;
    }

    return "source-over";
  }

  switch (value.name) {
    case "Normal":
    case "Compatible":
      return "source-over";

    case "Multiply":
      return "multiply";

    case "Screen":
      return "screen";

    case "Overlay":
      return "overlay";

    case "Darken":
      return "darken";

    case "Lighten":
      return "lighten";

    case "ColorDodge":
      return "color-dodge";

    case "ColorBurn":
      return "color-burn";

    case "HardLight":
      return "hard-light";

    case "SoftLight":
      return "soft-light";

    case "Difference":
      return "difference";

    case "Exclusion":
      return "exclusion";

    case "Hue":
      return "hue";

    case "Saturation":
      return "saturation";

    case "Color":
      return "color";

    case "Luminosity":
      return "luminosity";
  }

  if (parsingArray) {
    return null;
  }

  (0, _util.warn)(`Unsupported blend mode: ${value.name}`);
  return "source-over";
}

class TimeSlotManager {
  static get TIME_SLOT_DURATION_MS() {
    return (0, _util.shadow)(this, "TIME_SLOT_DURATION_MS", 20);
  }

  static get CHECK_TIME_EVERY() {
    return (0, _util.shadow)(this, "CHECK_TIME_EVERY", 100);
  }

  constructor() {
    this.reset();
  }

  check() {
    if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
      return false;
    }

    this.checked = 0;
    return this.endTime <= Date.now();
  }

  reset() {
    this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
    this.checked = 0;
  }

}

class PartialEvaluator {
  constructor({
    xref,
    handler,
    pageIndex,
    idFactory,
    fontCache,
    builtInCMapCache,
    globalImageCache,
    options = null
  }) {
    this.xref = xref;
    this.handler = handler;
    this.pageIndex = pageIndex;
    this.idFactory = idFactory;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.globalImageCache = globalImageCache;
    this.options = options || DefaultPartialEvaluatorOptions;
    this.parsingType3Font = false;
    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
  }

  get _pdfFunctionFactory() {
    const pdfFunctionFactory = new _function.PDFFunctionFactory({
      xref: this.xref,
      isEvalSupported: this.options.isEvalSupported
    });
    return (0, _util.shadow)(this, "_pdfFunctionFactory", pdfFunctionFactory);
  }

  clone(newOptions = DefaultPartialEvaluatorOptions) {
    const newEvaluator = Object.create(this);
    newEvaluator.options = newOptions;
    return newEvaluator;
  }

  hasBlendModes(resources, nonBlendModesSet) {
    if (!(resources instanceof _primitives.Dict)) {
      return false;
    }

    if (resources.objId && nonBlendModesSet.has(resources.objId)) {
      return false;
    }

    const processed = new _primitives.RefSet(nonBlendModesSet);

    if (resources.objId) {
      processed.put(resources.objId);
    }

    const nodes = [resources],
          xref = this.xref;

    while (nodes.length) {
      const node = nodes.shift();
      const graphicStates = node.get("ExtGState");

      if (graphicStates instanceof _primitives.Dict) {
        for (let graphicState of graphicStates.getRawValues()) {
          if (graphicState instanceof _primitives.Ref) {
            if (processed.has(graphicState)) {
              continue;
            }

            try {
              graphicState = xref.fetch(graphicState);
            } catch (ex) {
              processed.put(graphicState);
              (0, _util.info)(`hasBlendModes - ignoring ExtGState: "${ex}".`);
              continue;
            }
          }

          if (!(graphicState instanceof _primitives.Dict)) {
            continue;
          }

          if (graphicState.objId) {
            processed.put(graphicState.objId);
          }

          const bm = graphicState.get("BM");

          if (bm instanceof _primitives.Name) {
            if (bm.name !== "Normal") {
              return true;
            }

            continue;
          }

          if (bm !== undefined && Array.isArray(bm)) {
            for (const element of bm) {
              if (element instanceof _primitives.Name && element.name !== "Normal") {
                return true;
              }
            }
          }
        }
      }

      const xObjects = node.get("XObject");

      if (!(xObjects instanceof _primitives.Dict)) {
        continue;
      }

      for (let xObject of xObjects.getRawValues()) {
        if (xObject instanceof _primitives.Ref) {
          if (processed.has(xObject)) {
            continue;
          }

          try {
            xObject = xref.fetch(xObject);
          } catch (ex) {
            processed.put(xObject);
            (0, _util.info)(`hasBlendModes - ignoring XObject: "${ex}".`);
            continue;
          }
        }

        if (!(0, _primitives.isStream)(xObject)) {
          continue;
        }

        if (xObject.dict.objId) {
          processed.put(xObject.dict.objId);
        }

        const xResources = xObject.dict.get("Resources");

        if (!(xResources instanceof _primitives.Dict)) {
          continue;
        }

        if (xResources.objId && processed.has(xResources.objId)) {
          continue;
        }

        nodes.push(xResources);

        if (xResources.objId) {
          processed.put(xResources.objId);
        }
      }
    }

    processed.forEach(ref => {
      nonBlendModesSet.put(ref);
    });
    return false;
  }

  async fetchBuiltInCMap(name) {
    const cachedData = this.builtInCMapCache.get(name);

    if (cachedData) {
      return cachedData;
    }

    const readableStream = this.handler.sendWithStream("FetchBuiltInCMap", {
      name
    });
    const reader = readableStream.getReader();
    const data = await new Promise(function (resolve, reject) {
      function pump() {
        reader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            return;
          }

          resolve(value);
          pump();
        }, reject);
      }

      pump();
    });

    if (data.compressionType !== _util.CMapCompressionType.NONE) {
      this.builtInCMapCache.set(name, data);
    }

    return data;
  }

  async buildFormXObject(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {
    const dict = xobj.dict;
    const matrix = dict.getArray("Matrix");
    let bbox = dict.getArray("BBox");

    if (Array.isArray(bbox) && bbox.length === 4) {
      bbox = _util.Util.normalizeRect(bbox);
    } else {
      bbox = null;
    }

    let optionalContent = null,
        groupOptions;

    if (dict.has("OC")) {
      optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
      operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }

    const group = dict.get("Group");

    if (group) {
      groupOptions = {
        matrix,
        bbox,
        smask,
        isolated: false,
        knockout: false
      };
      const groupSubtype = group.get("S");
      let colorSpace = null;

      if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
        groupOptions.isolated = group.get("I") || false;
        groupOptions.knockout = group.get("K") || false;

        if (group.has("CS")) {
          const cs = group.getRaw("CS");

          const cachedColorSpace = _colorspace.ColorSpace.getCached(cs, this.xref, localColorSpaceCache);

          if (cachedColorSpace) {
            colorSpace = cachedColorSpace;
          } else {
            colorSpace = await this.parseColorSpace({
              cs,
              resources,
              localColorSpaceCache
            });
          }
        }
      }

      if (smask && smask.backdrop) {
        colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
        smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
      }

      operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
    }

    operatorList.addOp(_util.OPS.paintFormXObjectBegin, [matrix, bbox]);
    return this.getOperatorList({
      stream: xobj,
      task,
      resources: dict.get("Resources") || resources,
      operatorList,
      initialState
    }).then(function () {
      operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);

      if (group) {
        operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
      }

      if (optionalContent) {
        operatorList.addOp(_util.OPS.endMarkedContent, []);
      }
    });
  }

  _sendImgData(objId, imgData, cacheGlobally = false) {
    const transfers = imgData ? [imgData.data.buffer] : null;

    if (this.parsingType3Font || cacheGlobally) {
      return this.handler.send("commonobj", [objId, "Image", imgData], transfers);
    }

    return this.handler.send("obj", [objId, this.pageIndex, "Image", imgData], transfers);
  }

  async buildPaintImageXObject({
    resources,
    image,
    isInline = false,
    operatorList,
    cacheKey,
    localImageCache,
    localColorSpaceCache
  }) {
    const dict = image.dict;
    const imageRef = dict.objId;
    const w = dict.get("Width", "W");
    const h = dict.get("Height", "H");

    if (!(w && (0, _util.isNum)(w)) || !(h && (0, _util.isNum)(h))) {
      (0, _util.warn)("Image dimensions are missing, or not numbers.");
      return undefined;
    }

    const maxImageSize = this.options.maxImageSize;

    if (maxImageSize !== -1 && w * h > maxImageSize) {
      (0, _util.warn)("Image exceeded maximum allowed size and was removed.");
      return undefined;
    }

    const imageMask = dict.get("ImageMask", "IM") || false;
    let imgData, args;

    if (imageMask) {
      const width = dict.get("Width", "W");
      const height = dict.get("Height", "H");
      const bitStrideLength = width + 7 >> 3;
      const imgArray = image.getBytes(bitStrideLength * height, true);
      const decode = dict.getArray("Decode", "D");
      imgData = _image.PDFImage.createMask({
        imgArray,
        width,
        height,
        imageIsFromDecodeStream: image instanceof _decode_stream.DecodeStream,
        inverseDecode: !!decode && decode[0] > 0
      });
      imgData.cached = !!cacheKey;
      args = [imgData];
      operatorList.addOp(_util.OPS.paintImageMaskXObject, args);

      if (cacheKey) {
        localImageCache.set(cacheKey, imageRef, {
          fn: _util.OPS.paintImageMaskXObject,
          args
        });
      }

      return undefined;
    }

    const softMask = dict.get("SMask", "SM") || false;
    const mask = dict.get("Mask") || false;
    const SMALL_IMAGE_DIMENSIONS = 200;

    if (isInline && !softMask && !mask && w + h < SMALL_IMAGE_DIMENSIONS) {
      const imageObj = new _image.PDFImage({
        xref: this.xref,
        res: resources,
        image,
        isInline,
        pdfFunctionFactory: this._pdfFunctionFactory,
        localColorSpaceCache
      });
      imgData = imageObj.createImageData(true);
      operatorList.addOp(_util.OPS.paintInlineImageXObject, [imgData]);
      return undefined;
    }

    let objId = `img_${this.idFactory.createObjId()}`,
        cacheGlobally = false;

    if (this.parsingType3Font) {
      objId = `${this.idFactory.getDocId()}_type3_${objId}`;
    } else if (imageRef) {
      cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);

      if (cacheGlobally) {
        objId = `${this.idFactory.getDocId()}_${objId}`;
      }
    }

    operatorList.addDependency(objId);
    args = [objId, w, h];

    _image.PDFImage.buildImage({
      xref: this.xref,
      res: resources,
      image,
      isInline,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache
    }).then(imageObj => {
      imgData = imageObj.createImageData(false);

      if (cacheKey && imageRef && cacheGlobally) {
        this.globalImageCache.addByteSize(imageRef, imgData.data.length);
      }

      return this._sendImgData(objId, imgData, cacheGlobally);
    }).catch(reason => {
      (0, _util.warn)(`Unable to decode image "${objId}": "${reason}".`);
      return this._sendImgData(objId, null, cacheGlobally);
    });

    operatorList.addOp(_util.OPS.paintImageXObject, args);

    if (cacheKey) {
      localImageCache.set(cacheKey, imageRef, {
        fn: _util.OPS.paintImageXObject,
        args
      });

      if (imageRef) {
        (0, _util.assert)(!isInline, "Cannot cache an inline image globally.");
        this.globalImageCache.addPageIndex(imageRef, this.pageIndex);

        if (cacheGlobally) {
          this.globalImageCache.setData(imageRef, {
            objId,
            fn: _util.OPS.paintImageXObject,
            args,
            byteSize: 0
          });
        }
      }
    }

    return undefined;
  }

  handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) {
    const smaskContent = smask.get("G");
    const smaskOptions = {
      subtype: smask.get("S").name,
      backdrop: smask.get("BC")
    };
    const transferObj = smask.get("TR");

    if ((0, _function.isPDFFunction)(transferObj)) {
      const transferFn = this._pdfFunctionFactory.create(transferObj);

      const transferMap = new Uint8Array(256);
      const tmp = new Float32Array(1);

      for (let i = 0; i < 256; i++) {
        tmp[0] = i / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[i] = tmp[0] * 255 | 0;
      }

      smaskOptions.transferMap = transferMap;
    }

    return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache);
  }

  handleTransferFunction(tr) {
    let transferArray;

    if (Array.isArray(tr)) {
      transferArray = tr;
    } else if ((0, _function.isPDFFunction)(tr)) {
      transferArray = [tr];
    } else {
      return null;
    }

    const transferMaps = [];
    let numFns = 0,
        numEffectfulFns = 0;

    for (const entry of transferArray) {
      const transferObj = this.xref.fetchIfRef(entry);
      numFns++;

      if ((0, _primitives.isName)(transferObj, "Identity")) {
        transferMaps.push(null);
        continue;
      } else if (!(0, _function.isPDFFunction)(transferObj)) {
        return null;
      }

      const transferFn = this._pdfFunctionFactory.create(transferObj);

      const transferMap = new Uint8Array(256),
            tmp = new Float32Array(1);

      for (let j = 0; j < 256; j++) {
        tmp[0] = j / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[j] = tmp[0] * 255 | 0;
      }

      transferMaps.push(transferMap);
      numEffectfulFns++;
    }

    if (!(numFns === 1 || numFns === 4)) {
      return null;
    }

    if (numEffectfulFns === 0) {
      return null;
    }

    return transferMaps;
  }

  handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, cacheKey, localTilingPatternCache) {
    const tilingOpList = new _operator_list.OperatorList();

    const patternResources = _primitives.Dict.merge({
      xref: this.xref,
      dictArray: [patternDict.get("Resources"), resources]
    });

    return this.getOperatorList({
      stream: pattern,
      task,
      resources: patternResources,
      operatorList: tilingOpList
    }).then(function () {
      const operatorListIR = tilingOpList.getIR();
      const tilingPatternIR = (0, _pattern.getTilingPatternIR)(operatorListIR, patternDict, color);
      operatorList.addDependencies(tilingOpList.dependencies);
      operatorList.addOp(fn, tilingPatternIR);

      if (cacheKey) {
        localTilingPatternCache.set(cacheKey, patternDict.objId, {
          operatorListIR,
          dict: patternDict
        });
      }
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return;
      }

      if (this.options.ignoreErrors) {
        this.handler.send("UnsupportedFeature", {
          featureId: _util.UNSUPPORTED_FEATURES.errorTilingPattern
        });
        (0, _util.warn)(`handleTilingType - ignoring pattern: "${reason}".`);
        return;
      }

      throw reason;
    });
  }

  handleSetFont(resources, fontArgs, fontRef, operatorList, task, state, fallbackFontDict = null, cssFontInfo = null) {
    const fontName = fontArgs && fontArgs[0] instanceof _primitives.Name ? fontArgs[0].name : null;
    return this.loadFont(fontName, fontRef, resources, fallbackFontDict, cssFontInfo).then(translated => {
      if (!translated.font.isType3Font) {
        return translated;
      }

      return translated.loadType3Data(this, resources, task).then(function () {
        operatorList.addDependencies(translated.type3Dependencies);
        return translated;
      }).catch(reason => {
        this.handler.send("UnsupportedFeature", {
          featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadType3
        });
        return new TranslatedFont({
          loadedName: "g_font_error",
          font: new _fonts.ErrorFont(`Type3 font load error: ${reason}`),
          dict: translated.font,
          evaluatorOptions: this.options
        });
      });
    }).then(translated => {
      state.font = translated.font;
      translated.send(this.handler);
      return translated.loadedName;
    });
  }

  handleText(chars, state) {
    const font = state.font;
    const glyphs = font.charsToGlyphs(chars);

    if (font.data) {
      const isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);

      if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
        PartialEvaluator.buildFontPaths(font, glyphs, this.handler, this.options);
      }
    }

    return glyphs;
  }

  ensureStateFont(state) {
    if (state.font) {
      return;
    }

    const reason = new _util.FormatError("Missing setFont (Tf) operator before text rendering operator.");

    if (this.options.ignoreErrors) {
      this.handler.send("UnsupportedFeature", {
        featureId: _util.UNSUPPORTED_FEATURES.errorFontState
      });
      (0, _util.warn)(`ensureStateFont: "${reason}".`);
      return;
    }

    throw reason;
  }

  async setGState({
    resources,
    gState,
    operatorList,
    cacheKey,
    task,
    stateManager,
    localGStateCache,
    localColorSpaceCache
  }) {
    const gStateRef = gState.objId;
    let isSimpleGState = true;
    const gStateObj = [];
    const gStateKeys = gState.getKeys();
    let promise = Promise.resolve();

    for (let i = 0, ii = gStateKeys.length; i < ii; i++) {
      const key = gStateKeys[i];
      const value = gState.get(key);

      switch (key) {
        case "Type":
          break;

        case "LW":
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          gStateObj.push([key, value]);
          break;

        case "Font":
          isSimpleGState = false;
          promise = promise.then(() => {
            return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function (loadedName) {
              operatorList.addDependency(loadedName);
              gStateObj.push([key, [loadedName, value[1]]]);
            });
          });
          break;

        case "BM":
          gStateObj.push([key, normalizeBlendMode(value)]);
          break;

        case "SMask":
          if ((0, _primitives.isName)(value, "None")) {
            gStateObj.push([key, false]);
            break;
          }

          if ((0, _primitives.isDict)(value)) {
            isSimpleGState = false;
            promise = promise.then(() => {
              return this.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache);
            });
            gStateObj.push([key, true]);
          } else {
            (0, _util.warn)("Unsupported SMask type");
          }

          break;

        case "TR":
          const transferMaps = this.handleTransferFunction(value);
          gStateObj.push([key, transferMaps]);
          break;

        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          (0, _util.info)("graphic state operator " + key);
          break;

        default:
          (0, _util.info)("Unknown graphic state operator " + key);
          break;
      }
    }

    return promise.then(function () {
      if (gStateObj.length > 0) {
        operatorList.addOp(_util.OPS.setGState, [gStateObj]);
      }

      if (isSimpleGState) {
        localGStateCache.set(cacheKey, gStateRef, gStateObj);
      }
    });
  }

  loadFont(fontName, font, resources, fallbackFontDict = null, cssFontInfo = null) {
    const errorFont = async () => {
      return new TranslatedFont({
        loadedName: "g_font_error",
        font: new _fonts.ErrorFont(`Font "${fontName}" is not available.`),
        dict: font,
        evaluatorOptions: this.options
      });
    };

    const xref = this.xref;
    let fontRef;

    if (font) {
      if (!(0, _primitives.isRef)(font)) {
        throw new _util.FormatError('The "font" object should be a reference.');
      }

      fontRef = font;
    } else {
      const fontRes = resources.get("Font");

      if (fontRes) {
        fontRef = fontRes.getRaw(fontName);
      }
    }

    if (!fontRef) {
      const partialMsg = `Font "${fontName || font && font.toString()}" is not available`;

      if (!this.options.ignoreErrors && !this.parsingType3Font) {
        (0, _util.warn)(`${partialMsg}.`);
        return errorFont();
      }

      this.handler.send("UnsupportedFeature", {
        featureId: _util.UNSUPPORTED_FEATURES.errorFontMissing
      });
      (0, _util.warn)(`${partialMsg} -- attempting to fallback to a default font.`);

      if (fallbackFontDict) {
        fontRef = fallbackFontDict;
      } else {
        fontRef = PartialEvaluator.fallbackFontDict;
      }
    }

    if (this.fontCache.has(fontRef)) {
      return this.fontCache.get(fontRef);
    }

    font = xref.fetchIfRef(fontRef);

    if (!(0, _primitives.isDict)(font)) {
      return errorFont();
    }

    if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
      return this.fontCache.get(font.cacheKey);
    }

    const fontCapability = (0, _util.createPromiseCapability)();
    let preEvaluatedFont;

    try {
      preEvaluatedFont = this.preEvaluateFont(font);
      preEvaluatedFont.cssFontInfo = cssFontInfo;
    } catch (reason) {
      (0, _util.warn)(`loadFont - preEvaluateFont failed: "${reason}".`);
      return errorFont();
    }

    const {
      descriptor,
      hash
    } = preEvaluatedFont;
    const fontRefIsRef = (0, _primitives.isRef)(fontRef);
    let fontID;

    if (fontRefIsRef) {
      fontID = `f${fontRef.toString()}`;
    }

    if (hash && (0, _primitives.isDict)(descriptor)) {
      if (!descriptor.fontAliases) {
        descriptor.fontAliases = Object.create(null);
      }

      const fontAliases = descriptor.fontAliases;

      if (fontAliases[hash]) {
        const aliasFontRef = fontAliases[hash].aliasRef;

        if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
          this.fontCache.putAlias(fontRef, aliasFontRef);
          return this.fontCache.get(fontRef);
        }
      } else {
        fontAliases[hash] = {
          fontID: this.idFactory.createFontId()
        };
      }

      if (fontRefIsRef) {
        fontAliases[hash].aliasRef = fontRef;
      }

      fontID = fontAliases[hash].fontID;
    }

    if (fontRefIsRef) {
      this.fontCache.put(fontRef, fontCapability.promise);
    } else {
      if (!fontID) {
        fontID = this.idFactory.createFontId();
      }

      font.cacheKey = `cacheKey_${fontID}`;
      this.fontCache.put(font.cacheKey, fontCapability.promise);
    }

    (0, _util.assert)(fontID && fontID.startsWith("f"), 'The "fontID" must be (correctly) defined.');
    font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
    this.translateFont(preEvaluatedFont).then(translatedFont => {
      if (translatedFont.fontType !== undefined) {
        const xrefFontStats = xref.stats.fontTypes;
        xrefFontStats[translatedFont.fontType] = true;
      }

      fontCapability.resolve(new TranslatedFont({
        loadedName: font.loadedName,
        font: translatedFont,
        dict: font,
        evaluatorOptions: this.options
      }));
    }).catch(reason => {
      this.handler.send("UnsupportedFeature", {
        featureId: _util.UNSUPPORTED_FEATURES.errorFontTranslate
      });
      (0, _util.warn)(`loadFont - translateFont failed: "${reason}".`);

      try {
        const fontFile3 = descriptor && descriptor.get("FontFile3");
        const subtype = fontFile3 && fontFile3.get("Subtype");
        const fontType = (0, _fonts_utils.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
        const xrefFontStats = xref.stats.fontTypes;
        xrefFontStats[fontType] = true;
      } catch (ex) {}

      fontCapability.resolve(new TranslatedFont({
        loadedName: font.loadedName,
        font: new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason),
        dict: font,
        evaluatorOptions: this.options
      }));
    });
    return fontCapability.promise;
  }

  buildPath(operatorList, fn, args, parsingText = false) {
    const lastIndex = operatorList.length - 1;

    if (!args) {
      args = [];
    }

    if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
      if (parsingText) {
        (0, _util.warn)(`Encountered path operator "${fn}" inside of a text object.`);
        operatorList.addOp(_util.OPS.save, null);
      }

      operatorList.addOp(_util.OPS.constructPath, [[fn], args]);

      if (parsingText) {
        operatorList.addOp(_util.OPS.restore, null);
      }
    } else {
      const opArgs = operatorList.argsArray[lastIndex];
      opArgs[0].push(fn);
      Array.prototype.push.apply(opArgs[1], args);
    }
  }

  parseColorSpace({
    cs,
    resources,
    localColorSpaceCache
  }) {
    return _colorspace.ColorSpace.parseAsync({
      cs,
      xref: this.xref,
      resources,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return null;
      }

      if (this.options.ignoreErrors) {
        this.handler.send("UnsupportedFeature", {
          featureId: _util.UNSUPPORTED_FEATURES.errorColorSpace
        });
        (0, _util.warn)(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
        return null;
      }

      throw reason;
    });
  }

  handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache) {
    const patternName = args.pop();

    if (patternName instanceof _primitives.Name) {
      const name = patternName.name;
      const localTilingPattern = localTilingPatternCache.getByName(name);

      if (localTilingPattern) {
        try {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          const tilingPatternIR = (0, _pattern.getTilingPatternIR)(localTilingPattern.operatorListIR, localTilingPattern.dict, color);
          operatorList.addOp(fn, tilingPatternIR);
          return undefined;
        } catch (ex) {}
      }

      let pattern = patterns.get(name);

      if (pattern) {
        const dict = (0, _primitives.isStream)(pattern) ? pattern.dict : pattern;
        const typeNum = dict.get("PatternType");

        if (typeNum === PatternType.TILING) {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task, name, localTilingPatternCache);
        } else if (typeNum === PatternType.SHADING) {
          const shading = dict.get("Shading");
          const matrix = dict.getArray("Matrix");
          pattern = _pattern.Pattern.parseShading(shading, matrix, this.xref, resources, this.handler, this._pdfFunctionFactory, localColorSpaceCache);
          operatorList.addOp(fn, pattern.getIR());
          return undefined;
        }

        throw new _util.FormatError(`Unknown PatternType: ${typeNum}`);
      }
    }

    throw new _util.FormatError(`Unknown PatternName: ${patternName}`);
  }

  _parseVisibilityExpression(array, nestingCounter, currentResult) {
    const MAX_NESTING = 10;

    if (++nestingCounter > MAX_NESTING) {
      (0, _util.warn)("Visibility expression is too deeply nested");
      return;
    }

    const length = array.length;
    const operator = this.xref.fetchIfRef(array[0]);

    if (length < 2 || !(0, _primitives.isName)(operator)) {
      (0, _util.warn)("Invalid visibility expression");
      return;
    }

    switch (operator.name) {
      case "And":
      case "Or":
      case "Not":
        currentResult.push(operator.name);
        break;

      default:
        (0, _util.warn)(`Invalid operator ${operator.name} in visibility expression`);
        return;
    }

    for (let i = 1; i < length; i++) {
      const raw = array[i];
      const object = this.xref.fetchIfRef(raw);

      if (Array.isArray(object)) {
        const nestedResult = [];
        currentResult.push(nestedResult);

        this._parseVisibilityExpression(object, nestingCounter, nestedResult);
      } else if ((0, _primitives.isRef)(raw)) {
        currentResult.push(raw.toString());
      }
    }
  }

  async parseMarkedContentProps(contentProperties, resources) {
    let optionalContent;

    if ((0, _primitives.isName)(contentProperties)) {
      const properties = resources.get("Properties");
      optionalContent = properties.get(contentProperties.name);
    } else if ((0, _primitives.isDict)(contentProperties)) {
      optionalContent = contentProperties;
    } else {
      throw new _util.FormatError("Optional content properties malformed.");
    }

    const optionalContentType = optionalContent.get("Type").name;

    if (optionalContentType === "OCG") {
      return {
        type: optionalContentType,
        id: optionalContent.objId
      };
    } else if (optionalContentType === "OCMD") {
      const expression = optionalContent.get("VE");

      if (Array.isArray(expression)) {
        const result = [];

        this._parseVisibilityExpression(expression, 0, result);

        if (result.length > 0) {
          return {
            type: "OCMD",
            expression: result
          };
        }
      }

      const optionalContentGroups = optionalContent.get("OCGs");

      if (Array.isArray(optionalContentGroups) || (0, _primitives.isDict)(optionalContentGroups)) {
        const groupIds = [];

        if (Array.isArray(optionalContentGroups)) {
          for (const ocg of optionalContentGroups) {
            groupIds.push(ocg.toString());
          }
        } else {
          groupIds.push(optionalContentGroups.objId);
        }

        return {
          type: optionalContentType,
          ids: groupIds,
          policy: (0, _primitives.isName)(optionalContent.get("P")) ? optionalContent.get("P").name : null,
          expression: null
        };
      } else if ((0, _primitives.isRef)(optionalContentGroups)) {
        return {
          type: optionalContentType,
          id: optionalContentGroups.toString()
        };
      }
    }

    return null;
  }

  getOperatorList({
    stream,
    task,
    resources,
    operatorList,
    initialState = null,
    fallbackFontDict = null
  }) {
    resources = resources || _primitives.Dict.empty;
    initialState = initialState || new EvalState();

    if (!operatorList) {
      throw new Error('getOperatorList: missing "operatorList" parameter');
    }

    const self = this;
    const xref = this.xref;
    let parsingText = false;
    const localImageCache = new _image_utils.LocalImageCache();
    const localColorSpaceCache = new _image_utils.LocalColorSpaceCache();
    const localGStateCache = new _image_utils.LocalGStateCache();
    const localTilingPatternCache = new _image_utils.LocalTilingPatternCache();

    const xobjs = resources.get("XObject") || _primitives.Dict.empty;

    const patterns = resources.get("Pattern") || _primitives.Dict.empty;

    const stateManager = new StateManager(initialState);
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    const timeSlotManager = new TimeSlotManager();

    function closePendingRestoreOPS(argument) {
      for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
        operatorList.addOp(_util.OPS.restore, []);
      }
    }

    return new Promise(function promiseBody(resolve, reject) {
      const next = function (promise) {
        Promise.all([promise, operatorList.ready]).then(function () {
          try {
            promiseBody(resolve, reject);
          } catch (ex) {
            reject(ex);
          }
        }, reject);
      };

      task.ensureNotTerminated();
      timeSlotManager.reset();
      const operation = {};
      let stop, i, ii, cs, name;

      while (!(stop = timeSlotManager.check())) {
        operation.args = null;

        if (!preprocessor.read(operation)) {
          break;
        }

        let args = operation.args;
        let fn = operation.fn;

        switch (fn | 0) {
          case _util.OPS.paintXObject:
            name = args[0].name;

            if (name) {
              const localImage = localImageCache.getByName(name);

              if (localImage) {
                operatorList.addOp(localImage.fn, localImage.args);
                args = null;
                continue;
              }
            }

            next(new Promise(function (resolveXObject, rejectXObject) {
              if (!name) {
                throw new _util.FormatError("XObject must be referred to by name.");
              }

              let xobj = xobjs.getRaw(name);

              if (xobj instanceof _primitives.Ref) {
                const localImage = localImageCache.getByRef(xobj);

                if (localImage) {
                  operatorList.addOp(localImage.fn, localImage.args);
                  resolveXObject();
                  return;
                }

                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);

                if (globalImage) {
                  operatorList.addDependency(globalImage.objId);
                  operatorList.addOp(globalImage.fn, globalImage.args);
                  resolveXObject();
                  return;
                }

                xobj = xref.fetch(xobj);
              }

              if (!(0, _primitives.isStream)(xobj)) {
                throw new _util.FormatError("XObject should be a stream");
              }

              const type = xobj.dict.get("Subtype");

              if (!(0, _primitives.isName)(type)) {
                throw new _util.FormatError("XObject should have a Name subtype");
              }

              if (type.name === "Form") {
                stateManager.save();
                self.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function () {
                  stateManager.restore();
                  resolveXObject();
                }, rejectXObject);
                return;
              } else if (type.name === "Image") {
                self.buildPaintImageXObject({
                  resources,
                  image: xobj,
                  operatorList,
                  cacheKey: name,
                  localImageCache,
                  localColorSpaceCache
                }).then(resolveXObject, rejectXObject);
                return;
              } else if (type.name === "PS") {
                (0, _util.info)("Ignored XObject subtype PS");
              } else {
                throw new _util.FormatError(`Unhandled XObject subtype ${type.name}`);
              }

              resolveXObject();
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }

              if (self.options.ignoreErrors) {
                self.handler.send("UnsupportedFeature", {
                  featureId: _util.UNSUPPORTED_FEATURES.errorXObject
                });
                (0, _util.warn)(`getOperatorList - ignoring XObject: "${reason}".`);
                return;
              }

              throw reason;
            }));
            return;

          case _util.OPS.setFont:
            var fontSize = args[1];
            next(self.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function (loadedName) {
              operatorList.addDependency(loadedName);
              operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
            }));
            return;

          case _util.OPS.beginText:
            parsingText = true;
            break;

          case _util.OPS.endText:
            parsingText = false;
            break;

          case _util.OPS.endInlineImage:
            var cacheKey = args[0].cacheKey;

            if (cacheKey) {
              const localImage = localImageCache.getByName(cacheKey);

              if (localImage) {
                operatorList.addOp(localImage.fn, localImage.args);
                args = null;
                continue;
              }
            }

            next(self.buildPaintImageXObject({
              resources,
              image: args[0],
              isInline: true,
              operatorList,
              cacheKey,
              localImageCache,
              localColorSpaceCache
            }));
            return;

          case _util.OPS.showText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            args[0] = self.handleText(args[0], stateManager.state);
            break;

          case _util.OPS.showSpacedText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            var arr = args[0];
            var combinedGlyphs = [];
            var arrLength = arr.length;
            var state = stateManager.state;

            for (i = 0; i < arrLength; ++i) {
              const arrItem = arr[i];

              if ((0, _util.isString)(arrItem)) {
                Array.prototype.push.apply(combinedGlyphs, self.handleText(arrItem, state));
              } else if ((0, _util.isNum)(arrItem)) {
                combinedGlyphs.push(arrItem);
              }
            }

            args[0] = combinedGlyphs;
            fn = _util.OPS.showText;
            break;

          case _util.OPS.nextLineShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            operatorList.addOp(_util.OPS.nextLine);
            args[0] = self.handleText(args[0], stateManager.state);
            fn = _util.OPS.showText;
            break;

          case _util.OPS.nextLineSetSpacingShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            operatorList.addOp(_util.OPS.nextLine);
            operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
            operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
            args[0] = self.handleText(args[0], stateManager.state);
            fn = _util.OPS.showText;
            break;

          case _util.OPS.setTextRenderingMode:
            stateManager.state.textRenderingMode = args[0];
            break;

          case _util.OPS.setFillColorSpace:
            {
              const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);

              if (cachedColorSpace) {
                stateManager.state.fillColorSpace = cachedColorSpace;
                continue;
              }

              next(self.parseColorSpace({
                cs: args[0],
                resources,
                localColorSpaceCache
              }).then(function (colorSpace) {
                if (colorSpace) {
                  stateManager.state.fillColorSpace = colorSpace;
                }
              }));
              return;
            }

          case _util.OPS.setStrokeColorSpace:
            {
              const cachedColorSpace = _colorspace.ColorSpace.getCached(args[0], xref, localColorSpaceCache);

              if (cachedColorSpace) {
                stateManager.state.strokeColorSpace = cachedColorSpace;
                continue;
              }

              next(self.parseColorSpace({
                cs: args[0],
                resources,
                localColorSpaceCache
              }).then(function (colorSpace) {
                if (colorSpace) {
                  stateManager.state.strokeColorSpace = colorSpace;
                }
              }));
              return;
            }

          case _util.OPS.setFillColor:
            cs = stateManager.state.fillColorSpace;
            args = cs.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;

          case _util.OPS.setStrokeColor:
            cs = stateManager.state.strokeColorSpace;
            args = cs.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;

          case _util.OPS.setFillGray:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
            args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;

          case _util.OPS.setStrokeGray:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
            args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;

          case _util.OPS.setFillCMYKColor:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
            args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;

          case _util.OPS.setStrokeCMYKColor:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
            args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;

          case _util.OPS.setFillRGBColor:
            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
            args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
            break;

          case _util.OPS.setStrokeRGBColor:
            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
            args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
            break;

          case _util.OPS.setFillColorN:
            cs = stateManager.state.fillColorSpace;

            if (cs.name === "Pattern") {
              next(self.handleColorN(operatorList, _util.OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache));
              return;
            }

            args = cs.getRgb(args, 0);
            fn = _util.OPS.setFillRGBColor;
            break;

          case _util.OPS.setStrokeColorN:
            cs = stateManager.state.strokeColorSpace;

            if (cs.name === "Pattern") {
              next(self.handleColorN(operatorList, _util.OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache));
              return;
            }

            args = cs.getRgb(args, 0);
            fn = _util.OPS.setStrokeRGBColor;
            break;

          case _util.OPS.shadingFill:
            var shadingRes = resources.get("Shading");

            if (!shadingRes) {
              throw new _util.FormatError("No shading resource found");
            }

            var shading = shadingRes.get(args[0].name);

            if (!shading) {
              throw new _util.FormatError("No shading object found");
            }

            var shadingFill = _pattern.Pattern.parseShading(shading, null, xref, resources, self.handler, self._pdfFunctionFactory, localColorSpaceCache);

            var patternIR = shadingFill.getIR();
            args = [patternIR];
            fn = _util.OPS.shadingFill;
            break;

          case _util.OPS.setGState:
            name = args[0].name;

            if (name) {
              const localGStateObj = localGStateCache.getByName(name);

              if (localGStateObj) {
                if (localGStateObj.length > 0) {
                  operatorList.addOp(_util.OPS.setGState, [localGStateObj]);
                }

                args = null;
                continue;
              }
            }

            next(new Promise(function (resolveGState, rejectGState) {
              if (!name) {
                throw new _util.FormatError("GState must be referred to by name.");
              }

              const extGState = resources.get("ExtGState");

              if (!(extGState instanceof _primitives.Dict)) {
                throw new _util.FormatError("ExtGState should be a dictionary.");
              }

              const gState = extGState.get(name);

              if (!(gState instanceof _primitives.Dict)) {
                throw new _util.FormatError("GState should be a dictionary.");
              }

              self.setGState({
                resources,
                gState,
                operatorList,
                cacheKey: name,
                task,
                stateManager,
                localGStateCache,
                localColorSpaceCache
              }).then(resolveGState, rejectGState);
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }

              if (self.options.ignoreErrors) {
                self.handler.send("UnsupportedFeature", {
                  featureId: _util.UNSUPPORTED_FEATURES.errorExtGState
                });
                (0, _util.warn)(`getOperatorList - ignoring ExtGState: "${reason}".`);
                return;
              }

              throw reason;
            }));
            return;

          case _util.OPS.moveTo:
          case _util.OPS.lineTo:
          case _util.OPS.curveTo:
          case _util.OPS.curveTo2:
          case _util.OPS.curveTo3:
          case _util.OPS.closePath:
          case _util.OPS.rectangle:
            self.buildPath(operatorList, fn, args, parsingText);
            continue;

          case _util.OPS.markPoint:
          case _util.OPS.markPointProps:
          case _util.OPS.beginCompat:
          case _util.OPS.endCompat:
            continue;

          case _util.OPS.beginMarkedContentProps:
            if (!(0, _primitives.isName)(args[0])) {
              (0, _util.warn)(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
              continue;
            }

            if (args[0].name === "OC") {
              next(self.parseMarkedContentProps(args[1], resources).then(data => {
                operatorList.addOp(_util.OPS.beginMarkedContentProps, ["OC", data]);
              }).catch(reason => {
                if (reason instanceof _util.AbortException) {
                  return;
                }

                if (self.options.ignoreErrors) {
                  self.handler.send("UnsupportedFeature", {
                    featureId: _util.UNSUPPORTED_FEATURES.errorMarkedContent
                  });
                  (0, _util.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${reason}".`);
                  return;
                }

                throw reason;
              }));
              return;
            }

            args = [args[0].name, args[1] instanceof _primitives.Dict ? args[1].get("MCID") : null];
            break;

          case _util.OPS.beginMarkedContent:
          case _util.OPS.endMarkedContent:
          default:
            if (args !== null) {
              for (i = 0, ii = args.length; i < ii; i++) {
                if (args[i] instanceof _primitives.Dict) {
                  break;
                }
              }

              if (i < ii) {
                (0, _util.warn)("getOperatorList - ignoring operator: " + fn);
                continue;
              }
            }

        }

        operatorList.addOp(fn, args);
      }

      if (stop) {
        next(deferred);
        return;
      }

      closePendingRestoreOPS();
      resolve();
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return;
      }

      if (this.options.ignoreErrors) {
        this.handler.send("UnsupportedFeature", {
          featureId: _util.UNSUPPORTED_FEATURES.errorOperatorList
        });
        (0, _util.warn)(`getOperatorList - ignoring errors during "${task.name}" ` + `task: "${reason}".`);
        closePendingRestoreOPS();
        return;
      }

      throw reason;
    });
  }

  getTextContent({
    stream,
    task,
    resources,
    stateManager = null,
    normalizeWhitespace = false,
    combineTextItems = false,
    includeMarkedContent = false,
    sink,
    seenStyles = new Set()
  }) {
    resources = resources || _primitives.Dict.empty;
    stateManager = stateManager || new StateManager(new TextState());
    const WhitespaceRegexp = /\s/g;
    const textContent = {
      items: [],
      styles: Object.create(null)
    };
    const textContentItem = {
      initialized: false,
      str: [],
      totalWidth: 0,
      totalHeight: 0,
      width: 0,
      height: 0,
      vertical: false,
      lastCharSize: 0,
      prevTransform: null,
      textAdvanceScale: 0,
      spaceWidth: 0,
      spaceInFlowMin: 0,
      spaceInFlowMax: 0,
      trackingSpaceMin: Infinity,
      transform: null,
      fontName: null,
      hasEOL: false,
      isLastCharWhiteSpace: false
    };
    const TRACKING_SPACE_FACTOR = 0.3;
    const SPACE_IN_FLOW_MIN_FACTOR = 0.3;
    const SPACE_IN_FLOW_MAX_FACTOR = 1.3;
    const self = this;
    const xref = this.xref;
    const showSpacedTextBuffer = [];
    let xobjs = null;
    const emptyXObjectCache = new _image_utils.LocalImageCache();
    const emptyGStateCache = new _image_utils.LocalGStateCache();
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    let textState;

    function getCurrentTextTransform() {
      const font = textState.font;
      const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];

      if (font.isType3Font && textState.fontSize <= 1 && !(0, _util.isArrayEqual)(textState.fontMatrix, _util.FONT_IDENTITY_MATRIX)) {
        const glyphHeight = font.bbox[3] - font.bbox[1];

        if (glyphHeight > 0) {
          tsm[3] *= glyphHeight * textState.fontMatrix[3];
        }
      }

      return _util.Util.transform(textState.ctm, _util.Util.transform(textState.textMatrix, tsm));
    }

    function ensureTextContentItem() {
      if (textContentItem.initialized) {
        return textContentItem;
      }

      const font = textState.font,
            loadedName = font.loadedName;

      if (!seenStyles.has(loadedName)) {
        seenStyles.add(loadedName);
        textContent.styles[loadedName] = {
          fontFamily: font.fallbackName,
          ascent: font.ascent,
          descent: font.descent,
          vertical: font.vertical
        };
      }

      textContentItem.fontName = loadedName;
      const trm = textContentItem.transform = getCurrentTextTransform();

      if (!font.vertical) {
        textContentItem.width = textContentItem.totalWidth = 0;
        textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]);
        textContentItem.vertical = false;
      } else {
        textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]);
        textContentItem.height = textContentItem.totalHeight = 0;
        textContentItem.vertical = true;
      }

      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
      textContentItem.lastCharSize = textContentItem.lastCharSize || 0;
      const spaceWidth = font.spaceWidth / 1000 * textState.fontSize;

      if (spaceWidth) {
        textContentItem.spaceWidth = spaceWidth;
        textContentItem.trackingSpaceMin = spaceWidth * TRACKING_SPACE_FACTOR;
        textContentItem.spaceInFlowMin = spaceWidth * SPACE_IN_FLOW_MIN_FACTOR;
        textContentItem.spaceInFlowMax = spaceWidth * SPACE_IN_FLOW_MAX_FACTOR;
      } else {
        textContentItem.spaceWidth = 0;
        textContentItem.trackingSpaceMin = Infinity;
      }

      textContentItem.hasEOL = false;
      textContentItem.initialized = true;
      return textContentItem;
    }

    function updateAdvanceScale() {
      if (!textContentItem.initialized) {
        return;
      }

      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      const scaleFactor = scaleCtmX * scaleLineX;

      if (scaleFactor === textContentItem.textAdvanceScale) {
        return;
      }

      if (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
        textContentItem.width = 0;
      } else {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
        textContentItem.height = 0;
      }

      textContentItem.textAdvanceScale = scaleFactor;
    }

    function replaceWhitespace(str) {
      const ii = str.length;
      let i = 0,
          code;

      while (i < ii && (code = str.charCodeAt(i)) >= 0x20 && code <= 0x7f) {
        i++;
      }

      return i < ii ? str.replace(WhitespaceRegexp, " ") : str;
    }

    function runBidiTransform(textChunk) {
      const text = textChunk.str.join("");
      const bidiResult = (0, _bidi.bidi)(text, -1, textChunk.vertical);
      const str = normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str;
      return {
        str,
        dir: bidiResult.dir,
        width: textChunk.totalWidth,
        height: textChunk.totalHeight,
        transform: textChunk.transform,
        fontName: textChunk.fontName,
        hasEOL: textChunk.hasEOL
      };
    }

    function handleSetFont(fontName, fontRef) {
      return self.loadFont(fontName, fontRef, resources).then(function (translated) {
        textState.font = translated.font;
        textState.fontMatrix = translated.font.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      });
    }

    function compareWithLastPosition(fontSize) {
      if (!combineTextItems || !textState.font || !textContentItem.prevTransform) {
        return;
      }

      const currentTransform = getCurrentTextTransform();
      const posX = currentTransform[4];
      const posY = currentTransform[5];
      const lastPosX = textContentItem.prevTransform[4];
      const lastPosY = textContentItem.prevTransform[5];

      if (lastPosX === posX && lastPosY === posY) {
        return;
      }

      const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
      const advanceY = (posY - lastPosY) / textContentItem.textAdvanceScale;
      const HALF_LAST_CHAR = -0.5 * textContentItem.lastCharSize;

      if (textState.font.vertical) {
        if (Math.abs(advanceX) > textContentItem.width / textContentItem.textAdvanceScale) {
          appendEOL();
          return;
        }

        if (HALF_LAST_CHAR > advanceY) {
          return;
        }

        if (advanceY > textContentItem.trackingSpaceMin) {
          textContentItem.height += advanceY;
        } else if (!addFakeSpaces(advanceY, 0, textContentItem.prevTransform)) {
          if (textContentItem.str.length === 0) {
            textContent.items.push({
              str: " ",
              dir: "ltr",
              width: 0,
              height: advanceY,
              transform: textContentItem.prevTransform,
              fontName: textContentItem.fontName,
              hasEOL: false
            });
            textContentItem.isLastCharWhiteSpace = true;
          } else {
            textContentItem.height += advanceY;
          }
        }

        return;
      }

      if (Math.abs(advanceY) > textContentItem.height / textContentItem.textAdvanceScale) {
        appendEOL();
        return;
      }

      if (HALF_LAST_CHAR > advanceX) {
        return;
      }

      if (advanceX <= textContentItem.trackingSpaceMin) {
        textContentItem.width += advanceX;
      } else if (!addFakeSpaces(advanceX, 0, textContentItem.prevTransform)) {
        if (textContentItem.str.length === 0) {
          textContent.items.push({
            str: " ",
            dir: "ltr",
            width: advanceX,
            height: 0,
            transform: textContentItem.prevTransform,
            fontName: textContentItem.fontName,
            hasEOL: false
          });
          textContentItem.isLastCharWhiteSpace = true;
        } else {
          textContentItem.width += advanceX;
        }
      }
    }

    function buildTextContentItem({
      chars,
      extraSpacing,
      isFirstChunk
    }) {
      const font = textState.font;

      if (!chars) {
        const charSpacing = textState.charSpacing + extraSpacing;

        if (charSpacing) {
          if (!font.vertical) {
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } else {
            textState.translateTextMatrix(0, charSpacing);
          }
        }

        return;
      }

      const NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)();
      const glyphs = font.charsToGlyphs(chars);
      const scale = textState.fontMatrix[0] * textState.fontSize;

      if (isFirstChunk) {
        compareWithLastPosition(scale);
      }

      let textChunk = ensureTextContentItem();
      let size = 0;
      let lastCharSize = 0;

      for (let i = 0, ii = glyphs.length; i < ii; i++) {
        const glyph = glyphs[i];
        let charSpacing = textState.charSpacing + (i === ii - 1 ? extraSpacing : 0);
        let glyphUnicode = glyph.unicode;

        if (glyph.isSpace) {
          charSpacing += textState.wordSpacing;
          textChunk.isLastCharWhiteSpace = true;
        } else {
          glyphUnicode = NormalizedUnicodes[glyphUnicode] || glyphUnicode;
          glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode);
          textChunk.isLastCharWhiteSpace = false;
        }

        textChunk.str.push(glyphUnicode);
        const glyphWidth = font.vertical && glyph.vmetric ? glyph.vmetric[0] : glyph.width;
        let scaledDim = glyphWidth * scale;

        if (!font.vertical) {
          scaledDim *= textState.textHScale;
          textState.translateTextMatrix(scaledDim, 0);
        } else {
          textState.translateTextMatrix(0, scaledDim);
          scaledDim = Math.abs(scaledDim);
        }

        size += scaledDim;

        if (charSpacing) {
          if (!font.vertical) {
            charSpacing *= textState.textHScale;
          }

          scaledDim += charSpacing;
          const wasSplit = charSpacing > textContentItem.trackingSpaceMin && addFakeSpaces(charSpacing, size);

          if (!font.vertical) {
            textState.translateTextMatrix(charSpacing, 0);
          } else {
            textState.translateTextMatrix(0, charSpacing);
          }

          if (wasSplit) {
            textChunk = ensureTextContentItem();
            size = 0;
          } else {
            size += charSpacing;
          }
        }

        lastCharSize = scaledDim;
      }

      textChunk.lastCharSize = lastCharSize;

      if (!font.vertical) {
        textChunk.width += size;
      } else {
        textChunk.height += size;
      }

      textChunk.prevTransform = getCurrentTextTransform();
    }

    function appendEOL() {
      if (textContentItem.initialized) {
        textContentItem.hasEOL = true;
        flushTextContentItem();
      } else if (textContent.items.length > 0) {
        textContent.items[textContent.items.length - 1].hasEOL = true;
      } else {
        textContent.items.push({
          str: "",
          dir: "ltr",
          width: 0,
          height: 0,
          transform: getCurrentTextTransform(),
          fontName: textState.font.loadedName,
          hasEOL: true
        });
      }

      textContentItem.isLastCharWhiteSpace = false;
      textContentItem.lastCharSize = 0;
    }

    function addFakeSpaces(width, size, transf = null) {
      if (textContentItem.spaceInFlowMin <= width && width <= textContentItem.spaceInFlowMax) {
        if (textContentItem.initialized) {
          textContentItem.str.push(" ");
          textContentItem.isLastCharWhiteSpace = true;
        }

        return false;
      }

      const fontName = textContentItem.fontName;
      let height = 0;
      width *= textContentItem.textAdvanceScale;

      if (!textContentItem.vertical) {
        textContentItem.width += size;
      } else {
        textContentItem.height += size;
        height = width;
        width = 0;
      }

      flushTextContentItem();

      if (textContentItem.isLastCharWhiteSpace) {
        return true;
      }

      textContentItem.isLastCharWhiteSpace = true;
      textContent.items.push({
        str: " ",
        dir: "ltr",
        width,
        height,
        transform: transf ? transf : getCurrentTextTransform(),
        fontName,
        hasEOL: false
      });
      return true;
    }

    function flushTextContentItem() {
      if (!textContentItem.initialized || !textContentItem.str) {
        return;
      }

      if (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
      } else {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
      }

      textContent.items.push(runBidiTransform(textContentItem));
      textContentItem.initialized = false;
      textContentItem.str.length = 0;
    }

    function enqueueChunk() {
      const length = textContent.items.length;

      if (length > 0) {
        sink.enqueue(textContent, length);
        textContent.items = [];
        textContent.styles = Object.create(null);
      }
    }

    const timeSlotManager = new TimeSlotManager();
    return new Promise(function promiseBody(resolve, reject) {
      const next = function (promise) {
        enqueueChunk();
        Promise.all([promise, sink.ready]).then(function () {
          try {
            promiseBody(resolve, reject);
          } catch (ex) {
            reject(ex);
          }
        }, reject);
      };

      task.ensureNotTerminated();
      timeSlotManager.reset();
      const operation = {};
      let stop,
          args = [];

      while (!(stop = timeSlotManager.check())) {
        args.length = 0;
        operation.args = args;

        if (!preprocessor.read(operation)) {
          break;
        }

        textState = stateManager.state;
        const fn = operation.fn;
        args = operation.args;

        switch (fn | 0) {
          case _util.OPS.setFont:
            var fontNameArg = args[0].name,
                fontSizeArg = args[1];

            if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
              break;
            }

            flushTextContentItem();
            textState.fontName = fontNameArg;
            textState.fontSize = fontSizeArg;
            next(handleSetFont(fontNameArg, null));
            return;

          case _util.OPS.setTextRise:
            flushTextContentItem();
            textState.textRise = args[0];
            break;

          case _util.OPS.setHScale:
            flushTextContentItem();
            textState.textHScale = args[0] / 100;
            break;

          case _util.OPS.setLeading:
            flushTextContentItem();
            textState.leading = args[0];
            break;

          case _util.OPS.moveText:
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            break;

          case _util.OPS.setLeadingMoveText:
            flushTextContentItem();
            textState.leading = -args[1];
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            break;

          case _util.OPS.nextLine:
            appendEOL();
            textState.carriageReturn();
            break;

          case _util.OPS.setTextMatrix:
            textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            updateAdvanceScale();
            break;

          case _util.OPS.setCharSpacing:
            textState.charSpacing = args[0];
            break;

          case _util.OPS.setWordSpacing:
            textState.wordSpacing = args[0];
            break;

          case _util.OPS.beginText:
            flushTextContentItem();
            textState.textMatrix = _util.IDENTITY_MATRIX.slice();
            textState.textLineMatrix = _util.IDENTITY_MATRIX.slice();
            break;

          case _util.OPS.showSpacedText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1000;
            const elements = args[0];
            let isFirstChunk = true;

            for (let i = 0, ii = elements.length; i < ii - 1; i++) {
              const item = elements[i];

              if (typeof item === "string") {
                showSpacedTextBuffer.push(item);
              } else if (typeof item === "number" && item !== 0) {
                const str = showSpacedTextBuffer.join("");
                showSpacedTextBuffer.length = 0;
                buildTextContentItem({
                  chars: str,
                  extraSpacing: item * spaceFactor,
                  isFirstChunk
                });

                if (str && isFirstChunk) {
                  isFirstChunk = false;
                }
              }
            }

            const item = elements[elements.length - 1];

            if (typeof item === "string") {
              showSpacedTextBuffer.push(item);
            }

            if (showSpacedTextBuffer.length > 0) {
              const str = showSpacedTextBuffer.join("");
              showSpacedTextBuffer.length = 0;
              buildTextContentItem({
                chars: str,
                extraSpacing: 0,
                isFirstChunk
              });
            }

            break;

          case _util.OPS.showText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            buildTextContentItem({
              chars: args[0],
              extraSpacing: 0,
              isFirstChunk: true
            });
            break;

          case _util.OPS.nextLineShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            textContentItem.hasEOL = true;
            flushTextContentItem();
            textState.carriageReturn();
            buildTextContentItem({
              chars: args[0],
              extraSpacing: 0,
              isFirstChunk: true
            });
            break;

          case _util.OPS.nextLineSetSpacingShowText:
            if (!stateManager.state.font) {
              self.ensureStateFont(stateManager.state);
              continue;
            }

            textContentItem.hasEOL = true;
            flushTextContentItem();
            textState.wordSpacing = args[0];
            textState.charSpacing = args[1];
            textState.carriageReturn();
            buildTextContentItem({
              chars: args[2],
              extraSpacing: 0,
              isFirstChunk: true
            });
            break;

          case _util.OPS.paintXObject:
            flushTextContentItem();

            if (!xobjs) {
              xobjs = resources.get("XObject") || _primitives.Dict.empty;
            }

            var name = args[0].name;

            if (name && emptyXObjectCache.getByName(name)) {
              break;
            }

            next(new Promise(function (resolveXObject, rejectXObject) {
              if (!name) {
                throw new _util.FormatError("XObject must be referred to by name.");
              }

              let xobj = xobjs.getRaw(name);

              if (xobj instanceof _primitives.Ref) {
                if (emptyXObjectCache.getByRef(xobj)) {
                  resolveXObject();
                  return;
                }

                const globalImage = self.globalImageCache.getData(xobj, self.pageIndex);

                if (globalImage) {
                  resolveXObject();
                  return;
                }

                xobj = xref.fetch(xobj);
              }

              if (!(0, _primitives.isStream)(xobj)) {
                throw new _util.FormatError("XObject should be a stream");
              }

              const type = xobj.dict.get("Subtype");

              if (!(0, _primitives.isName)(type)) {
                throw new _util.FormatError("XObject should have a Name subtype");
              }

              if (type.name !== "Form") {
                emptyXObjectCache.set(name, xobj.dict.objId, true);
                resolveXObject();
                return;
              }

              const currentState = stateManager.state.clone();
              const xObjStateManager = new StateManager(currentState);
              const matrix = xobj.dict.getArray("Matrix");

              if (Array.isArray(matrix) && matrix.length === 6) {
                xObjStateManager.transform(matrix);
              }

              enqueueChunk();
              const sinkWrapper = {
                enqueueInvoked: false,

                enqueue(chunk, size) {
                  this.enqueueInvoked = true;
                  sink.enqueue(chunk, size);
                },

                get desiredSize() {
                  return sink.desiredSize;
                },

                get ready() {
                  return sink.ready;
                }

              };
              self.getTextContent({
                stream: xobj,
                task,
                resources: xobj.dict.get("Resources") || resources,
                stateManager: xObjStateManager,
                normalizeWhitespace,
                combineTextItems,
                includeMarkedContent,
                sink: sinkWrapper,
                seenStyles
              }).then(function () {
                if (!sinkWrapper.enqueueInvoked) {
                  emptyXObjectCache.set(name, xobj.dict.objId, true);
                }

                resolveXObject();
              }, rejectXObject);
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }

              if (self.options.ignoreErrors) {
                (0, _util.warn)(`getTextContent - ignoring XObject: "${reason}".`);
                return;
              }

              throw reason;
            }));
            return;

          case _util.OPS.setGState:
            name = args[0].name;

            if (name && emptyGStateCache.getByName(name)) {
              break;
            }

            next(new Promise(function (resolveGState, rejectGState) {
              if (!name) {
                throw new _util.FormatError("GState must be referred to by name.");
              }

              const extGState = resources.get("ExtGState");

              if (!(extGState instanceof _primitives.Dict)) {
                throw new _util.FormatError("ExtGState should be a dictionary.");
              }

              const gState = extGState.get(name);

              if (!(gState instanceof _primitives.Dict)) {
                throw new _util.FormatError("GState should be a dictionary.");
              }

              const gStateFont = gState.get("Font");

              if (!gStateFont) {
                emptyGStateCache.set(name, gState.objId, true);
                resolveGState();
                return;
              }

              flushTextContentItem();
              textState.fontName = null;
              textState.fontSize = gStateFont[1];
              handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);
            }).catch(function (reason) {
              if (reason instanceof _util.AbortException) {
                return;
              }

              if (self.options.ignoreErrors) {
                (0, _util.warn)(`getTextContent - ignoring ExtGState: "${reason}".`);
                return;
              }

              throw reason;
            }));
            return;

          case _util.OPS.beginMarkedContent:
            if (includeMarkedContent) {
              textContent.items.push({
                type: "beginMarkedContent",
                tag: (0, _primitives.isName)(args[0]) ? args[0].name : null
              });
            }

            break;

          case _util.OPS.beginMarkedContentProps:
            if (includeMarkedContent) {
              flushTextContentItem();
              let mcid = null;

              if ((0, _primitives.isDict)(args[1])) {
                mcid = args[1].get("MCID");
              }

              textContent.items.push({
                type: "beginMarkedContentProps",
                id: Number.isInteger(mcid) ? `${self.idFactory.getPageObjId()}_mcid${mcid}` : null,
                tag: (0, _primitives.isName)(args[0]) ? args[0].name : null
              });
            }

            break;

          case _util.OPS.endMarkedContent:
            if (includeMarkedContent) {
              flushTextContentItem();
              textContent.items.push({
                type: "endMarkedContent"
              });
            }

            break;
        }

        if (textContent.items.length >= sink.desiredSize) {
          stop = true;
          break;
        }
      }

      if (stop) {
        next(deferred);
        return;
      }

      flushTextContentItem();
      enqueueChunk();
      resolve();
    }).catch(reason => {
      if (reason instanceof _util.AbortException) {
        return;
      }

      if (this.options.ignoreErrors) {
        (0, _util.warn)(`getTextContent - ignoring errors during "${task.name}" ` + `task: "${reason}".`);
        flushTextContentItem();
        enqueueChunk();
        return;
      }

      throw reason;
    });
  }

  extractDataStructures(dict, baseDict, properties) {
    const xref = this.xref;
    let cidToGidBytes;
    const toUnicodePromise = this.readToUnicode(properties.toUnicode || dict.get("ToUnicode") || baseDict.get("ToUnicode"));

    if (properties.composite) {
      const cidSystemInfo = dict.get("CIDSystemInfo");

      if ((0, _primitives.isDict)(cidSystemInfo)) {
        properties.cidSystemInfo = {
          registry: (0, _util.stringToPDFString)(cidSystemInfo.get("Registry")),
          ordering: (0, _util.stringToPDFString)(cidSystemInfo.get("Ordering")),
          supplement: cidSystemInfo.get("Supplement")
        };
      }

      const cidToGidMap = dict.get("CIDToGIDMap");

      if ((0, _primitives.isStream)(cidToGidMap)) {
        cidToGidBytes = cidToGidMap.getBytes();
      }
    }

    const differences = [];
    let baseEncodingName = null;
    let encoding;

    if (dict.has("Encoding")) {
      encoding = dict.get("Encoding");

      if ((0, _primitives.isDict)(encoding)) {
        baseEncodingName = encoding.get("BaseEncoding");
        baseEncodingName = (0, _primitives.isName)(baseEncodingName) ? baseEncodingName.name : null;

        if (encoding.has("Differences")) {
          const diffEncoding = encoding.get("Differences");
          let index = 0;

          for (let j = 0, jj = diffEncoding.length; j < jj; j++) {
            const data = xref.fetchIfRef(diffEncoding[j]);

            if ((0, _util.isNum)(data)) {
              index = data;
            } else if ((0, _primitives.isName)(data)) {
              differences[index++] = data.name;
            } else {
              throw new _util.FormatError(`Invalid entry in 'Differences' array: ${data}`);
            }
          }
        }
      } else if ((0, _primitives.isName)(encoding)) {
        baseEncodingName = encoding.name;
      } else {
        throw new _util.FormatError("Encoding is not a Name nor a Dict");
      }

      if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
        baseEncodingName = null;
      }
    }

    if (baseEncodingName) {
      properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName);
    } else {
      const isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
      const isNonsymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Nonsymbolic);
      encoding = _encodings.StandardEncoding;

      if (properties.type === "TrueType" && !isNonsymbolicFont) {
        encoding = _encodings.WinAnsiEncoding;
      }

      if (isSymbolicFont) {
        encoding = _encodings.MacRomanEncoding;

        if (!properties.file) {
          if (/Symbol/i.test(properties.name)) {
            encoding = _encodings.SymbolSetEncoding;
          } else if (/Dingbats|Wingdings/i.test(properties.name)) {
            encoding = _encodings.ZapfDingbatsEncoding;
          }
        }
      }

      properties.defaultEncoding = encoding;
    }

    properties.differences = differences;
    properties.baseEncodingName = baseEncodingName;
    properties.hasEncoding = !!baseEncodingName || differences.length > 0;
    properties.dict = dict;
    return toUnicodePromise.then(readToUnicode => {
      properties.toUnicode = readToUnicode;
      return this.buildToUnicode(properties);
    }).then(builtToUnicode => {
      properties.toUnicode = builtToUnicode;

      if (cidToGidBytes) {
        properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode);
      }

      return properties;
    });
  }

  _buildSimpleFontToUnicode(properties, forceGlyphs = false) {
    (0, _util.assert)(!properties.composite, "Must be a simple font.");
    const toUnicode = [];
    const encoding = properties.defaultEncoding.slice();
    const baseEncodingName = properties.baseEncodingName;
    const differences = properties.differences;

    for (const charcode in differences) {
      const glyphName = differences[charcode];

      if (glyphName === ".notdef") {
        continue;
      }

      encoding[charcode] = glyphName;
    }

    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();

    for (const charcode in encoding) {
      let glyphName = encoding[charcode];

      if (glyphName === "") {
        continue;
      } else if (glyphsUnicodeMap[glyphName] === undefined) {
        let code = 0;

        switch (glyphName[0]) {
          case "G":
            if (glyphName.length === 3) {
              code = parseInt(glyphName.substring(1), 16);
            }

            break;

          case "g":
            if (glyphName.length === 5) {
              code = parseInt(glyphName.substring(1), 16);
            }

            break;

          case "C":
          case "c":
            if (glyphName.length >= 3 && glyphName.length <= 4) {
              const codeStr = glyphName.substring(1);

              if (forceGlyphs) {
                code = parseInt(codeStr, 16);
                break;
              }

              code = +codeStr;

              if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
                return this._buildSimpleFontToUnicode(properties, true);
              }
            }

            break;

          default:
            const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);

            if (unicode !== -1) {
              code = unicode;
            }

        }

        if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
          if (baseEncodingName && code === +charcode) {
            const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);

            if (baseEncoding && (glyphName = baseEncoding[charcode])) {
              toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
              continue;
            }
          }

          toUnicode[charcode] = String.fromCodePoint(code);
        }

        continue;
      }

      toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
    }

    return new _to_unicode_map.ToUnicodeMap(toUnicode);
  }

  buildToUnicode(properties) {
    properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;

    if (properties.hasIncludedToUnicodeMap) {
      if (!properties.composite && properties.hasEncoding) {
        properties.fallbackToUnicode = this._buildSimpleFontToUnicode(properties);
      }

      return Promise.resolve(properties.toUnicode);
    }

    if (!properties.composite) {
      return Promise.resolve(this._buildSimpleFontToUnicode(properties));
    }

    if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
      const registry = properties.cidSystemInfo.registry;
      const ordering = properties.cidSystemInfo.ordering;

      const ucs2CMapName = _primitives.Name.get(registry + "-" + ordering + "-UCS2");

      return _cmap.CMapFactory.create({
        encoding: ucs2CMapName,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(function (ucs2CMap) {
        const cMap = properties.cMap;
        const toUnicode = [];
        cMap.forEach(function (charcode, cid) {
          if (cid > 0xffff) {
            throw new _util.FormatError("Max size of CID is 65,535");
          }

          const ucs2 = ucs2CMap.lookup(cid);

          if (ucs2) {
            toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
          }
        });
        return new _to_unicode_map.ToUnicodeMap(toUnicode);
      });
    }

    return Promise.resolve(new _to_unicode_map.IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
  }

  readToUnicode(cmapObj) {
    if (!cmapObj) {
      return Promise.resolve(null);
    }

    if ((0, _primitives.isName)(cmapObj)) {
      return _cmap.CMapFactory.create({
        encoding: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(function (cmap) {
        if (cmap instanceof _cmap.IdentityCMap) {
          return new _to_unicode_map.IdentityToUnicodeMap(0, 0xffff);
        }

        return new _to_unicode_map.ToUnicodeMap(cmap.getMap());
      });
    } else if ((0, _primitives.isStream)(cmapObj)) {
      return _cmap.CMapFactory.create({
        encoding: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(function (cmap) {
        if (cmap instanceof _cmap.IdentityCMap) {
          return new _to_unicode_map.IdentityToUnicodeMap(0, 0xffff);
        }

        const map = new Array(cmap.length);
        cmap.forEach(function (charCode, token) {
          const str = [];

          for (let k = 0; k < token.length; k += 2) {
            const w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);

            if ((w1 & 0xf800) !== 0xd800) {
              str.push(w1);
              continue;
            }

            k += 2;
            const w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
            str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
          }

          map[charCode] = String.fromCodePoint.apply(String, str);
        });
        return new _to_unicode_map.ToUnicodeMap(map);
      }, reason => {
        if (reason instanceof _util.AbortException) {
          return null;
        }

        if (this.options.ignoreErrors) {
          this.handler.send("UnsupportedFeature", {
            featureId: _util.UNSUPPORTED_FEATURES.errorFontToUnicode
          });
          (0, _util.warn)(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
          return null;
        }

        throw reason;
      });
    }

    return Promise.resolve(null);
  }

  readCidToGidMap(glyphsData, toUnicode) {
    const result = [];

    for (let j = 0, jj = glyphsData.length; j < jj; j++) {
      const glyphID = glyphsData[j++] << 8 | glyphsData[j];
      const code = j >> 1;

      if (glyphID === 0 && !toUnicode.has(code)) {
        continue;
      }

      result[code] = glyphID;
    }

    return result;
  }

  extractWidths(dict, descriptor, properties) {
    const xref = this.xref;
    let glyphsWidths = [];
    let defaultWidth = 0;
    const glyphsVMetrics = [];
    let defaultVMetrics;
    let i, ii, j, jj, start, code, widths;

    if (properties.composite) {
      defaultWidth = dict.has("DW") ? dict.get("DW") : 1000;
      widths = dict.get("W");

      if (widths) {
        for (i = 0, ii = widths.length; i < ii; i++) {
          start = xref.fetchIfRef(widths[i++]);
          code = xref.fetchIfRef(widths[i]);

          if (Array.isArray(code)) {
            for (j = 0, jj = code.length; j < jj; j++) {
              glyphsWidths[start++] = xref.fetchIfRef(code[j]);
            }
          } else {
            const width = xref.fetchIfRef(widths[++i]);

            for (j = start; j <= code; j++) {
              glyphsWidths[j] = width;
            }
          }
        }
      }

      if (properties.vertical) {
        let vmetrics = dict.getArray("DW2") || [880, -1000];
        defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
        vmetrics = dict.get("W2");

        if (vmetrics) {
          for (i = 0, ii = vmetrics.length; i < ii; i++) {
            start = xref.fetchIfRef(vmetrics[i++]);
            code = xref.fetchIfRef(vmetrics[i]);

            if (Array.isArray(code)) {
              for (j = 0, jj = code.length; j < jj; j++) {
                glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
              }
            } else {
              const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];

              for (j = start; j <= code; j++) {
                glyphsVMetrics[j] = vmetric;
              }
            }
          }
        }
      }
    } else {
      const firstChar = properties.firstChar;
      widths = dict.get("Widths");

      if (widths) {
        j = firstChar;

        for (i = 0, ii = widths.length; i < ii; i++) {
          glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
        }

        defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
      } else {
        const baseFontName = dict.get("BaseFont");

        if ((0, _primitives.isName)(baseFontName)) {
          const metrics = this.getBaseFontMetrics(baseFontName.name);
          glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
          defaultWidth = metrics.defaultWidth;
        }
      }
    }

    let isMonospace = true;
    let firstWidth = defaultWidth;

    for (const glyph in glyphsWidths) {
      const glyphWidth = glyphsWidths[glyph];

      if (!glyphWidth) {
        continue;
      }

      if (!firstWidth) {
        firstWidth = glyphWidth;
        continue;
      }

      if (firstWidth !== glyphWidth) {
        isMonospace = false;
        break;
      }
    }

    if (isMonospace) {
      properties.flags |= _fonts_utils.FontFlags.FixedPitch;
    }

    properties.defaultWidth = defaultWidth;
    properties.widths = glyphsWidths;
    properties.defaultVMetrics = defaultVMetrics;
    properties.vmetrics = glyphsVMetrics;
  }

  isSerifFont(baseFontName) {
    const fontNameWoStyle = baseFontName.split("-")[0];
    return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || fontNameWoStyle.search(/serif/gi) !== -1;
  }

  getBaseFontMetrics(name) {
    let defaultWidth = 0;
    let widths = Object.create(null);
    let monospace = false;
    const stdFontMap = (0, _standard_fonts.getStdFontMap)();
    let lookupName = stdFontMap[name] || name;
    const Metrics = (0, _metrics.getMetrics)();

    if (!(lookupName in Metrics)) {
      if (this.isSerifFont(name)) {
        lookupName = "Times-Roman";
      } else {
        lookupName = "Helvetica";
      }
    }

    const glyphWidths = Metrics[lookupName];

    if ((0, _util.isNum)(glyphWidths)) {
      defaultWidth = glyphWidths;
      monospace = true;
    } else {
      widths = glyphWidths();
    }

    return {
      defaultWidth,
      monospace,
      widths
    };
  }

  buildCharCodeToWidth(widthsByGlyphName, properties) {
    const widths = Object.create(null);
    const differences = properties.differences;
    const encoding = properties.defaultEncoding;

    for (let charCode = 0; charCode < 256; charCode++) {
      if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
        widths[charCode] = widthsByGlyphName[differences[charCode]];
        continue;
      }

      if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
        widths[charCode] = widthsByGlyphName[encoding[charCode]];
        continue;
      }
    }

    return widths;
  }

  preEvaluateFont(dict) {
    const baseDict = dict;
    let type = dict.get("Subtype");

    if (!(0, _primitives.isName)(type)) {
      throw new _util.FormatError("invalid font Subtype");
    }

    let composite = false;
    let hash, toUnicode;

    if (type.name === "Type0") {
      const df = dict.get("DescendantFonts");

      if (!df) {
        throw new _util.FormatError("Descendant fonts are not specified");
      }

      dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;

      if (!(dict instanceof _primitives.Dict)) {
        throw new _util.FormatError("Descendant font is not a dictionary.");
      }

      type = dict.get("Subtype");

      if (!(0, _primitives.isName)(type)) {
        throw new _util.FormatError("invalid font Subtype");
      }

      composite = true;
    }

    const firstChar = dict.get("FirstChar") || 0,
          lastChar = dict.get("LastChar") || (composite ? 0xffff : 0xff);
    const descriptor = dict.get("FontDescriptor");

    if (descriptor) {
      hash = new _murmurhash.MurmurHash3_64();
      const encoding = baseDict.getRaw("Encoding");

      if ((0, _primitives.isName)(encoding)) {
        hash.update(encoding.name);
      } else if ((0, _primitives.isRef)(encoding)) {
        hash.update(encoding.toString());
      } else if ((0, _primitives.isDict)(encoding)) {
        for (const entry of encoding.getRawValues()) {
          if ((0, _primitives.isName)(entry)) {
            hash.update(entry.name);
          } else if ((0, _primitives.isRef)(entry)) {
            hash.update(entry.toString());
          } else if (Array.isArray(entry)) {
            const diffLength = entry.length,
                  diffBuf = new Array(diffLength);

            for (let j = 0; j < diffLength; j++) {
              const diffEntry = entry[j];

              if ((0, _primitives.isName)(diffEntry)) {
                diffBuf[j] = diffEntry.name;
              } else if ((0, _util.isNum)(diffEntry) || (0, _primitives.isRef)(diffEntry)) {
                diffBuf[j] = diffEntry.toString();
              }
            }

            hash.update(diffBuf.join());
          }
        }
      }

      hash.update(`${firstChar}-${lastChar}`);
      toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");

      if ((0, _primitives.isStream)(toUnicode)) {
        const stream = toUnicode.str || toUnicode;
        const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
        hash.update(uint8array);
      } else if ((0, _primitives.isName)(toUnicode)) {
        hash.update(toUnicode.name);
      }

      const widths = dict.get("Widths") || baseDict.get("Widths");

      if (Array.isArray(widths)) {
        const widthsBuf = [];

        for (const entry of widths) {
          if ((0, _util.isNum)(entry) || (0, _primitives.isRef)(entry)) {
            widthsBuf.push(entry.toString());
          }
        }

        hash.update(widthsBuf.join());
      }

      if (composite) {
        hash.update("compositeFont");
        const compositeWidths = dict.get("W") || baseDict.get("W");

        if (Array.isArray(compositeWidths)) {
          const widthsBuf = [];

          for (const entry of compositeWidths) {
            if ((0, _util.isNum)(entry) || (0, _primitives.isRef)(entry)) {
              widthsBuf.push(entry.toString());
            } else if (Array.isArray(entry)) {
              const subWidthsBuf = [];

              for (const element of entry) {
                if ((0, _util.isNum)(element) || (0, _primitives.isRef)(element)) {
                  subWidthsBuf.push(element.toString());
                }
              }

              widthsBuf.push(`[${subWidthsBuf.join()}]`);
            }
          }

          hash.update(widthsBuf.join());
        }
      }
    }

    return {
      descriptor,
      dict,
      baseDict,
      composite,
      type: type.name,
      firstChar,
      lastChar,
      toUnicode,
      hash: hash ? hash.hexdigest() : ""
    };
  }

  async translateFont({
    descriptor,
    dict,
    baseDict,
    composite,
    type,
    firstChar,
    lastChar,
    toUnicode,
    cssFontInfo
  }) {
    const isType3Font = type === "Type3";
    let properties;

    if (!descriptor) {
      if (isType3Font) {
        descriptor = new _primitives.Dict(null);
        descriptor.set("FontName", _primitives.Name.get(type));
        descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
      } else {
        let baseFontName = dict.get("BaseFont");

        if (!(0, _primitives.isName)(baseFontName)) {
          throw new _util.FormatError("Base font is not specified");
        }

        baseFontName = baseFontName.name.replace(/[,_]/g, "-");
        const metrics = this.getBaseFontMetrics(baseFontName);
        const fontNameWoStyle = baseFontName.split("-")[0];
        const flags = (this.isSerifFont(fontNameWoStyle) ? _fonts_utils.FontFlags.Serif : 0) | (metrics.monospace ? _fonts_utils.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts_utils.FontFlags.Symbolic : _fonts_utils.FontFlags.Nonsymbolic);
        properties = {
          type,
          name: baseFontName,
          widths: metrics.widths,
          defaultWidth: metrics.defaultWidth,
          flags,
          firstChar,
          lastChar,
          toUnicode,
          isType3Font
        };
        const widths = dict.get("Widths");
        return this.extractDataStructures(dict, dict, properties).then(newProperties => {
          if (widths) {
            const glyphWidths = [];
            let j = firstChar;

            for (let i = 0, ii = widths.length; i < ii; i++) {
              glyphWidths[j++] = this.xref.fetchIfRef(widths[i]);
            }

            newProperties.widths = glyphWidths;
          } else {
            newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
          }

          return new _fonts.Font(baseFontName, null, newProperties);
        });
      }
    }

    let fontName = descriptor.get("FontName");
    let baseFont = dict.get("BaseFont");

    if ((0, _util.isString)(fontName)) {
      fontName = _primitives.Name.get(fontName);
    }

    if ((0, _util.isString)(baseFont)) {
      baseFont = _primitives.Name.get(baseFont);
    }

    if (!isType3Font) {
      const fontNameStr = fontName && fontName.name;
      const baseFontStr = baseFont && baseFont.name;

      if (fontNameStr !== baseFontStr) {
        (0, _util.info)(`The FontDescriptor's FontName is "${fontNameStr}" but ` + `should be the same as the Font's BaseFont "${baseFontStr}".`);

        if (fontNameStr && baseFontStr && baseFontStr.startsWith(fontNameStr)) {
          fontName = baseFont;
        }
      }
    }

    fontName = fontName || baseFont;

    if (!(0, _primitives.isName)(fontName)) {
      throw new _util.FormatError("invalid font name");
    }

    let fontFile, subtype, length1, length2, length3;

    try {
      fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
    } catch (ex) {
      if (!this.options.ignoreErrors) {
        throw ex;
      }

      (0, _util.warn)(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
      fontFile = new _stream.NullStream();
    }

    if (fontFile) {
      if (fontFile.dict) {
        const subtypeEntry = fontFile.dict.get("Subtype");

        if (subtypeEntry instanceof _primitives.Name) {
          subtype = subtypeEntry.name;
        }

        length1 = fontFile.dict.get("Length1");
        length2 = fontFile.dict.get("Length2");
        length3 = fontFile.dict.get("Length3");
      }
    }

    properties = {
      type,
      name: fontName.name,
      subtype,
      file: fontFile,
      length1,
      length2,
      length3,
      loadedName: baseDict.loadedName,
      composite,
      fixedPitch: false,
      fontMatrix: dict.getArray("FontMatrix") || _util.FONT_IDENTITY_MATRIX,
      firstChar,
      lastChar,
      toUnicode,
      bbox: descriptor.getArray("FontBBox"),
      ascent: descriptor.get("Ascent"),
      descent: descriptor.get("Descent"),
      xHeight: descriptor.get("XHeight"),
      capHeight: descriptor.get("CapHeight"),
      flags: descriptor.get("Flags"),
      italicAngle: descriptor.get("ItalicAngle"),
      isType3Font,
      cssFontInfo
    };

    if (composite) {
      const cidEncoding = baseDict.get("Encoding");

      if ((0, _primitives.isName)(cidEncoding)) {
        properties.cidEncoding = cidEncoding.name;
      }

      const cMap = await _cmap.CMapFactory.create({
        encoding: cidEncoding,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      properties.cMap = cMap;
      properties.vertical = properties.cMap.vertical;
    }

    return this.extractDataStructures(dict, baseDict, properties).then(newProperties => {
      this.extractWidths(dict, descriptor, newProperties);
      return new _fonts.Font(fontName.name, fontFile, newProperties);
    });
  }

  static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
    function buildPath(fontChar) {
      const glyphName = `${font.loadedName}_path_${fontChar}`;

      try {
        if (font.renderer.hasBuiltPath(fontChar)) {
          return;
        }

        handler.send("commonobj", [glyphName, "FontPath", font.renderer.getPathJs(fontChar)]);
      } catch (reason) {
        if (evaluatorOptions.ignoreErrors) {
          handler.send("UnsupportedFeature", {
            featureId: _util.UNSUPPORTED_FEATURES.errorFontBuildPath
          });
          (0, _util.warn)(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
          return;
        }

        throw reason;
      }
    }

    for (const glyph of glyphs) {
      buildPath(glyph.fontChar);
      const accent = glyph.accent;

      if (accent && accent.fontChar) {
        buildPath(accent.fontChar);
      }
    }
  }

  static get fallbackFontDict() {
    const dict = new _primitives.Dict();
    dict.set("BaseFont", _primitives.Name.get("PDFJS-FallbackFont"));
    dict.set("Type", _primitives.Name.get("FallbackType"));
    dict.set("Subtype", _primitives.Name.get("FallbackType"));
    dict.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
    return (0, _util.shadow)(this, "fallbackFontDict", dict);
  }

}

exports.PartialEvaluator = PartialEvaluator;

class TranslatedFont {
  constructor({
    loadedName,
    font,
    dict,
    evaluatorOptions
  }) {
    this.loadedName = loadedName;
    this.font = font;
    this.dict = dict;
    this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
    this.type3Loaded = null;
    this.type3Dependencies = font.isType3Font ? new Set() : null;
    this.sent = false;
  }

  send(handler) {
    if (this.sent) {
      return;
    }

    this.sent = true;
    handler.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
  }

  fallback(handler) {
    if (!this.font.data) {
      return;
    }

    this.font.disableFontFace = true;
    PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, handler, this._evaluatorOptions);
  }

  loadType3Data(evaluator, resources, task) {
    if (this.type3Loaded) {
      return this.type3Loaded;
    }

    if (!this.font.isType3Font) {
      throw new Error("Must be a Type3 font.");
    }

    const type3Options = Object.create(evaluator.options);
    type3Options.ignoreErrors = false;
    const type3Evaluator = evaluator.clone(type3Options);
    type3Evaluator.parsingType3Font = true;
    const translatedFont = this.font,
          type3Dependencies = this.type3Dependencies;
    let loadCharProcsPromise = Promise.resolve();
    const charProcs = this.dict.get("CharProcs");
    const fontResources = this.dict.get("Resources") || resources;
    const charProcOperatorList = Object.create(null);

    for (const key of charProcs.getKeys()) {
      loadCharProcsPromise = loadCharProcsPromise.then(() => {
        const glyphStream = charProcs.get(key);
        const operatorList = new _operator_list.OperatorList();
        return type3Evaluator.getOperatorList({
          stream: glyphStream,
          task,
          resources: fontResources,
          operatorList
        }).then(() => {
          if (operatorList.fnArray[0] === _util.OPS.setCharWidthAndBounds) {
            this._removeType3ColorOperators(operatorList);
          }

          charProcOperatorList[key] = operatorList.getIR();

          for (const dependency of operatorList.dependencies) {
            type3Dependencies.add(dependency);
          }
        }).catch(function (reason) {
          (0, _util.warn)(`Type3 font resource "${key}" is not available.`);
          const dummyOperatorList = new _operator_list.OperatorList();
          charProcOperatorList[key] = dummyOperatorList.getIR();
        });
      });
    }

    this.type3Loaded = loadCharProcsPromise.then(function () {
      translatedFont.charProcOperatorList = charProcOperatorList;
    });
    return this.type3Loaded;
  }

  _removeType3ColorOperators(operatorList) {
    let i = 1,
        ii = operatorList.length;

    while (i < ii) {
      switch (operatorList.fnArray[i]) {
        case _util.OPS.setStrokeColorSpace:
        case _util.OPS.setFillColorSpace:
        case _util.OPS.setStrokeColor:
        case _util.OPS.setStrokeColorN:
        case _util.OPS.setFillColor:
        case _util.OPS.setFillColorN:
        case _util.OPS.setStrokeGray:
        case _util.OPS.setFillGray:
        case _util.OPS.setStrokeRGBColor:
        case _util.OPS.setFillRGBColor:
        case _util.OPS.setStrokeCMYKColor:
        case _util.OPS.setFillCMYKColor:
        case _util.OPS.shadingFill:
        case _util.OPS.setRenderingIntent:
          operatorList.fnArray.splice(i, 1);
          operatorList.argsArray.splice(i, 1);
          ii--;
          continue;

        case _util.OPS.setGState:
          const [gStateObj] = operatorList.argsArray[i];
          let j = 0,
              jj = gStateObj.length;

          while (j < jj) {
            const [gStateKey] = gStateObj[j];

            switch (gStateKey) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                gStateObj.splice(j, 1);
                jj--;
                continue;
            }

            j++;
          }

          break;
      }

      i++;
    }
  }

}

class StateManager {
  constructor(initialState = new EvalState()) {
    this.state = initialState;
    this.stateStack = [];
  }

  save() {
    const old = this.state;
    this.stateStack.push(this.state);
    this.state = old.clone();
  }

  restore() {
    const prev = this.stateStack.pop();

    if (prev) {
      this.state = prev;
    }
  }

  transform(args) {
    this.state.ctm = _util.Util.transform(this.state.ctm, args);
  }

}

class TextState {
  constructor() {
    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    this.fontName = null;
    this.fontSize = 0;
    this.font = null;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.textMatrix = _util.IDENTITY_MATRIX.slice();
    this.textLineMatrix = _util.IDENTITY_MATRIX.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.leading = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }

  setTextMatrix(a, b, c, d, e, f) {
    const m = this.textMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }

  setTextLineMatrix(a, b, c, d, e, f) {
    const m = this.textLineMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }

  translateTextMatrix(x, y) {
    const m = this.textMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }

  translateTextLineMatrix(x, y) {
    const m = this.textLineMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }

  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading);
    this.textMatrix = this.textLineMatrix.slice();
  }

  clone() {
    const clone = Object.create(this);
    clone.textMatrix = this.textMatrix.slice();
    clone.textLineMatrix = this.textLineMatrix.slice();
    clone.fontMatrix = this.fontMatrix.slice();
    return clone;
  }

}

class EvalState {
  constructor() {
    this.ctm = new Float32Array(_util.IDENTITY_MATRIX);
    this.font = null;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
    this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
  }

  clone() {
    return Object.create(this);
  }

}

class EvaluatorPreprocessor {
  static get opMap() {
    const getOPMap = (0, _core_utils.getLookupTableFactory)(function (t) {
      t.w = {
        id: _util.OPS.setLineWidth,
        numArgs: 1,
        variableArgs: false
      };
      t.J = {
        id: _util.OPS.setLineCap,
        numArgs: 1,
        variableArgs: false
      };
      t.j = {
        id: _util.OPS.setLineJoin,
        numArgs: 1,
        variableArgs: false
      };
      t.M = {
        id: _util.OPS.setMiterLimit,
        numArgs: 1,
        variableArgs: false
      };
      t.d = {
        id: _util.OPS.setDash,
        numArgs: 2,
        variableArgs: false
      };
      t.ri = {
        id: _util.OPS.setRenderingIntent,
        numArgs: 1,
        variableArgs: false
      };
      t.i = {
        id: _util.OPS.setFlatness,
        numArgs: 1,
        variableArgs: false
      };
      t.gs = {
        id: _util.OPS.setGState,
        numArgs: 1,
        variableArgs: false
      };
      t.q = {
        id: _util.OPS.save,
        numArgs: 0,
        variableArgs: false
      };
      t.Q = {
        id: _util.OPS.restore,
        numArgs: 0,
        variableArgs: false
      };
      t.cm = {
        id: _util.OPS.transform,
        numArgs: 6,
        variableArgs: false
      };
      t.m = {
        id: _util.OPS.moveTo,
        numArgs: 2,
        variableArgs: false
      };
      t.l = {
        id: _util.OPS.lineTo,
        numArgs: 2,
        variableArgs: false
      };
      t.c = {
        id: _util.OPS.curveTo,
        numArgs: 6,
        variableArgs: false
      };
      t.v = {
        id: _util.OPS.curveTo2,
        numArgs: 4,
        variableArgs: false
      };
      t.y = {
        id: _util.OPS.curveTo3,
        numArgs: 4,
        variableArgs: false
      };
      t.h = {
        id: _util.OPS.closePath,
        numArgs: 0,
        variableArgs: false
      };
      t.re = {
        id: _util.OPS.rectangle,
        numArgs: 4,
        variableArgs: false
      };
      t.S = {
        id: _util.OPS.stroke,
        numArgs: 0,
        variableArgs: false
      };
      t.s = {
        id: _util.OPS.closeStroke,
        numArgs: 0,
        variableArgs: false
      };
      t.f = {
        id: _util.OPS.fill,
        numArgs: 0,
        variableArgs: false
      };
      t.F = {
        id: _util.OPS.fill,
        numArgs: 0,
        variableArgs: false
      };
      t["f*"] = {
        id: _util.OPS.eoFill,
        numArgs: 0,
        variableArgs: false
      };
      t.B = {
        id: _util.OPS.fillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t["B*"] = {
        id: _util.OPS.eoFillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t.b = {
        id: _util.OPS.closeFillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t["b*"] = {
        id: _util.OPS.closeEOFillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t.n = {
        id: _util.OPS.endPath,
        numArgs: 0,
        variableArgs: false
      };
      t.W = {
        id: _util.OPS.clip,
        numArgs: 0,
        variableArgs: false
      };
      t["W*"] = {
        id: _util.OPS.eoClip,
        numArgs: 0,
        variableArgs: false
      };
      t.BT = {
        id: _util.OPS.beginText,
        numArgs: 0,
        variableArgs: false
      };
      t.ET = {
        id: _util.OPS.endText,
        numArgs: 0,
        variableArgs: false
      };
      t.Tc = {
        id: _util.OPS.setCharSpacing,
        numArgs: 1,
        variableArgs: false
      };
      t.Tw = {
        id: _util.OPS.setWordSpacing,
        numArgs: 1,
        variableArgs: false
      };
      t.Tz = {
        id: _util.OPS.setHScale,
        numArgs: 1,
        variableArgs: false
      };
      t.TL = {
        id: _util.OPS.setLeading,
        numArgs: 1,
        variableArgs: false
      };
      t.Tf = {
        id: _util.OPS.setFont,
        numArgs: 2,
        variableArgs: false
      };
      t.Tr = {
        id: _util.OPS.setTextRenderingMode,
        numArgs: 1,
        variableArgs: false
      };
      t.Ts = {
        id: _util.OPS.setTextRise,
        numArgs: 1,
        variableArgs: false
      };
      t.Td = {
        id: _util.OPS.moveText,
        numArgs: 2,
        variableArgs: false
      };
      t.TD = {
        id: _util.OPS.setLeadingMoveText,
        numArgs: 2,
        variableArgs: false
      };
      t.Tm = {
        id: _util.OPS.setTextMatrix,
        numArgs: 6,
        variableArgs: false
      };
      t["T*"] = {
        id: _util.OPS.nextLine,
        numArgs: 0,
        variableArgs: false
      };
      t.Tj = {
        id: _util.OPS.showText,
        numArgs: 1,
        variableArgs: false
      };
      t.TJ = {
        id: _util.OPS.showSpacedText,
        numArgs: 1,
        variableArgs: false
      };
      t["'"] = {
        id: _util.OPS.nextLineShowText,
        numArgs: 1,
        variableArgs: false
      };
      t['"'] = {
        id: _util.OPS.nextLineSetSpacingShowText,
        numArgs: 3,
        variableArgs: false
      };
      t.d0 = {
        id: _util.OPS.setCharWidth,
        numArgs: 2,
        variableArgs: false
      };
      t.d1 = {
        id: _util.OPS.setCharWidthAndBounds,
        numArgs: 6,
        variableArgs: false
      };
      t.CS = {
        id: _util.OPS.setStrokeColorSpace,
        numArgs: 1,
        variableArgs: false
      };
      t.cs = {
        id: _util.OPS.setFillColorSpace,
        numArgs: 1,
        variableArgs: false
      };
      t.SC = {
        id: _util.OPS.setStrokeColor,
        numArgs: 4,
        variableArgs: true
      };
      t.SCN = {
        id: _util.OPS.setStrokeColorN,
        numArgs: 33,
        variableArgs: true
      };
      t.sc = {
        id: _util.OPS.setFillColor,
        numArgs: 4,
        variableArgs: true
      };
      t.scn = {
        id: _util.OPS.setFillColorN,
        numArgs: 33,
        variableArgs: true
      };
      t.G = {
        id: _util.OPS.setStrokeGray,
        numArgs: 1,
        variableArgs: false
      };
      t.g = {
        id: _util.OPS.setFillGray,
        numArgs: 1,
        variableArgs: false
      };
      t.RG = {
        id: _util.OPS.setStrokeRGBColor,
        numArgs: 3,
        variableArgs: false
      };
      t.rg = {
        id: _util.OPS.setFillRGBColor,
        numArgs: 3,
        variableArgs: false
      };
      t.K = {
        id: _util.OPS.setStrokeCMYKColor,
        numArgs: 4,
        variableArgs: false
      };
      t.k = {
        id: _util.OPS.setFillCMYKColor,
        numArgs: 4,
        variableArgs: false
      };
      t.sh = {
        id: _util.OPS.shadingFill,
        numArgs: 1,
        variableArgs: false
      };
      t.BI = {
        id: _util.OPS.beginInlineImage,
        numArgs: 0,
        variableArgs: false
      };
      t.ID = {
        id: _util.OPS.beginImageData,
        numArgs: 0,
        variableArgs: false
      };
      t.EI = {
        id: _util.OPS.endInlineImage,
        numArgs: 1,
        variableArgs: false
      };
      t.Do = {
        id: _util.OPS.paintXObject,
        numArgs: 1,
        variableArgs: false
      };
      t.MP = {
        id: _util.OPS.markPoint,
        numArgs: 1,
        variableArgs: false
      };
      t.DP = {
        id: _util.OPS.markPointProps,
        numArgs: 2,
        variableArgs: false
      };
      t.BMC = {
        id: _util.OPS.beginMarkedContent,
        numArgs: 1,
        variableArgs: false
      };
      t.BDC = {
        id: _util.OPS.beginMarkedContentProps,
        numArgs: 2,
        variableArgs: false
      };
      t.EMC = {
        id: _util.OPS.endMarkedContent,
        numArgs: 0,
        variableArgs: false
      };
      t.BX = {
        id: _util.OPS.beginCompat,
        numArgs: 0,
        variableArgs: false
      };
      t.EX = {
        id: _util.OPS.endCompat,
        numArgs: 0,
        variableArgs: false
      };
      t.BM = null;
      t.BD = null;
      t.true = null;
      t.fa = null;
      t.fal = null;
      t.fals = null;
      t.false = null;
      t.nu = null;
      t.nul = null;
      t.null = null;
    });
    return (0, _util.shadow)(this, "opMap", getOPMap());
  }

  static get MAX_INVALID_PATH_OPS() {
    return (0, _util.shadow)(this, "MAX_INVALID_PATH_OPS", 20);
  }

  constructor(stream, xref, stateManager = new StateManager()) {
    this.parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream, EvaluatorPreprocessor.opMap),
      xref
    });
    this.stateManager = stateManager;
    this.nonProcessedArgs = [];
    this._numInvalidPathOPS = 0;
  }

  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }

  read(operation) {
    let args = operation.args;

    while (true) {
      const obj = this.parser.getObj();

      if (obj instanceof _primitives.Cmd) {
        const cmd = obj.cmd;
        const opSpec = EvaluatorPreprocessor.opMap[cmd];

        if (!opSpec) {
          (0, _util.warn)(`Unknown command "${cmd}".`);
          continue;
        }

        const fn = opSpec.id;
        const numArgs = opSpec.numArgs;
        let argsLength = args !== null ? args.length : 0;

        if (!opSpec.variableArgs) {
          if (argsLength !== numArgs) {
            const nonProcessedArgs = this.nonProcessedArgs;

            while (argsLength > numArgs) {
              nonProcessedArgs.push(args.shift());
              argsLength--;
            }

            while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
              if (args === null) {
                args = [];
              }

              args.unshift(nonProcessedArgs.pop());
              argsLength++;
            }
          }

          if (argsLength < numArgs) {
            const partialMsg = `command ${cmd}: expected ${numArgs} args, ` + `but received ${argsLength} args.`;

            if (fn >= _util.OPS.moveTo && fn <= _util.OPS.endPath && ++this._numInvalidPathOPS > EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {
              throw new _util.FormatError(`Invalid ${partialMsg}`);
            }

            (0, _util.warn)(`Skipping ${partialMsg}`);

            if (args !== null) {
              args.length = 0;
            }

            continue;
          }
        } else if (argsLength > numArgs) {
          (0, _util.info)(`Command ${cmd}: expected [0, ${numArgs}] args, ` + `but received ${argsLength} args.`);
        }

        this.preprocessCommand(fn, args);
        operation.fn = fn;
        operation.args = args;
        return true;
      }

      if (obj === _primitives.EOF) {
        return false;
      }

      if (obj !== null) {
        if (args === null) {
          args = [];
        }

        args.push(obj);

        if (args.length > 33) {
          throw new _util.FormatError("Too many arguments");
        }
      }
    }
  }

  preprocessCommand(fn, args) {
    switch (fn | 0) {
      case _util.OPS.save:
        this.stateManager.save();
        break;

      case _util.OPS.restore:
        this.stateManager.restore();
        break;

      case _util.OPS.transform:
        this.stateManager.transform(args);
        break;
    }
  }

}

exports.EvaluatorPreprocessor = EvaluatorPreprocessor;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IdentityCMap = exports.CMapFactory = exports.CMap = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _parser = __w_pdfjs_require__(17);

var _core_utils = __w_pdfjs_require__(9);

var _stream = __w_pdfjs_require__(10);

const BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
const MAX_MAP_RANGE = 2 ** 24 - 1;

class CMap {
  constructor(builtInCMap = false) {
    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    this._map = [];
    this.name = "";
    this.vertical = false;
    this.useCMap = null;
    this.builtInCMap = builtInCMap;
  }

  addCodespaceRange(n, low, high) {
    this.codespaceRanges[n - 1].push(low, high);
    this.numCodespaceRanges++;
  }

  mapCidRange(low, high, dstLow) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    }

    while (low <= high) {
      this._map[low++] = dstLow++;
    }
  }

  mapBfRange(low, high, dstLow) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    }

    const lastByte = dstLow.length - 1;

    while (low <= high) {
      this._map[low++] = dstLow;
      dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
    }
  }

  mapBfRangeToArray(low, high, array) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    }

    const ii = array.length;
    let i = 0;

    while (low <= high && i < ii) {
      this._map[low] = array[i++];
      ++low;
    }
  }

  mapOne(src, dst) {
    this._map[src] = dst;
  }

  lookup(code) {
    return this._map[code];
  }

  contains(code) {
    return this._map[code] !== undefined;
  }

  forEach(callback) {
    const map = this._map;
    const length = map.length;

    if (length <= 0x10000) {
      for (let i = 0; i < length; i++) {
        if (map[i] !== undefined) {
          callback(i, map[i]);
        }
      }
    } else {
      for (const i in map) {
        callback(i, map[i]);
      }
    }
  }

  charCodeOf(value) {
    const map = this._map;

    if (map.length <= 0x10000) {
      return map.indexOf(value);
    }

    for (const charCode in map) {
      if (map[charCode] === value) {
        return charCode | 0;
      }
    }

    return -1;
  }

  getMap() {
    return this._map;
  }

  readCharCode(str, offset, out) {
    let c = 0;
    const codespaceRanges = this.codespaceRanges;

    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
      c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
      const codespaceRange = codespaceRanges[n];

      for (let k = 0, kk = codespaceRange.length; k < kk;) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];

        if (c >= low && c <= high) {
          out.charcode = c;
          out.length = n + 1;
          return;
        }
      }
    }

    out.charcode = 0;
    out.length = 1;
  }

  getCharCodeLength(charCode) {
    const codespaceRanges = this.codespaceRanges;

    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
      const codespaceRange = codespaceRanges[n];

      for (let k = 0, kk = codespaceRange.length; k < kk;) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];

        if (charCode >= low && charCode <= high) {
          return n + 1;
        }
      }
    }

    return 1;
  }

  get length() {
    return this._map.length;
  }

  get isIdentityCMap() {
    if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
      return false;
    }

    if (this._map.length !== 0x10000) {
      return false;
    }

    for (let i = 0; i < 0x10000; i++) {
      if (this._map[i] !== i) {
        return false;
      }
    }

    return true;
  }

}

exports.CMap = CMap;

class IdentityCMap extends CMap {
  constructor(vertical, n) {
    super();
    this.vertical = vertical;
    this.addCodespaceRange(n, 0, 0xffff);
  }

  mapCidRange(low, high, dstLow) {
    (0, _util.unreachable)("should not call mapCidRange");
  }

  mapBfRange(low, high, dstLow) {
    (0, _util.unreachable)("should not call mapBfRange");
  }

  mapBfRangeToArray(low, high, array) {
    (0, _util.unreachable)("should not call mapBfRangeToArray");
  }

  mapOne(src, dst) {
    (0, _util.unreachable)("should not call mapCidOne");
  }

  lookup(code) {
    return Number.isInteger(code) && code <= 0xffff ? code : undefined;
  }

  contains(code) {
    return Number.isInteger(code) && code <= 0xffff;
  }

  forEach(callback) {
    for (let i = 0; i <= 0xffff; i++) {
      callback(i, i);
    }
  }

  charCodeOf(value) {
    return Number.isInteger(value) && value <= 0xffff ? value : -1;
  }

  getMap() {
    const map = new Array(0x10000);

    for (let i = 0; i <= 0xffff; i++) {
      map[i] = i;
    }

    return map;
  }

  get length() {
    return 0x10000;
  }

  get isIdentityCMap() {
    (0, _util.unreachable)("should not access .isIdentityCMap");
  }

}

exports.IdentityCMap = IdentityCMap;

const BinaryCMapReader = function BinaryCMapReaderClosure() {
  function hexToInt(a, size) {
    let n = 0;

    for (let i = 0; i <= size; i++) {
      n = n << 8 | a[i];
    }

    return n >>> 0;
  }

  function hexToStr(a, size) {
    if (size === 1) {
      return String.fromCharCode(a[0], a[1]);
    }

    if (size === 3) {
      return String.fromCharCode(a[0], a[1], a[2], a[3]);
    }

    return String.fromCharCode.apply(null, a.subarray(0, size + 1));
  }

  function addHex(a, b, size) {
    let c = 0;

    for (let i = size; i >= 0; i--) {
      c += a[i] + b[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }

  function incHex(a, size) {
    let c = 1;

    for (let i = size; i >= 0 && c > 0; i--) {
      c += a[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }

  const MAX_NUM_SIZE = 16;
  const MAX_ENCODED_NUM_SIZE = 19;

  class BinaryCMapStream {
    constructor(data) {
      this.buffer = data;
      this.pos = 0;
      this.end = data.length;
      this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
    }

    readByte() {
      if (this.pos >= this.end) {
        return -1;
      }

      return this.buffer[this.pos++];
    }

    readNumber() {
      let n = 0;
      let last;

      do {
        const b = this.readByte();

        if (b < 0) {
          throw new _util.FormatError("unexpected EOF in bcmap");
        }

        last = !(b & 0x80);
        n = n << 7 | b & 0x7f;
      } while (!last);

      return n;
    }

    readSigned() {
      const n = this.readNumber();
      return n & 1 ? ~(n >>> 1) : n >>> 1;
    }

    readHex(num, size) {
      num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
      this.pos += size + 1;
    }

    readHexNumber(num, size) {
      let last;
      const stack = this.tmpBuf;
      let sp = 0;

      do {
        const b = this.readByte();

        if (b < 0) {
          throw new _util.FormatError("unexpected EOF in bcmap");
        }

        last = !(b & 0x80);
        stack[sp++] = b & 0x7f;
      } while (!last);

      let i = size,
          buffer = 0,
          bufferSize = 0;

      while (i >= 0) {
        while (bufferSize < 8 && stack.length > 0) {
          buffer = stack[--sp] << bufferSize | buffer;
          bufferSize += 7;
        }

        num[i] = buffer & 255;
        i--;
        buffer >>= 8;
        bufferSize -= 8;
      }
    }

    readHexSigned(num, size) {
      this.readHexNumber(num, size);
      const sign = num[size] & 1 ? 255 : 0;
      let c = 0;

      for (let i = 0; i <= size; i++) {
        c = (c & 1) << 8 | num[i];
        num[i] = c >> 1 ^ sign;
      }
    }

    readString() {
      const len = this.readNumber();
      let s = "";

      for (let i = 0; i < len; i++) {
        s += String.fromCharCode(this.readNumber());
      }

      return s;
    }

  }

  class BinaryCMapReader {
    async process(data, cMap, extend) {
      const stream = new BinaryCMapStream(data);
      const header = stream.readByte();
      cMap.vertical = !!(header & 1);
      let useCMap = null;
      const start = new Uint8Array(MAX_NUM_SIZE);
      const end = new Uint8Array(MAX_NUM_SIZE);
      const char = new Uint8Array(MAX_NUM_SIZE);
      const charCode = new Uint8Array(MAX_NUM_SIZE);
      const tmp = new Uint8Array(MAX_NUM_SIZE);
      let code;
      let b;

      while ((b = stream.readByte()) >= 0) {
        const type = b >> 5;

        if (type === 7) {
          switch (b & 0x1f) {
            case 0:
              stream.readString();
              break;

            case 1:
              useCMap = stream.readString();
              break;
          }

          continue;
        }

        const sequence = !!(b & 0x10);
        const dataSize = b & 15;

        if (dataSize + 1 > MAX_NUM_SIZE) {
          throw new Error("BinaryCMapReader.process: Invalid dataSize.");
        }

        const ucs2DataSize = 1;
        const subitemsCount = stream.readNumber();

        switch (type) {
          case 0:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));

            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
            }

            break;

          case 1:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            stream.readNumber();

            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              stream.readNumber();
            }

            break;

          case 2:
            stream.readHex(char, dataSize);
            code = stream.readNumber();
            cMap.mapOne(hexToInt(char, dataSize), code);

            for (let i = 1; i < subitemsCount; i++) {
              incHex(char, dataSize);

              if (!sequence) {
                stream.readHexNumber(tmp, dataSize);
                addHex(char, tmp, dataSize);
              }

              code = stream.readSigned() + (code + 1);
              cMap.mapOne(hexToInt(char, dataSize), code);
            }

            break;

          case 3:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            code = stream.readNumber();
            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);

            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);

              if (!sequence) {
                stream.readHexNumber(start, dataSize);
                addHex(start, end, dataSize);
              } else {
                start.set(end);
              }

              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              code = stream.readNumber();
              cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
            }

            break;

          case 4:
            stream.readHex(char, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));

            for (let i = 1; i < subitemsCount; i++) {
              incHex(char, ucs2DataSize);

              if (!sequence) {
                stream.readHexNumber(tmp, ucs2DataSize);
                addHex(char, tmp, ucs2DataSize);
              }

              incHex(charCode, dataSize);
              stream.readHexSigned(tmp, dataSize);
              addHex(charCode, tmp, dataSize);
              cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
            }

            break;

          case 5:
            stream.readHex(start, ucs2DataSize);
            stream.readHexNumber(end, ucs2DataSize);
            addHex(end, start, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));

            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, ucs2DataSize);

              if (!sequence) {
                stream.readHexNumber(start, ucs2DataSize);
                addHex(start, end, ucs2DataSize);
              } else {
                start.set(end);
              }

              stream.readHexNumber(end, ucs2DataSize);
              addHex(end, start, ucs2DataSize);
              stream.readHex(charCode, dataSize);
              cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
            }

            break;

          default:
            throw new Error(`BinaryCMapReader.process - unknown type: ${type}`);
        }
      }

      if (useCMap) {
        return extend(useCMap);
      }

      return cMap;
    }

  }

  return BinaryCMapReader;
}();

const CMapFactory = function CMapFactoryClosure() {
  function strToInt(str) {
    let a = 0;

    for (let i = 0; i < str.length; i++) {
      a = a << 8 | str.charCodeAt(i);
    }

    return a >>> 0;
  }

  function expectString(obj) {
    if (!(0, _util.isString)(obj)) {
      throw new _util.FormatError("Malformed CMap: expected string.");
    }
  }

  function expectInt(obj) {
    if (!Number.isInteger(obj)) {
      throw new _util.FormatError("Malformed CMap: expected int.");
    }
  }

  function parseBfChar(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endbfchar")) {
        return;
      }

      expectString(obj);
      const src = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      const dst = obj;
      cMap.mapOne(src, dst);
    }
  }

  function parseBfRange(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endbfrange")) {
        return;
      }

      expectString(obj);
      const low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      const high = strToInt(obj);
      obj = lexer.getObj();

      if (Number.isInteger(obj) || (0, _util.isString)(obj)) {
        const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
        cMap.mapBfRange(low, high, dstLow);
      } else if ((0, _primitives.isCmd)(obj, "[")) {
        obj = lexer.getObj();
        const array = [];

        while (!(0, _primitives.isCmd)(obj, "]") && !(0, _primitives.isEOF)(obj)) {
          array.push(obj);
          obj = lexer.getObj();
        }

        cMap.mapBfRangeToArray(low, high, array);
      } else {
        break;
      }
    }

    throw new _util.FormatError("Invalid bf range.");
  }

  function parseCidChar(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endcidchar")) {
        return;
      }

      expectString(obj);
      const src = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      const dst = obj;
      cMap.mapOne(src, dst);
    }
  }

  function parseCidRange(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endcidrange")) {
        return;
      }

      expectString(obj);
      const low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      const high = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      const dstLow = obj;
      cMap.mapCidRange(low, high, dstLow);
    }
  }

  function parseCodespaceRange(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();

      if ((0, _primitives.isEOF)(obj)) {
        break;
      }

      if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
        return;
      }

      if (!(0, _util.isString)(obj)) {
        break;
      }

      const low = strToInt(obj);
      obj = lexer.getObj();

      if (!(0, _util.isString)(obj)) {
        break;
      }

      const high = strToInt(obj);
      cMap.addCodespaceRange(obj.length, low, high);
    }

    throw new _util.FormatError("Invalid codespace range.");
  }

  function parseWMode(cMap, lexer) {
    const obj = lexer.getObj();

    if (Number.isInteger(obj)) {
      cMap.vertical = !!obj;
    }
  }

  function parseCMapName(cMap, lexer) {
    const obj = lexer.getObj();

    if ((0, _primitives.isName)(obj) && (0, _util.isString)(obj.name)) {
      cMap.name = obj.name;
    }
  }

  async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
    let previous, embeddedUseCMap;

    objLoop: while (true) {
      try {
        const obj = lexer.getObj();

        if ((0, _primitives.isEOF)(obj)) {
          break;
        } else if ((0, _primitives.isName)(obj)) {
          if (obj.name === "WMode") {
            parseWMode(cMap, lexer);
          } else if (obj.name === "CMapName") {
            parseCMapName(cMap, lexer);
          }

          previous = obj;
        } else if ((0, _primitives.isCmd)(obj)) {
          switch (obj.cmd) {
            case "endcmap":
              break objLoop;

            case "usecmap":
              if ((0, _primitives.isName)(previous)) {
                embeddedUseCMap = previous.name;
              }

              break;

            case "begincodespacerange":
              parseCodespaceRange(cMap, lexer);
              break;

            case "beginbfchar":
              parseBfChar(cMap, lexer);
              break;

            case "begincidchar":
              parseCidChar(cMap, lexer);
              break;

            case "beginbfrange":
              parseBfRange(cMap, lexer);
              break;

            case "begincidrange":
              parseCidRange(cMap, lexer);
              break;
          }
        }
      } catch (ex) {
        if (ex instanceof _core_utils.MissingDataException) {
          throw ex;
        }

        (0, _util.warn)("Invalid cMap data: " + ex);
        continue;
      }
    }

    if (!useCMap && embeddedUseCMap) {
      useCMap = embeddedUseCMap;
    }

    if (useCMap) {
      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
    }

    return cMap;
  }

  async function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
    cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);

    if (cMap.numCodespaceRanges === 0) {
      const useCodespaceRanges = cMap.useCMap.codespaceRanges;

      for (let i = 0; i < useCodespaceRanges.length; i++) {
        cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
      }

      cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
    }

    cMap.useCMap.forEach(function (key, value) {
      if (!cMap.contains(key)) {
        cMap.mapOne(key, cMap.useCMap.lookup(key));
      }
    });
    return cMap;
  }

  async function createBuiltInCMap(name, fetchBuiltInCMap) {
    if (name === "Identity-H") {
      return new IdentityCMap(false, 2);
    } else if (name === "Identity-V") {
      return new IdentityCMap(true, 2);
    }

    if (!BUILT_IN_CMAPS.includes(name)) {
      throw new Error("Unknown CMap name: " + name);
    }

    if (!fetchBuiltInCMap) {
      throw new Error("Built-in CMap parameters are not provided.");
    }

    const {
      cMapData,
      compressionType
    } = await fetchBuiltInCMap(name);
    const cMap = new CMap(true);

    if (compressionType === _util.CMapCompressionType.BINARY) {
      return new BinaryCMapReader().process(cMapData, cMap, useCMap => {
        return extendCMap(cMap, fetchBuiltInCMap, useCMap);
      });
    }

    if (compressionType === _util.CMapCompressionType.NONE) {
      const lexer = new _parser.Lexer(new _stream.Stream(cMapData));
      return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
    }

    throw new Error("TODO: Only BINARY/NONE CMap compression is currently supported.");
  }

  return {
    async create(params) {
      const encoding = params.encoding;
      const fetchBuiltInCMap = params.fetchBuiltInCMap;
      const useCMap = params.useCMap;

      if ((0, _primitives.isName)(encoding)) {
        return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
      } else if ((0, _primitives.isStream)(encoding)) {
        const parsedCMap = await parseCMap(new CMap(), new _parser.Lexer(encoding), fetchBuiltInCMap, useCMap);

        if (parsedCMap.isIdentityCMap) {
          return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
        }

        return parsedCMap;
      }

      throw new Error("Encoding required.");
    }

  };
}();

exports.CMapFactory = CMapFactory;

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Parser = exports.Linearization = exports.Lexer = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

var _ascii_85_stream = __w_pdfjs_require__(18);

var _ascii_hex_stream = __w_pdfjs_require__(20);

var _ccitt_stream = __w_pdfjs_require__(21);

var _flate_stream = __w_pdfjs_require__(23);

var _jbig2_stream = __w_pdfjs_require__(24);

var _jpeg_stream = __w_pdfjs_require__(27);

var _jpx_stream = __w_pdfjs_require__(29);

var _lzw_stream = __w_pdfjs_require__(31);

var _stream = __w_pdfjs_require__(10);

var _predictor_stream = __w_pdfjs_require__(32);

var _run_length_stream = __w_pdfjs_require__(33);

const MAX_LENGTH_TO_CACHE = 1000;
const MAX_ADLER32_LENGTH = 5552;

function computeAdler32(bytes) {
  const bytesLength = bytes.length;
  let a = 1,
      b = 0;

  for (let i = 0; i < bytesLength; ++i) {
    a += bytes[i] & 0xff;
    b += a;
  }

  return b % 65521 << 16 | a % 65521;
}

class Parser {
  constructor({
    lexer,
    xref,
    allowStreams = false,
    recoveryMode = false
  }) {
    this.lexer = lexer;
    this.xref = xref;
    this.allowStreams = allowStreams;
    this.recoveryMode = recoveryMode;
    this.imageCache = Object.create(null);
    this.refill();
  }

  refill() {
    this.buf1 = this.lexer.getObj();
    this.buf2 = this.lexer.getObj();
  }

  shift() {
    if (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
      this.buf1 = this.buf2;
      this.buf2 = null;
    } else {
      this.buf1 = this.buf2;
      this.buf2 = this.lexer.getObj();
    }
  }

  tryShift() {
    try {
      this.shift();
      return true;
    } catch (e) {
      if (e instanceof _core_utils.MissingDataException) {
        throw e;
      }

      return false;
    }
  }

  getObj(cipherTransform = null) {
    const buf1 = this.buf1;
    this.shift();

    if (buf1 instanceof _primitives.Cmd) {
      switch (buf1.cmd) {
        case "BI":
          return this.makeInlineImage(cipherTransform);

        case "[":
          const array = [];

          while (!(0, _primitives.isCmd)(this.buf1, "]") && !(0, _primitives.isEOF)(this.buf1)) {
            array.push(this.getObj(cipherTransform));
          }

          if ((0, _primitives.isEOF)(this.buf1)) {
            if (!this.recoveryMode) {
              throw new _util.FormatError("End of file inside array");
            }

            return array;
          }

          this.shift();
          return array;

        case "<<":
          const dict = new _primitives.Dict(this.xref);

          while (!(0, _primitives.isCmd)(this.buf1, ">>") && !(0, _primitives.isEOF)(this.buf1)) {
            if (!(0, _primitives.isName)(this.buf1)) {
              (0, _util.info)("Malformed dictionary: key must be a name object");
              this.shift();
              continue;
            }

            const key = this.buf1.name;
            this.shift();

            if ((0, _primitives.isEOF)(this.buf1)) {
              break;
            }

            dict.set(key, this.getObj(cipherTransform));
          }

          if ((0, _primitives.isEOF)(this.buf1)) {
            if (!this.recoveryMode) {
              throw new _util.FormatError("End of file inside dictionary");
            }

            return dict;
          }

          if ((0, _primitives.isCmd)(this.buf2, "stream")) {
            return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
          }

          this.shift();
          return dict;

        default:
          return buf1;
      }
    }

    if (Number.isInteger(buf1)) {
      if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
        const ref = _primitives.Ref.get(buf1, this.buf1);

        this.shift();
        this.shift();
        return ref;
      }

      return buf1;
    }

    if (typeof buf1 === "string") {
      if (cipherTransform) {
        return cipherTransform.decryptString(buf1);
      }

      return buf1;
    }

    return buf1;
  }

  findDefaultInlineStreamEnd(stream) {
    const E = 0x45,
          I = 0x49,
          SPACE = 0x20,
          LF = 0xa,
          CR = 0xd,
          NUL = 0x0;
    const lexer = this.lexer,
          startPos = stream.pos,
          n = 10;
    let state = 0,
        ch,
        maybeEIPos;

    while ((ch = stream.getByte()) !== -1) {
      if (state === 0) {
        state = ch === E ? 1 : 0;
      } else if (state === 1) {
        state = ch === I ? 2 : 0;
      } else {
        (0, _util.assert)(state === 2, "findDefaultInlineStreamEnd - invalid state.");

        if (ch === SPACE || ch === LF || ch === CR) {
          maybeEIPos = stream.pos;
          const followingBytes = stream.peekBytes(n);

          for (let i = 0, ii = followingBytes.length; i < ii; i++) {
            ch = followingBytes[i];

            if (ch === NUL && followingBytes[i + 1] !== NUL) {
              continue;
            }

            if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7f)) {
              state = 0;
              break;
            }
          }

          if (state !== 2) {
            continue;
          }

          if (lexer.knownCommands) {
            const nextObj = lexer.peekObj();

            if (nextObj instanceof _primitives.Cmd && !lexer.knownCommands[nextObj.cmd]) {
              state = 0;
            }
          } else {
            (0, _util.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
          }

          if (state === 2) {
            break;
          }
        } else {
          state = 0;
        }
      }
    }

    if (ch === -1) {
      (0, _util.warn)("findDefaultInlineStreamEnd: " + "Reached the end of the stream without finding a valid EI marker");

      if (maybeEIPos) {
        (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
        stream.skip(-(stream.pos - maybeEIPos));
      }
    }

    let endOffset = 4;
    stream.skip(-endOffset);
    ch = stream.peekByte();
    stream.skip(endOffset);

    if (!(0, _core_utils.isWhiteSpace)(ch)) {
      endOffset--;
    }

    return stream.pos - endOffset - startPos;
  }

  findDCTDecodeInlineStreamEnd(stream) {
    const startPos = stream.pos;
    let foundEOI = false,
        b,
        markerLength;

    while ((b = stream.getByte()) !== -1) {
      if (b !== 0xff) {
        continue;
      }

      switch (stream.getByte()) {
        case 0x00:
          break;

        case 0xff:
          stream.skip(-1);
          break;

        case 0xd9:
          foundEOI = true;
          break;

        case 0xc0:
        case 0xc1:
        case 0xc2:
        case 0xc3:
        case 0xc5:
        case 0xc6:
        case 0xc7:
        case 0xc9:
        case 0xca:
        case 0xcb:
        case 0xcd:
        case 0xce:
        case 0xcf:
        case 0xc4:
        case 0xcc:
        case 0xda:
        case 0xdb:
        case 0xdc:
        case 0xdd:
        case 0xde:
        case 0xdf:
        case 0xe0:
        case 0xe1:
        case 0xe2:
        case 0xe3:
        case 0xe4:
        case 0xe5:
        case 0xe6:
        case 0xe7:
        case 0xe8:
        case 0xe9:
        case 0xea:
        case 0xeb:
        case 0xec:
        case 0xed:
        case 0xee:
        case 0xef:
        case 0xfe:
          markerLength = stream.getUint16();

          if (markerLength > 2) {
            stream.skip(markerLength - 2);
          } else {
            stream.skip(-2);
          }

          break;
      }

      if (foundEOI) {
        break;
      }
    }

    const length = stream.pos - startPos;

    if (b === -1) {
      (0, _util.warn)("Inline DCTDecode image stream: " + "EOI marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }

    this.inlineStreamSkipEI(stream);
    return length;
  }

  findASCII85DecodeInlineStreamEnd(stream) {
    const TILDE = 0x7e,
          GT = 0x3e;
    const startPos = stream.pos;
    let ch;

    while ((ch = stream.getByte()) !== -1) {
      if (ch === TILDE) {
        const tildePos = stream.pos;
        ch = stream.peekByte();

        while ((0, _core_utils.isWhiteSpace)(ch)) {
          stream.skip();
          ch = stream.peekByte();
        }

        if (ch === GT) {
          stream.skip();
          break;
        }

        if (stream.pos > tildePos) {
          const maybeEI = stream.peekBytes(2);

          if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {
            break;
          }
        }
      }
    }

    const length = stream.pos - startPos;

    if (ch === -1) {
      (0, _util.warn)("Inline ASCII85Decode image stream: " + "EOD marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }

    this.inlineStreamSkipEI(stream);
    return length;
  }

  findASCIIHexDecodeInlineStreamEnd(stream) {
    const GT = 0x3e;
    const startPos = stream.pos;
    let ch;

    while ((ch = stream.getByte()) !== -1) {
      if (ch === GT) {
        break;
      }
    }

    const length = stream.pos - startPos;

    if (ch === -1) {
      (0, _util.warn)("Inline ASCIIHexDecode image stream: " + "EOD marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }

    this.inlineStreamSkipEI(stream);
    return length;
  }

  inlineStreamSkipEI(stream) {
    const E = 0x45,
          I = 0x49;
    let state = 0,
        ch;

    while ((ch = stream.getByte()) !== -1) {
      if (state === 0) {
        state = ch === E ? 1 : 0;
      } else if (state === 1) {
        state = ch === I ? 2 : 0;
      } else if (state === 2) {
        break;
      }
    }
  }

  makeInlineImage(cipherTransform) {
    const lexer = this.lexer;
    const stream = lexer.stream;
    const dict = new _primitives.Dict(this.xref);
    let dictLength;

    while (!(0, _primitives.isCmd)(this.buf1, "ID") && !(0, _primitives.isEOF)(this.buf1)) {
      if (!(0, _primitives.isName)(this.buf1)) {
        throw new _util.FormatError("Dictionary key must be a name object");
      }

      const key = this.buf1.name;
      this.shift();

      if ((0, _primitives.isEOF)(this.buf1)) {
        break;
      }

      dict.set(key, this.getObj(cipherTransform));
    }

    if (lexer.beginInlineImagePos !== -1) {
      dictLength = stream.pos - lexer.beginInlineImagePos;
    }

    const filter = dict.get("Filter", "F");
    let filterName;

    if ((0, _primitives.isName)(filter)) {
      filterName = filter.name;
    } else if (Array.isArray(filter)) {
      const filterZero = this.xref.fetchIfRef(filter[0]);

      if ((0, _primitives.isName)(filterZero)) {
        filterName = filterZero.name;
      }
    }

    const startPos = stream.pos;
    let length;

    if (filterName === "DCTDecode" || filterName === "DCT") {
      length = this.findDCTDecodeInlineStreamEnd(stream);
    } else if (filterName === "ASCII85Decode" || filterName === "A85") {
      length = this.findASCII85DecodeInlineStreamEnd(stream);
    } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
      length = this.findASCIIHexDecodeInlineStreamEnd(stream);
    } else {
      length = this.findDefaultInlineStreamEnd(stream);
    }

    let imageStream = stream.makeSubStream(startPos, length, dict);
    let cacheKey;

    if (length < MAX_LENGTH_TO_CACHE && dictLength < MAX_ADLER32_LENGTH) {
      const imageBytes = imageStream.getBytes();
      imageStream.reset();
      const initialStreamPos = stream.pos;
      stream.pos = lexer.beginInlineImagePos;
      const dictBytes = stream.getBytes(dictLength);
      stream.pos = initialStreamPos;
      cacheKey = computeAdler32(imageBytes) + "_" + computeAdler32(dictBytes);
      const cacheEntry = this.imageCache[cacheKey];

      if (cacheEntry !== undefined) {
        this.buf2 = _primitives.Cmd.get("EI");
        this.shift();
        cacheEntry.reset();
        return cacheEntry;
      }
    }

    if (cipherTransform) {
      imageStream = cipherTransform.createStream(imageStream, length);
    }

    imageStream = this.filter(imageStream, dict, length);
    imageStream.dict = dict;

    if (cacheKey !== undefined) {
      imageStream.cacheKey = `inline_${length}_${cacheKey}`;
      this.imageCache[cacheKey] = imageStream;
    }

    this.buf2 = _primitives.Cmd.get("EI");
    this.shift();
    return imageStream;
  }

  _findStreamLength(startPos, signature) {
    const {
      stream
    } = this.lexer;
    stream.pos = startPos;
    const SCAN_BLOCK_LENGTH = 2048;
    const signatureLength = signature.length;

    while (stream.pos < stream.end) {
      const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
      const scanLength = scanBytes.length - signatureLength;

      if (scanLength <= 0) {
        break;
      }

      let pos = 0;

      while (pos < scanLength) {
        let j = 0;

        while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
          j++;
        }

        if (j >= signatureLength) {
          stream.pos += pos;
          return stream.pos - startPos;
        }

        pos++;
      }

      stream.pos += scanLength;
    }

    return -1;
  }

  makeStream(dict, cipherTransform) {
    const lexer = this.lexer;
    let stream = lexer.stream;
    lexer.skipToNextLine();
    const startPos = stream.pos - 1;
    let length = dict.get("Length");

    if (!Number.isInteger(length)) {
      (0, _util.info)(`Bad length "${length}" in stream`);
      length = 0;
    }

    stream.pos = startPos + length;
    lexer.nextChar();

    if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
      this.shift();
    } else {
      const ENDSTREAM_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);

      let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);

      if (actualLength < 0) {
        const MAX_TRUNCATION = 1;

        for (let i = 1; i <= MAX_TRUNCATION; i++) {
          const end = ENDSTREAM_SIGNATURE.length - i;
          const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);

          const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);

          if (maybeLength >= 0) {
            const lastByte = stream.peekBytes(end + 1)[end];

            if (!(0, _core_utils.isWhiteSpace)(lastByte)) {
              break;
            }

            (0, _util.info)(`Found "${(0, _util.bytesToString)(TRUNCATED_SIGNATURE)}" when ` + "searching for endstream command.");
            actualLength = maybeLength;
            break;
          }
        }

        if (actualLength < 0) {
          throw new _util.FormatError("Missing endstream command.");
        }
      }

      length = actualLength;
      lexer.nextChar();
      this.shift();
      this.shift();
    }

    this.shift();
    stream = stream.makeSubStream(startPos, length, dict);

    if (cipherTransform) {
      stream = cipherTransform.createStream(stream, length);
    }

    stream = this.filter(stream, dict, length);
    stream.dict = dict;
    return stream;
  }

  filter(stream, dict, length) {
    let filter = dict.get("Filter", "F");
    let params = dict.get("DecodeParms", "DP");

    if ((0, _primitives.isName)(filter)) {
      if (Array.isArray(params)) {
        (0, _util.warn)("/DecodeParms should not contain an Array, " + "when /Filter contains a Name.");
      }

      return this.makeFilter(stream, filter.name, length, params);
    }

    let maybeLength = length;

    if (Array.isArray(filter)) {
      const filterArray = filter;
      const paramsArray = params;

      for (let i = 0, ii = filterArray.length; i < ii; ++i) {
        filter = this.xref.fetchIfRef(filterArray[i]);

        if (!(0, _primitives.isName)(filter)) {
          throw new _util.FormatError(`Bad filter name "${filter}"`);
        }

        params = null;

        if (Array.isArray(paramsArray) && i in paramsArray) {
          params = this.xref.fetchIfRef(paramsArray[i]);
        }

        stream = this.makeFilter(stream, filter.name, maybeLength, params);
        maybeLength = null;
      }
    }

    return stream;
  }

  makeFilter(stream, name, maybeLength, params) {
    if (maybeLength === 0) {
      (0, _util.warn)(`Empty "${name}" stream.`);
      return new _stream.NullStream();
    }

    try {
      const xrefStreamStats = this.xref.stats.streamTypes;

      if (name === "FlateDecode" || name === "Fl") {
        xrefStreamStats[_util.StreamType.FLATE] = true;

        if (params) {
          return new _predictor_stream.PredictorStream(new _flate_stream.FlateStream(stream, maybeLength), maybeLength, params);
        }

        return new _flate_stream.FlateStream(stream, maybeLength);
      }

      if (name === "LZWDecode" || name === "LZW") {
        xrefStreamStats[_util.StreamType.LZW] = true;
        let earlyChange = 1;

        if (params) {
          if (params.has("EarlyChange")) {
            earlyChange = params.get("EarlyChange");
          }

          return new _predictor_stream.PredictorStream(new _lzw_stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
        }

        return new _lzw_stream.LZWStream(stream, maybeLength, earlyChange);
      }

      if (name === "DCTDecode" || name === "DCT") {
        xrefStreamStats[_util.StreamType.DCT] = true;
        return new _jpeg_stream.JpegStream(stream, maybeLength, params);
      }

      if (name === "JPXDecode" || name === "JPX") {
        xrefStreamStats[_util.StreamType.JPX] = true;
        return new _jpx_stream.JpxStream(stream, maybeLength, params);
      }

      if (name === "ASCII85Decode" || name === "A85") {
        xrefStreamStats[_util.StreamType.A85] = true;
        return new _ascii_85_stream.Ascii85Stream(stream, maybeLength);
      }

      if (name === "ASCIIHexDecode" || name === "AHx") {
        xrefStreamStats[_util.StreamType.AHX] = true;
        return new _ascii_hex_stream.AsciiHexStream(stream, maybeLength);
      }

      if (name === "CCITTFaxDecode" || name === "CCF") {
        xrefStreamStats[_util.StreamType.CCF] = true;
        return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
      }

      if (name === "RunLengthDecode" || name === "RL") {
        xrefStreamStats[_util.StreamType.RLX] = true;
        return new _run_length_stream.RunLengthStream(stream, maybeLength);
      }

      if (name === "JBIG2Decode") {
        xrefStreamStats[_util.StreamType.JBIG] = true;
        return new _jbig2_stream.Jbig2Stream(stream, maybeLength, params);
      }

      (0, _util.warn)(`Filter "${name}" is not supported.`);
      return stream;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)(`Invalid stream: "${ex}"`);
      return new _stream.NullStream();
    }
  }

}

exports.Parser = Parser;
const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

function toHexDigit(ch) {
  if (ch >= 0x30 && ch <= 0x39) {
    return ch & 0x0f;
  }

  if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
    return (ch & 0x0f) + 9;
  }

  return -1;
}

class Lexer {
  constructor(stream, knownCommands = null) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = knownCommands;
    this._hexStringNumWarn = 0;
    this.beginInlineImagePos = -1;
  }

  nextChar() {
    return this.currentChar = this.stream.getByte();
  }

  peekChar() {
    return this.stream.peekByte();
  }

  getNumber() {
    let ch = this.currentChar;
    let eNotation = false;
    let divideBy = 0;
    let sign = 0;

    if (ch === 0x2d) {
      sign = -1;
      ch = this.nextChar();

      if (ch === 0x2d) {
        ch = this.nextChar();
      }
    } else if (ch === 0x2b) {
      sign = 1;
      ch = this.nextChar();
    }

    if (ch === 0x0a || ch === 0x0d) {
      do {
        ch = this.nextChar();
      } while (ch === 0x0a || ch === 0x0d);
    }

    if (ch === 0x2e) {
      divideBy = 10;
      ch = this.nextChar();
    }

    if (ch < 0x30 || ch > 0x39) {
      if (divideBy === 10 && sign === 0 && ((0, _core_utils.isWhiteSpace)(ch) || ch === -1)) {
        (0, _util.warn)("Lexer.getNumber - treating a single decimal point as zero.");
        return 0;
      }

      throw new _util.FormatError(`Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`);
    }

    sign = sign || 1;
    let baseValue = ch - 0x30;
    let powerValue = 0;
    let powerValueSign = 1;

    while ((ch = this.nextChar()) >= 0) {
      if (ch >= 0x30 && ch <= 0x39) {
        const currentDigit = ch - 0x30;

        if (eNotation) {
          powerValue = powerValue * 10 + currentDigit;
        } else {
          if (divideBy !== 0) {
            divideBy *= 10;
          }

          baseValue = baseValue * 10 + currentDigit;
        }
      } else if (ch === 0x2e) {
        if (divideBy === 0) {
          divideBy = 1;
        } else {
          break;
        }
      } else if (ch === 0x2d) {
        (0, _util.warn)("Badly formatted number: minus sign in the middle");
      } else if (ch === 0x45 || ch === 0x65) {
        ch = this.peekChar();

        if (ch === 0x2b || ch === 0x2d) {
          powerValueSign = ch === 0x2d ? -1 : 1;
          this.nextChar();
        } else if (ch < 0x30 || ch > 0x39) {
          break;
        }

        eNotation = true;
      } else {
        break;
      }
    }

    if (divideBy !== 0) {
      baseValue /= divideBy;
    }

    if (eNotation) {
      baseValue *= 10 ** (powerValueSign * powerValue);
    }

    return sign * baseValue;
  }

  getString() {
    let numParen = 1;
    let done = false;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    let ch = this.nextChar();

    while (true) {
      let charBuffered = false;

      switch (ch | 0) {
        case -1:
          (0, _util.warn)("Unterminated string");
          done = true;
          break;

        case 0x28:
          ++numParen;
          strBuf.push("(");
          break;

        case 0x29:
          if (--numParen === 0) {
            this.nextChar();
            done = true;
          } else {
            strBuf.push(")");
          }

          break;

        case 0x5c:
          ch = this.nextChar();

          switch (ch) {
            case -1:
              (0, _util.warn)("Unterminated string");
              done = true;
              break;

            case 0x6e:
              strBuf.push("\n");
              break;

            case 0x72:
              strBuf.push("\r");
              break;

            case 0x74:
              strBuf.push("\t");
              break;

            case 0x62:
              strBuf.push("\b");
              break;

            case 0x66:
              strBuf.push("\f");
              break;

            case 0x5c:
            case 0x28:
            case 0x29:
              strBuf.push(String.fromCharCode(ch));
              break;

            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
              let x = ch & 0x0f;
              ch = this.nextChar();
              charBuffered = true;

              if (ch >= 0x30 && ch <= 0x37) {
                x = (x << 3) + (ch & 0x0f);
                ch = this.nextChar();

                if (ch >= 0x30 && ch <= 0x37) {
                  charBuffered = false;
                  x = (x << 3) + (ch & 0x0f);
                }
              }

              strBuf.push(String.fromCharCode(x));
              break;

            case 0x0d:
              if (this.peekChar() === 0x0a) {
                this.nextChar();
              }

              break;

            case 0x0a:
              break;

            default:
              strBuf.push(String.fromCharCode(ch));
              break;
          }

          break;

        default:
          strBuf.push(String.fromCharCode(ch));
          break;
      }

      if (done) {
        break;
      }

      if (!charBuffered) {
        ch = this.nextChar();
      }
    }

    return strBuf.join("");
  }

  getName() {
    let ch, previousCh;
    const strBuf = this.strBuf;
    strBuf.length = 0;

    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      if (ch === 0x23) {
        ch = this.nextChar();

        if (specialChars[ch]) {
          (0, _util.warn)("Lexer_getName: " + "NUMBER SIGN (#) should be followed by a hexadecimal number.");
          strBuf.push("#");
          break;
        }

        const x = toHexDigit(ch);

        if (x !== -1) {
          previousCh = ch;
          ch = this.nextChar();
          const x2 = toHexDigit(ch);

          if (x2 === -1) {
            (0, _util.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) ` + "in hexadecimal number.");
            strBuf.push("#", String.fromCharCode(previousCh));

            if (specialChars[ch]) {
              break;
            }

            strBuf.push(String.fromCharCode(ch));
            continue;
          }

          strBuf.push(String.fromCharCode(x << 4 | x2));
        } else {
          strBuf.push("#", String.fromCharCode(ch));
        }
      } else {
        strBuf.push(String.fromCharCode(ch));
      }
    }

    if (strBuf.length > 127) {
      (0, _util.warn)(`Name token is longer than allowed by the spec: ${strBuf.length}`);
    }

    return _primitives.Name.get(strBuf.join(""));
  }

  _hexStringWarn(ch) {
    const MAX_HEX_STRING_NUM_WARN = 5;

    if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
      (0, _util.warn)("getHexString - ignoring additional invalid characters.");
      return;
    }

    if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
      return;
    }

    (0, _util.warn)(`getHexString - ignoring invalid character: ${ch}`);
  }

  getHexString() {
    const strBuf = this.strBuf;
    strBuf.length = 0;
    let ch = this.currentChar;
    let isFirstHex = true;
    let firstDigit, secondDigit;
    this._hexStringNumWarn = 0;

    while (true) {
      if (ch < 0) {
        (0, _util.warn)("Unterminated hex string");
        break;
      } else if (ch === 0x3e) {
        this.nextChar();
        break;
      } else if (specialChars[ch] === 1) {
        ch = this.nextChar();
        continue;
      } else {
        if (isFirstHex) {
          firstDigit = toHexDigit(ch);

          if (firstDigit === -1) {
            this._hexStringWarn(ch);

            ch = this.nextChar();
            continue;
          }
        } else {
          secondDigit = toHexDigit(ch);

          if (secondDigit === -1) {
            this._hexStringWarn(ch);

            ch = this.nextChar();
            continue;
          }

          strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
        }

        isFirstHex = !isFirstHex;
        ch = this.nextChar();
      }
    }

    return strBuf.join("");
  }

  getObj() {
    let comment = false;
    let ch = this.currentChar;

    while (true) {
      if (ch < 0) {
        return _primitives.EOF;
      }

      if (comment) {
        if (ch === 0x0a || ch === 0x0d) {
          comment = false;
        }
      } else if (ch === 0x25) {
        comment = true;
      } else if (specialChars[ch] !== 1) {
        break;
      }

      ch = this.nextChar();
    }

    switch (ch | 0) {
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x2b:
      case 0x2d:
      case 0x2e:
        return this.getNumber();

      case 0x28:
        return this.getString();

      case 0x2f:
        return this.getName();

      case 0x5b:
        this.nextChar();
        return _primitives.Cmd.get("[");

      case 0x5d:
        this.nextChar();
        return _primitives.Cmd.get("]");

      case 0x3c:
        ch = this.nextChar();

        if (ch === 0x3c) {
          this.nextChar();
          return _primitives.Cmd.get("<<");
        }

        return this.getHexString();

      case 0x3e:
        ch = this.nextChar();

        if (ch === 0x3e) {
          this.nextChar();
          return _primitives.Cmd.get(">>");
        }

        return _primitives.Cmd.get(">");

      case 0x7b:
        this.nextChar();
        return _primitives.Cmd.get("{");

      case 0x7d:
        this.nextChar();
        return _primitives.Cmd.get("}");

      case 0x29:
        this.nextChar();
        throw new _util.FormatError(`Illegal character: ${ch}`);
    }

    let str = String.fromCharCode(ch);
    const knownCommands = this.knownCommands;
    let knownCommandFound = knownCommands && knownCommands[str] !== undefined;

    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      const possibleCommand = str + String.fromCharCode(ch);

      if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
        break;
      }

      if (str.length === 128) {
        throw new _util.FormatError(`Command token too long: ${str.length}`);
      }

      str = possibleCommand;
      knownCommandFound = knownCommands && knownCommands[str] !== undefined;
    }

    if (str === "true") {
      return true;
    }

    if (str === "false") {
      return false;
    }

    if (str === "null") {
      return null;
    }

    if (str === "BI") {
      this.beginInlineImagePos = this.stream.pos;
    }

    return _primitives.Cmd.get(str);
  }

  peekObj() {
    const streamPos = this.stream.pos,
          currentChar = this.currentChar,
          beginInlineImagePos = this.beginInlineImagePos;
    let nextObj;

    try {
      nextObj = this.getObj();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)(`peekObj: ${ex}`);
    }

    this.stream.pos = streamPos;
    this.currentChar = currentChar;
    this.beginInlineImagePos = beginInlineImagePos;
    return nextObj;
  }

  skipToNextLine() {
    let ch = this.currentChar;

    while (ch >= 0) {
      if (ch === 0x0d) {
        ch = this.nextChar();

        if (ch === 0x0a) {
          this.nextChar();
        }

        break;
      } else if (ch === 0x0a) {
        this.nextChar();
        break;
      }

      ch = this.nextChar();
    }
  }

}

exports.Lexer = Lexer;

class Linearization {
  static create(stream) {
    function getInt(linDict, name, allowZeroValue = false) {
      const obj = linDict.get(name);

      if (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
        return obj;
      }

      throw new Error(`The "${name}" parameter in the linearization ` + "dictionary is invalid.");
    }

    function getHints(linDict) {
      const hints = linDict.get("H");
      let hintsLength;

      if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
        for (let index = 0; index < hintsLength; index++) {
          const hint = hints[index];

          if (!(Number.isInteger(hint) && hint > 0)) {
            throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
          }
        }

        return hints;
      }

      throw new Error("Hint array in the linearization dictionary is invalid.");
    }

    const parser = new Parser({
      lexer: new Lexer(stream),
      xref: null
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();
    const linDict = parser.getObj();
    let obj, length;

    if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && (0, _primitives.isDict)(linDict) && (0, _util.isNum)(obj = linDict.get("Linearized")) && obj > 0)) {
      return null;
    } else if ((length = getInt(linDict, "L")) !== stream.length) {
      throw new Error('The "L" parameter in the linearization dictionary ' + "does not equal the stream length.");
    }

    return {
      length,
      hints: getHints(linDict),
      objectNumberFirst: getInt(linDict, "O"),
      endFirst: getInt(linDict, "E"),
      numPages: getInt(linDict, "N"),
      mainXRefEntriesOffset: getInt(linDict, "T"),
      pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0
    };
  }

}

exports.Linearization = Linearization;

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Ascii85Stream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

var _core_utils = __w_pdfjs_require__(9);

class Ascii85Stream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    if (maybeLength) {
      maybeLength = 0.8 * maybeLength;
    }

    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.input = new Uint8Array(5);
  }

  readBlock() {
    const TILDA_CHAR = 0x7e;
    const Z_LOWER_CHAR = 0x7a;
    const EOF = -1;
    const str = this.str;
    let c = str.getByte();

    while ((0, _core_utils.isWhiteSpace)(c)) {
      c = str.getByte();
    }

    if (c === EOF || c === TILDA_CHAR) {
      this.eof = true;
      return;
    }

    const bufferLength = this.bufferLength;
    let buffer, i;

    if (c === Z_LOWER_CHAR) {
      buffer = this.ensureBuffer(bufferLength + 4);

      for (i = 0; i < 4; ++i) {
        buffer[bufferLength + i] = 0;
      }

      this.bufferLength += 4;
    } else {
      const input = this.input;
      input[0] = c;

      for (i = 1; i < 5; ++i) {
        c = str.getByte();

        while ((0, _core_utils.isWhiteSpace)(c)) {
          c = str.getByte();
        }

        input[i] = c;

        if (c === EOF || c === TILDA_CHAR) {
          break;
        }
      }

      buffer = this.ensureBuffer(bufferLength + i - 1);
      this.bufferLength += i - 1;

      if (i < 5) {
        for (; i < 5; ++i) {
          input[i] = 0x21 + 84;
        }

        this.eof = true;
      }

      let t = 0;

      for (i = 0; i < 5; ++i) {
        t = t * 85 + (input[i] - 0x21);
      }

      for (i = 3; i >= 0; --i) {
        buffer[bufferLength + i] = t & 0xff;
        t >>= 8;
      }
    }
  }

}

exports.Ascii85Stream = Ascii85Stream;

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StreamsSequenceStream = exports.DecodeStream = void 0;

var _base_stream = __w_pdfjs_require__(6);

var _stream = __w_pdfjs_require__(10);

const emptyBuffer = new Uint8Array(0);

class DecodeStream extends _base_stream.BaseStream {
  constructor(maybeMinBufferLength) {
    super();
    this._rawMinBufferLength = maybeMinBufferLength || 0;
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = emptyBuffer;
    this.minBufferLength = 512;

    if (maybeMinBufferLength) {
      while (this.minBufferLength < maybeMinBufferLength) {
        this.minBufferLength *= 2;
      }
    }
  }

  get isEmpty() {
    while (!this.eof && this.bufferLength === 0) {
      this.readBlock();
    }

    return this.bufferLength === 0;
  }

  ensureBuffer(requested) {
    const buffer = this.buffer;

    if (requested <= buffer.byteLength) {
      return buffer;
    }

    let size = this.minBufferLength;

    while (size < requested) {
      size *= 2;
    }

    const buffer2 = new Uint8Array(size);
    buffer2.set(buffer);
    return this.buffer = buffer2;
  }

  getByte() {
    const pos = this.pos;

    while (this.bufferLength <= pos) {
      if (this.eof) {
        return -1;
      }

      this.readBlock();
    }

    return this.buffer[this.pos++];
  }

  getBytes(length, forceClamped = false) {
    const pos = this.pos;
    let end;

    if (length) {
      this.ensureBuffer(pos + length);
      end = pos + length;

      while (!this.eof && this.bufferLength < end) {
        this.readBlock();
      }

      const bufEnd = this.bufferLength;

      if (end > bufEnd) {
        end = bufEnd;
      }
    } else {
      while (!this.eof) {
        this.readBlock();
      }

      end = this.bufferLength;
    }

    this.pos = end;
    const subarray = this.buffer.subarray(pos, end);
    return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
  }

  reset() {
    this.pos = 0;
  }

  makeSubStream(start, length, dict = null) {
    if (length === undefined) {
      while (!this.eof) {
        this.readBlock();
      }
    } else {
      const end = start + length;

      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }
    }

    return new _stream.Stream(this.buffer, start, length, dict);
  }

  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }

}

exports.DecodeStream = DecodeStream;

class StreamsSequenceStream extends DecodeStream {
  constructor(streams) {
    let maybeLength = 0;

    for (const stream of streams) {
      maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length;
    }

    super(maybeLength);
    this.streams = streams;
  }

  readBlock() {
    const streams = this.streams;

    if (streams.length === 0) {
      this.eof = true;
      return;
    }

    const stream = streams.shift();
    const chunk = stream.getBytes();
    const bufferLength = this.bufferLength;
    const newLength = bufferLength + chunk.length;
    const buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  }

  getBaseStreams() {
    const baseStreamsBuf = [];

    for (const stream of this.streams) {
      const baseStreams = stream.getBaseStreams();

      if (baseStreams) {
        baseStreamsBuf.push(...baseStreams);
      }
    }

    return baseStreamsBuf.length > 0 ? baseStreamsBuf : null;
  }

}

exports.StreamsSequenceStream = StreamsSequenceStream;

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AsciiHexStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

class AsciiHexStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    if (maybeLength) {
      maybeLength = 0.5 * maybeLength;
    }

    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.firstDigit = -1;
  }

  readBlock() {
    const UPSTREAM_BLOCK_SIZE = 8000;
    const bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);

    if (!bytes.length) {
      this.eof = true;
      return;
    }

    const maxDecodeLength = bytes.length + 1 >> 1;
    const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
    let bufferLength = this.bufferLength;
    let firstDigit = this.firstDigit;

    for (const ch of bytes) {
      let digit;

      if (ch >= 0x30 && ch <= 0x39) {
        digit = ch & 0x0f;
      } else if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
        digit = (ch & 0x0f) + 9;
      } else if (ch === 0x3e) {
        this.eof = true;
        break;
      } else {
        continue;
      }

      if (firstDigit < 0) {
        firstDigit = digit;
      } else {
        buffer[bufferLength++] = firstDigit << 4 | digit;
        firstDigit = -1;
      }
    }

    if (firstDigit >= 0 && this.eof) {
      buffer[bufferLength++] = firstDigit << 4;
      firstDigit = -1;
    }

    this.firstDigit = firstDigit;
    this.bufferLength = bufferLength;
  }

}

exports.AsciiHexStream = AsciiHexStream;

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CCITTFaxStream = void 0;

var _primitives = __w_pdfjs_require__(5);

var _ccitt = __w_pdfjs_require__(22);

var _decode_stream = __w_pdfjs_require__(19);

class CCITTFaxStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, params) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;

    if (!(0, _primitives.isDict)(params)) {
      params = _primitives.Dict.empty;
    }

    const source = {
      next() {
        return str.getByte();
      }

    };
    this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, {
      K: params.get("K"),
      EndOfLine: params.get("EndOfLine"),
      EncodedByteAlign: params.get("EncodedByteAlign"),
      Columns: params.get("Columns"),
      Rows: params.get("Rows"),
      EndOfBlock: params.get("EndOfBlock"),
      BlackIs1: params.get("BlackIs1")
    });
  }

  readBlock() {
    while (!this.eof) {
      const c = this.ccittFaxDecoder.readNextChar();

      if (c === -1) {
        this.eof = true;
        return;
      }

      this.ensureBuffer(this.bufferLength + 1);
      this.buffer[this.bufferLength++] = c;
    }
  }

}

exports.CCITTFaxStream = CCITTFaxStream;

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CCITTFaxDecoder = void 0;

var _util = __w_pdfjs_require__(2);

const ccittEOL = -2;
const ccittEOF = -1;
const twoDimPass = 0;
const twoDimHoriz = 1;
const twoDimVert0 = 2;
const twoDimVertR1 = 3;
const twoDimVertL1 = 4;
const twoDimVertR2 = 5;
const twoDimVertL2 = 6;
const twoDimVertR3 = 7;
const twoDimVertL3 = 8;
const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];

class CCITTFaxDecoder {
  constructor(source, options = {}) {
    if (!source || typeof source.next !== "function") {
      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    }

    this.source = source;
    this.eof = false;
    this.encoding = options.K || 0;
    this.eoline = options.EndOfLine || false;
    this.byteAlign = options.EncodedByteAlign || false;
    this.columns = options.Columns || 1728;
    this.rows = options.Rows || 0;
    let eoblock = options.EndOfBlock;

    if (eoblock === null || eoblock === undefined) {
      eoblock = true;
    }

    this.eoblock = eoblock;
    this.black = options.BlackIs1 || false;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    this.row = 0;
    this.nextLine2D = this.encoding < 0;
    this.inputBits = 0;
    this.inputBuf = 0;
    this.outputBits = 0;
    this.rowsDone = false;
    let code1;

    while ((code1 = this._lookBits(12)) === 0) {
      this._eatBits(1);
    }

    if (code1 === 1) {
      this._eatBits(12);
    }

    if (this.encoding > 0) {
      this.nextLine2D = !this._lookBits(1);

      this._eatBits(1);
    }
  }

  readNextChar() {
    if (this.eof) {
      return -1;
    }

    const refLine = this.refLine;
    const codingLine = this.codingLine;
    const columns = this.columns;
    let refPos, blackPixels, bits, i;

    if (this.outputBits === 0) {
      if (this.rowsDone) {
        this.eof = true;
      }

      if (this.eof) {
        return -1;
      }

      this.err = false;
      let code1, code2, code3;

      if (this.nextLine2D) {
        for (i = 0; codingLine[i] < columns; ++i) {
          refLine[i] = codingLine[i];
        }

        refLine[i++] = columns;
        refLine[i] = columns;
        codingLine[0] = 0;
        this.codingPos = 0;
        refPos = 0;
        blackPixels = 0;

        while (codingLine[this.codingPos] < columns) {
          code1 = this._getTwoDimCode();

          switch (code1) {
            case twoDimPass:
              this._addPixels(refLine[refPos + 1], blackPixels);

              if (refLine[refPos + 1] < columns) {
                refPos += 2;
              }

              break;

            case twoDimHoriz:
              code1 = code2 = 0;

              if (blackPixels) {
                do {
                  code1 += code3 = this._getBlackCode();
                } while (code3 >= 64);

                do {
                  code2 += code3 = this._getWhiteCode();
                } while (code3 >= 64);
              } else {
                do {
                  code1 += code3 = this._getWhiteCode();
                } while (code3 >= 64);

                do {
                  code2 += code3 = this._getBlackCode();
                } while (code3 >= 64);
              }

              this._addPixels(codingLine[this.codingPos] + code1, blackPixels);

              if (codingLine[this.codingPos] < columns) {
                this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
              }

              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                refPos += 2;
              }

              break;

            case twoDimVertR3:
              this._addPixels(refLine[refPos] + 3, blackPixels);

              blackPixels ^= 1;

              if (codingLine[this.codingPos] < columns) {
                ++refPos;

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }

              break;

            case twoDimVertR2:
              this._addPixels(refLine[refPos] + 2, blackPixels);

              blackPixels ^= 1;

              if (codingLine[this.codingPos] < columns) {
                ++refPos;

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }

              break;

            case twoDimVertR1:
              this._addPixels(refLine[refPos] + 1, blackPixels);

              blackPixels ^= 1;

              if (codingLine[this.codingPos] < columns) {
                ++refPos;

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }

              break;

            case twoDimVert0:
              this._addPixels(refLine[refPos], blackPixels);

              blackPixels ^= 1;

              if (codingLine[this.codingPos] < columns) {
                ++refPos;

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }

              break;

            case twoDimVertL3:
              this._addPixelsNeg(refLine[refPos] - 3, blackPixels);

              blackPixels ^= 1;

              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }

              break;

            case twoDimVertL2:
              this._addPixelsNeg(refLine[refPos] - 2, blackPixels);

              blackPixels ^= 1;

              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }

              break;

            case twoDimVertL1:
              this._addPixelsNeg(refLine[refPos] - 1, blackPixels);

              blackPixels ^= 1;

              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }

                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }

              break;

            case ccittEOF:
              this._addPixels(columns, 0);

              this.eof = true;
              break;

            default:
              (0, _util.info)("bad 2d code");

              this._addPixels(columns, 0);

              this.err = true;
          }
        }
      } else {
        codingLine[0] = 0;
        this.codingPos = 0;
        blackPixels = 0;

        while (codingLine[this.codingPos] < columns) {
          code1 = 0;

          if (blackPixels) {
            do {
              code1 += code3 = this._getBlackCode();
            } while (code3 >= 64);
          } else {
            do {
              code1 += code3 = this._getWhiteCode();
            } while (code3 >= 64);
          }

          this._addPixels(codingLine[this.codingPos] + code1, blackPixels);

          blackPixels ^= 1;
        }
      }

      let gotEOL = false;

      if (this.byteAlign) {
        this.inputBits &= ~7;
      }

      if (!this.eoblock && this.row === this.rows - 1) {
        this.rowsDone = true;
      } else {
        code1 = this._lookBits(12);

        if (this.eoline) {
          while (code1 !== ccittEOF && code1 !== 1) {
            this._eatBits(1);

            code1 = this._lookBits(12);
          }
        } else {
          while (code1 === 0) {
            this._eatBits(1);

            code1 = this._lookBits(12);
          }
        }

        if (code1 === 1) {
          this._eatBits(12);

          gotEOL = true;
        } else if (code1 === ccittEOF) {
          this.eof = true;
        }
      }

      if (!this.eof && this.encoding > 0 && !this.rowsDone) {
        this.nextLine2D = !this._lookBits(1);

        this._eatBits(1);
      }

      if (this.eoblock && gotEOL && this.byteAlign) {
        code1 = this._lookBits(12);

        if (code1 === 1) {
          this._eatBits(12);

          if (this.encoding > 0) {
            this._lookBits(1);

            this._eatBits(1);
          }

          if (this.encoding >= 0) {
            for (i = 0; i < 4; ++i) {
              code1 = this._lookBits(12);

              if (code1 !== 1) {
                (0, _util.info)("bad rtc code: " + code1);
              }

              this._eatBits(12);

              if (this.encoding > 0) {
                this._lookBits(1);

                this._eatBits(1);
              }
            }
          }

          this.eof = true;
        }
      } else if (this.err && this.eoline) {
        while (true) {
          code1 = this._lookBits(13);

          if (code1 === ccittEOF) {
            this.eof = true;
            return -1;
          }

          if (code1 >> 1 === 1) {
            break;
          }

          this._eatBits(1);
        }

        this._eatBits(12);

        if (this.encoding > 0) {
          this._eatBits(1);

          this.nextLine2D = !(code1 & 1);
        }
      }

      if (codingLine[0] > 0) {
        this.outputBits = codingLine[this.codingPos = 0];
      } else {
        this.outputBits = codingLine[this.codingPos = 1];
      }

      this.row++;
    }

    let c;

    if (this.outputBits >= 8) {
      c = this.codingPos & 1 ? 0 : 0xff;
      this.outputBits -= 8;

      if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
        this.codingPos++;
        this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
      }
    } else {
      bits = 8;
      c = 0;

      do {
        if (this.outputBits > bits) {
          c <<= bits;

          if (!(this.codingPos & 1)) {
            c |= 0xff >> 8 - bits;
          }

          this.outputBits -= bits;
          bits = 0;
        } else {
          c <<= this.outputBits;

          if (!(this.codingPos & 1)) {
            c |= 0xff >> 8 - this.outputBits;
          }

          bits -= this.outputBits;
          this.outputBits = 0;

          if (codingLine[this.codingPos] < columns) {
            this.codingPos++;
            this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
          } else if (bits > 0) {
            c <<= bits;
            bits = 0;
          }
        }
      } while (bits);
    }

    if (this.black) {
      c ^= 0xff;
    }

    return c;
  }

  _addPixels(a1, blackPixels) {
    const codingLine = this.codingLine;
    let codingPos = this.codingPos;

    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        (0, _util.info)("row is wrong length");
        this.err = true;
        a1 = this.columns;
      }

      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }

      codingLine[codingPos] = a1;
    }

    this.codingPos = codingPos;
  }

  _addPixelsNeg(a1, blackPixels) {
    const codingLine = this.codingLine;
    let codingPos = this.codingPos;

    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        (0, _util.info)("row is wrong length");
        this.err = true;
        a1 = this.columns;
      }

      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }

      codingLine[codingPos] = a1;
    } else if (a1 < codingLine[codingPos]) {
      if (a1 < 0) {
        (0, _util.info)("invalid code");
        this.err = true;
        a1 = 0;
      }

      while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
        --codingPos;
      }

      codingLine[codingPos] = a1;
    }

    this.codingPos = codingPos;
  }

  _findTableCode(start, end, table, limit) {
    const limitValue = limit || 0;

    for (let i = start; i <= end; ++i) {
      let code = this._lookBits(i);

      if (code === ccittEOF) {
        return [true, 1, false];
      }

      if (i < end) {
        code <<= end - i;
      }

      if (!limitValue || code >= limitValue) {
        const p = table[code - limitValue];

        if (p[0] === i) {
          this._eatBits(i);

          return [true, p[1], true];
        }
      }
    }

    return [false, 0, false];
  }

  _getTwoDimCode() {
    let code = 0;
    let p;

    if (this.eoblock) {
      code = this._lookBits(7);
      p = twoDimTable[code];

      if (p && p[0] > 0) {
        this._eatBits(p[0]);

        return p[1];
      }
    } else {
      const result = this._findTableCode(1, 7, twoDimTable);

      if (result[0] && result[2]) {
        return result[1];
      }
    }

    (0, _util.info)("Bad two dim code");
    return ccittEOF;
  }

  _getWhiteCode() {
    let code = 0;
    let p;

    if (this.eoblock) {
      code = this._lookBits(12);

      if (code === ccittEOF) {
        return 1;
      }

      if (code >> 5 === 0) {
        p = whiteTable1[code];
      } else {
        p = whiteTable2[code >> 3];
      }

      if (p[0] > 0) {
        this._eatBits(p[0]);

        return p[1];
      }
    } else {
      let result = this._findTableCode(1, 9, whiteTable2);

      if (result[0]) {
        return result[1];
      }

      result = this._findTableCode(11, 12, whiteTable1);

      if (result[0]) {
        return result[1];
      }
    }

    (0, _util.info)("bad white code");

    this._eatBits(1);

    return 1;
  }

  _getBlackCode() {
    let code, p;

    if (this.eoblock) {
      code = this._lookBits(13);

      if (code === ccittEOF) {
        return 1;
      }

      if (code >> 7 === 0) {
        p = blackTable1[code];
      } else if (code >> 9 === 0 && code >> 7 !== 0) {
        p = blackTable2[(code >> 1) - 64];
      } else {
        p = blackTable3[code >> 7];
      }

      if (p[0] > 0) {
        this._eatBits(p[0]);

        return p[1];
      }
    } else {
      let result = this._findTableCode(2, 6, blackTable3);

      if (result[0]) {
        return result[1];
      }

      result = this._findTableCode(7, 12, blackTable2, 64);

      if (result[0]) {
        return result[1];
      }

      result = this._findTableCode(10, 13, blackTable1);

      if (result[0]) {
        return result[1];
      }
    }

    (0, _util.info)("bad black code");

    this._eatBits(1);

    return 1;
  }

  _lookBits(n) {
    let c;

    while (this.inputBits < n) {
      if ((c = this.source.next()) === -1) {
        if (this.inputBits === 0) {
          return ccittEOF;
        }

        return this.inputBuf << n - this.inputBits & 0xffff >> 16 - n;
      }

      this.inputBuf = this.inputBuf << 8 | c;
      this.inputBits += 8;
    }

    return this.inputBuf >> this.inputBits - n & 0xffff >> 16 - n;
  }

  _eatBits(n) {
    if ((this.inputBits -= n) < 0) {
      this.inputBits = 0;
    }
  }

}

exports.CCITTFaxDecoder = CCITTFaxDecoder;

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FlateStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

var _util = __w_pdfjs_require__(2);

const codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
const distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
const fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
const fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];

class FlateStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    const cmf = str.getByte();
    const flg = str.getByte();

    if (cmf === -1 || flg === -1) {
      throw new _util.FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);
    }

    if ((cmf & 0x0f) !== 0x08) {
      throw new _util.FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
    }

    if (((cmf << 8) + flg) % 31 !== 0) {
      throw new _util.FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
    }

    if (flg & 0x20) {
      throw new _util.FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
    }

    this.codeSize = 0;
    this.codeBuf = 0;
  }

  getBits(bits) {
    const str = this.str;
    let codeSize = this.codeSize;
    let codeBuf = this.codeBuf;
    let b;

    while (codeSize < bits) {
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad encoding in flate stream");
      }

      codeBuf |= b << codeSize;
      codeSize += 8;
    }

    b = codeBuf & (1 << bits) - 1;
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    return b;
  }

  getCode(table) {
    const str = this.str;
    const codes = table[0];
    const maxLen = table[1];
    let codeSize = this.codeSize;
    let codeBuf = this.codeBuf;
    let b;

    while (codeSize < maxLen) {
      if ((b = str.getByte()) === -1) {
        break;
      }

      codeBuf |= b << codeSize;
      codeSize += 8;
    }

    const code = codes[codeBuf & (1 << maxLen) - 1];
    const codeLen = code >> 16;
    const codeVal = code & 0xffff;

    if (codeLen < 1 || codeSize < codeLen) {
      throw new _util.FormatError("Bad encoding in flate stream");
    }

    this.codeBuf = codeBuf >> codeLen;
    this.codeSize = codeSize - codeLen;
    return codeVal;
  }

  generateHuffmanTable(lengths) {
    const n = lengths.length;
    let maxLen = 0;
    let i;

    for (i = 0; i < n; ++i) {
      if (lengths[i] > maxLen) {
        maxLen = lengths[i];
      }
    }

    const size = 1 << maxLen;
    const codes = new Int32Array(size);

    for (let len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
      for (let val = 0; val < n; ++val) {
        if (lengths[val] === len) {
          let code2 = 0;
          let t = code;

          for (i = 0; i < len; ++i) {
            code2 = code2 << 1 | t & 1;
            t >>= 1;
          }

          for (i = code2; i < size; i += skip) {
            codes[i] = len << 16 | val;
          }

          ++code;
        }
      }
    }

    return [codes, maxLen];
  }

  readBlock() {
    let buffer, len;
    const str = this.str;
    let hdr = this.getBits(3);

    if (hdr & 1) {
      this.eof = true;
    }

    hdr >>= 1;

    if (hdr === 0) {
      let b;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      let blockLen = b;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      blockLen |= b << 8;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      let check = b;

      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError("Bad block header in flate stream");
      }

      check |= b << 8;

      if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
        throw new _util.FormatError("Bad uncompressed block length in flate stream");
      }

      this.codeBuf = 0;
      this.codeSize = 0;
      const bufferLength = this.bufferLength,
            end = bufferLength + blockLen;
      buffer = this.ensureBuffer(end);
      this.bufferLength = end;

      if (blockLen === 0) {
        if (str.peekByte() === -1) {
          this.eof = true;
        }
      } else {
        const block = str.getBytes(blockLen);
        buffer.set(block, bufferLength);

        if (block.length < blockLen) {
          this.eof = true;
        }
      }

      return;
    }

    let litCodeTable;
    let distCodeTable;

    if (hdr === 1) {
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr === 2) {
      const numLitCodes = this.getBits(5) + 257;
      const numDistCodes = this.getBits(5) + 1;
      const numCodeLenCodes = this.getBits(4) + 4;
      const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
      let i;

      for (i = 0; i < numCodeLenCodes; ++i) {
        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
      }

      const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
      len = 0;
      i = 0;
      const codes = numLitCodes + numDistCodes;
      const codeLengths = new Uint8Array(codes);
      let bitsLength, bitsOffset, what;

      while (i < codes) {
        const code = this.getCode(codeLenCodeTab);

        if (code === 16) {
          bitsLength = 2;
          bitsOffset = 3;
          what = len;
        } else if (code === 17) {
          bitsLength = 3;
          bitsOffset = 3;
          what = len = 0;
        } else if (code === 18) {
          bitsLength = 7;
          bitsOffset = 11;
          what = len = 0;
        } else {
          codeLengths[i++] = len = code;
          continue;
        }

        let repeatLength = this.getBits(bitsLength) + bitsOffset;

        while (repeatLength-- > 0) {
          codeLengths[i++] = what;
        }
      }

      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
    } else {
      throw new _util.FormatError("Unknown block type in flate stream");
    }

    buffer = this.buffer;
    let limit = buffer ? buffer.length : 0;
    let pos = this.bufferLength;

    while (true) {
      let code1 = this.getCode(litCodeTable);

      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }

        buffer[pos++] = code1;
        continue;
      }

      if (code1 === 256) {
        this.bufferLength = pos;
        return;
      }

      code1 -= 257;
      code1 = lengthDecode[code1];
      let code2 = code1 >> 16;

      if (code2 > 0) {
        code2 = this.getBits(code2);
      }

      len = (code1 & 0xffff) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;

      if (code2 > 0) {
        code2 = this.getBits(code2);
      }

      const dist = (code1 & 0xffff) + code2;

      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }

      for (let k = 0; k < len; ++k, ++pos) {
        buffer[pos] = buffer[pos - dist];
      }
    }
  }

}

exports.FlateStream = FlateStream;

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Jbig2Stream = void 0;

var _primitives = __w_pdfjs_require__(5);

var _decode_stream = __w_pdfjs_require__(19);

var _jbig = __w_pdfjs_require__(25);

var _util = __w_pdfjs_require__(2);

class Jbig2Stream extends _decode_stream.DecodeStream {
  constructor(stream, maybeLength, params) {
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }

  get bytes() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }

  ensureBuffer(requested) {}

  readBlock() {
    if (this.eof) {
      return;
    }

    const jbig2Image = new _jbig.Jbig2Image();
    const chunks = [];

    if ((0, _primitives.isDict)(this.params)) {
      const globalsStream = this.params.get("JBIG2Globals");

      if ((0, _primitives.isStream)(globalsStream)) {
        const globals = globalsStream.getBytes();
        chunks.push({
          data: globals,
          start: 0,
          end: globals.length
        });
      }
    }

    chunks.push({
      data: this.bytes,
      start: 0,
      end: this.bytes.length
    });
    const data = jbig2Image.parseChunks(chunks);
    const dataLength = data.length;

    for (let i = 0; i < dataLength; i++) {
      data[i] ^= 0xff;
    }

    this.buffer = data;
    this.bufferLength = dataLength;
    this.eof = true;
  }

}

exports.Jbig2Stream = Jbig2Stream;

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Jbig2Image = void 0;

var _util = __w_pdfjs_require__(2);

var _core_utils = __w_pdfjs_require__(9);

var _arithmetic_decoder = __w_pdfjs_require__(26);

var _ccitt = __w_pdfjs_require__(22);

class Jbig2Error extends _util.BaseException {
  constructor(msg) {
    super(`JBIG2 error: ${msg}`);
  }

}

class ContextCache {
  getContexts(id) {
    if (id in this) {
      return this[id];
    }

    return this[id] = new Int8Array(1 << 16);
  }

}

class DecodingContext {
  constructor(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
  }

  get decoder() {
    const decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
    return (0, _util.shadow)(this, "decoder", decoder);
  }

  get contextCache() {
    const cache = new ContextCache();
    return (0, _util.shadow)(this, "contextCache", cache);
  }

}

function decodeInteger(contextCache, procedure, decoder) {
  const contexts = contextCache.getContexts(procedure);
  let prev = 1;

  function readBits(length) {
    let v = 0;

    for (let i = 0; i < length; i++) {
      const bit = decoder.readBit(contexts, prev);
      prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
      v = v << 1 | bit;
    }

    return v >>> 0;
  }

  const sign = readBits(1);
  const value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);

  if (sign === 0) {
    return value;
  } else if (value > 0) {
    return -value;
  }

  return null;
}

function decodeIAID(contextCache, decoder, codeLength) {
  const contexts = contextCache.getContexts("IAID");
  let prev = 1;

  for (let i = 0; i < codeLength; i++) {
    const bit = decoder.readBit(contexts, prev);
    prev = prev << 1 | bit;
  }

  if (codeLength < 31) {
    return prev & (1 << codeLength) - 1;
  }

  return prev & 0x7fffffff;
}

const SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
const CodingTemplates = [[{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: 2,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -3,
  y: -1
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}]];
const RefinementTemplates = [{
  coding: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: -1,
    y: 1
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}, {
  coding: [{
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}];
const ReusedContexts = [0x9b25, 0x0795, 0x00e5, 0x0195];
const RefinementReusedContexts = [0x0020, 0x0008];

function decodeBitmapTemplate0(width, height, decodingContext) {
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GB");
  const bitmap = [];
  let contextLabel, i, j, pixel, row, row1, row2;
  const OLD_PIXEL_MASK = 0x7bf7;

  for (i = 0; i < height; i++) {
    row = bitmap[i] = new Uint8Array(width);
    row1 = i < 1 ? row : bitmap[i - 1];
    row2 = i < 2 ? row : bitmap[i - 2];
    contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;

    for (j = 0; j < width; j++) {
      row[j] = pixel = decoder.readBit(contexts, contextLabel);
      contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
    }
  }

  return bitmap;
}

function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
  if (mmr) {
    const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
    return decodeMMRBitmap(input, width, height, false);
  }

  if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
    return decodeBitmapTemplate0(width, height, decodingContext);
  }

  const useskip = !!skip;
  const template = CodingTemplates[templateIndex].concat(at);
  template.sort(function (a, b) {
    return a.y - b.y || a.x - b.x;
  });
  const templateLength = template.length;
  const templateX = new Int8Array(templateLength);
  const templateY = new Int8Array(templateLength);
  const changingTemplateEntries = [];
  let reuseMask = 0,
      minX = 0,
      maxX = 0,
      minY = 0;
  let c, k;

  for (k = 0; k < templateLength; k++) {
    templateX[k] = template[k].x;
    templateY[k] = template[k].y;
    minX = Math.min(minX, template[k].x);
    maxX = Math.max(maxX, template[k].x);
    minY = Math.min(minY, template[k].y);

    if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
      reuseMask |= 1 << templateLength - 1 - k;
    } else {
      changingTemplateEntries.push(k);
    }
  }

  const changingEntriesLength = changingTemplateEntries.length;
  const changingTemplateX = new Int8Array(changingEntriesLength);
  const changingTemplateY = new Int8Array(changingEntriesLength);
  const changingTemplateBit = new Uint16Array(changingEntriesLength);

  for (c = 0; c < changingEntriesLength; c++) {
    k = changingTemplateEntries[c];
    changingTemplateX[c] = template[k].x;
    changingTemplateY[c] = template[k].y;
    changingTemplateBit[c] = 1 << templateLength - 1 - k;
  }

  const sbb_left = -minX;
  const sbb_top = -minY;
  const sbb_right = width - maxX;
  const pseudoPixelContext = ReusedContexts[templateIndex];
  let row = new Uint8Array(width);
  const bitmap = [];
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GB");
  let ltp = 0,
      j,
      i0,
      j0,
      contextLabel = 0,
      bit,
      shift;

  for (let i = 0; i < height; i++) {
    if (prediction) {
      const sltp = decoder.readBit(contexts, pseudoPixelContext);
      ltp ^= sltp;

      if (ltp) {
        bitmap.push(row);
        continue;
      }
    }

    row = new Uint8Array(row);
    bitmap.push(row);

    for (j = 0; j < width; j++) {
      if (useskip && skip[i][j]) {
        row[j] = 0;
        continue;
      }

      if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
        contextLabel = contextLabel << 1 & reuseMask;

        for (k = 0; k < changingEntriesLength; k++) {
          i0 = i + changingTemplateY[k];
          j0 = j + changingTemplateX[k];
          bit = bitmap[i0][j0];

          if (bit) {
            bit = changingTemplateBit[k];
            contextLabel |= bit;
          }
        }
      } else {
        contextLabel = 0;
        shift = templateLength - 1;

        for (k = 0; k < templateLength; k++, shift--) {
          j0 = j + templateX[k];

          if (j0 >= 0 && j0 < width) {
            i0 = i + templateY[k];

            if (i0 >= 0) {
              bit = bitmap[i0][j0];

              if (bit) {
                contextLabel |= bit << shift;
              }
            }
          }
        }
      }

      const pixel = decoder.readBit(contexts, contextLabel);
      row[j] = pixel;
    }
  }

  return bitmap;
}

function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
  let codingTemplate = RefinementTemplates[templateIndex].coding;

  if (templateIndex === 0) {
    codingTemplate = codingTemplate.concat([at[0]]);
  }

  const codingTemplateLength = codingTemplate.length;
  const codingTemplateX = new Int32Array(codingTemplateLength);
  const codingTemplateY = new Int32Array(codingTemplateLength);
  let k;

  for (k = 0; k < codingTemplateLength; k++) {
    codingTemplateX[k] = codingTemplate[k].x;
    codingTemplateY[k] = codingTemplate[k].y;
  }

  let referenceTemplate = RefinementTemplates[templateIndex].reference;

  if (templateIndex === 0) {
    referenceTemplate = referenceTemplate.concat([at[1]]);
  }

  const referenceTemplateLength = referenceTemplate.length;
  const referenceTemplateX = new Int32Array(referenceTemplateLength);
  const referenceTemplateY = new Int32Array(referenceTemplateLength);

  for (k = 0; k < referenceTemplateLength; k++) {
    referenceTemplateX[k] = referenceTemplate[k].x;
    referenceTemplateY[k] = referenceTemplate[k].y;
  }

  const referenceWidth = referenceBitmap[0].length;
  const referenceHeight = referenceBitmap.length;
  const pseudoPixelContext = RefinementReusedContexts[templateIndex];
  const bitmap = [];
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GR");
  let ltp = 0;

  for (let i = 0; i < height; i++) {
    if (prediction) {
      const sltp = decoder.readBit(contexts, pseudoPixelContext);
      ltp ^= sltp;

      if (ltp) {
        throw new Jbig2Error("prediction is not supported");
      }
    }

    const row = new Uint8Array(width);
    bitmap.push(row);

    for (let j = 0; j < width; j++) {
      let i0, j0;
      let contextLabel = 0;

      for (k = 0; k < codingTemplateLength; k++) {
        i0 = i + codingTemplateY[k];
        j0 = j + codingTemplateX[k];

        if (i0 < 0 || j0 < 0 || j0 >= width) {
          contextLabel <<= 1;
        } else {
          contextLabel = contextLabel << 1 | bitmap[i0][j0];
        }
      }

      for (k = 0; k < referenceTemplateLength; k++) {
        i0 = i + referenceTemplateY[k] - offsetY;
        j0 = j + referenceTemplateX[k] - offsetX;

        if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
          contextLabel <<= 1;
        } else {
          contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
        }
      }

      const pixel = decoder.readBit(contexts, contextLabel);
      row[j] = pixel;
    }
  }

  return bitmap;
}

function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
  if (huffman && refinement) {
    throw new Jbig2Error("symbol refinement with Huffman is not supported");
  }

  const newSymbols = [];
  let currentHeight = 0;
  let symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  let tableB1, symbolWidths;

  if (huffman) {
    tableB1 = getStandardTable(1);
    symbolWidths = [];
    symbolCodeLength = Math.max(symbolCodeLength, 1);
  }

  while (newSymbols.length < numberOfNewSymbols) {
    const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
    currentHeight += deltaHeight;
    let currentWidth = 0,
        totalWidth = 0;
    const firstSymbol = huffman ? symbolWidths.length : 0;

    while (true) {
      const deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);

      if (deltaWidth === null) {
        break;
      }

      currentWidth += deltaWidth;
      totalWidth += currentWidth;
      let bitmap;

      if (refinement) {
        const numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);

        if (numberOfInstances > 1) {
          bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
        } else {
          const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
          const rdx = decodeInteger(contextCache, "IARDX", decoder);
          const rdy = decodeInteger(contextCache, "IARDY", decoder);
          const symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
          bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
        }

        newSymbols.push(bitmap);
      } else if (huffman) {
        symbolWidths.push(currentWidth);
      } else {
        bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
        newSymbols.push(bitmap);
      }
    }

    if (huffman && !refinement) {
      const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
      huffmanInput.byteAlign();
      let collectiveBitmap;

      if (bitmapSize === 0) {
        collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
      } else {
        const originalEnd = huffmanInput.end;
        const bitmapEnd = huffmanInput.position + bitmapSize;
        huffmanInput.end = bitmapEnd;
        collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
        huffmanInput.end = originalEnd;
        huffmanInput.position = bitmapEnd;
      }

      const numberOfSymbolsDecoded = symbolWidths.length;

      if (firstSymbol === numberOfSymbolsDecoded - 1) {
        newSymbols.push(collectiveBitmap);
      } else {
        let i,
            y,
            xMin = 0,
            xMax,
            bitmapWidth,
            symbolBitmap;

        for (i = firstSymbol; i < numberOfSymbolsDecoded; i++) {
          bitmapWidth = symbolWidths[i];
          xMax = xMin + bitmapWidth;
          symbolBitmap = [];

          for (y = 0; y < currentHeight; y++) {
            symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
          }

          newSymbols.push(symbolBitmap);
          xMin = xMax;
        }
      }
    }
  }

  const exportedSymbols = [],
        flags = [];
  let currentFlag = false,
      i,
      ii;
  const totalSymbolsLength = symbols.length + numberOfNewSymbols;

  while (flags.length < totalSymbolsLength) {
    let runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);

    while (runLength--) {
      flags.push(currentFlag);
    }

    currentFlag = !currentFlag;
  }

  for (i = 0, ii = symbols.length; i < ii; i++) {
    if (flags[i]) {
      exportedSymbols.push(symbols[i]);
    }
  }

  for (let j = 0; j < numberOfNewSymbols; i++, j++) {
    if (flags[i]) {
      exportedSymbols.push(newSymbols[j]);
    }
  }

  return exportedSymbols;
}

function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
  if (huffman && refinement) {
    throw new Jbig2Error("refinement with Huffman is not supported");
  }

  const bitmap = [];
  let i, row;

  for (i = 0; i < height; i++) {
    row = new Uint8Array(width);

    if (defaultPixelValue) {
      for (let j = 0; j < width; j++) {
        row[j] = defaultPixelValue;
      }
    }

    bitmap.push(row);
  }

  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  let stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
  let firstS = 0;
  i = 0;

  while (i < numberOfSymbolInstances) {
    const deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
    stripT += deltaT;
    const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
    firstS += deltaFirstS;
    let currentS = firstS;

    do {
      let currentT = 0;

      if (stripSize > 1) {
        currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
      }

      const t = stripSize * stripT + currentT;
      const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
      const applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
      let symbolBitmap = inputSymbols[symbolId];
      let symbolWidth = symbolBitmap[0].length;
      let symbolHeight = symbolBitmap.length;

      if (applyRefinement) {
        const rdw = decodeInteger(contextCache, "IARDW", decoder);
        const rdh = decodeInteger(contextCache, "IARDH", decoder);
        const rdx = decodeInteger(contextCache, "IARDX", decoder);
        const rdy = decodeInteger(contextCache, "IARDY", decoder);
        symbolWidth += rdw;
        symbolHeight += rdh;
        symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
      }

      const offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
      const offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
      let s2, t2, symbolRow;

      if (transposed) {
        for (s2 = 0; s2 < symbolHeight; s2++) {
          row = bitmap[offsetS + s2];

          if (!row) {
            continue;
          }

          symbolRow = symbolBitmap[s2];
          const maxWidth = Math.min(width - offsetT, symbolWidth);

          switch (combinationOperator) {
            case 0:
              for (t2 = 0; t2 < maxWidth; t2++) {
                row[offsetT + t2] |= symbolRow[t2];
              }

              break;

            case 2:
              for (t2 = 0; t2 < maxWidth; t2++) {
                row[offsetT + t2] ^= symbolRow[t2];
              }

              break;

            default:
              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
          }
        }

        currentS += symbolHeight - 1;
      } else {
        for (t2 = 0; t2 < symbolHeight; t2++) {
          row = bitmap[offsetT + t2];

          if (!row) {
            continue;
          }

          symbolRow = symbolBitmap[t2];

          switch (combinationOperator) {
            case 0:
              for (s2 = 0; s2 < symbolWidth; s2++) {
                row[offsetS + s2] |= symbolRow[s2];
              }

              break;

            case 2:
              for (s2 = 0; s2 < symbolWidth; s2++) {
                row[offsetS + s2] ^= symbolRow[s2];
              }

              break;

            default:
              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
          }
        }

        currentS += symbolWidth - 1;
      }

      i++;
      const deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);

      if (deltaS === null) {
        break;
      }

      currentS += deltaS + dsOffset;
    } while (true);
  }

  return bitmap;
}

function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
  const at = [];

  if (!mmr) {
    at.push({
      x: -patternWidth,
      y: 0
    });

    if (template === 0) {
      at.push({
        x: -3,
        y: -1
      });
      at.push({
        x: 2,
        y: -2
      });
      at.push({
        x: -2,
        y: -2
      });
    }
  }

  const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
  const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
  const patterns = [];

  for (let i = 0; i <= maxPatternIndex; i++) {
    const patternBitmap = [];
    const xMin = patternWidth * i;
    const xMax = xMin + patternWidth;

    for (let y = 0; y < patternHeight; y++) {
      patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
    }

    patterns.push(patternBitmap);
  }

  return patterns;
}

function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
  const skip = null;

  if (enableSkip) {
    throw new Jbig2Error("skip is not supported");
  }

  if (combinationOperator !== 0) {
    throw new Jbig2Error(`operator "${combinationOperator}" is not supported in halftone region`);
  }

  const regionBitmap = [];
  let i, j, row;

  for (i = 0; i < regionHeight; i++) {
    row = new Uint8Array(regionWidth);

    if (defaultPixelValue) {
      for (j = 0; j < regionWidth; j++) {
        row[j] = defaultPixelValue;
      }
    }

    regionBitmap.push(row);
  }

  const numberOfPatterns = patterns.length;
  const pattern0 = patterns[0];
  const patternWidth = pattern0[0].length,
        patternHeight = pattern0.length;
  const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
  const at = [];

  if (!mmr) {
    at.push({
      x: template <= 1 ? 3 : 2,
      y: -1
    });

    if (template === 0) {
      at.push({
        x: -3,
        y: -1
      });
      at.push({
        x: 2,
        y: -2
      });
      at.push({
        x: -2,
        y: -2
      });
    }
  }

  const grayScaleBitPlanes = [];
  let mmrInput, bitmap;

  if (mmr) {
    mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
  }

  for (i = bitsPerValue - 1; i >= 0; i--) {
    if (mmr) {
      bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
    } else {
      bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
    }

    grayScaleBitPlanes[i] = bitmap;
  }

  let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;

  for (mg = 0; mg < gridHeight; mg++) {
    for (ng = 0; ng < gridWidth; ng++) {
      bit = 0;
      patternIndex = 0;

      for (j = bitsPerValue - 1; j >= 0; j--) {
        bit = grayScaleBitPlanes[j][mg][ng] ^ bit;
        patternIndex |= bit << j;
      }

      patternBitmap = patterns[patternIndex];
      x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
      y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;

      if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
        for (i = 0; i < patternHeight; i++) {
          regionRow = regionBitmap[y + i];
          patternRow = patternBitmap[i];

          for (j = 0; j < patternWidth; j++) {
            regionRow[x + j] |= patternRow[j];
          }
        }
      } else {
        let regionX, regionY;

        for (i = 0; i < patternHeight; i++) {
          regionY = y + i;

          if (regionY < 0 || regionY >= regionHeight) {
            continue;
          }

          regionRow = regionBitmap[regionY];
          patternRow = patternBitmap[i];

          for (j = 0; j < patternWidth; j++) {
            regionX = x + j;

            if (regionX >= 0 && regionX < regionWidth) {
              regionRow[regionX] |= patternRow[j];
            }
          }
        }
      }
    }
  }

  return regionBitmap;
}

function readSegmentHeader(data, start) {
  const segmentHeader = {};
  segmentHeader.number = (0, _core_utils.readUint32)(data, start);
  const flags = data[start + 4];
  const segmentType = flags & 0x3f;

  if (!SegmentTypes[segmentType]) {
    throw new Jbig2Error("invalid segment type: " + segmentType);
  }

  segmentHeader.type = segmentType;
  segmentHeader.typeName = SegmentTypes[segmentType];
  segmentHeader.deferredNonRetain = !!(flags & 0x80);
  const pageAssociationFieldSize = !!(flags & 0x40);
  const referredFlags = data[start + 5];
  let referredToCount = referredFlags >> 5 & 7;
  const retainBits = [referredFlags & 31];
  let position = start + 6;

  if (referredFlags === 7) {
    referredToCount = (0, _core_utils.readUint32)(data, position - 1) & 0x1fffffff;
    position += 3;
    let bytes = referredToCount + 7 >> 3;
    retainBits[0] = data[position++];

    while (--bytes > 0) {
      retainBits.push(data[position++]);
    }
  } else if (referredFlags === 5 || referredFlags === 6) {
    throw new Jbig2Error("invalid referred-to flags");
  }

  segmentHeader.retainBits = retainBits;
  let referredToSegmentNumberSize = 4;

  if (segmentHeader.number <= 256) {
    referredToSegmentNumberSize = 1;
  } else if (segmentHeader.number <= 65536) {
    referredToSegmentNumberSize = 2;
  }

  const referredTo = [];
  let i, ii;

  for (i = 0; i < referredToCount; i++) {
    let number;

    if (referredToSegmentNumberSize === 1) {
      number = data[position];
    } else if (referredToSegmentNumberSize === 2) {
      number = (0, _core_utils.readUint16)(data, position);
    } else {
      number = (0, _core_utils.readUint32)(data, position);
    }

    referredTo.push(number);
    position += referredToSegmentNumberSize;
  }

  segmentHeader.referredTo = referredTo;

  if (!pageAssociationFieldSize) {
    segmentHeader.pageAssociation = data[position++];
  } else {
    segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position);
    position += 4;
  }

  segmentHeader.length = (0, _core_utils.readUint32)(data, position);
  position += 4;

  if (segmentHeader.length === 0xffffffff) {
    if (segmentType === 38) {
      const genericRegionInfo = readRegionSegmentInformation(data, position);
      const genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
      const genericRegionMmr = !!(genericRegionSegmentFlags & 1);
      const searchPatternLength = 6;
      const searchPattern = new Uint8Array(searchPatternLength);

      if (!genericRegionMmr) {
        searchPattern[0] = 0xff;
        searchPattern[1] = 0xac;
      }

      searchPattern[2] = genericRegionInfo.height >>> 24 & 0xff;
      searchPattern[3] = genericRegionInfo.height >> 16 & 0xff;
      searchPattern[4] = genericRegionInfo.height >> 8 & 0xff;
      searchPattern[5] = genericRegionInfo.height & 0xff;

      for (i = position, ii = data.length; i < ii; i++) {
        let j = 0;

        while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
          j++;
        }

        if (j === searchPatternLength) {
          segmentHeader.length = i + searchPatternLength;
          break;
        }
      }

      if (segmentHeader.length === 0xffffffff) {
        throw new Jbig2Error("segment end was not found");
      }
    } else {
      throw new Jbig2Error("invalid unknown segment length");
    }
  }

  segmentHeader.headerEnd = position;
  return segmentHeader;
}

function readSegments(header, data, start, end) {
  const segments = [];
  let position = start;

  while (position < end) {
    const segmentHeader = readSegmentHeader(data, position);
    position = segmentHeader.headerEnd;
    const segment = {
      header: segmentHeader,
      data
    };

    if (!header.randomAccess) {
      segment.start = position;
      position += segmentHeader.length;
      segment.end = position;
    }

    segments.push(segment);

    if (segmentHeader.type === 51) {
      break;
    }
  }

  if (header.randomAccess) {
    for (let i = 0, ii = segments.length; i < ii; i++) {
      segments[i].start = position;
      position += segments[i].header.length;
      segments[i].end = position;
    }
  }

  return segments;
}

function readRegionSegmentInformation(data, start) {
  return {
    width: (0, _core_utils.readUint32)(data, start),
    height: (0, _core_utils.readUint32)(data, start + 4),
    x: (0, _core_utils.readUint32)(data, start + 8),
    y: (0, _core_utils.readUint32)(data, start + 12),
    combinationOperator: data[start + 16] & 7
  };
}

const RegionSegmentInformationFieldLength = 17;

function processSegment(segment, visitor) {
  const header = segment.header;
  const data = segment.data,
        end = segment.end;
  let position = segment.start;
  let args, at, i, atLength;

  switch (header.type) {
    case 0:
      const dictionary = {};
      const dictionaryFlags = (0, _core_utils.readUint16)(data, position);
      dictionary.huffman = !!(dictionaryFlags & 1);
      dictionary.refinement = !!(dictionaryFlags & 2);
      dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
      dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
      dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
      dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
      dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
      dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
      dictionary.template = dictionaryFlags >> 10 & 3;
      dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
      position += 2;

      if (!dictionary.huffman) {
        atLength = dictionary.template === 0 ? 4 : 1;
        at = [];

        for (i = 0; i < atLength; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }

        dictionary.at = at;
      }

      if (dictionary.refinement && !dictionary.refinementTemplate) {
        at = [];

        for (i = 0; i < 2; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }

        dictionary.refinementAt = at;
      }

      dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position);
      position += 4;
      dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position);
      position += 4;
      args = [dictionary, header.number, header.referredTo, data, position, end];
      break;

    case 6:
    case 7:
      const textRegion = {};
      textRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position);
      position += 2;
      textRegion.huffman = !!(textRegionSegmentFlags & 1);
      textRegion.refinement = !!(textRegionSegmentFlags & 2);
      textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
      textRegion.stripSize = 1 << textRegion.logStripSize;
      textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
      textRegion.transposed = !!(textRegionSegmentFlags & 64);
      textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
      textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
      textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
      textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;

      if (textRegion.huffman) {
        const textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position);
        position += 2;
        textRegion.huffmanFS = textRegionHuffmanFlags & 3;
        textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
        textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
        textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
        textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
        textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
        textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
        textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 0x4000);
      }

      if (textRegion.refinement && !textRegion.refinementTemplate) {
        at = [];

        for (i = 0; i < 2; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }

        textRegion.refinementAt = at;
      }

      textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position);
      position += 4;
      args = [textRegion, header.referredTo, data, position, end];
      break;

    case 16:
      const patternDictionary = {};
      const patternDictionaryFlags = data[position++];
      patternDictionary.mmr = !!(patternDictionaryFlags & 1);
      patternDictionary.template = patternDictionaryFlags >> 1 & 3;
      patternDictionary.patternWidth = data[position++];
      patternDictionary.patternHeight = data[position++];
      patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position);
      position += 4;
      args = [patternDictionary, header.number, data, position, end];
      break;

    case 22:
    case 23:
      const halftoneRegion = {};
      halftoneRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const halftoneRegionFlags = data[position++];
      halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
      halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
      halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
      halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
      halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
      halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position);
      position += 4;
      halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position);
      position += 4;
      halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) & 0xffffffff;
      position += 4;
      halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) & 0xffffffff;
      position += 4;
      halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position);
      position += 2;
      halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position);
      position += 2;
      args = [halftoneRegion, header.referredTo, data, position, end];
      break;

    case 38:
    case 39:
      const genericRegion = {};
      genericRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const genericRegionSegmentFlags = data[position++];
      genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
      genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
      genericRegion.prediction = !!(genericRegionSegmentFlags & 8);

      if (!genericRegion.mmr) {
        atLength = genericRegion.template === 0 ? 4 : 1;
        at = [];

        for (i = 0; i < atLength; i++) {
          at.push({
            x: (0, _core_utils.readInt8)(data, position),
            y: (0, _core_utils.readInt8)(data, position + 1)
          });
          position += 2;
        }

        genericRegion.at = at;
      }

      args = [genericRegion, data, position, end];
      break;

    case 48:
      const pageInfo = {
        width: (0, _core_utils.readUint32)(data, position),
        height: (0, _core_utils.readUint32)(data, position + 4),
        resolutionX: (0, _core_utils.readUint32)(data, position + 8),
        resolutionY: (0, _core_utils.readUint32)(data, position + 12)
      };

      if (pageInfo.height === 0xffffffff) {
        delete pageInfo.height;
      }

      const pageSegmentFlags = data[position + 16];
      (0, _core_utils.readUint16)(data, position + 17);
      pageInfo.lossless = !!(pageSegmentFlags & 1);
      pageInfo.refinement = !!(pageSegmentFlags & 2);
      pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
      pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
      pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
      pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
      args = [pageInfo];
      break;

    case 49:
      break;

    case 50:
      break;

    case 51:
      break;

    case 53:
      args = [header.number, data, position, end];
      break;

    case 62:
      break;

    default:
      throw new Jbig2Error(`segment type ${header.typeName}(${header.type})` + " is not implemented");
  }

  const callbackName = "on" + header.typeName;

  if (callbackName in visitor) {
    visitor[callbackName].apply(visitor, args);
  }
}

function processSegments(segments, visitor) {
  for (let i = 0, ii = segments.length; i < ii; i++) {
    processSegment(segments[i], visitor);
  }
}

function parseJbig2Chunks(chunks) {
  const visitor = new SimpleSegmentVisitor();

  for (let i = 0, ii = chunks.length; i < ii; i++) {
    const chunk = chunks[i];
    const segments = readSegments({}, chunk.data, chunk.start, chunk.end);
    processSegments(segments, visitor);
  }

  return visitor.buffer;
}

function parseJbig2(data) {
  const end = data.length;
  let position = 0;

  if (data[position] !== 0x97 || data[position + 1] !== 0x4a || data[position + 2] !== 0x42 || data[position + 3] !== 0x32 || data[position + 4] !== 0x0d || data[position + 5] !== 0x0a || data[position + 6] !== 0x1a || data[position + 7] !== 0x0a) {
    throw new Jbig2Error("parseJbig2 - invalid header.");
  }

  const header = Object.create(null);
  position += 8;
  const flags = data[position++];
  header.randomAccess = !(flags & 1);

  if (!(flags & 2)) {
    header.numberOfPages = (0, _core_utils.readUint32)(data, position);
    position += 4;
  }

  const segments = readSegments(header, data, position, end);
  const visitor = new SimpleSegmentVisitor();
  processSegments(segments, visitor);
  const {
    width,
    height
  } = visitor.currentPageInfo;
  const bitPacked = visitor.buffer;
  const imgData = new Uint8ClampedArray(width * height);
  let q = 0,
      k = 0;

  for (let i = 0; i < height; i++) {
    let mask = 0,
        buffer;

    for (let j = 0; j < width; j++) {
      if (!mask) {
        mask = 128;
        buffer = bitPacked[k++];
      }

      imgData[q++] = buffer & mask ? 0 : 255;
      mask >>= 1;
    }
  }

  return {
    imgData,
    width,
    height
  };
}

class SimpleSegmentVisitor {
  onPageInformation(info) {
    this.currentPageInfo = info;
    const rowSize = info.width + 7 >> 3;
    const buffer = new Uint8ClampedArray(rowSize * info.height);

    if (info.defaultPixelValue) {
      for (let i = 0, ii = buffer.length; i < ii; i++) {
        buffer[i] = 0xff;
      }
    }

    this.buffer = buffer;
  }

  drawBitmap(regionInfo, bitmap) {
    const pageInfo = this.currentPageInfo;
    const width = regionInfo.width,
          height = regionInfo.height;
    const rowSize = pageInfo.width + 7 >> 3;
    const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
    const buffer = this.buffer;
    const mask0 = 128 >> (regionInfo.x & 7);
    let offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
    let i, j, mask, offset;

    switch (combinationOperator) {
      case 0:
        for (i = 0; i < height; i++) {
          mask = mask0;
          offset = offset0;

          for (j = 0; j < width; j++) {
            if (bitmap[i][j]) {
              buffer[offset] |= mask;
            }

            mask >>= 1;

            if (!mask) {
              mask = 128;
              offset++;
            }
          }

          offset0 += rowSize;
        }

        break;

      case 2:
        for (i = 0; i < height; i++) {
          mask = mask0;
          offset = offset0;

          for (j = 0; j < width; j++) {
            if (bitmap[i][j]) {
              buffer[offset] ^= mask;
            }

            mask >>= 1;

            if (!mask) {
              mask = 128;
              offset++;
            }
          }

          offset0 += rowSize;
        }

        break;

      default:
        throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
    }
  }

  onImmediateGenericRegion(region, data, start, end) {
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }

  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion.apply(this, arguments);
  }

  onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
    let huffmanTables, huffmanInput;

    if (dictionary.huffman) {
      huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
      huffmanInput = new Reader(data, start, end);
    }

    let symbols = this.symbols;

    if (!symbols) {
      this.symbols = symbols = {};
    }

    let inputSymbols = [];

    for (let i = 0, ii = referredSegments.length; i < ii; i++) {
      const referredSymbols = symbols[referredSegments[i]];

      if (referredSymbols) {
        inputSymbols = inputSymbols.concat(referredSymbols);
      }
    }

    const decodingContext = new DecodingContext(data, start, end);
    symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
  }

  onImmediateTextRegion(region, referredSegments, data, start, end) {
    const regionInfo = region.info;
    let huffmanTables, huffmanInput;
    const symbols = this.symbols;
    let inputSymbols = [];

    for (let i = 0, ii = referredSegments.length; i < ii; i++) {
      const referredSymbols = symbols[referredSegments[i]];

      if (referredSymbols) {
        inputSymbols = inputSymbols.concat(referredSymbols);
      }
    }

    const symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);

    if (region.huffman) {
      huffmanInput = new Reader(data, start, end);
      huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
    }

    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
    this.drawBitmap(regionInfo, bitmap);
  }

  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion.apply(this, arguments);
  }

  onPatternDictionary(dictionary, currentSegment, data, start, end) {
    let patterns = this.patterns;

    if (!patterns) {
      this.patterns = patterns = {};
    }

    const decodingContext = new DecodingContext(data, start, end);
    patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
  }

  onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
    const patterns = this.patterns[referredSegments[0]];
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }

  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion.apply(this, arguments);
  }

  onTables(currentSegment, data, start, end) {
    let customTables = this.customTables;

    if (!customTables) {
      this.customTables = customTables = {};
    }

    customTables[currentSegment] = decodeTablesSegment(data, start, end);
  }

}

class HuffmanLine {
  constructor(lineData) {
    if (lineData.length === 2) {
      this.isOOB = true;
      this.rangeLow = 0;
      this.prefixLength = lineData[0];
      this.rangeLength = 0;
      this.prefixCode = lineData[1];
      this.isLowerRange = false;
    } else {
      this.isOOB = false;
      this.rangeLow = lineData[0];
      this.prefixLength = lineData[1];
      this.rangeLength = lineData[2];
      this.prefixCode = lineData[3];
      this.isLowerRange = lineData[4] === "lower";
    }
  }

}

class HuffmanTreeNode {
  constructor(line) {
    this.children = [];

    if (line) {
      this.isLeaf = true;
      this.rangeLength = line.rangeLength;
      this.rangeLow = line.rangeLow;
      this.isLowerRange = line.isLowerRange;
      this.isOOB = line.isOOB;
    } else {
      this.isLeaf = false;
    }
  }

  buildTree(line, shift) {
    const bit = line.prefixCode >> shift & 1;

    if (shift <= 0) {
      this.children[bit] = new HuffmanTreeNode(line);
    } else {
      let node = this.children[bit];

      if (!node) {
        this.children[bit] = node = new HuffmanTreeNode(null);
      }

      node.buildTree(line, shift - 1);
    }
  }

  decodeNode(reader) {
    if (this.isLeaf) {
      if (this.isOOB) {
        return null;
      }

      const htOffset = reader.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
    }

    const node = this.children[reader.readBit()];

    if (!node) {
      throw new Jbig2Error("invalid Huffman data");
    }

    return node.decodeNode(reader);
  }

}

class HuffmanTable {
  constructor(lines, prefixCodesDone) {
    if (!prefixCodesDone) {
      this.assignPrefixCodes(lines);
    }

    this.rootNode = new HuffmanTreeNode(null);

    for (let i = 0, ii = lines.length; i < ii; i++) {
      const line = lines[i];

      if (line.prefixLength > 0) {
        this.rootNode.buildTree(line, line.prefixLength - 1);
      }
    }
  }

  decode(reader) {
    return this.rootNode.decodeNode(reader);
  }

  assignPrefixCodes(lines) {
    const linesLength = lines.length;
    let prefixLengthMax = 0;

    for (let i = 0; i < linesLength; i++) {
      prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
    }

    const histogram = new Uint32Array(prefixLengthMax + 1);

    for (let i = 0; i < linesLength; i++) {
      histogram[lines[i].prefixLength]++;
    }

    let currentLength = 1,
        firstCode = 0,
        currentCode,
        currentTemp,
        line;
    histogram[0] = 0;

    while (currentLength <= prefixLengthMax) {
      firstCode = firstCode + histogram[currentLength - 1] << 1;
      currentCode = firstCode;
      currentTemp = 0;

      while (currentTemp < linesLength) {
        line = lines[currentTemp];

        if (line.prefixLength === currentLength) {
          line.prefixCode = currentCode;
          currentCode++;
        }

        currentTemp++;
      }

      currentLength++;
    }
  }

}

function decodeTablesSegment(data, start, end) {
  const flags = data[start];
  const lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 0xffffffff;
  const highestValue = (0, _core_utils.readUint32)(data, start + 5) & 0xffffffff;
  const reader = new Reader(data, start + 9, end);
  const prefixSizeBits = (flags >> 1 & 7) + 1;
  const rangeSizeBits = (flags >> 4 & 7) + 1;
  const lines = [];
  let prefixLength,
      rangeLength,
      currentRangeLow = lowestValue;

  do {
    prefixLength = reader.readBits(prefixSizeBits);
    rangeLength = reader.readBits(rangeSizeBits);
    lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
    currentRangeLow += 1 << rangeLength;
  } while (currentRangeLow < highestValue);

  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));

  if (flags & 1) {
    prefixLength = reader.readBits(prefixSizeBits);
    lines.push(new HuffmanLine([prefixLength, 0]));
  }

  return new HuffmanTable(lines, false);
}

const standardTablesCache = {};

function getStandardTable(number) {
  let table = standardTablesCache[number];

  if (table) {
    return table;
  }

  let lines;

  switch (number) {
    case 1:
      lines = [[0, 1, 4, 0x0], [16, 2, 8, 0x2], [272, 3, 16, 0x6], [65808, 3, 32, 0x7]];
      break;

    case 2:
      lines = [[0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [75, 6, 32, 0x3e], [6, 0x3f]];
      break;

    case 3:
      lines = [[-256, 8, 8, 0xfe], [0, 1, 0, 0x0], [1, 2, 0, 0x2], [2, 3, 0, 0x6], [3, 4, 3, 0xe], [11, 5, 6, 0x1e], [-257, 8, 32, 0xff, "lower"], [75, 7, 32, 0x7e], [6, 0x3e]];
      break;

    case 4:
      lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [76, 5, 32, 0x1f]];
      break;

    case 5:
      lines = [[-255, 7, 8, 0x7e], [1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 0, 0x6], [4, 4, 3, 0xe], [12, 5, 6, 0x1e], [-256, 7, 32, 0x7f, "lower"], [76, 6, 32, 0x3e]];
      break;

    case 6:
      lines = [[-2048, 5, 10, 0x1c], [-1024, 4, 9, 0x8], [-512, 4, 8, 0x9], [-256, 4, 7, 0xa], [-128, 5, 6, 0x1d], [-64, 5, 5, 0x1e], [-32, 4, 5, 0xb], [0, 2, 7, 0x0], [128, 3, 7, 0x2], [256, 3, 8, 0x3], [512, 4, 9, 0xc], [1024, 4, 10, 0xd], [-2049, 6, 32, 0x3e, "lower"], [2048, 6, 32, 0x3f]];
      break;

    case 7:
      lines = [[-1024, 4, 9, 0x8], [-512, 3, 8, 0x0], [-256, 4, 7, 0x9], [-128, 5, 6, 0x1a], [-64, 5, 5, 0x1b], [-32, 4, 5, 0xa], [0, 4, 5, 0xb], [32, 5, 5, 0x1c], [64, 5, 6, 0x1d], [128, 4, 7, 0xc], [256, 3, 8, 0x1], [512, 3, 9, 0x2], [1024, 3, 10, 0x3], [-1025, 5, 32, 0x1e, "lower"], [2048, 5, 32, 0x1f]];
      break;

    case 8:
      lines = [[-15, 8, 3, 0xfc], [-7, 9, 1, 0x1fc], [-5, 8, 1, 0xfd], [-3, 9, 0, 0x1fd], [-2, 7, 0, 0x7c], [-1, 4, 0, 0xa], [0, 2, 1, 0x0], [2, 5, 0, 0x1a], [3, 6, 0, 0x3a], [4, 3, 4, 0x4], [20, 6, 1, 0x3b], [22, 4, 4, 0xb], [38, 4, 5, 0xc], [70, 5, 6, 0x1b], [134, 5, 7, 0x1c], [262, 6, 7, 0x3c], [390, 7, 8, 0x7d], [646, 6, 10, 0x3d], [-16, 9, 32, 0x1fe, "lower"], [1670, 9, 32, 0x1ff], [2, 0x1]];
      break;

    case 9:
      lines = [[-31, 8, 4, 0xfc], [-15, 9, 2, 0x1fc], [-11, 8, 2, 0xfd], [-7, 9, 1, 0x1fd], [-5, 7, 1, 0x7c], [-3, 4, 1, 0xa], [-1, 3, 1, 0x2], [1, 3, 1, 0x3], [3, 5, 1, 0x1a], [5, 6, 1, 0x3a], [7, 3, 5, 0x4], [39, 6, 2, 0x3b], [43, 4, 5, 0xb], [75, 4, 6, 0xc], [139, 5, 7, 0x1b], [267, 5, 8, 0x1c], [523, 6, 8, 0x3c], [779, 7, 9, 0x7d], [1291, 6, 11, 0x3d], [-32, 9, 32, 0x1fe, "lower"], [3339, 9, 32, 0x1ff], [2, 0x0]];
      break;

    case 10:
      lines = [[-21, 7, 4, 0x7a], [-5, 8, 0, 0xfc], [-4, 7, 0, 0x7b], [-3, 5, 0, 0x18], [-2, 2, 2, 0x0], [2, 5, 0, 0x19], [3, 6, 0, 0x36], [4, 7, 0, 0x7c], [5, 8, 0, 0xfd], [6, 2, 6, 0x1], [70, 5, 5, 0x1a], [102, 6, 5, 0x37], [134, 6, 6, 0x38], [198, 6, 7, 0x39], [326, 6, 8, 0x3a], [582, 6, 9, 0x3b], [1094, 6, 10, 0x3c], [2118, 7, 11, 0x7d], [-22, 8, 32, 0xfe, "lower"], [4166, 8, 32, 0xff], [2, 0x2]];
      break;

    case 11:
      lines = [[1, 1, 0, 0x0], [2, 2, 1, 0x2], [4, 4, 0, 0xc], [5, 4, 1, 0xd], [7, 5, 1, 0x1c], [9, 5, 2, 0x1d], [13, 6, 2, 0x3c], [17, 7, 2, 0x7a], [21, 7, 3, 0x7b], [29, 7, 4, 0x7c], [45, 7, 5, 0x7d], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
      break;

    case 12:
      lines = [[1, 1, 0, 0x0], [2, 2, 0, 0x2], [3, 3, 1, 0x6], [5, 5, 0, 0x1c], [6, 5, 1, 0x1d], [8, 6, 1, 0x3c], [10, 7, 0, 0x7a], [11, 7, 1, 0x7b], [13, 7, 2, 0x7c], [17, 7, 3, 0x7d], [25, 7, 4, 0x7e], [41, 8, 5, 0xfe], [73, 8, 32, 0xff]];
      break;

    case 13:
      lines = [[1, 1, 0, 0x0], [2, 3, 0, 0x4], [3, 4, 0, 0xc], [4, 5, 0, 0x1c], [5, 4, 1, 0xd], [7, 3, 3, 0x5], [15, 6, 1, 0x3a], [17, 6, 2, 0x3b], [21, 6, 3, 0x3c], [29, 6, 4, 0x3d], [45, 6, 5, 0x3e], [77, 7, 6, 0x7e], [141, 7, 32, 0x7f]];
      break;

    case 14:
      lines = [[-2, 3, 0, 0x4], [-1, 3, 0, 0x5], [0, 1, 0, 0x0], [1, 3, 0, 0x6], [2, 3, 0, 0x7]];
      break;

    case 15:
      lines = [[-24, 7, 4, 0x7c], [-8, 6, 2, 0x3c], [-4, 5, 1, 0x1c], [-2, 4, 0, 0xc], [-1, 3, 0, 0x4], [0, 1, 0, 0x0], [1, 3, 0, 0x5], [2, 4, 0, 0xd], [3, 5, 1, 0x1d], [5, 6, 2, 0x3d], [9, 7, 4, 0x7d], [-25, 7, 32, 0x7e, "lower"], [25, 7, 32, 0x7f]];
      break;

    default:
      throw new Jbig2Error(`standard table B.${number} does not exist`);
  }

  for (let i = 0, ii = lines.length; i < ii; i++) {
    lines[i] = new HuffmanLine(lines[i]);
  }

  table = new HuffmanTable(lines, true);
  standardTablesCache[number] = table;
  return table;
}

class Reader {
  constructor(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
    this.position = start;
    this.shift = -1;
    this.currentByte = 0;
  }

  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end) {
        throw new Jbig2Error("end of data while reading bit");
      }

      this.currentByte = this.data[this.position++];
      this.shift = 7;
    }

    const bit = this.currentByte >> this.shift & 1;
    this.shift--;
    return bit;
  }

  readBits(numBits) {
    let result = 0,
        i;

    for (i = numBits - 1; i >= 0; i--) {
      result |= this.readBit() << i;
    }

    return result;
  }

  byteAlign() {
    this.shift = -1;
  }

  next() {
    if (this.position >= this.end) {
      return -1;
    }

    return this.data[this.position++];
  }

}

function getCustomHuffmanTable(index, referredTo, customTables) {
  let currentIndex = 0;

  for (let i = 0, ii = referredTo.length; i < ii; i++) {
    const table = customTables[referredTo[i]];

    if (table) {
      if (index === currentIndex) {
        return table;
      }

      currentIndex++;
    }
  }

  throw new Jbig2Error("can't find custom Huffman table");
}

function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
  const codes = [];

  for (let i = 0; i <= 34; i++) {
    const codeLength = reader.readBits(4);
    codes.push(new HuffmanLine([i, codeLength, 0, 0]));
  }

  const runCodesTable = new HuffmanTable(codes, false);
  codes.length = 0;

  for (let i = 0; i < numberOfSymbols;) {
    const codeLength = runCodesTable.decode(reader);

    if (codeLength >= 32) {
      let repeatedLength, numberOfRepeats, j;

      switch (codeLength) {
        case 32:
          if (i === 0) {
            throw new Jbig2Error("no previous value in symbol ID table");
          }

          numberOfRepeats = reader.readBits(2) + 3;
          repeatedLength = codes[i - 1].prefixLength;
          break;

        case 33:
          numberOfRepeats = reader.readBits(3) + 3;
          repeatedLength = 0;
          break;

        case 34:
          numberOfRepeats = reader.readBits(7) + 11;
          repeatedLength = 0;
          break;

        default:
          throw new Jbig2Error("invalid code length in symbol ID table");
      }

      for (j = 0; j < numberOfRepeats; j++) {
        codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));
        i++;
      }
    } else {
      codes.push(new HuffmanLine([i, codeLength, 0, 0]));
      i++;
    }
  }

  reader.byteAlign();
  const symbolIDTable = new HuffmanTable(codes, false);
  let customIndex = 0,
      tableFirstS,
      tableDeltaS,
      tableDeltaT;

  switch (textRegion.huffmanFS) {
    case 0:
    case 1:
      tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
      break;

    case 3:
      tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;

    default:
      throw new Jbig2Error("invalid Huffman FS selector");
  }

  switch (textRegion.huffmanDS) {
    case 0:
    case 1:
    case 2:
      tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
      break;

    case 3:
      tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;

    default:
      throw new Jbig2Error("invalid Huffman DS selector");
  }

  switch (textRegion.huffmanDT) {
    case 0:
    case 1:
    case 2:
      tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
      break;

    case 3:
      tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;

    default:
      throw new Jbig2Error("invalid Huffman DT selector");
  }

  if (textRegion.refinement) {
    throw new Jbig2Error("refinement with Huffman is not supported");
  }

  return {
    symbolIDTable,
    tableFirstS,
    tableDeltaS,
    tableDeltaT
  };
}

function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
  let customIndex = 0,
      tableDeltaHeight,
      tableDeltaWidth;

  switch (dictionary.huffmanDHSelector) {
    case 0:
    case 1:
      tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
      break;

    case 3:
      tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;

    default:
      throw new Jbig2Error("invalid Huffman DH selector");
  }

  switch (dictionary.huffmanDWSelector) {
    case 0:
    case 1:
      tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
      break;

    case 3:
      tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;

    default:
      throw new Jbig2Error("invalid Huffman DW selector");
  }

  let tableBitmapSize, tableAggregateInstances;

  if (dictionary.bitmapSizeSelector) {
    tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
    customIndex++;
  } else {
    tableBitmapSize = getStandardTable(1);
  }

  if (dictionary.aggregationInstancesSelector) {
    tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
  } else {
    tableAggregateInstances = getStandardTable(1);
  }

  return {
    tableDeltaHeight,
    tableDeltaWidth,
    tableBitmapSize,
    tableAggregateInstances
  };
}

function readUncompressedBitmap(reader, width, height) {
  const bitmap = [];

  for (let y = 0; y < height; y++) {
    const row = new Uint8Array(width);
    bitmap.push(row);

    for (let x = 0; x < width; x++) {
      row[x] = reader.readBit();
    }

    reader.byteAlign();
  }

  return bitmap;
}

function decodeMMRBitmap(input, width, height, endOfBlock) {
  const params = {
    K: -1,
    Columns: width,
    Rows: height,
    BlackIs1: true,
    EndOfBlock: endOfBlock
  };
  const decoder = new _ccitt.CCITTFaxDecoder(input, params);
  const bitmap = [];
  let currentByte,
      eof = false;

  for (let y = 0; y < height; y++) {
    const row = new Uint8Array(width);
    bitmap.push(row);
    let shift = -1;

    for (let x = 0; x < width; x++) {
      if (shift < 0) {
        currentByte = decoder.readNextChar();

        if (currentByte === -1) {
          currentByte = 0;
          eof = true;
        }

        shift = 7;
      }

      row[x] = currentByte >> shift & 1;
      shift--;
    }
  }

  if (endOfBlock && !eof) {
    const lookForEOFLimit = 5;

    for (let i = 0; i < lookForEOFLimit; i++) {
      if (decoder.readNextChar() === -1) {
        break;
      }
    }
  }

  return bitmap;
}

class Jbig2Image {
  parseChunks(chunks) {
    return parseJbig2Chunks(chunks);
  }

  parse(data) {
    const {
      imgData,
      width,
      height
    } = parseJbig2(data);
    this.width = width;
    this.height = height;
    return imgData;
  }

}

exports.Jbig2Image = Jbig2Image;

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ArithmeticDecoder = void 0;
const QeTable = [{
  qe: 0x5601,
  nmps: 1,
  nlps: 1,
  switchFlag: 1
}, {
  qe: 0x3401,
  nmps: 2,
  nlps: 6,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 3,
  nlps: 9,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 4,
  nlps: 12,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 5,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 38,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 7,
  nlps: 6,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 8,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 9,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 10,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 11,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 12,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 13,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 29,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 15,
  nlps: 14,
  switchFlag: 1
}, {
  qe: 0x5401,
  nmps: 16,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 0x5101,
  nmps: 17,
  nlps: 15,
  switchFlag: 0
}, {
  qe: 0x4801,
  nmps: 18,
  nlps: 16,
  switchFlag: 0
}, {
  qe: 0x3801,
  nmps: 19,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 0x3401,
  nmps: 20,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 0x3001,
  nmps: 21,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2801,
  nmps: 22,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 0x2401,
  nmps: 23,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 0x2201,
  nmps: 24,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 0x1c01,
  nmps: 25,
  nlps: 22,
  switchFlag: 0
}, {
  qe: 0x1801,
  nmps: 26,
  nlps: 23,
  switchFlag: 0
}, {
  qe: 0x1601,
  nmps: 27,
  nlps: 24,
  switchFlag: 0
}, {
  qe: 0x1401,
  nmps: 28,
  nlps: 25,
  switchFlag: 0
}, {
  qe: 0x1201,
  nmps: 29,
  nlps: 26,
  switchFlag: 0
}, {
  qe: 0x1101,
  nmps: 30,
  nlps: 27,
  switchFlag: 0
}, {
  qe: 0x0ac1,
  nmps: 31,
  nlps: 28,
  switchFlag: 0
}, {
  qe: 0x09c1,
  nmps: 32,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 0x08a1,
  nmps: 33,
  nlps: 30,
  switchFlag: 0
}, {
  qe: 0x0521,
  nmps: 34,
  nlps: 31,
  switchFlag: 0
}, {
  qe: 0x0441,
  nmps: 35,
  nlps: 32,
  switchFlag: 0
}, {
  qe: 0x02a1,
  nmps: 36,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 0x0221,
  nmps: 37,
  nlps: 34,
  switchFlag: 0
}, {
  qe: 0x0141,
  nmps: 38,
  nlps: 35,
  switchFlag: 0
}, {
  qe: 0x0111,
  nmps: 39,
  nlps: 36,
  switchFlag: 0
}, {
  qe: 0x0085,
  nmps: 40,
  nlps: 37,
  switchFlag: 0
}, {
  qe: 0x0049,
  nmps: 41,
  nlps: 38,
  switchFlag: 0
}, {
  qe: 0x0025,
  nmps: 42,
  nlps: 39,
  switchFlag: 0
}, {
  qe: 0x0015,
  nmps: 43,
  nlps: 40,
  switchFlag: 0
}, {
  qe: 0x0009,
  nmps: 44,
  nlps: 41,
  switchFlag: 0
}, {
  qe: 0x0005,
  nmps: 45,
  nlps: 42,
  switchFlag: 0
}, {
  qe: 0x0001,
  nmps: 45,
  nlps: 43,
  switchFlag: 0
}, {
  qe: 0x5601,
  nmps: 46,
  nlps: 46,
  switchFlag: 0
}];

class ArithmeticDecoder {
  constructor(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;
    this.chigh = data[start];
    this.clow = 0;
    this.byteIn();
    this.chigh = this.chigh << 7 & 0xffff | this.clow >> 9 & 0x7f;
    this.clow = this.clow << 7 & 0xffff;
    this.ct -= 7;
    this.a = 0x8000;
  }

  byteIn() {
    const data = this.data;
    let bp = this.bp;

    if (data[bp] === 0xff) {
      if (data[bp + 1] > 0x8f) {
        this.clow += 0xff00;
        this.ct = 8;
      } else {
        bp++;
        this.clow += data[bp] << 9;
        this.ct = 7;
        this.bp = bp;
      }
    } else {
      bp++;
      this.clow += bp < this.dataEnd ? data[bp] << 8 : 0xff00;
      this.ct = 8;
      this.bp = bp;
    }

    if (this.clow > 0xffff) {
      this.chigh += this.clow >> 16;
      this.clow &= 0xffff;
    }
  }

  readBit(contexts, pos) {
    let cx_index = contexts[pos] >> 1,
        cx_mps = contexts[pos] & 1;
    const qeTableIcx = QeTable[cx_index];
    const qeIcx = qeTableIcx.qe;
    let d;
    let a = this.a - qeIcx;

    if (this.chigh < qeIcx) {
      if (a < qeIcx) {
        a = qeIcx;
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      } else {
        a = qeIcx;
        d = 1 ^ cx_mps;

        if (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }

        cx_index = qeTableIcx.nlps;
      }
    } else {
      this.chigh -= qeIcx;

      if ((a & 0x8000) !== 0) {
        this.a = a;
        return cx_mps;
      }

      if (a < qeIcx) {
        d = 1 ^ cx_mps;

        if (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }

        cx_index = qeTableIcx.nlps;
      } else {
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      }
    }

    do {
      if (this.ct === 0) {
        this.byteIn();
      }

      a <<= 1;
      this.chigh = this.chigh << 1 & 0xffff | this.clow >> 15 & 1;
      this.clow = this.clow << 1 & 0xffff;
      this.ct--;
    } while ((a & 0x8000) === 0);

    this.a = a;
    contexts[pos] = cx_index << 1 | cx_mps;
    return d;
  }

}

exports.ArithmeticDecoder = ArithmeticDecoder;

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpegStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

var _primitives = __w_pdfjs_require__(5);

var _jpg = __w_pdfjs_require__(28);

var _util = __w_pdfjs_require__(2);

class JpegStream extends _decode_stream.DecodeStream {
  constructor(stream, maybeLength, params) {
    let ch;

    while ((ch = stream.getByte()) !== -1) {
      if (ch === 0xff) {
        stream.skip(-1);
        break;
      }
    }

    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }

  get bytes() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }

  ensureBuffer(requested) {}

  readBlock() {
    if (this.eof) {
      return;
    }

    const jpegOptions = {
      decodeTransform: undefined,
      colorTransform: undefined
    };
    const decodeArr = this.dict.getArray("Decode", "D");

    if (this.forceRGB && Array.isArray(decodeArr)) {
      const bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
      const decodeArrLength = decodeArr.length;
      const transform = new Int32Array(decodeArrLength);
      let transformNeeded = false;
      const maxValue = (1 << bitsPerComponent) - 1;

      for (let i = 0; i < decodeArrLength; i += 2) {
        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
        transform[i + 1] = decodeArr[i] * maxValue | 0;

        if (transform[i] !== 256 || transform[i + 1] !== 0) {
          transformNeeded = true;
        }
      }

      if (transformNeeded) {
        jpegOptions.decodeTransform = transform;
      }
    }

    if ((0, _primitives.isDict)(this.params)) {
      const colorTransform = this.params.get("ColorTransform");

      if (Number.isInteger(colorTransform)) {
        jpegOptions.colorTransform = colorTransform;
      }
    }

    const jpegImage = new _jpg.JpegImage(jpegOptions);
    jpegImage.parse(this.bytes);
    const data = jpegImage.getData({
      width: this.drawWidth,
      height: this.drawHeight,
      forceRGB: this.forceRGB,
      isSourcePDF: true
    });
    this.buffer = data;
    this.bufferLength = data.length;
    this.eof = true;
  }

}

exports.JpegStream = JpegStream;

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpegImage = void 0;

var _util = __w_pdfjs_require__(2);

var _core_utils = __w_pdfjs_require__(9);

class JpegError extends _util.BaseException {
  constructor(msg) {
    super(`JPEG error: ${msg}`);
  }

}

class DNLMarkerError extends _util.BaseException {
  constructor(message, scanLines) {
    super(message);
    this.scanLines = scanLines;
  }

}

class EOIMarkerError extends _util.BaseException {}

const dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
const dctCos1 = 4017;
const dctSin1 = 799;
const dctCos3 = 3406;
const dctSin3 = 2276;
const dctCos6 = 1567;
const dctSin6 = 3784;
const dctSqrt2 = 5793;
const dctSqrt1d2 = 2896;

function buildHuffmanTable(codeLengths, values) {
  let k = 0,
      i,
      j,
      length = 16;

  while (length > 0 && !codeLengths[length - 1]) {
    length--;
  }

  const code = [{
    children: [],
    index: 0
  }];
  let p = code[0],
      q;

  for (i = 0; i < length; i++) {
    for (j = 0; j < codeLengths[i]; j++) {
      p = code.pop();
      p.children[p.index] = values[k];

      while (p.index > 0) {
        p = code.pop();
      }

      p.index++;
      code.push(p);

      while (code.length <= i) {
        code.push(q = {
          children: [],
          index: 0
        });
        p.children[p.index] = q.children;
        p = q;
      }

      k++;
    }

    if (i + 1 < length) {
      code.push(q = {
        children: [],
        index: 0
      });
      p.children[p.index] = q.children;
      p = q;
    }
  }

  return code[0].children;
}

function getBlockBufferOffset(component, row, col) {
  return 64 * ((component.blocksPerLine + 1) * row + col);
}

function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {
  const mcusPerLine = frame.mcusPerLine;
  const progressive = frame.progressive;
  const startOffset = offset;
  let bitsData = 0,
      bitsCount = 0;

  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return bitsData >> bitsCount & 1;
    }

    bitsData = data[offset++];

    if (bitsData === 0xff) {
      const nextByte = data[offset++];

      if (nextByte) {
        if (nextByte === 0xdc && parseDNLMarker) {
          offset += 2;
          const scanLines = (0, _core_utils.readUint16)(data, offset);
          offset += 2;

          if (scanLines > 0 && scanLines !== frame.scanLines) {
            throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
          }
        } else if (nextByte === 0xd9) {
          if (parseDNLMarker) {
            const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);

            if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 10) {
              throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, " + "possibly caused by incorrect `scanLines` parameter", maybeScanLines);
            }
          }

          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }

        throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);
      }
    }

    bitsCount = 7;
    return bitsData >>> 7;
  }

  function decodeHuffman(tree) {
    let node = tree;

    while (true) {
      node = node[readBit()];

      switch (typeof node) {
        case "number":
          return node;

        case "object":
          continue;
      }

      throw new JpegError("invalid huffman sequence");
    }
  }

  function receive(length) {
    let n = 0;

    while (length > 0) {
      n = n << 1 | readBit();
      length--;
    }

    return n;
  }

  function receiveAndExtend(length) {
    if (length === 1) {
      return readBit() === 1 ? 1 : -1;
    }

    const n = receive(length);

    if (n >= 1 << length - 1) {
      return n;
    }

    return n + (-1 << length) + 1;
  }

  function decodeBaseline(component, blockOffset) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t);
    component.blockData[blockOffset] = component.pred += diff;
    let k = 1;

    while (k < 64) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15,
            r = rs >> 4;

      if (s === 0) {
        if (r < 15) {
          break;
        }

        k += 16;
        continue;
      }

      k += r;
      const z = dctZigZag[k];
      component.blockData[blockOffset + z] = receiveAndExtend(s);
      k++;
    }
  }

  function decodeDCFirst(component, blockOffset) {
    const t = decodeHuffman(component.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
    component.blockData[blockOffset] = component.pred += diff;
  }

  function decodeDCSuccessive(component, blockOffset) {
    component.blockData[blockOffset] |= readBit() << successive;
  }

  let eobrun = 0;

  function decodeACFirst(component, blockOffset) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }

    let k = spectralStart;
    const e = spectralEnd;

    while (k <= e) {
      const rs = decodeHuffman(component.huffmanTableAC);
      const s = rs & 15,
            r = rs >> 4;

      if (s === 0) {
        if (r < 15) {
          eobrun = receive(r) + (1 << r) - 1;
          break;
        }

        k += 16;
        continue;
      }

      k += r;
      const z = dctZigZag[k];
      component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);
      k++;
    }
  }

  let successiveACState = 0,
      successiveACNextValue;

  function decodeACSuccessive(component, blockOffset) {
    let k = spectralStart;
    const e = spectralEnd;
    let r = 0;
    let s;
    let rs;

    while (k <= e) {
      const offsetZ = blockOffset + dctZigZag[k];
      const sign = component.blockData[offsetZ] < 0 ? -1 : 1;

      switch (successiveACState) {
        case 0:
          rs = decodeHuffman(component.huffmanTableAC);
          s = rs & 15;
          r = rs >> 4;

          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1) {
              throw new JpegError("invalid ACn encoding");
            }

            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }

          continue;

        case 1:
        case 2:
          if (component.blockData[offsetZ]) {
            component.blockData[offsetZ] += sign * (readBit() << successive);
          } else {
            r--;

            if (r === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }

          break;

        case 3:
          if (component.blockData[offsetZ]) {
            component.blockData[offsetZ] += sign * (readBit() << successive);
          } else {
            component.blockData[offsetZ] = successiveACNextValue << successive;
            successiveACState = 0;
          }

          break;

        case 4:
          if (component.blockData[offsetZ]) {
            component.blockData[offsetZ] += sign * (readBit() << successive);
          }

          break;
      }

      k++;
    }

    if (successiveACState === 4) {
      eobrun--;

      if (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }

  let blockRow = 0;

  function decodeMcu(component, decode, mcu, row, col) {
    const mcuRow = mcu / mcusPerLine | 0;
    const mcuCol = mcu % mcusPerLine;
    blockRow = mcuRow * component.v + row;
    const blockCol = mcuCol * component.h + col;
    const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
    decode(component, blockOffset);
  }

  function decodeBlock(component, decode, mcu) {
    blockRow = mcu / component.blocksPerLine | 0;
    const blockCol = mcu % component.blocksPerLine;
    const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
    decode(component, blockOffset);
  }

  const componentsLength = components.length;
  let component, i, j, k, n;
  let decodeFn;

  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }

  let mcu = 0,
      fileMarker;
  let mcuExpected;

  if (componentsLength === 1) {
    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
  } else {
    mcuExpected = mcusPerLine * frame.mcusPerColumn;
  }

  let h, v;

  while (mcu <= mcuExpected) {
    const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;

    if (mcuToRead > 0) {
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }

      eobrun = 0;

      if (componentsLength === 1) {
        component = components[0];

        for (n = 0; n < mcuToRead; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < mcuToRead; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;

            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }

          mcu++;
        }
      }
    }

    bitsCount = 0;
    fileMarker = findNextFileMarker(data, offset);

    if (!fileMarker) {
      break;
    }

    if (fileMarker.invalid) {
      const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
      (0, _util.warn)(`decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`);
      offset = fileMarker.offset;
    }

    if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {
      offset += 2;
    } else {
      break;
    }
  }

  return offset - startOffset;
}

function quantizeAndInverse(component, blockBufferOffset, p) {
  const qt = component.quantizationTable,
        blockData = component.blockData;
  let v0, v1, v2, v3, v4, v5, v6, v7;
  let p0, p1, p2, p3, p4, p5, p6, p7;
  let t;

  if (!qt) {
    throw new JpegError("missing required Quantization Table.");
  }

  for (let row = 0; row < 64; row += 8) {
    p0 = blockData[blockBufferOffset + row];
    p1 = blockData[blockBufferOffset + row + 1];
    p2 = blockData[blockBufferOffset + row + 2];
    p3 = blockData[blockBufferOffset + row + 3];
    p4 = blockData[blockBufferOffset + row + 4];
    p5 = blockData[blockBufferOffset + row + 5];
    p6 = blockData[blockBufferOffset + row + 6];
    p7 = blockData[blockBufferOffset + row + 7];
    p0 *= qt[row];

    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 512 >> 10;
      p[row] = t;
      p[row + 1] = t;
      p[row + 2] = t;
      p[row + 3] = t;
      p[row + 4] = t;
      p[row + 5] = t;
      p[row + 6] = t;
      p[row + 7] = t;
      continue;
    }

    p1 *= qt[row + 1];
    p2 *= qt[row + 2];
    p3 *= qt[row + 3];
    p4 *= qt[row + 4];
    p5 *= qt[row + 5];
    p6 *= qt[row + 6];
    p7 *= qt[row + 7];
    v0 = dctSqrt2 * p0 + 128 >> 8;
    v1 = dctSqrt2 * p4 + 128 >> 8;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
    v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
    v5 = p3 << 4;
    v6 = p5 << 4;
    v0 = v0 + v1 + 1 >> 1;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p[row] = v0 + v7;
    p[row + 7] = v0 - v7;
    p[row + 1] = v1 + v6;
    p[row + 6] = v1 - v6;
    p[row + 2] = v2 + v5;
    p[row + 5] = v2 - v5;
    p[row + 3] = v3 + v4;
    p[row + 4] = v3 - v4;
  }

  for (let col = 0; col < 8; ++col) {
    p0 = p[col];
    p1 = p[col + 8];
    p2 = p[col + 16];
    p3 = p[col + 24];
    p4 = p[col + 32];
    p5 = p[col + 40];
    p6 = p[col + 48];
    p7 = p[col + 56];

    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 8192 >> 14;

      if (t < -2040) {
        t = 0;
      } else if (t >= 2024) {
        t = 255;
      } else {
        t = t + 2056 >> 4;
      }

      blockData[blockBufferOffset + col] = t;
      blockData[blockBufferOffset + col + 8] = t;
      blockData[blockBufferOffset + col + 16] = t;
      blockData[blockBufferOffset + col + 24] = t;
      blockData[blockBufferOffset + col + 32] = t;
      blockData[blockBufferOffset + col + 40] = t;
      blockData[blockBufferOffset + col + 48] = t;
      blockData[blockBufferOffset + col + 56] = t;
      continue;
    }

    v0 = dctSqrt2 * p0 + 2048 >> 12;
    v1 = dctSqrt2 * p4 + 2048 >> 12;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
    v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
    v5 = p3;
    v6 = p5;
    v0 = (v0 + v1 + 1 >> 1) + 4112;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p0 = v0 + v7;
    p7 = v0 - v7;
    p1 = v1 + v6;
    p6 = v1 - v6;
    p2 = v2 + v5;
    p5 = v2 - v5;
    p3 = v3 + v4;
    p4 = v3 - v4;

    if (p0 < 16) {
      p0 = 0;
    } else if (p0 >= 4080) {
      p0 = 255;
    } else {
      p0 >>= 4;
    }

    if (p1 < 16) {
      p1 = 0;
    } else if (p1 >= 4080) {
      p1 = 255;
    } else {
      p1 >>= 4;
    }

    if (p2 < 16) {
      p2 = 0;
    } else if (p2 >= 4080) {
      p2 = 255;
    } else {
      p2 >>= 4;
    }

    if (p3 < 16) {
      p3 = 0;
    } else if (p3 >= 4080) {
      p3 = 255;
    } else {
      p3 >>= 4;
    }

    if (p4 < 16) {
      p4 = 0;
    } else if (p4 >= 4080) {
      p4 = 255;
    } else {
      p4 >>= 4;
    }

    if (p5 < 16) {
      p5 = 0;
    } else if (p5 >= 4080) {
      p5 = 255;
    } else {
      p5 >>= 4;
    }

    if (p6 < 16) {
      p6 = 0;
    } else if (p6 >= 4080) {
      p6 = 255;
    } else {
      p6 >>= 4;
    }

    if (p7 < 16) {
      p7 = 0;
    } else if (p7 >= 4080) {
      p7 = 255;
    } else {
      p7 >>= 4;
    }

    blockData[blockBufferOffset + col] = p0;
    blockData[blockBufferOffset + col + 8] = p1;
    blockData[blockBufferOffset + col + 16] = p2;
    blockData[blockBufferOffset + col + 24] = p3;
    blockData[blockBufferOffset + col + 32] = p4;
    blockData[blockBufferOffset + col + 40] = p5;
    blockData[blockBufferOffset + col + 48] = p6;
    blockData[blockBufferOffset + col + 56] = p7;
  }
}

function buildComponentData(frame, component) {
  const blocksPerLine = component.blocksPerLine;
  const blocksPerColumn = component.blocksPerColumn;
  const computationBuffer = new Int16Array(64);

  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      const offset = getBlockBufferOffset(component, blockRow, blockCol);
      quantizeAndInverse(component, offset, computationBuffer);
    }
  }

  return component.blockData;
}

function findNextFileMarker(data, currentPos, startPos = currentPos) {
  const maxPos = data.length - 1;
  let newPos = startPos < currentPos ? startPos : currentPos;

  if (currentPos >= maxPos) {
    return null;
  }

  const currentMarker = (0, _core_utils.readUint16)(data, currentPos);

  if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {
    return {
      invalid: null,
      marker: currentMarker,
      offset: currentPos
    };
  }

  let newMarker = (0, _core_utils.readUint16)(data, newPos);

  while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
    if (++newPos >= maxPos) {
      return null;
    }

    newMarker = (0, _core_utils.readUint16)(data, newPos);
  }

  return {
    invalid: currentMarker.toString(16),
    marker: newMarker,
    offset: newPos
  };
}

class JpegImage {
  constructor({
    decodeTransform = null,
    colorTransform = -1
  } = {}) {
    this._decodeTransform = decodeTransform;
    this._colorTransform = colorTransform;
  }

  parse(data, {
    dnlScanLines = null
  } = {}) {
    function readDataBlock() {
      const length = (0, _core_utils.readUint16)(data, offset);
      offset += 2;
      let endOffset = offset + length - 2;
      const fileMarker = findNextFileMarker(data, endOffset, offset);

      if (fileMarker && fileMarker.invalid) {
        (0, _util.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker.invalid);
        endOffset = fileMarker.offset;
      }

      const array = data.subarray(offset, endOffset);
      offset += array.length;
      return array;
    }

    function prepareComponents(frame) {
      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);

      for (let i = 0, ii = frame.components.length; i < ii; i++) {
        const component = frame.components[i];
        const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
        const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
        const blocksPerLineForMcu = mcusPerLine * component.h;
        const blocksPerColumnForMcu = mcusPerColumn * component.v;
        const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
        component.blockData = new Int16Array(blocksBufferSize);
        component.blocksPerLine = blocksPerLine;
        component.blocksPerColumn = blocksPerColumn;
      }

      frame.mcusPerLine = mcusPerLine;
      frame.mcusPerColumn = mcusPerColumn;
    }

    let offset = 0;
    let jfif = null;
    let adobe = null;
    let frame, resetInterval;
    let numSOSMarkers = 0;
    const quantizationTables = [];
    const huffmanTablesAC = [],
          huffmanTablesDC = [];
    let fileMarker = (0, _core_utils.readUint16)(data, offset);
    offset += 2;

    if (fileMarker !== 0xffd8) {
      throw new JpegError("SOI not found");
    }

    fileMarker = (0, _core_utils.readUint16)(data, offset);
    offset += 2;

    markerLoop: while (fileMarker !== 0xffd9) {
      let i, j, l;

      switch (fileMarker) {
        case 0xffe0:
        case 0xffe1:
        case 0xffe2:
        case 0xffe3:
        case 0xffe4:
        case 0xffe5:
        case 0xffe6:
        case 0xffe7:
        case 0xffe8:
        case 0xffe9:
        case 0xffea:
        case 0xffeb:
        case 0xffec:
        case 0xffed:
        case 0xffee:
        case 0xffef:
        case 0xfffe:
          const appData = readDataBlock();

          if (fileMarker === 0xffe0) {
            if (appData[0] === 0x4a && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {
              jfif = {
                version: {
                  major: appData[5],
                  minor: appData[6]
                },
                densityUnits: appData[7],
                xDensity: appData[8] << 8 | appData[9],
                yDensity: appData[10] << 8 | appData[11],
                thumbWidth: appData[12],
                thumbHeight: appData[13],
                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
              };
            }
          }

          if (fileMarker === 0xffee) {
            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6f && appData[3] === 0x62 && appData[4] === 0x65) {
              adobe = {
                version: appData[5] << 8 | appData[6],
                flags0: appData[7] << 8 | appData[8],
                flags1: appData[9] << 8 | appData[10],
                transformCode: appData[11]
              };
            }
          }

          break;

        case 0xffdb:
          const quantizationTablesLength = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          const quantizationTablesEnd = quantizationTablesLength + offset - 2;
          let z;

          while (offset < quantizationTablesEnd) {
            const quantizationTableSpec = data[offset++];
            const tableData = new Uint16Array(64);

            if (quantizationTableSpec >> 4 === 0) {
              for (j = 0; j < 64; j++) {
                z = dctZigZag[j];
                tableData[z] = data[offset++];
              }
            } else if (quantizationTableSpec >> 4 === 1) {
              for (j = 0; j < 64; j++) {
                z = dctZigZag[j];
                tableData[z] = (0, _core_utils.readUint16)(data, offset);
                offset += 2;
              }
            } else {
              throw new JpegError("DQT - invalid table spec");
            }

            quantizationTables[quantizationTableSpec & 15] = tableData;
          }

          break;

        case 0xffc0:
        case 0xffc1:
        case 0xffc2:
          if (frame) {
            throw new JpegError("Only single frame JPEGs supported");
          }

          offset += 2;
          frame = {};
          frame.extended = fileMarker === 0xffc1;
          frame.progressive = fileMarker === 0xffc2;
          frame.precision = data[offset++];
          const sofScanLines = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          frame.scanLines = dnlScanLines || sofScanLines;
          frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          frame.components = [];
          frame.componentIds = {};
          const componentsCount = data[offset++];
          let maxH = 0,
              maxV = 0;

          for (i = 0; i < componentsCount; i++) {
            const componentId = data[offset];
            const h = data[offset + 1] >> 4;
            const v = data[offset + 1] & 15;

            if (maxH < h) {
              maxH = h;
            }

            if (maxV < v) {
              maxV = v;
            }

            const qId = data[offset + 2];
            l = frame.components.push({
              h,
              v,
              quantizationId: qId,
              quantizationTable: null
            });
            frame.componentIds[componentId] = l - 1;
            offset += 3;
          }

          frame.maxH = maxH;
          frame.maxV = maxV;
          prepareComponents(frame);
          break;

        case 0xffc4:
          const huffmanLength = (0, _core_utils.readUint16)(data, offset);
          offset += 2;

          for (i = 2; i < huffmanLength;) {
            const huffmanTableSpec = data[offset++];
            const codeLengths = new Uint8Array(16);
            let codeLengthSum = 0;

            for (j = 0; j < 16; j++, offset++) {
              codeLengthSum += codeLengths[j] = data[offset];
            }

            const huffmanValues = new Uint8Array(codeLengthSum);

            for (j = 0; j < codeLengthSum; j++, offset++) {
              huffmanValues[j] = data[offset];
            }

            i += 17 + codeLengthSum;
            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
          }

          break;

        case 0xffdd:
          offset += 2;
          resetInterval = (0, _core_utils.readUint16)(data, offset);
          offset += 2;
          break;

        case 0xffda:
          const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
          offset += 2;
          const selectorsCount = data[offset++],
                components = [];

          for (i = 0; i < selectorsCount; i++) {
            const index = data[offset++];
            const componentIndex = frame.componentIds[index];
            const component = frame.components[componentIndex];
            component.index = index;
            const tableSpec = data[offset++];
            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
            components.push(component);
          }

          const spectralStart = data[offset++],
                spectralEnd = data[offset++],
                successiveApproximation = data[offset++];

          try {
            const processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
            offset += processed;
          } catch (ex) {
            if (ex instanceof DNLMarkerError) {
              (0, _util.warn)(`${ex.message} -- attempting to re-parse the JPEG image.`);
              return this.parse(data, {
                dnlScanLines: ex.scanLines
              });
            } else if (ex instanceof EOIMarkerError) {
              (0, _util.warn)(`${ex.message} -- ignoring the rest of the image data.`);
              break markerLoop;
            }

            throw ex;
          }

          break;

        case 0xffdc:
          offset += 4;
          break;

        case 0xffff:
          if (data[offset] !== 0xff) {
            offset--;
          }

          break;

        default:
          const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);

          if (nextFileMarker && nextFileMarker.invalid) {
            (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
            offset = nextFileMarker.offset;
            break;
          }

          if (!nextFileMarker || offset >= data.length - 1) {
            (0, _util.warn)("JpegImage.parse - reached the end of the image data " + "without finding an EOI marker (0xFFD9).");
            break markerLoop;
          }

          throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
      }

      fileMarker = (0, _core_utils.readUint16)(data, offset);
      offset += 2;
    }

    this.width = frame.samplesPerLine;
    this.height = frame.scanLines;
    this.jfif = jfif;
    this.adobe = adobe;
    this.components = [];

    for (let i = 0, ii = frame.components.length; i < ii; i++) {
      const component = frame.components[i];
      const quantizationTable = quantizationTables[component.quantizationId];

      if (quantizationTable) {
        component.quantizationTable = quantizationTable;
      }

      this.components.push({
        index: component.index,
        output: buildComponentData(frame, component),
        scaleX: component.h / frame.maxH,
        scaleY: component.v / frame.maxV,
        blocksPerLine: component.blocksPerLine,
        blocksPerColumn: component.blocksPerColumn
      });
    }

    this.numComponents = this.components.length;
    return undefined;
  }

  _getLinearizedBlockData(width, height, isSourcePDF = false) {
    const scaleX = this.width / width,
          scaleY = this.height / height;
    let component, componentScaleX, componentScaleY, blocksPerScanline;
    let x, y, i, j, k;
    let index;
    let offset = 0;
    let output;
    const numComponents = this.components.length;
    const dataLength = width * height * numComponents;
    const data = new Uint8ClampedArray(dataLength);
    const xScaleBlockOffset = new Uint32Array(width);
    const mask3LSB = 0xfffffff8;
    let lastComponentScaleX;

    for (i = 0; i < numComponents; i++) {
      component = this.components[i];
      componentScaleX = component.scaleX * scaleX;
      componentScaleY = component.scaleY * scaleY;
      offset = i;
      output = component.output;
      blocksPerScanline = component.blocksPerLine + 1 << 3;

      if (componentScaleX !== lastComponentScaleX) {
        for (x = 0; x < width; x++) {
          j = 0 | x * componentScaleX;
          xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
        }

        lastComponentScaleX = componentScaleX;
      }

      for (y = 0; y < height; y++) {
        j = 0 | y * componentScaleY;
        index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;

        for (x = 0; x < width; x++) {
          data[offset] = output[index + xScaleBlockOffset[x]];
          offset += numComponents;
        }
      }
    }

    let transform = this._decodeTransform;

    if (!isSourcePDF && numComponents === 4 && !transform) {
      transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
    }

    if (transform) {
      for (i = 0; i < dataLength;) {
        for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
          data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
        }
      }
    }

    return data;
  }

  get _isColorConversionNeeded() {
    if (this.adobe) {
      return !!this.adobe.transformCode;
    }

    if (this.numComponents === 3) {
      if (this._colorTransform === 0) {
        return false;
      } else if (this.components[0].index === 0x52 && this.components[1].index === 0x47 && this.components[2].index === 0x42) {
        return false;
      }

      return true;
    }

    if (this._colorTransform === 1) {
      return true;
    }

    return false;
  }

  _convertYccToRgb(data) {
    let Y, Cb, Cr;

    for (let i = 0, length = data.length; i < length; i += 3) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      data[i] = Y - 179.456 + 1.402 * Cr;
      data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
      data[i + 2] = Y - 226.816 + 1.772 * Cb;
    }

    return data;
  }

  _convertYcckToRgb(data) {
    let Y, Cb, Cr, k;
    let offset = 0;

    for (let i = 0, length = data.length; i < length; i += 4) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      k = data[i + 3];
      data[offset++] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);
      data[offset++] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);
      data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);
    }

    return data.subarray(0, offset);
  }

  _convertYcckToCmyk(data) {
    let Y, Cb, Cr;

    for (let i = 0, length = data.length; i < length; i += 4) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      data[i] = 434.456 - Y - 1.402 * Cr;
      data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
      data[i + 2] = 481.816 - Y - 1.772 * Cb;
    }

    return data;
  }

  _convertCmykToRgb(data) {
    let c, m, y, k;
    let offset = 0;

    for (let i = 0, length = data.length; i < length; i += 4) {
      c = data[i];
      m = data[i + 1];
      y = data[i + 2];
      k = data[i + 3];
      data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);
      data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.00031891311758832814 * k + 0.7364883807733168);
      data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);
    }

    return data.subarray(0, offset);
  }

  getData({
    width,
    height,
    forceRGB = false,
    isSourcePDF = false
  }) {
    if (this.numComponents > 4) {
      throw new JpegError("Unsupported color mode");
    }

    const data = this._getLinearizedBlockData(width, height, isSourcePDF);

    if (this.numComponents === 1 && forceRGB) {
      const dataLength = data.length;
      const rgbData = new Uint8ClampedArray(dataLength * 3);
      let offset = 0;

      for (let i = 0; i < dataLength; i++) {
        const grayColor = data[i];
        rgbData[offset++] = grayColor;
        rgbData[offset++] = grayColor;
        rgbData[offset++] = grayColor;
      }

      return rgbData;
    } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
      return this._convertYccToRgb(data);
    } else if (this.numComponents === 4) {
      if (this._isColorConversionNeeded) {
        if (forceRGB) {
          return this._convertYcckToRgb(data);
        }

        return this._convertYcckToCmyk(data);
      } else if (forceRGB) {
        return this._convertCmykToRgb(data);
      }
    }

    return data;
  }

}

exports.JpegImage = JpegImage;

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpxStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

var _jpx = __w_pdfjs_require__(30);

var _util = __w_pdfjs_require__(2);

class JpxStream extends _decode_stream.DecodeStream {
  constructor(stream, maybeLength, params) {
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }

  get bytes() {
    return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
  }

  ensureBuffer(requested) {}

  readBlock() {
    if (this.eof) {
      return;
    }

    const jpxImage = new _jpx.JpxImage();
    jpxImage.parse(this.bytes);
    const width = jpxImage.width;
    const height = jpxImage.height;
    const componentsCount = jpxImage.componentsCount;
    const tileCount = jpxImage.tiles.length;

    if (tileCount === 1) {
      this.buffer = jpxImage.tiles[0].items;
    } else {
      const data = new Uint8ClampedArray(width * height * componentsCount);

      for (let k = 0; k < tileCount; k++) {
        const tileComponents = jpxImage.tiles[k];
        const tileWidth = tileComponents.width;
        const tileHeight = tileComponents.height;
        const tileLeft = tileComponents.left;
        const tileTop = tileComponents.top;
        const src = tileComponents.items;
        let srcPosition = 0;
        let dataPosition = (width * tileTop + tileLeft) * componentsCount;
        const imgRowSize = width * componentsCount;
        const tileRowSize = tileWidth * componentsCount;

        for (let j = 0; j < tileHeight; j++) {
          const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
          data.set(rowBytes, dataPosition);
          srcPosition += tileRowSize;
          dataPosition += imgRowSize;
        }
      }

      this.buffer = data;
    }

    this.bufferLength = this.buffer.length;
    this.eof = true;
  }

}

exports.JpxStream = JpxStream;

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpxImage = void 0;

var _util = __w_pdfjs_require__(2);

var _core_utils = __w_pdfjs_require__(9);

var _arithmetic_decoder = __w_pdfjs_require__(26);

class JpxError extends _util.BaseException {
  constructor(msg) {
    super(`JPX error: ${msg}`);
  }

}

const SubbandsGainLog2 = {
  LL: 0,
  LH: 1,
  HL: 1,
  HH: 2
};

class JpxImage {
  constructor() {
    this.failOnCorruptedImage = false;
  }

  parse(data) {
    const head = (0, _core_utils.readUint16)(data, 0);

    if (head === 0xff4f) {
      this.parseCodestream(data, 0, data.length);
      return;
    }

    const length = data.length;
    let position = 0;

    while (position < length) {
      let headerSize = 8;
      let lbox = (0, _core_utils.readUint32)(data, position);
      const tbox = (0, _core_utils.readUint32)(data, position + 4);
      position += headerSize;

      if (lbox === 1) {
        lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4);
        position += 8;
        headerSize += 8;
      }

      if (lbox === 0) {
        lbox = length - position + headerSize;
      }

      if (lbox < headerSize) {
        throw new JpxError("Invalid box field size");
      }

      const dataLength = lbox - headerSize;
      let jumpDataLength = true;

      switch (tbox) {
        case 0x6a703268:
          jumpDataLength = false;
          break;

        case 0x636f6c72:
          const method = data[position];

          if (method === 1) {
            const colorspace = (0, _core_utils.readUint32)(data, position + 3);

            switch (colorspace) {
              case 16:
              case 17:
              case 18:
                break;

              default:
                (0, _util.warn)("Unknown colorspace " + colorspace);
                break;
            }
          } else if (method === 2) {
            (0, _util.info)("ICC profile not supported");
          }

          break;

        case 0x6a703263:
          this.parseCodestream(data, position, position + dataLength);
          break;

        case 0x6a502020:
          if ((0, _core_utils.readUint32)(data, position) !== 0x0d0a870a) {
            (0, _util.warn)("Invalid JP2 signature");
          }

          break;

        case 0x6a501a1a:
        case 0x66747970:
        case 0x72726571:
        case 0x72657320:
        case 0x69686472:
          break;

        default:
          const headerType = String.fromCharCode(tbox >> 24 & 0xff, tbox >> 16 & 0xff, tbox >> 8 & 0xff, tbox & 0xff);
          (0, _util.warn)(`Unsupported header type ${tbox} (${headerType}).`);
          break;
      }

      if (jumpDataLength) {
        position += dataLength;
      }
    }
  }

  parseImageProperties(stream) {
    let newByte = stream.getByte();

    while (newByte >= 0) {
      const oldByte = newByte;
      newByte = stream.getByte();
      const code = oldByte << 8 | newByte;

      if (code === 0xff51) {
        stream.skip(4);
        const Xsiz = stream.getInt32() >>> 0;
        const Ysiz = stream.getInt32() >>> 0;
        const XOsiz = stream.getInt32() >>> 0;
        const YOsiz = stream.getInt32() >>> 0;
        stream.skip(16);
        const Csiz = stream.getUint16();
        this.width = Xsiz - XOsiz;
        this.height = Ysiz - YOsiz;
        this.componentsCount = Csiz;
        this.bitsPerComponent = 8;
        return;
      }
    }

    throw new JpxError("No size marker found in JPX stream");
  }

  parseCodestream(data, start, end) {
    const context = {};
    let doNotRecover = false;

    try {
      let position = start;

      while (position + 1 < end) {
        const code = (0, _core_utils.readUint16)(data, position);
        position += 2;
        let length = 0,
            j,
            sqcd,
            spqcds,
            spqcdSize,
            scalarExpounded,
            tile;

        switch (code) {
          case 0xff4f:
            context.mainHeader = true;
            break;

          case 0xffd9:
            break;

          case 0xff51:
            length = (0, _core_utils.readUint16)(data, position);
            const siz = {};
            siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4);
            siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8);
            siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12);
            siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16);
            siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20);
            siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24);
            siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28);
            siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32);
            const componentsCount = (0, _core_utils.readUint16)(data, position + 36);
            siz.Csiz = componentsCount;
            const components = [];
            j = position + 38;

            for (let i = 0; i < componentsCount; i++) {
              const component = {
                precision: (data[j] & 0x7f) + 1,
                isSigned: !!(data[j] & 0x80),
                XRsiz: data[j + 1],
                YRsiz: data[j + 2]
              };
              j += 3;
              calculateComponentDimensions(component, siz);
              components.push(component);
            }

            context.SIZ = siz;
            context.components = components;
            calculateTileGrids(context, components);
            context.QCC = [];
            context.COC = [];
            break;

          case 0xff5c:
            length = (0, _core_utils.readUint16)(data, position);
            const qcd = {};
            j = position + 2;
            sqcd = data[j++];

            switch (sqcd & 0x1f) {
              case 0:
                spqcdSize = 8;
                scalarExpounded = true;
                break;

              case 1:
                spqcdSize = 16;
                scalarExpounded = false;
                break;

              case 2:
                spqcdSize = 16;
                scalarExpounded = true;
                break;

              default:
                throw new Error("Invalid SQcd value " + sqcd);
            }

            qcd.noQuantization = spqcdSize === 8;
            qcd.scalarExpounded = scalarExpounded;
            qcd.guardBits = sqcd >> 5;
            spqcds = [];

            while (j < length + position) {
              const spqcd = {};

              if (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } else {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                j += 2;
              }

              spqcds.push(spqcd);
            }

            qcd.SPqcds = spqcds;

            if (context.mainHeader) {
              context.QCD = qcd;
            } else {
              context.currentTile.QCD = qcd;
              context.currentTile.QCC = [];
            }

            break;

          case 0xff5d:
            length = (0, _core_utils.readUint16)(data, position);
            const qcc = {};
            j = position + 2;
            let cqcc;

            if (context.SIZ.Csiz < 257) {
              cqcc = data[j++];
            } else {
              cqcc = (0, _core_utils.readUint16)(data, j);
              j += 2;
            }

            sqcd = data[j++];

            switch (sqcd & 0x1f) {
              case 0:
                spqcdSize = 8;
                scalarExpounded = true;
                break;

              case 1:
                spqcdSize = 16;
                scalarExpounded = false;
                break;

              case 2:
                spqcdSize = 16;
                scalarExpounded = true;
                break;

              default:
                throw new Error("Invalid SQcd value " + sqcd);
            }

            qcc.noQuantization = spqcdSize === 8;
            qcc.scalarExpounded = scalarExpounded;
            qcc.guardBits = sqcd >> 5;
            spqcds = [];

            while (j < length + position) {
              const spqcd = {};

              if (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } else {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 0x7) << 8 | data[j + 1];
                j += 2;
              }

              spqcds.push(spqcd);
            }

            qcc.SPqcds = spqcds;

            if (context.mainHeader) {
              context.QCC[cqcc] = qcc;
            } else {
              context.currentTile.QCC[cqcc] = qcc;
            }

            break;

          case 0xff52:
            length = (0, _core_utils.readUint16)(data, position);
            const cod = {};
            j = position + 2;
            const scod = data[j++];
            cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
            cod.sopMarkerUsed = !!(scod & 2);
            cod.ephMarkerUsed = !!(scod & 4);
            cod.progressionOrder = data[j++];
            cod.layersCount = (0, _core_utils.readUint16)(data, j);
            j += 2;
            cod.multipleComponentTransform = data[j++];
            cod.decompositionLevelsCount = data[j++];
            cod.xcb = (data[j++] & 0xf) + 2;
            cod.ycb = (data[j++] & 0xf) + 2;
            const blockStyle = data[j++];
            cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
            cod.resetContextProbabilities = !!(blockStyle & 2);
            cod.terminationOnEachCodingPass = !!(blockStyle & 4);
            cod.verticallyStripe = !!(blockStyle & 8);
            cod.predictableTermination = !!(blockStyle & 16);
            cod.segmentationSymbolUsed = !!(blockStyle & 32);
            cod.reversibleTransformation = data[j++];

            if (cod.entropyCoderWithCustomPrecincts) {
              const precinctsSizes = [];

              while (j < length + position) {
                const precinctsSize = data[j++];
                precinctsSizes.push({
                  PPx: precinctsSize & 0xf,
                  PPy: precinctsSize >> 4
                });
              }

              cod.precinctsSizes = precinctsSizes;
            }

            const unsupported = [];

            if (cod.selectiveArithmeticCodingBypass) {
              unsupported.push("selectiveArithmeticCodingBypass");
            }

            if (cod.resetContextProbabilities) {
              unsupported.push("resetContextProbabilities");
            }

            if (cod.terminationOnEachCodingPass) {
              unsupported.push("terminationOnEachCodingPass");
            }

            if (cod.verticallyStripe) {
              unsupported.push("verticallyStripe");
            }

            if (cod.predictableTermination) {
              unsupported.push("predictableTermination");
            }

            if (unsupported.length > 0) {
              doNotRecover = true;
              (0, _util.warn)(`JPX: Unsupported COD options (${unsupported.join(", ")}).`);
            }

            if (context.mainHeader) {
              context.COD = cod;
            } else {
              context.currentTile.COD = cod;
              context.currentTile.COC = [];
            }

            break;

          case 0xff90:
            length = (0, _core_utils.readUint16)(data, position);
            tile = {};
            tile.index = (0, _core_utils.readUint16)(data, position + 2);
            tile.length = (0, _core_utils.readUint32)(data, position + 4);
            tile.dataEnd = tile.length + position - 2;
            tile.partIndex = data[position + 8];
            tile.partsCount = data[position + 9];
            context.mainHeader = false;

            if (tile.partIndex === 0) {
              tile.COD = context.COD;
              tile.COC = context.COC.slice(0);
              tile.QCD = context.QCD;
              tile.QCC = context.QCC.slice(0);
            }

            context.currentTile = tile;
            break;

          case 0xff93:
            tile = context.currentTile;

            if (tile.partIndex === 0) {
              initializeTile(context, tile.index);
              buildPackets(context);
            }

            length = tile.dataEnd - position;
            parseTilePackets(context, data, position, length);
            break;

          case 0xff53:
            (0, _util.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");

          case 0xff55:
          case 0xff57:
          case 0xff58:
          case 0xff64:
            length = (0, _core_utils.readUint16)(data, position);
            break;

          default:
            throw new Error("Unknown codestream code: " + code.toString(16));
        }

        position += length;
      }
    } catch (e) {
      if (doNotRecover || this.failOnCorruptedImage) {
        throw new JpxError(e.message);
      } else {
        (0, _util.warn)(`JPX: Trying to recover from: "${e.message}".`);
      }
    }

    this.tiles = transformComponents(context);
    this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
    this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
    this.componentsCount = context.SIZ.Csiz;
  }

}

exports.JpxImage = JpxImage;

function calculateComponentDimensions(component, siz) {
  component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
  component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
  component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
  component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
  component.width = component.x1 - component.x0;
  component.height = component.y1 - component.y0;
}

function calculateTileGrids(context, components) {
  const siz = context.SIZ;
  const tiles = [];
  let tile;
  const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
  const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);

  for (let q = 0; q < numYtiles; q++) {
    for (let p = 0; p < numXtiles; p++) {
      tile = {};
      tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
      tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
      tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
      tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
      tile.width = tile.tx1 - tile.tx0;
      tile.height = tile.ty1 - tile.ty0;
      tile.components = [];
      tiles.push(tile);
    }
  }

  context.tiles = tiles;
  const componentsCount = siz.Csiz;

  for (let i = 0, ii = componentsCount; i < ii; i++) {
    const component = components[i];

    for (let j = 0, jj = tiles.length; j < jj; j++) {
      const tileComponent = {};
      tile = tiles[j];
      tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
      tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
      tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
      tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
      tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
      tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
      tile.components[i] = tileComponent;
    }
  }
}

function getBlocksDimensions(context, component, r) {
  const codOrCoc = component.codingStyleParameters;
  const result = {};

  if (!codOrCoc.entropyCoderWithCustomPrecincts) {
    result.PPx = 15;
    result.PPy = 15;
  } else {
    result.PPx = codOrCoc.precinctsSizes[r].PPx;
    result.PPy = codOrCoc.precinctsSizes[r].PPy;
  }

  result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
  result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
  return result;
}

function buildPrecincts(context, resolution, dimensions) {
  const precinctWidth = 1 << dimensions.PPx;
  const precinctHeight = 1 << dimensions.PPy;
  const isZeroRes = resolution.resLevel === 0;
  const precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
  const precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
  const numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
  const numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
  const numprecincts = numprecinctswide * numprecinctshigh;
  resolution.precinctParameters = {
    precinctWidth,
    precinctHeight,
    numprecinctswide,
    numprecinctshigh,
    numprecincts,
    precinctWidthInSubband,
    precinctHeightInSubband
  };
}

function buildCodeblocks(context, subband, dimensions) {
  const xcb_ = dimensions.xcb_;
  const ycb_ = dimensions.ycb_;
  const codeblockWidth = 1 << xcb_;
  const codeblockHeight = 1 << ycb_;
  const cbx0 = subband.tbx0 >> xcb_;
  const cby0 = subband.tby0 >> ycb_;
  const cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
  const cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
  const precinctParameters = subband.resolution.precinctParameters;
  const codeblocks = [];
  const precincts = [];
  let i, j, codeblock, precinctNumber;

  for (j = cby0; j < cby1; j++) {
    for (i = cbx0; i < cbx1; i++) {
      codeblock = {
        cbx: i,
        cby: j,
        tbx0: codeblockWidth * i,
        tby0: codeblockHeight * j,
        tbx1: codeblockWidth * (i + 1),
        tby1: codeblockHeight * (j + 1)
      };
      codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
      codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
      codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
      codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
      const pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
      const pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
      precinctNumber = pi + pj * precinctParameters.numprecinctswide;
      codeblock.precinctNumber = precinctNumber;
      codeblock.subbandType = subband.type;
      codeblock.Lblock = 3;

      if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
        continue;
      }

      codeblocks.push(codeblock);
      let precinct = precincts[precinctNumber];

      if (precinct !== undefined) {
        if (i < precinct.cbxMin) {
          precinct.cbxMin = i;
        } else if (i > precinct.cbxMax) {
          precinct.cbxMax = i;
        }

        if (j < precinct.cbyMin) {
          precinct.cbxMin = j;
        } else if (j > precinct.cbyMax) {
          precinct.cbyMax = j;
        }
      } else {
        precincts[precinctNumber] = precinct = {
          cbxMin: i,
          cbyMin: j,
          cbxMax: i,
          cbyMax: j
        };
      }

      codeblock.precinct = precinct;
    }
  }

  subband.codeblockParameters = {
    codeblockWidth: xcb_,
    codeblockHeight: ycb_,
    numcodeblockwide: cbx1 - cbx0 + 1,
    numcodeblockhigh: cby1 - cby0 + 1
  };
  subband.codeblocks = codeblocks;
  subband.precincts = precincts;
}

function createPacket(resolution, precinctNumber, layerNumber) {
  const precinctCodeblocks = [];
  const subbands = resolution.subbands;

  for (let i = 0, ii = subbands.length; i < ii; i++) {
    const subband = subbands[i];
    const codeblocks = subband.codeblocks;

    for (let j = 0, jj = codeblocks.length; j < jj; j++) {
      const codeblock = codeblocks[j];

      if (codeblock.precinctNumber !== precinctNumber) {
        continue;
      }

      precinctCodeblocks.push(codeblock);
    }
  }

  return {
    layerNumber,
    codeblocks: precinctCodeblocks
  };
}

function LayerResolutionComponentPositionIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let maxDecompositionLevelsCount = 0;

  for (let q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }

  let l = 0,
      r = 0,
      i = 0,
      k = 0;

  this.nextPacket = function JpxImage_nextPacket() {
    for (; l < layersCount; l++) {
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; i < componentsCount; i++) {
          const component = tile.components[i];

          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }

          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;

          for (; k < numprecincts;) {
            const packet = createPacket(resolution, k, l);
            k++;
            return packet;
          }

          k = 0;
        }

        i = 0;
      }

      r = 0;
    }

    throw new JpxError("Out of packets");
  };
}

function ResolutionLayerComponentPositionIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let maxDecompositionLevelsCount = 0;

  for (let q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }

  let r = 0,
      l = 0,
      i = 0,
      k = 0;

  this.nextPacket = function JpxImage_nextPacket() {
    for (; r <= maxDecompositionLevelsCount; r++) {
      for (; l < layersCount; l++) {
        for (; i < componentsCount; i++) {
          const component = tile.components[i];

          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }

          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;

          for (; k < numprecincts;) {
            const packet = createPacket(resolution, k, l);
            k++;
            return packet;
          }

          k = 0;
        }

        i = 0;
      }

      l = 0;
    }

    throw new JpxError("Out of packets");
  };
}

function ResolutionPositionComponentLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let l, r, c, p;
  let maxDecompositionLevelsCount = 0;

  for (c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
  }

  const maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);

  for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
    let maxNumPrecincts = 0;

    for (c = 0; c < componentsCount; ++c) {
      const resolutions = tile.components[c].resolutions;

      if (r < resolutions.length) {
        maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
      }
    }

    maxNumPrecinctsInLevel[r] = maxNumPrecincts;
  }

  l = 0;
  r = 0;
  c = 0;
  p = 0;

  this.nextPacket = function JpxImage_nextPacket() {
    for (; r <= maxDecompositionLevelsCount; r++) {
      for (; p < maxNumPrecinctsInLevel[r]; p++) {
        for (; c < componentsCount; c++) {
          const component = tile.components[c];

          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }

          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;

          if (p >= numprecincts) {
            continue;
          }

          for (; l < layersCount;) {
            const packet = createPacket(resolution, p, l);
            l++;
            return packet;
          }

          l = 0;
        }

        c = 0;
      }

      p = 0;
    }

    throw new JpxError("Out of packets");
  };
}

function PositionComponentResolutionLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  const precinctsIterationSizes = precinctsSizes;
  let l = 0,
      r = 0,
      c = 0,
      px = 0,
      py = 0;

  this.nextPacket = function JpxImage_nextPacket() {
    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
      for (; px < precinctsIterationSizes.maxNumWide; px++) {
        for (; c < componentsCount; c++) {
          const component = tile.components[c];
          const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;

          for (; r <= decompositionLevelsCount; r++) {
            const resolution = component.resolutions[r];
            const sizeInImageScale = precinctsSizes.components[c].resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);

            if (k === null) {
              continue;
            }

            for (; l < layersCount;) {
              const packet = createPacket(resolution, k, l);
              l++;
              return packet;
            }

            l = 0;
          }

          r = 0;
        }

        c = 0;
      }

      px = 0;
    }

    throw new JpxError("Out of packets");
  };
}

function ComponentPositionResolutionLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  let l = 0,
      r = 0,
      c = 0,
      px = 0,
      py = 0;

  this.nextPacket = function JpxImage_nextPacket() {
    for (; c < componentsCount; ++c) {
      const component = tile.components[c];
      const precinctsIterationSizes = precinctsSizes.components[c];
      const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;

      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; r <= decompositionLevelsCount; r++) {
            const resolution = component.resolutions[r];
            const sizeInImageScale = precinctsIterationSizes.resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);

            if (k === null) {
              continue;
            }

            for (; l < layersCount;) {
              const packet = createPacket(resolution, k, l);
              l++;
              return packet;
            }

            l = 0;
          }

          r = 0;
        }

        px = 0;
      }

      py = 0;
    }

    throw new JpxError("Out of packets");
  };
}

function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
  const posX = pxIndex * precinctIterationSizes.minWidth;
  const posY = pyIndex * precinctIterationSizes.minHeight;

  if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
    return null;
  }

  const startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
  return posX / sizeInImageScale.height + startPrecinctRowIndex;
}

function getPrecinctSizesInImageScale(tile) {
  const componentsCount = tile.components.length;
  let minWidth = Number.MAX_VALUE;
  let minHeight = Number.MAX_VALUE;
  let maxNumWide = 0;
  let maxNumHigh = 0;
  const sizePerComponent = new Array(componentsCount);

  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
    const sizePerResolution = new Array(decompositionLevelsCount + 1);
    let minWidthCurrentComponent = Number.MAX_VALUE;
    let minHeightCurrentComponent = Number.MAX_VALUE;
    let maxNumWideCurrentComponent = 0;
    let maxNumHighCurrentComponent = 0;
    let scale = 1;

    for (let r = decompositionLevelsCount; r >= 0; --r) {
      const resolution = component.resolutions[r];
      const widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
      const heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
      minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
      minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
      maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
      maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
      sizePerResolution[r] = {
        width: widthCurrentResolution,
        height: heightCurrentResolution
      };
      scale <<= 1;
    }

    minWidth = Math.min(minWidth, minWidthCurrentComponent);
    minHeight = Math.min(minHeight, minHeightCurrentComponent);
    maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
    maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
    sizePerComponent[c] = {
      resolutions: sizePerResolution,
      minWidth: minWidthCurrentComponent,
      minHeight: minHeightCurrentComponent,
      maxNumWide: maxNumWideCurrentComponent,
      maxNumHigh: maxNumHighCurrentComponent
    };
  }

  return {
    components: sizePerComponent,
    minWidth,
    minHeight,
    maxNumWide,
    maxNumHigh
  };
}

function buildPackets(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const componentsCount = siz.Csiz;

  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
    const resolutions = [];
    const subbands = [];

    for (let r = 0; r <= decompositionLevelsCount; r++) {
      const blocksDimensions = getBlocksDimensions(context, component, r);
      const resolution = {};
      const scale = 1 << decompositionLevelsCount - r;
      resolution.trx0 = Math.ceil(component.tcx0 / scale);
      resolution.try0 = Math.ceil(component.tcy0 / scale);
      resolution.trx1 = Math.ceil(component.tcx1 / scale);
      resolution.try1 = Math.ceil(component.tcy1 / scale);
      resolution.resLevel = r;
      buildPrecincts(context, resolution, blocksDimensions);
      resolutions.push(resolution);
      let subband;

      if (r === 0) {
        subband = {};
        subband.type = "LL";
        subband.tbx0 = Math.ceil(component.tcx0 / scale);
        subband.tby0 = Math.ceil(component.tcy0 / scale);
        subband.tbx1 = Math.ceil(component.tcx1 / scale);
        subband.tby1 = Math.ceil(component.tcy1 / scale);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolution.subbands = [subband];
      } else {
        const bscale = 1 << decompositionLevelsCount - r + 1;
        const resolutionSubbands = [];
        subband = {};
        subband.type = "HL";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
        subband.tby1 = Math.ceil(component.tcy1 / bscale);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        subband = {};
        subband.type = "LH";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        subband = {};
        subband.type = "HH";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        resolution.subbands = resolutionSubbands;
      }
    }

    component.resolutions = resolutions;
    component.subbands = subbands;
  }

  const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;

  switch (progressionOrder) {
    case 0:
      tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
      break;

    case 1:
      tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
      break;

    case 2:
      tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
      break;

    case 3:
      tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
      break;

    case 4:
      tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
      break;

    default:
      throw new JpxError(`Unsupported progression order ${progressionOrder}`);
  }
}

function parseTilePackets(context, data, offset, dataLength) {
  let position = 0;
  let buffer,
      bufferSize = 0,
      skipNextBit = false;

  function readBits(count) {
    while (bufferSize < count) {
      const b = data[offset + position];
      position++;

      if (skipNextBit) {
        buffer = buffer << 7 | b;
        bufferSize += 7;
        skipNextBit = false;
      } else {
        buffer = buffer << 8 | b;
        bufferSize += 8;
      }

      if (b === 0xff) {
        skipNextBit = true;
      }
    }

    bufferSize -= count;
    return buffer >>> bufferSize & (1 << count) - 1;
  }

  function skipMarkerIfEqual(value) {
    if (data[offset + position - 1] === 0xff && data[offset + position] === value) {
      skipBytes(1);
      return true;
    } else if (data[offset + position] === 0xff && data[offset + position + 1] === value) {
      skipBytes(2);
      return true;
    }

    return false;
  }

  function skipBytes(count) {
    position += count;
  }

  function alignToByte() {
    bufferSize = 0;

    if (skipNextBit) {
      position++;
      skipNextBit = false;
    }
  }

  function readCodingpasses() {
    if (readBits(1) === 0) {
      return 1;
    }

    if (readBits(1) === 0) {
      return 2;
    }

    let value = readBits(2);

    if (value < 3) {
      return value + 3;
    }

    value = readBits(5);

    if (value < 31) {
      return value + 6;
    }

    value = readBits(7);
    return value + 37;
  }

  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const sopMarkerUsed = context.COD.sopMarkerUsed;
  const ephMarkerUsed = context.COD.ephMarkerUsed;
  const packetsIterator = tile.packetsIterator;

  while (position < dataLength) {
    alignToByte();

    if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
      skipBytes(4);
    }

    const packet = packetsIterator.nextPacket();

    if (!readBits(1)) {
      continue;
    }

    const layerNumber = packet.layerNumber,
          queue = [];
    let codeblock;

    for (let i = 0, ii = packet.codeblocks.length; i < ii; i++) {
      codeblock = packet.codeblocks[i];
      let precinct = codeblock.precinct;
      const codeblockColumn = codeblock.cbx - precinct.cbxMin;
      const codeblockRow = codeblock.cby - precinct.cbyMin;
      let codeblockIncluded = false;
      let firstTimeInclusion = false;
      let valueReady, zeroBitPlanesTree;

      if (codeblock.included !== undefined) {
        codeblockIncluded = !!readBits(1);
      } else {
        precinct = codeblock.precinct;
        let inclusionTree;

        if (precinct.inclusionTree !== undefined) {
          inclusionTree = precinct.inclusionTree;
        } else {
          const width = precinct.cbxMax - precinct.cbxMin + 1;
          const height = precinct.cbyMax - precinct.cbyMin + 1;
          inclusionTree = new InclusionTree(width, height, layerNumber);
          zeroBitPlanesTree = new TagTree(width, height);
          precinct.inclusionTree = inclusionTree;
          precinct.zeroBitPlanesTree = zeroBitPlanesTree;
        }

        if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
          while (true) {
            if (readBits(1)) {
              valueReady = !inclusionTree.nextLevel();

              if (valueReady) {
                codeblock.included = true;
                codeblockIncluded = firstTimeInclusion = true;
                break;
              }
            } else {
              inclusionTree.incrementValue(layerNumber);
              break;
            }
          }
        }
      }

      if (!codeblockIncluded) {
        continue;
      }

      if (firstTimeInclusion) {
        zeroBitPlanesTree = precinct.zeroBitPlanesTree;
        zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);

        while (true) {
          if (readBits(1)) {
            valueReady = !zeroBitPlanesTree.nextLevel();

            if (valueReady) {
              break;
            }
          } else {
            zeroBitPlanesTree.incrementValue();
          }
        }

        codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
      }

      const codingpasses = readCodingpasses();

      while (readBits(1)) {
        codeblock.Lblock++;
      }

      const codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
      const bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
      const codedDataLength = readBits(bits);
      queue.push({
        codeblock,
        codingpasses,
        dataLength: codedDataLength
      });
    }

    alignToByte();

    if (ephMarkerUsed) {
      skipMarkerIfEqual(0x92);
    }

    while (queue.length > 0) {
      const packetItem = queue.shift();
      codeblock = packetItem.codeblock;

      if (codeblock.data === undefined) {
        codeblock.data = [];
      }

      codeblock.data.push({
        data,
        start: offset + position,
        end: offset + position + packetItem.dataLength,
        codingpasses: packetItem.codingpasses
      });
      position += packetItem.dataLength;
    }
  }

  return position;
}

function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
  const x0 = subband.tbx0;
  const y0 = subband.tby0;
  const width = subband.tbx1 - subband.tbx0;
  const codeblocks = subband.codeblocks;
  const right = subband.type.charAt(0) === "H" ? 1 : 0;
  const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;

  for (let i = 0, ii = codeblocks.length; i < ii; ++i) {
    const codeblock = codeblocks[i];
    const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
    const blockHeight = codeblock.tby1_ - codeblock.tby0_;

    if (blockWidth === 0 || blockHeight === 0) {
      continue;
    }

    if (codeblock.data === undefined) {
      continue;
    }

    const bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
    let currentCodingpassType = 2;
    const data = codeblock.data;
    let totalLength = 0,
        codingpasses = 0;
    let j, jj, dataItem;

    for (j = 0, jj = data.length; j < jj; j++) {
      dataItem = data[j];
      totalLength += dataItem.end - dataItem.start;
      codingpasses += dataItem.codingpasses;
    }

    const encodedData = new Uint8Array(totalLength);
    let position = 0;

    for (j = 0, jj = data.length; j < jj; j++) {
      dataItem = data[j];
      const chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
      encodedData.set(chunk, position);
      position += chunk.length;
    }

    const decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
    bitModel.setDecoder(decoder);

    for (j = 0; j < codingpasses; j++) {
      switch (currentCodingpassType) {
        case 0:
          bitModel.runSignificancePropagationPass();
          break;

        case 1:
          bitModel.runMagnitudeRefinementPass();
          break;

        case 2:
          bitModel.runCleanupPass();

          if (segmentationSymbolUsed) {
            bitModel.checkSegmentationSymbol();
          }

          break;
      }

      currentCodingpassType = (currentCodingpassType + 1) % 3;
    }

    let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
    const sign = bitModel.coefficentsSign;
    const magnitude = bitModel.coefficentsMagnitude;
    const bitsDecoded = bitModel.bitsDecoded;
    const magnitudeCorrection = reversible ? 0 : 0.5;
    let k, n, nb;
    position = 0;
    const interleave = subband.type !== "LL";

    for (j = 0; j < blockHeight; j++) {
      const row = offset / width | 0;
      const levelOffset = 2 * row * (levelWidth - width) + right + bottom;

      for (k = 0; k < blockWidth; k++) {
        n = magnitude[position];

        if (n !== 0) {
          n = (n + magnitudeCorrection) * delta;

          if (sign[position] !== 0) {
            n = -n;
          }

          nb = bitsDecoded[position];
          const pos = interleave ? levelOffset + (offset << 1) : offset;

          if (reversible && nb >= mb) {
            coefficients[pos] = n;
          } else {
            coefficients[pos] = n * (1 << mb - nb);
          }
        }

        offset++;
        position++;
      }

      offset += width - blockWidth;
    }
  }
}

function transformTile(context, tile, c) {
  const component = tile.components[c];
  const codingStyleParameters = component.codingStyleParameters;
  const quantizationParameters = component.quantizationParameters;
  const decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
  const spqcds = quantizationParameters.SPqcds;
  const scalarExpounded = quantizationParameters.scalarExpounded;
  const guardBits = quantizationParameters.guardBits;
  const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
  const precision = context.components[c].precision;
  const reversible = codingStyleParameters.reversibleTransformation;
  const transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
  const subbandCoefficients = [];
  let b = 0;

  for (let i = 0; i <= decompositionLevelsCount; i++) {
    const resolution = component.resolutions[i];
    const width = resolution.trx1 - resolution.trx0;
    const height = resolution.try1 - resolution.try0;
    const coefficients = new Float32Array(width * height);

    for (let j = 0, jj = resolution.subbands.length; j < jj; j++) {
      let mu, epsilon;

      if (!scalarExpounded) {
        mu = spqcds[0].mu;
        epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
      } else {
        mu = spqcds[b].mu;
        epsilon = spqcds[b].epsilon;
        b++;
      }

      const subband = resolution.subbands[j];
      const gainLog2 = SubbandsGainLog2[subband.type];
      const delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
      const mb = guardBits + epsilon - 1;
      copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
    }

    subbandCoefficients.push({
      width,
      height,
      items: coefficients
    });
  }

  const result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
  return {
    left: component.tcx0,
    top: component.tcy0,
    width: result.width,
    height: result.height,
    items: result.items
  };
}

function transformComponents(context) {
  const siz = context.SIZ;
  const components = context.components;
  const componentsCount = siz.Csiz;
  const resultImages = [];

  for (let i = 0, ii = context.tiles.length; i < ii; i++) {
    const tile = context.tiles[i];
    const transformedTiles = [];

    for (let c = 0; c < componentsCount; c++) {
      transformedTiles[c] = transformTile(context, tile, c);
    }

    const tile0 = transformedTiles[0];
    const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
    const result = {
      left: tile0.left,
      top: tile0.top,
      width: tile0.width,
      height: tile0.height,
      items: out
    };
    let shift, offset;
    let pos = 0,
        j,
        jj,
        y0,
        y1,
        y2;

    if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
      const fourComponents = componentsCount === 4;
      const y0items = transformedTiles[0].items;
      const y1items = transformedTiles[1].items;
      const y2items = transformedTiles[2].items;
      const y3items = fourComponents ? transformedTiles[3].items : null;
      shift = components[0].precision - 8;
      offset = (128 << shift) + 0.5;
      const component0 = tile.components[0];
      const alpha01 = componentsCount - 3;
      jj = y0items.length;

      if (!component0.codingStyleParameters.reversibleTransformation) {
        for (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1items[j];
          y2 = y2items[j];
          out[pos++] = y0 + 1.402 * y2 >> shift;
          out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
          out[pos++] = y0 + 1.772 * y1 >> shift;
        }
      } else {
        for (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1items[j];
          y2 = y2items[j];
          const g = y0 - (y2 + y1 >> 2);
          out[pos++] = g + y2 >> shift;
          out[pos++] = g >> shift;
          out[pos++] = g + y1 >> shift;
        }
      }

      if (fourComponents) {
        for (j = 0, pos = 3; j < jj; j++, pos += 4) {
          out[pos] = y3items[j] + offset >> shift;
        }
      }
    } else {
      for (let c = 0; c < componentsCount; c++) {
        const items = transformedTiles[c].items;
        shift = components[c].precision - 8;
        offset = (128 << shift) + 0.5;

        for (pos = c, j = 0, jj = items.length; j < jj; j++) {
          out[pos] = items[j] + offset >> shift;
          pos += componentsCount;
        }
      }
    }

    resultImages.push(result);
  }

  return resultImages;
}

function initializeTile(context, tileIndex) {
  const siz = context.SIZ;
  const componentsCount = siz.Csiz;
  const tile = context.tiles[tileIndex];

  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const qcdOrQcc = context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD;
    component.quantizationParameters = qcdOrQcc;
    const codOrCoc = context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD;
    component.codingStyleParameters = codOrCoc;
  }

  tile.codingStyleDefaultParameters = context.currentTile.COD;
}

class TagTree {
  constructor(width, height) {
    const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
    this.levels = [];

    for (let i = 0; i < levelsLength; i++) {
      const level = {
        width,
        height,
        items: []
      };
      this.levels.push(level);
      width = Math.ceil(width / 2);
      height = Math.ceil(height / 2);
    }
  }

  reset(i, j) {
    let currentLevel = 0,
        value = 0,
        level;

    while (currentLevel < this.levels.length) {
      level = this.levels[currentLevel];
      const index = i + j * level.width;

      if (level.items[index] !== undefined) {
        value = level.items[index];
        break;
      }

      level.index = index;
      i >>= 1;
      j >>= 1;
      currentLevel++;
    }

    currentLevel--;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    this.currentLevel = currentLevel;
    delete this.value;
  }

  incrementValue() {
    const level = this.levels[this.currentLevel];
    level.items[level.index]++;
  }

  nextLevel() {
    let currentLevel = this.currentLevel;
    let level = this.levels[currentLevel];
    const value = level.items[level.index];
    currentLevel--;

    if (currentLevel < 0) {
      this.value = value;
      return false;
    }

    this.currentLevel = currentLevel;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    return true;
  }

}

class InclusionTree {
  constructor(width, height, defaultValue) {
    const levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
    this.levels = [];

    for (let i = 0; i < levelsLength; i++) {
      const items = new Uint8Array(width * height);

      for (let j = 0, jj = items.length; j < jj; j++) {
        items[j] = defaultValue;
      }

      const level = {
        width,
        height,
        items
      };
      this.levels.push(level);
      width = Math.ceil(width / 2);
      height = Math.ceil(height / 2);
    }
  }

  reset(i, j, stopValue) {
    let currentLevel = 0;

    while (currentLevel < this.levels.length) {
      const level = this.levels[currentLevel];
      const index = i + j * level.width;
      level.index = index;
      const value = level.items[index];

      if (value === 0xff) {
        break;
      }

      if (value > stopValue) {
        this.currentLevel = currentLevel;
        this.propagateValues();
        return false;
      }

      i >>= 1;
      j >>= 1;
      currentLevel++;
    }

    this.currentLevel = currentLevel - 1;
    return true;
  }

  incrementValue(stopValue) {
    const level = this.levels[this.currentLevel];
    level.items[level.index] = stopValue + 1;
    this.propagateValues();
  }

  propagateValues() {
    let levelIndex = this.currentLevel;
    let level = this.levels[levelIndex];
    const currentValue = level.items[level.index];

    while (--levelIndex >= 0) {
      level = this.levels[levelIndex];
      level.items[level.index] = currentValue;
    }
  }

  nextLevel() {
    let currentLevel = this.currentLevel;
    let level = this.levels[currentLevel];
    const value = level.items[level.index];
    level.items[level.index] = 0xff;
    currentLevel--;

    if (currentLevel < 0) {
      return false;
    }

    this.currentLevel = currentLevel;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    return true;
  }

}

const BitModel = function BitModelClosure() {
  const UNIFORM_CONTEXT = 17;
  const RUNLENGTH_CONTEXT = 18;
  const LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
  const HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
  const HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);

  class BitModel {
    constructor(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;
      let contextLabelTable;

      if (subband === "HH") {
        contextLabelTable = HHContextLabel;
      } else if (subband === "HL") {
        contextLabelTable = HLContextLabel;
      } else {
        contextLabelTable = LLAndLHContextsLabel;
      }

      this.contextLabelTable = contextLabelTable;
      const coefficientCount = width * height;
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      let coefficentsMagnitude;

      if (mb > 14) {
        coefficentsMagnitude = new Uint32Array(coefficientCount);
      } else if (mb > 6) {
        coefficentsMagnitude = new Uint16Array(coefficientCount);
      } else {
        coefficentsMagnitude = new Uint8Array(coefficientCount);
      }

      this.coefficentsMagnitude = coefficentsMagnitude;
      this.processingFlags = new Uint8Array(coefficientCount);
      const bitsDecoded = new Uint8Array(coefficientCount);

      if (zeroBitPlanes !== 0) {
        for (let i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }

      this.bitsDecoded = bitsDecoded;
      this.reset();
    }

    setDecoder(decoder) {
      this.decoder = decoder;
    }

    reset() {
      this.contexts = new Int8Array(19);
      this.contexts[0] = 4 << 1 | 0;
      this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
      this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
    }

    setNeighborsSignificance(row, column, index) {
      const neighborsSignificance = this.neighborsSignificance;
      const width = this.width,
            height = this.height;
      const left = column > 0;
      const right = column + 1 < width;
      let i;

      if (row > 0) {
        i = index - width;

        if (left) {
          neighborsSignificance[i - 1] += 0x10;
        }

        if (right) {
          neighborsSignificance[i + 1] += 0x10;
        }

        neighborsSignificance[i] += 0x04;
      }

      if (row + 1 < height) {
        i = index + width;

        if (left) {
          neighborsSignificance[i - 1] += 0x10;
        }

        if (right) {
          neighborsSignificance[i + 1] += 0x10;
        }

        neighborsSignificance[i] += 0x04;
      }

      if (left) {
        neighborsSignificance[index - 1] += 0x01;
      }

      if (right) {
        neighborsSignificance[index + 1] += 0x01;
      }

      neighborsSignificance[index] |= 0x80;
    }

    runSignificancePropagationPass() {
      const decoder = this.decoder;
      const width = this.width,
            height = this.height;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const coefficentsSign = this.coefficentsSign;
      const neighborsSignificance = this.neighborsSignificance;
      const processingFlags = this.processingFlags;
      const contexts = this.contexts;
      const labels = this.contextLabelTable;
      const bitsDecoded = this.bitsDecoded;
      const processedInverseMask = ~1;
      const processedMask = 1;
      const firstMagnitudeBitMask = 2;

      for (let i0 = 0; i0 < height; i0 += 4) {
        for (let j = 0; j < width; j++) {
          let index = i0 * width + j;

          for (let i1 = 0; i1 < 4; i1++, index += width) {
            const i = i0 + i1;

            if (i >= height) {
              break;
            }

            processingFlags[index] &= processedInverseMask;

            if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
              continue;
            }

            const contextLabel = labels[neighborsSignificance[index]];
            const decision = decoder.readBit(contexts, contextLabel);

            if (decision) {
              const sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;
            }

            bitsDecoded[index]++;
            processingFlags[index] |= processedMask;
          }
        }
      }
    }

    decodeSignBit(row, column, index) {
      const width = this.width,
            height = this.height;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const coefficentsSign = this.coefficentsSign;
      let contribution, sign0, sign1, significance1;
      let contextLabel, decoded;
      significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;

      if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
        sign1 = coefficentsSign[index + 1];

        if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign1 - sign0;
        } else {
          contribution = 1 - sign1 - sign1;
        }
      } else if (significance1) {
        sign0 = coefficentsSign[index - 1];
        contribution = 1 - sign0 - sign0;
      } else {
        contribution = 0;
      }

      const horizontalContribution = 3 * contribution;
      significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;

      if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
        sign1 = coefficentsSign[index + width];

        if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign1 - sign0 + horizontalContribution;
        } else {
          contribution = 1 - sign1 - sign1 + horizontalContribution;
        }
      } else if (significance1) {
        sign0 = coefficentsSign[index - width];
        contribution = 1 - sign0 - sign0 + horizontalContribution;
      } else {
        contribution = horizontalContribution;
      }

      if (contribution >= 0) {
        contextLabel = 9 + contribution;
        decoded = this.decoder.readBit(this.contexts, contextLabel);
      } else {
        contextLabel = 9 - contribution;
        decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
      }

      return decoded;
    }

    runMagnitudeRefinementPass() {
      const decoder = this.decoder;
      const width = this.width,
            height = this.height;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const neighborsSignificance = this.neighborsSignificance;
      const contexts = this.contexts;
      const bitsDecoded = this.bitsDecoded;
      const processingFlags = this.processingFlags;
      const processedMask = 1;
      const firstMagnitudeBitMask = 2;
      const length = width * height;
      const width4 = width * 4;

      for (let index0 = 0, indexNext; index0 < length; index0 = indexNext) {
        indexNext = Math.min(length, index0 + width4);

        for (let j = 0; j < width; j++) {
          for (let index = index0 + j; index < indexNext; index += width) {
            if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
              continue;
            }

            let contextLabel = 16;

            if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
              processingFlags[index] ^= firstMagnitudeBitMask;
              const significance = neighborsSignificance[index] & 127;
              contextLabel = significance === 0 ? 15 : 14;
            }

            const bit = decoder.readBit(contexts, contextLabel);
            coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
            bitsDecoded[index]++;
            processingFlags[index] |= processedMask;
          }
        }
      }
    }

    runCleanupPass() {
      const decoder = this.decoder;
      const width = this.width,
            height = this.height;
      const neighborsSignificance = this.neighborsSignificance;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const coefficentsSign = this.coefficentsSign;
      const contexts = this.contexts;
      const labels = this.contextLabelTable;
      const bitsDecoded = this.bitsDecoded;
      const processingFlags = this.processingFlags;
      const processedMask = 1;
      const firstMagnitudeBitMask = 2;
      const oneRowDown = width;
      const twoRowsDown = width * 2;
      const threeRowsDown = width * 3;
      let iNext;

      for (let i0 = 0; i0 < height; i0 = iNext) {
        iNext = Math.min(i0 + 4, height);
        const indexBase = i0 * width;
        const checkAllEmpty = i0 + 3 < height;

        for (let j = 0; j < width; j++) {
          const index0 = indexBase + j;
          const allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
          let i1 = 0,
              index = index0;
          let i = i0,
              sign;

          if (allEmpty) {
            const hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);

            if (!hasSignificantCoefficent) {
              bitsDecoded[index0]++;
              bitsDecoded[index0 + oneRowDown]++;
              bitsDecoded[index0 + twoRowsDown]++;
              bitsDecoded[index0 + threeRowsDown]++;
              continue;
            }

            i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);

            if (i1 !== 0) {
              i = i0 + i1;
              index += i1 * width;
            }

            sign = this.decodeSignBit(i, j, index);
            coefficentsSign[index] = sign;
            coefficentsMagnitude[index] = 1;
            this.setNeighborsSignificance(i, j, index);
            processingFlags[index] |= firstMagnitudeBitMask;
            index = index0;

            for (let i2 = i0; i2 <= i; i2++, index += width) {
              bitsDecoded[index]++;
            }

            i1++;
          }

          for (i = i0 + i1; i < iNext; i++, index += width) {
            if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
              continue;
            }

            const contextLabel = labels[neighborsSignificance[index]];
            const decision = decoder.readBit(contexts, contextLabel);

            if (decision === 1) {
              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;
            }

            bitsDecoded[index]++;
          }
        }
      }
    }

    checkSegmentationSymbol() {
      const decoder = this.decoder;
      const contexts = this.contexts;
      const symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);

      if (symbol !== 0xa) {
        throw new JpxError("Invalid segmentation symbol");
      }
    }

  }

  return BitModel;
}();

class Transform {
  constructor() {
    if (this.constructor === Transform) {
      (0, _util.unreachable)("Cannot initialize Transform.");
    }
  }

  calculate(subbands, u0, v0) {
    let ll = subbands[0];

    for (let i = 1, ii = subbands.length; i < ii; i++) {
      ll = this.iterate(ll, subbands[i], u0, v0);
    }

    return ll;
  }

  extend(buffer, offset, size) {
    let i1 = offset - 1,
        j1 = offset + 1;
    let i2 = offset + size - 2,
        j2 = offset + size;
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1] = buffer[j1];
    buffer[j2] = buffer[i2];
  }

  filter(x, offset, length) {
    (0, _util.unreachable)("Abstract method `filter` called");
  }

  iterate(ll, hl_lh_hh, u0, v0) {
    const llWidth = ll.width,
          llHeight = ll.height;
    let llItems = ll.items;
    const width = hl_lh_hh.width;
    const height = hl_lh_hh.height;
    const items = hl_lh_hh.items;
    let i, j, k, l, u, v;

    for (k = 0, i = 0; i < llHeight; i++) {
      l = i * 2 * width;

      for (j = 0; j < llWidth; j++, k++, l += 2) {
        items[l] = llItems[k];
      }
    }

    llItems = ll.items = null;
    const bufferPadding = 4;
    const rowBuffer = new Float32Array(width + 2 * bufferPadding);

    if (width === 1) {
      if ((u0 & 1) !== 0) {
        for (v = 0, k = 0; v < height; v++, k += width) {
          items[k] *= 0.5;
        }
      }
    } else {
      for (v = 0, k = 0; v < height; v++, k += width) {
        rowBuffer.set(items.subarray(k, k + width), bufferPadding);
        this.extend(rowBuffer, bufferPadding, width);
        this.filter(rowBuffer, bufferPadding, width);
        items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
      }
    }

    let numBuffers = 16;
    const colBuffers = [];

    for (i = 0; i < numBuffers; i++) {
      colBuffers.push(new Float32Array(height + 2 * bufferPadding));
    }

    let b,
        currentBuffer = 0;
    ll = bufferPadding + height;

    if (height === 1) {
      if ((v0 & 1) !== 0) {
        for (u = 0; u < width; u++) {
          items[u] *= 0.5;
        }
      }
    } else {
      for (u = 0; u < width; u++) {
        if (currentBuffer === 0) {
          numBuffers = Math.min(width - u, numBuffers);

          for (k = u, l = bufferPadding; l < ll; k += width, l++) {
            for (b = 0; b < numBuffers; b++) {
              colBuffers[b][l] = items[k + b];
            }
          }

          currentBuffer = numBuffers;
        }

        currentBuffer--;
        const buffer = colBuffers[currentBuffer];
        this.extend(buffer, bufferPadding, height);
        this.filter(buffer, bufferPadding, height);

        if (currentBuffer === 0) {
          k = u - numBuffers + 1;

          for (l = bufferPadding; l < ll; k += width, l++) {
            for (b = 0; b < numBuffers; b++) {
              items[k + b] = colBuffers[b][l];
            }
          }
        }
      }
    }

    return {
      width,
      height,
      items
    };
  }

}

class IrreversibleTransform extends Transform {
  filter(x, offset, length) {
    const len = length >> 1;
    offset = offset | 0;
    let j, n, current, next;
    const alpha = -1.586134342059924;
    const beta = -0.052980118572961;
    const gamma = 0.882911075530934;
    const delta = 0.443506852043971;
    const K = 1.230174104914001;
    const K_ = 1 / K;
    j = offset - 3;

    for (n = len + 4; n--; j += 2) {
      x[j] *= K_;
    }

    j = offset - 2;
    current = delta * x[j - 1];

    for (n = len + 3; n--; j += 2) {
      next = delta * x[j + 1];
      x[j] = K * x[j] - current - next;

      if (n--) {
        j += 2;
        current = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
      } else {
        break;
      }
    }

    j = offset - 1;
    current = gamma * x[j - 1];

    for (n = len + 2; n--; j += 2) {
      next = gamma * x[j + 1];
      x[j] -= current + next;

      if (n--) {
        j += 2;
        current = gamma * x[j + 1];
        x[j] -= current + next;
      } else {
        break;
      }
    }

    j = offset;
    current = beta * x[j - 1];

    for (n = len + 1; n--; j += 2) {
      next = beta * x[j + 1];
      x[j] -= current + next;

      if (n--) {
        j += 2;
        current = beta * x[j + 1];
        x[j] -= current + next;
      } else {
        break;
      }
    }

    if (len !== 0) {
      j = offset + 1;
      current = alpha * x[j - 1];

      for (n = len; n--; j += 2) {
        next = alpha * x[j + 1];
        x[j] -= current + next;

        if (n--) {
          j += 2;
          current = alpha * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }
    }
  }

}

class ReversibleTransform extends Transform {
  filter(x, offset, length) {
    const len = length >> 1;
    offset = offset | 0;
    let j, n;

    for (j = offset, n = len + 1; n--; j += 2) {
      x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
    }

    for (j = offset + 1, n = len; n--; j += 2) {
      x[j] += x[j - 1] + x[j + 1] >> 1;
    }
  }

}

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LZWStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

class LZWStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, earlyChange) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    const maxLzwDictionarySize = 4096;
    const lzwState = {
      earlyChange,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(maxLzwDictionarySize),
      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
      currentSequence: new Uint8Array(maxLzwDictionarySize),
      currentSequenceLength: 0
    };

    for (let i = 0; i < 256; ++i) {
      lzwState.dictionaryValues[i] = i;
      lzwState.dictionaryLengths[i] = 1;
    }

    this.lzwState = lzwState;
  }

  readBits(n) {
    let bitsCached = this.bitsCached;
    let cachedData = this.cachedData;

    while (bitsCached < n) {
      const c = this.str.getByte();

      if (c === -1) {
        this.eof = true;
        return null;
      }

      cachedData = cachedData << 8 | c;
      bitsCached += 8;
    }

    this.bitsCached = bitsCached -= n;
    this.cachedData = cachedData;
    this.lastCode = null;
    return cachedData >>> bitsCached & (1 << n) - 1;
  }

  readBlock() {
    const blockSize = 512,
          decodedSizeDelta = blockSize;
    let estimatedDecodedSize = blockSize * 2;
    let i, j, q;
    const lzwState = this.lzwState;

    if (!lzwState) {
      return;
    }

    const earlyChange = lzwState.earlyChange;
    let nextCode = lzwState.nextCode;
    const dictionaryValues = lzwState.dictionaryValues;
    const dictionaryLengths = lzwState.dictionaryLengths;
    const dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
    let codeLength = lzwState.codeLength;
    let prevCode = lzwState.prevCode;
    const currentSequence = lzwState.currentSequence;
    let currentSequenceLength = lzwState.currentSequenceLength;
    let decodedLength = 0;
    let currentBufferLength = this.bufferLength;
    let buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);

    for (i = 0; i < blockSize; i++) {
      const code = this.readBits(codeLength);
      const hasPrev = currentSequenceLength > 0;

      if (code < 256) {
        currentSequence[0] = code;
        currentSequenceLength = 1;
      } else if (code >= 258) {
        if (code < nextCode) {
          currentSequenceLength = dictionaryLengths[code];

          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
            currentSequence[j] = dictionaryValues[q];
            q = dictionaryPrevCodes[q];
          }
        } else {
          currentSequence[currentSequenceLength++] = currentSequence[0];
        }
      } else if (code === 256) {
        codeLength = 9;
        nextCode = 258;
        currentSequenceLength = 0;
        continue;
      } else {
        this.eof = true;
        delete this.lzwState;
        break;
      }

      if (hasPrev) {
        dictionaryPrevCodes[nextCode] = prevCode;
        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
        dictionaryValues[nextCode] = currentSequence[0];
        nextCode++;
        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
      }

      prevCode = code;
      decodedLength += currentSequenceLength;

      if (estimatedDecodedSize < decodedLength) {
        do {
          estimatedDecodedSize += decodedSizeDelta;
        } while (estimatedDecodedSize < decodedLength);

        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      }

      for (j = 0; j < currentSequenceLength; j++) {
        buffer[currentBufferLength++] = currentSequence[j];
      }
    }

    lzwState.nextCode = nextCode;
    lzwState.codeLength = codeLength;
    lzwState.prevCode = prevCode;
    lzwState.currentSequenceLength = currentSequenceLength;
    this.bufferLength = currentBufferLength;
  }

}

exports.LZWStream = LZWStream;

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PredictorStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

class PredictorStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, params) {
    super(maybeLength);

    if (!(0, _primitives.isDict)(params)) {
      return str;
    }

    const predictor = this.predictor = params.get("Predictor") || 1;

    if (predictor <= 1) {
      return str;
    }

    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
      throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
    }

    if (predictor === 2) {
      this.readBlock = this.readBlockTiff;
    } else {
      this.readBlock = this.readBlockPng;
    }

    this.str = str;
    this.dict = str.dict;
    const colors = this.colors = params.get("Colors") || 1;
    const bits = this.bits = params.get("BitsPerComponent") || 8;
    const columns = this.columns = params.get("Columns") || 1;
    this.pixBytes = colors * bits + 7 >> 3;
    this.rowBytes = columns * colors * bits + 7 >> 3;
    return this;
  }

  readBlockTiff() {
    const rowBytes = this.rowBytes;
    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    const bits = this.bits;
    const colors = this.colors;
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;

    if (this.eof) {
      return;
    }

    let inbuf = 0,
        outbuf = 0;
    let inbits = 0,
        outbits = 0;
    let pos = bufferLength;
    let i;

    if (bits === 1 && colors === 1) {
      for (i = 0; i < rowBytes; ++i) {
        let c = rawBytes[i] ^ inbuf;
        c ^= c >> 1;
        c ^= c >> 2;
        c ^= c >> 4;
        inbuf = (c & 1) << 7;
        buffer[pos++] = c;
      }
    } else if (bits === 8) {
      for (i = 0; i < colors; ++i) {
        buffer[pos++] = rawBytes[i];
      }

      for (; i < rowBytes; ++i) {
        buffer[pos] = buffer[pos - colors] + rawBytes[i];
        pos++;
      }
    } else if (bits === 16) {
      const bytesPerPixel = colors * 2;

      for (i = 0; i < bytesPerPixel; ++i) {
        buffer[pos++] = rawBytes[i];
      }

      for (; i < rowBytes; i += 2) {
        const sum = ((rawBytes[i] & 0xff) << 8) + (rawBytes[i + 1] & 0xff) + ((buffer[pos - bytesPerPixel] & 0xff) << 8) + (buffer[pos - bytesPerPixel + 1] & 0xff);
        buffer[pos++] = sum >> 8 & 0xff;
        buffer[pos++] = sum & 0xff;
      }
    } else {
      const compArray = new Uint8Array(colors + 1);
      const bitMask = (1 << bits) - 1;
      let j = 0,
          k = bufferLength;
      const columns = this.columns;

      for (i = 0; i < columns; ++i) {
        for (let kk = 0; kk < colors; ++kk) {
          if (inbits < bits) {
            inbuf = inbuf << 8 | rawBytes[j++] & 0xff;
            inbits += 8;
          }

          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
          inbits -= bits;
          outbuf = outbuf << bits | compArray[kk];
          outbits += bits;

          if (outbits >= 8) {
            buffer[k++] = outbuf >> outbits - 8 & 0xff;
            outbits -= 8;
          }
        }
      }

      if (outbits > 0) {
        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
      }
    }

    this.bufferLength += rowBytes;
  }

  readBlockPng() {
    const rowBytes = this.rowBytes;
    const pixBytes = this.pixBytes;
    const predictor = this.str.getByte();
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;

    if (this.eof) {
      return;
    }

    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);

    if (prevRow.length === 0) {
      prevRow = new Uint8Array(rowBytes);
    }

    let i,
        j = bufferLength,
        up,
        c;

    switch (predictor) {
      case 0:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }

        break;

      case 1:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }

        for (; i < rowBytes; ++i) {
          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xff;
          j++;
        }

        break;

      case 2:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = prevRow[i] + rawBytes[i] & 0xff;
        }

        break;

      case 3:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
        }

        for (; i < rowBytes; ++i) {
          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xff;
          j++;
        }

        break;

      case 4:
        for (i = 0; i < pixBytes; ++i) {
          up = prevRow[i];
          c = rawBytes[i];
          buffer[j++] = up + c;
        }

        for (; i < rowBytes; ++i) {
          up = prevRow[i];
          const upLeft = prevRow[i - pixBytes];
          const left = buffer[j - pixBytes];
          const p = left + up - upLeft;
          let pa = p - left;

          if (pa < 0) {
            pa = -pa;
          }

          let pb = p - up;

          if (pb < 0) {
            pb = -pb;
          }

          let pc = p - upLeft;

          if (pc < 0) {
            pc = -pc;
          }

          c = rawBytes[i];

          if (pa <= pb && pa <= pc) {
            buffer[j++] = left + c;
          } else if (pb <= pc) {
            buffer[j++] = up + c;
          } else {
            buffer[j++] = upLeft + c;
          }
        }

        break;

      default:
        throw new _util.FormatError(`Unsupported predictor: ${predictor}`);
    }

    this.bufferLength += rowBytes;
  }

}

exports.PredictorStream = PredictorStream;

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RunLengthStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

class RunLengthStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
  }

  readBlock() {
    const repeatHeader = this.str.getBytes(2);

    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
      this.eof = true;
      return;
    }

    let buffer;
    let bufferLength = this.bufferLength;
    let n = repeatHeader[0];

    if (n < 128) {
      buffer = this.ensureBuffer(bufferLength + n + 1);
      buffer[bufferLength++] = repeatHeader[1];

      if (n > 0) {
        const source = this.str.getBytes(n);
        buffer.set(source, bufferLength);
        bufferLength += n;
      }
    } else {
      n = 257 - n;
      const b = repeatHeader[1];
      buffer = this.ensureBuffer(bufferLength + n + 1);

      for (let i = 0; i < n; i++) {
        buffer[bufferLength++] = b;
      }
    }

    this.bufferLength = bufferLength;
  }

}

exports.RunLengthStream = RunLengthStream;

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Font = exports.ErrorFont = void 0;

var _util = __w_pdfjs_require__(2);

var _cff_parser = __w_pdfjs_require__(35);

var _fonts_utils = __w_pdfjs_require__(38);

var _glyphlist = __w_pdfjs_require__(39);

var _encodings = __w_pdfjs_require__(37);

var _standard_fonts = __w_pdfjs_require__(41);

var _unicode = __w_pdfjs_require__(40);

var _to_unicode_map = __w_pdfjs_require__(42);

var _cff_font = __w_pdfjs_require__(43);

var _font_renderer = __w_pdfjs_require__(44);

var _cmap = __w_pdfjs_require__(16);

var _opentype_file_builder = __w_pdfjs_require__(45);

var _core_utils = __w_pdfjs_require__(9);

var _stream = __w_pdfjs_require__(10);

var _type1_font = __w_pdfjs_require__(46);

const PRIVATE_USE_AREAS = [[0xe000, 0xf8ff], [0x100000, 0x10fffd]];
const PDF_GLYPH_SPACE_UNITS = 1000;
const EXPORT_DATA_PROPERTIES = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isMonospace", "isSerifFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"];
const EXPORT_DATA_EXTRA_PROPERTIES = ["cMap", "defaultEncoding", "differences", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];

function adjustWidths(properties) {
  if (!properties.fontMatrix) {
    return;
  }

  if (properties.fontMatrix[0] === _util.FONT_IDENTITY_MATRIX[0]) {
    return;
  }

  const scale = 0.001 / properties.fontMatrix[0];
  const glyphsWidths = properties.widths;

  for (const glyph in glyphsWidths) {
    glyphsWidths[glyph] *= scale;
  }

  properties.defaultWidth *= scale;
}

function adjustToUnicode(properties, builtInEncoding) {
  if (properties.hasIncludedToUnicodeMap) {
    return;
  }

  if (builtInEncoding === properties.defaultEncoding) {
    return;
  }

  if (properties.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
    return;
  }

  const toUnicode = [],
        glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();

  for (const charCode in builtInEncoding) {
    if (properties.hasEncoding && properties.differences[charCode] !== undefined) {
      continue;
    }

    const glyphName = builtInEncoding[charCode];
    const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);

    if (unicode !== -1) {
      toUnicode[charCode] = String.fromCharCode(unicode);
    }
  }

  properties.toUnicode.amend(toUnicode);
}

class Glyph {
  constructor(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    this.fontChar = fontChar;
    this.unicode = unicode;
    this.accent = accent;
    this.width = width;
    this.vmetric = vmetric;
    this.operatorListId = operatorListId;
    this.isSpace = isSpace;
    this.isInFont = isInFont;
  }

  matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    return this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
  }

}

function int16(b0, b1) {
  return (b0 << 8) + b1;
}

function writeSignedInt16(bytes, index, value) {
  bytes[index + 1] = value;
  bytes[index] = value >>> 8;
}

function signedInt16(b0, b1) {
  const value = (b0 << 8) + b1;
  return value & 1 << 15 ? value - 0x10000 : value;
}

function int32(b0, b1, b2, b3) {
  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
}

function string16(value) {
  return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
}

function safeString16(value) {
  if (value > 0x7fff) {
    value = 0x7fff;
  } else if (value < -0x8000) {
    value = -0x8000;
  }

  return String.fromCharCode(value >> 8 & 0xff, value & 0xff);
}

function isTrueTypeFile(file) {
  const header = file.peekBytes(4);
  return (0, _core_utils.readUint32)(header, 0) === 0x00010000 || (0, _util.bytesToString)(header) === "true";
}

function isTrueTypeCollectionFile(file) {
  const header = file.peekBytes(4);
  return (0, _util.bytesToString)(header) === "ttcf";
}

function isOpenTypeFile(file) {
  const header = file.peekBytes(4);
  return (0, _util.bytesToString)(header) === "OTTO";
}

function isType1File(file) {
  const header = file.peekBytes(2);

  if (header[0] === 0x25 && header[1] === 0x21) {
    return true;
  }

  if (header[0] === 0x80 && header[1] === 0x01) {
    return true;
  }

  return false;
}

function isCFFFile(file) {
  const header = file.peekBytes(4);

  if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {
    return true;
  }

  return false;
}

function getFontFileType(file, {
  type,
  subtype,
  composite
}) {
  let fileType, fileSubtype;

  if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
    if (composite) {
      fileType = "CIDFontType2";
    } else {
      fileType = "TrueType";
    }
  } else if (isOpenTypeFile(file)) {
    if (composite) {
      fileType = "CIDFontType2";
    } else {
      fileType = "OpenType";
    }
  } else if (isType1File(file)) {
    if (composite) {
      fileType = "CIDFontType0";
    } else {
      fileType = type === "MMType1" ? "MMType1" : "Type1";
    }
  } else if (isCFFFile(file)) {
    if (composite) {
      fileType = "CIDFontType0";
      fileSubtype = "CIDFontType0C";
    } else {
      fileType = type === "MMType1" ? "MMType1" : "Type1";
      fileSubtype = "Type1C";
    }
  } else {
    (0, _util.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
    fileType = type;
    fileSubtype = subtype;
  }

  return [fileType, fileSubtype];
}

function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
  const toFontChar = [];
  let unicode;

  for (let i = 0, ii = encoding.length; i < ii; i++) {
    unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);

    if (unicode !== -1) {
      toFontChar[i] = unicode;
    }
  }

  for (const charCode in differences) {
    unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);

    if (unicode !== -1) {
      toFontChar[+charCode] = unicode;
    }
  }

  return toFontChar;
}

function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId) {
  const newMap = Object.create(null);
  const toFontChar = [];
  let privateUseAreaIndex = 0;
  let nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
  let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];

  for (let originalCharCode in charCodeToGlyphId) {
    originalCharCode |= 0;
    let glyphId = charCodeToGlyphId[originalCharCode];

    if (!hasGlyph(glyphId)) {
      continue;
    }

    if (nextAvailableFontCharCode > privateUseOffetEnd) {
      privateUseAreaIndex++;

      if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
        (0, _util.warn)("Ran out of space in font private use area.");
        break;
      }

      nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
      privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
    }

    const fontCharCode = nextAvailableFontCharCode++;

    if (glyphId === 0) {
      glyphId = newGlyphZeroId;
    }

    newMap[fontCharCode] = glyphId;
    toFontChar[originalCharCode] = fontCharCode;
  }

  return {
    toFontChar,
    charCodeToGlyphId: newMap,
    nextAvailableFontCharCode
  };
}

function getRanges(glyphs, numGlyphs) {
  const codes = [];

  for (const charCode in glyphs) {
    if (glyphs[charCode] >= numGlyphs) {
      continue;
    }

    codes.push({
      fontCharCode: charCode | 0,
      glyphId: glyphs[charCode]
    });
  }

  if (codes.length === 0) {
    codes.push({
      fontCharCode: 0,
      glyphId: 0
    });
  }

  codes.sort(function fontGetRangesSort(a, b) {
    return a.fontCharCode - b.fontCharCode;
  });
  const ranges = [];
  const length = codes.length;

  for (let n = 0; n < length;) {
    const start = codes[n].fontCharCode;
    const codeIndices = [codes[n].glyphId];
    ++n;
    let end = start;

    while (n < length && end + 1 === codes[n].fontCharCode) {
      codeIndices.push(codes[n].glyphId);
      ++end;
      ++n;

      if (end === 0xffff) {
        break;
      }
    }

    ranges.push([start, end, codeIndices]);
  }

  return ranges;
}

function createCmapTable(glyphs, numGlyphs) {
  const ranges = getRanges(glyphs, numGlyphs);
  const numTables = ranges[ranges.length - 1][1] > 0xffff ? 2 : 1;
  let cmap = "\x00\x00" + string16(numTables) + "\x00\x03" + "\x00\x01" + (0, _util.string32)(4 + numTables * 8);
  let i, ii, j, jj;

  for (i = ranges.length - 1; i >= 0; --i) {
    if (ranges[i][0] <= 0xffff) {
      break;
    }
  }

  const bmpLength = i + 1;

  if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
    ranges[i][1] = 0xfffe;
  }

  const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
  const segCount = bmpLength + trailingRangesCount;

  const searchParams = _opentype_file_builder.OpenTypeFileBuilder.getSearchParams(segCount, 2);

  let startCount = "";
  let endCount = "";
  let idDeltas = "";
  let idRangeOffsets = "";
  let glyphsIds = "";
  let bias = 0;
  let range, start, end, codes;

  for (i = 0, ii = bmpLength; i < ii; i++) {
    range = ranges[i];
    start = range[0];
    end = range[1];
    startCount += string16(start);
    endCount += string16(end);
    codes = range[2];
    let contiguous = true;

    for (j = 1, jj = codes.length; j < jj; ++j) {
      if (codes[j] !== codes[j - 1] + 1) {
        contiguous = false;
        break;
      }
    }

    if (!contiguous) {
      const offset = (segCount - i) * 2 + bias * 2;
      bias += end - start + 1;
      idDeltas += string16(0);
      idRangeOffsets += string16(offset);

      for (j = 0, jj = codes.length; j < jj; ++j) {
        glyphsIds += string16(codes[j]);
      }
    } else {
      const startCode = codes[0];
      idDeltas += string16(startCode - start & 0xffff);
      idRangeOffsets += string16(0);
    }
  }

  if (trailingRangesCount > 0) {
    endCount += "\xFF\xFF";
    startCount += "\xFF\xFF";
    idDeltas += "\x00\x01";
    idRangeOffsets += "\x00\x00";
  }

  const format314 = "\x00\x00" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\x00\x00" + startCount + idDeltas + idRangeOffsets + glyphsIds;
  let format31012 = "";
  let header31012 = "";

  if (numTables > 1) {
    cmap += "\x00\x03" + "\x00\x0A" + (0, _util.string32)(4 + numTables * 8 + 4 + format314.length);
    format31012 = "";

    for (i = 0, ii = ranges.length; i < ii; i++) {
      range = ranges[i];
      start = range[0];
      codes = range[2];
      let code = codes[0];

      for (j = 1, jj = codes.length; j < jj; ++j) {
        if (codes[j] !== codes[j - 1] + 1) {
          end = range[0] + j - 1;
          format31012 += (0, _util.string32)(start) + (0, _util.string32)(end) + (0, _util.string32)(code);
          start = end + 1;
          code = codes[j];
        }
      }

      format31012 += (0, _util.string32)(start) + (0, _util.string32)(range[1]) + (0, _util.string32)(code);
    }

    header31012 = "\x00\x0C" + "\x00\x00" + (0, _util.string32)(format31012.length + 16) + "\x00\x00\x00\x00" + (0, _util.string32)(format31012.length / 12);
  }

  return cmap + "\x00\x04" + string16(format314.length + 4) + format314 + header31012 + format31012;
}

function validateOS2Table(os2, file) {
  file.pos = (file.start || 0) + os2.offset;
  const version = file.getUint16();
  file.skip(60);
  const selection = file.getUint16();

  if (version < 4 && selection & 0x0300) {
    return false;
  }

  const firstChar = file.getUint16();
  const lastChar = file.getUint16();

  if (firstChar > lastChar) {
    return false;
  }

  file.skip(6);
  const usWinAscent = file.getUint16();

  if (usWinAscent === 0) {
    return false;
  }

  os2.data[8] = os2.data[9] = 0;
  return true;
}

function createOS2Table(properties, charstrings, override) {
  override = override || {
    unitsPerEm: 0,
    yMax: 0,
    yMin: 0,
    ascent: 0,
    descent: 0
  };
  let ulUnicodeRange1 = 0;
  let ulUnicodeRange2 = 0;
  let ulUnicodeRange3 = 0;
  let ulUnicodeRange4 = 0;
  let firstCharIndex = null;
  let lastCharIndex = 0;

  if (charstrings) {
    for (let code in charstrings) {
      code |= 0;

      if (firstCharIndex > code || !firstCharIndex) {
        firstCharIndex = code;
      }

      if (lastCharIndex < code) {
        lastCharIndex = code;
      }

      const position = (0, _unicode.getUnicodeRangeFor)(code);

      if (position < 32) {
        ulUnicodeRange1 |= 1 << position;
      } else if (position < 64) {
        ulUnicodeRange2 |= 1 << position - 32;
      } else if (position < 96) {
        ulUnicodeRange3 |= 1 << position - 64;
      } else if (position < 123) {
        ulUnicodeRange4 |= 1 << position - 96;
      } else {
        throw new _util.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
      }
    }

    if (lastCharIndex > 0xffff) {
      lastCharIndex = 0xffff;
    }
  } else {
    firstCharIndex = 0;
    lastCharIndex = 255;
  }

  const bbox = properties.bbox || [0, 0, 0, 0];
  const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
  const scale = properties.ascentScaled ? 1.0 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
  const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
  let typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));

  if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
    typoDescent = -typoDescent;
  }

  const winAscent = override.yMax || typoAscent;
  const winDescent = -override.yMin || -typoDescent;
  return "\x00\x03" + "\x02\x24" + "\x01\xF4" + "\x00\x05" + "\x00\x00" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x00\x8C" + "\x02\x8A" + "\x02\xBB" + "\x00\x00" + "\x01\xDF" + "\x00\x31" + "\x01\x02" + "\x00\x00" + "\x00\x00\x06" + String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) + "\x00\x00\x00\x00\x00\x00" + (0, _util.string32)(ulUnicodeRange1) + (0, _util.string32)(ulUnicodeRange2) + (0, _util.string32)(ulUnicodeRange3) + (0, _util.string32)(ulUnicodeRange4) + "\x2A\x32\x31\x2A" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\x00\x64" + string16(winAscent) + string16(winDescent) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\x00\x03";
}

function createPostTable(properties) {
  const angle = Math.floor(properties.italicAngle * 2 ** 16);
  return "\x00\x03\x00\x00" + (0, _util.string32)(angle) + "\x00\x00" + "\x00\x00" + (0, _util.string32)(properties.fixedPitch) + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00" + "\x00\x00\x00\x00";
}

function createNameTable(name, proto) {
  if (!proto) {
    proto = [[], []];
  }

  const strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || "", proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
  const stringsUnicode = [];
  let i, ii, j, jj, str;

  for (i = 0, ii = strings.length; i < ii; i++) {
    str = proto[1][i] || strings[i];
    const strBufUnicode = [];

    for (j = 0, jj = str.length; j < jj; j++) {
      strBufUnicode.push(string16(str.charCodeAt(j)));
    }

    stringsUnicode.push(strBufUnicode.join(""));
  }

  const names = [strings, stringsUnicode];
  const platforms = ["\x00\x01", "\x00\x03"];
  const encodings = ["\x00\x00", "\x00\x01"];
  const languages = ["\x00\x00", "\x04\x09"];
  const namesRecordCount = strings.length * platforms.length;
  let nameTable = "\x00\x00" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
  let strOffset = 0;

  for (i = 0, ii = platforms.length; i < ii; i++) {
    const strs = names[i];

    for (j = 0, jj = strs.length; j < jj; j++) {
      str = strs[j];
      const nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
      nameTable += nameRecord;
      strOffset += str.length;
    }
  }

  nameTable += strings.join("") + stringsUnicode.join("");
  return nameTable;
}

class Font {
  constructor(name, file, properties) {
    this.name = name;
    this.mimetype = null;
    this.disableFontFace = false;
    this.loadedName = properties.loadedName;
    this.isType3Font = properties.isType3Font;
    this.missingFile = false;
    this.cssFontInfo = properties.cssFontInfo;
    this.glyphCache = Object.create(null);
    this.isSerifFont = !!(properties.flags & _fonts_utils.FontFlags.Serif);
    this.isSymbolicFont = !!(properties.flags & _fonts_utils.FontFlags.Symbolic);
    this.isMonospace = !!(properties.flags & _fonts_utils.FontFlags.FixedPitch);
    let type = properties.type;
    let subtype = properties.subtype;
    this.type = type;
    this.subtype = subtype;
    let fallbackName = "sans-serif";

    if (this.isMonospace) {
      fallbackName = "monospace";
    } else if (this.isSerifFont) {
      fallbackName = "serif";
    }

    this.fallbackName = fallbackName;
    this.differences = properties.differences;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.composite = properties.composite;
    this.cMap = properties.cMap;
    this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
    this.fontMatrix = properties.fontMatrix;
    this.bbox = properties.bbox;
    this.defaultEncoding = properties.defaultEncoding;
    this.toUnicode = properties.toUnicode;
    this.fallbackToUnicode = properties.fallbackToUnicode || new _to_unicode_map.ToUnicodeMap();
    this.toFontChar = [];

    if (properties.type === "Type3") {
      for (let charCode = 0; charCode < 256; charCode++) {
        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
      }

      this.fontType = _util.FontType.TYPE3;
      return;
    }

    this.cidEncoding = properties.cidEncoding;
    this.vertical = !!properties.vertical;

    if (this.vertical) {
      this.vmetrics = properties.vmetrics;
      this.defaultVMetrics = properties.defaultVMetrics;
    }

    if (!file || file.isEmpty) {
      if (file) {
        (0, _util.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
      }

      this.fallbackToSystemFont(properties);
      return;
    }

    [type, subtype] = getFontFileType(file, properties);

    if (type !== this.type || subtype !== this.subtype) {
      (0, _util.info)("Inconsistent font file Type/SubType, expected: " + `${this.type}/${this.subtype} but found: ${type}/${subtype}.`);
    }

    let data;

    try {
      switch (type) {
        case "MMType1":
          (0, _util.info)("MMType1 font (" + name + "), falling back to Type1.");

        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new _cff_font.CFFFont(file, properties) : new _type1_font.Type1Font(name, file, properties);
          adjustWidths(properties);
          data = this.convert(name, cff, properties);
          break;

        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype";
          data = this.checkAndRepair(name, file, properties);

          if (this.isOpenType) {
            adjustWidths(properties);
            type = "OpenType";
          }

          break;

        default:
          throw new _util.FormatError(`Font ${type} is not supported`);
      }
    } catch (e) {
      (0, _util.warn)(e);
      this.fallbackToSystemFont(properties);
      return;
    }

    this.data = data;
    this.fontType = (0, _fonts_utils.getFontType)(type, subtype);
    this.fontMatrix = properties.fontMatrix;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.toUnicode = properties.toUnicode;
    this.seacMap = properties.seacMap;
  }

  get renderer() {
    const renderer = _font_renderer.FontRendererFactory.create(this, _fonts_utils.SEAC_ANALYSIS_ENABLED);

    return (0, _util.shadow)(this, "renderer", renderer);
  }

  exportData(extraProperties = false) {
    const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES;
    const data = Object.create(null);
    let property, value;

    for (property of exportDataProperties) {
      value = this[property];

      if (value !== undefined) {
        data[property] = value;
      }
    }

    return data;
  }

  fallbackToSystemFont(properties) {
    this.missingFile = true;
    const name = this.name;
    const type = this.type;
    const subtype = this.subtype;
    let fontName = name.replace(/[,_]/g, "-").replace(/\s/g, "");
    const stdFontMap = (0, _standard_fonts.getStdFontMap)(),
          nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
    const isStandardFont = !!stdFontMap[fontName];
    const isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
    fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
    this.bold = fontName.search(/bold/gi) !== -1;
    this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
    this.black = name.search(/Black/g) !== -1;
    const isNarrow = name.search(/Narrow/g) !== -1;
    this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;

    if ((isStandardFont || isMappedToStandardFont) && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)(),
            cidToGidMap = properties.cidToGidMap;
      const map = [];

      for (const charCode in GlyphMapForStandardFonts) {
        map[+charCode] = GlyphMapForStandardFonts[charCode];
      }

      if (/Arial-?Black/i.test(name)) {
        const SupplementalGlyphMapForArialBlack = (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)();

        for (const charCode in SupplementalGlyphMapForArialBlack) {
          map[+charCode] = SupplementalGlyphMapForArialBlack[charCode];
        }
      } else if (/Calibri/i.test(name)) {
        const SupplementalGlyphMapForCalibri = (0, _standard_fonts.getSupplementalGlyphMapForCalibri)();

        for (const charCode in SupplementalGlyphMapForCalibri) {
          map[+charCode] = SupplementalGlyphMapForCalibri[charCode];
        }
      }

      if (cidToGidMap) {
        for (const charCode in map) {
          const cid = map[charCode];

          if (cidToGidMap[cid] !== undefined) {
            map[+charCode] = cidToGidMap[cid];
          }
        }
      }

      const isIdentityUnicode = this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap;

      if (!isIdentityUnicode) {
        this.toUnicode.forEach(function (charCode, unicodeCharCode) {
          map[+charCode] = unicodeCharCode;
        });
      }

      this.toFontChar = map;
      this.toUnicode = new _to_unicode_map.ToUnicodeMap(map);
    } else if (/Symbol/i.test(fontName)) {
      this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
    } else if (/Dingbats/i.test(fontName)) {
      if (/Wingdings/i.test(name)) {
        (0, _util.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats.");
      }

      this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
    } else if (isStandardFont) {
      this.toFontChar = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
    } else {
      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
      const map = [];
      this.toUnicode.forEach((charCode, unicodeCharCode) => {
        if (!this.composite) {
          const glyphName = this.differences[charCode] || this.defaultEncoding[charCode];
          const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);

          if (unicode !== -1) {
            unicodeCharCode = unicode;
          }
        }

        map[+charCode] = unicodeCharCode;
      });

      if (this.composite && this.toUnicode instanceof _to_unicode_map.IdentityToUnicodeMap) {
        if (/Verdana/i.test(name)) {
          const GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)();

          for (const charCode in GlyphMapForStandardFonts) {
            map[+charCode] = GlyphMapForStandardFonts[charCode];
          }
        }
      }

      this.toFontChar = map;
    }

    this.loadedName = fontName.split("-")[0];
    this.fontType = (0, _fonts_utils.getFontType)(type, subtype);
  }

  checkAndRepair(name, font, properties) {
    const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];

    function readTables(file, numTables) {
      const tables = Object.create(null);
      tables["OS/2"] = null;
      tables.cmap = null;
      tables.head = null;
      tables.hhea = null;
      tables.hmtx = null;
      tables.maxp = null;
      tables.name = null;
      tables.post = null;

      for (let i = 0; i < numTables; i++) {
        const table = readTableEntry(file);

        if (!VALID_TABLES.includes(table.tag)) {
          continue;
        }

        if (table.length === 0) {
          continue;
        }

        tables[table.tag] = table;
      }

      return tables;
    }

    function readTableEntry(file) {
      const tag = file.getString(4);
      const checksum = file.getInt32() >>> 0;
      const offset = file.getInt32() >>> 0;
      const length = file.getInt32() >>> 0;
      const previousPosition = file.pos;
      file.pos = file.start ? file.start : 0;
      file.skip(offset);
      const data = file.getBytes(length);
      file.pos = previousPosition;

      if (tag === "head") {
        data[8] = data[9] = data[10] = data[11] = 0;
        data[17] |= 0x20;
      }

      return {
        tag,
        checksum,
        length,
        offset,
        data
      };
    }

    function readOpenTypeHeader(ttf) {
      return {
        version: ttf.getString(4),
        numTables: ttf.getUint16(),
        searchRange: ttf.getUint16(),
        entrySelector: ttf.getUint16(),
        rangeShift: ttf.getUint16()
      };
    }

    function readTrueTypeCollectionHeader(ttc) {
      const ttcTag = ttc.getString(4);
      (0, _util.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
      const majorVersion = ttc.getUint16();
      const minorVersion = ttc.getUint16();
      const numFonts = ttc.getInt32() >>> 0;
      const offsetTable = [];

      for (let i = 0; i < numFonts; i++) {
        offsetTable.push(ttc.getInt32() >>> 0);
      }

      const header = {
        ttcTag,
        majorVersion,
        minorVersion,
        numFonts,
        offsetTable
      };

      switch (majorVersion) {
        case 1:
          return header;

        case 2:
          header.dsigTag = ttc.getInt32() >>> 0;
          header.dsigLength = ttc.getInt32() >>> 0;
          header.dsigOffset = ttc.getInt32() >>> 0;
          return header;
      }

      throw new _util.FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);
    }

    function readTrueTypeCollectionData(ttc, fontName) {
      const {
        numFonts,
        offsetTable
      } = readTrueTypeCollectionHeader(ttc);
      const fontNameParts = fontName.split("+");
      let fallbackData;

      for (let i = 0; i < numFonts; i++) {
        ttc.pos = (ttc.start || 0) + offsetTable[i];
        const potentialHeader = readOpenTypeHeader(ttc);
        const potentialTables = readTables(ttc, potentialHeader.numTables);

        if (!potentialTables.name) {
          throw new _util.FormatError('TrueType Collection font must contain a "name" table.');
        }

        const nameTable = readNameTable(potentialTables.name);

        for (let j = 0, jj = nameTable.length; j < jj; j++) {
          for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
            const nameEntry = nameTable[j][k] && nameTable[j][k].replace(/\s/g, "");

            if (!nameEntry) {
              continue;
            }

            if (nameEntry === fontName) {
              return {
                header: potentialHeader,
                tables: potentialTables
              };
            }

            if (fontNameParts.length < 2) {
              continue;
            }

            for (const part of fontNameParts) {
              if (nameEntry === part) {
                fallbackData = {
                  name: part,
                  header: potentialHeader,
                  tables: potentialTables
                };
              }
            }
          }
        }
      }

      if (fallbackData) {
        (0, _util.warn)(`TrueType Collection does not contain "${fontName}" font, ` + `falling back to "${fallbackData.name}" font instead.`);
        return {
          header: fallbackData.header,
          tables: fallbackData.tables
        };
      }

      throw new _util.FormatError(`TrueType Collection does not contain "${fontName}" font.`);
    }

    function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
      if (!cmap) {
        (0, _util.warn)("No cmap table available.");
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }

      let segment;
      let start = (file.start ? file.start : 0) + cmap.offset;
      file.pos = start;
      file.skip(2);
      const numTables = file.getUint16();
      let potentialTable;
      let canBreak = false;

      for (let i = 0; i < numTables; i++) {
        const platformId = file.getUint16();
        const encodingId = file.getUint16();
        const offset = file.getInt32() >>> 0;
        let useTable = false;

        if (potentialTable && potentialTable.platformId === platformId && potentialTable.encodingId === encodingId) {
          continue;
        }

        if (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 3)) {
          useTable = true;
        } else if (platformId === 1 && encodingId === 0) {
          useTable = true;
        } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
          useTable = true;

          if (!isSymbolicFont) {
            canBreak = true;
          }
        } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
          useTable = true;
          canBreak = true;
        }

        if (useTable) {
          potentialTable = {
            platformId,
            encodingId,
            offset
          };
        }

        if (canBreak) {
          break;
        }
      }

      if (potentialTable) {
        file.pos = start + potentialTable.offset;
      }

      if (!potentialTable || file.peekByte() === -1) {
        (0, _util.warn)("Could not find a preferred cmap table.");
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }

      const format = file.getUint16();
      file.skip(2 + 2);
      let hasShortCmap = false;
      const mappings = [];
      let j, glyphId;

      if (format === 0) {
        for (j = 0; j < 256; j++) {
          const index = file.getByte();

          if (!index) {
            continue;
          }

          mappings.push({
            charCode: j,
            glyphId: index
          });
        }

        hasShortCmap = true;
      } else if (format === 4) {
        const segCount = file.getUint16() >> 1;
        file.skip(6);
        const segments = [];
        let segIndex;

        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments.push({
            end: file.getUint16()
          });
        }

        file.skip(2);

        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments[segIndex].start = file.getUint16();
        }

        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments[segIndex].delta = file.getUint16();
        }

        let offsetsCount = 0,
            offsetIndex;

        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segment = segments[segIndex];
          const rangeOffset = file.getUint16();

          if (!rangeOffset) {
            segment.offsetIndex = -1;
            continue;
          }

          offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
          segment.offsetIndex = offsetIndex;
          offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
        }

        const offsets = [];

        for (j = 0; j < offsetsCount; j++) {
          offsets.push(file.getUint16());
        }

        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segment = segments[segIndex];
          start = segment.start;
          const end = segment.end;
          const delta = segment.delta;
          offsetIndex = segment.offsetIndex;

          for (j = start; j <= end; j++) {
            if (j === 0xffff) {
              continue;
            }

            glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
            glyphId = glyphId + delta & 0xffff;
            mappings.push({
              charCode: j,
              glyphId
            });
          }
        }
      } else if (format === 6) {
        const firstCode = file.getUint16();
        const entryCount = file.getUint16();

        for (j = 0; j < entryCount; j++) {
          glyphId = file.getUint16();
          const charCode = firstCode + j;
          mappings.push({
            charCode,
            glyphId
          });
        }
      } else {
        (0, _util.warn)("cmap table has unsupported format: " + format);
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }

      mappings.sort(function (a, b) {
        return a.charCode - b.charCode;
      });

      for (let i = 1; i < mappings.length; i++) {
        if (mappings[i - 1].charCode === mappings[i].charCode) {
          mappings.splice(i, 1);
          i--;
        }
      }

      return {
        platformId: potentialTable.platformId,
        encodingId: potentialTable.encodingId,
        mappings,
        hasShortCmap
      };
    }

    function sanitizeMetrics(file, header, metrics, numGlyphs, dupFirstEntry) {
      if (!header) {
        if (metrics) {
          metrics.data = null;
        }

        return;
      }

      file.pos = (file.start ? file.start : 0) + header.offset;
      file.pos += 4;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 8;
      file.pos += 2;
      let numOfMetrics = file.getUint16();

      if (numOfMetrics > numGlyphs) {
        (0, _util.info)("The numOfMetrics (" + numOfMetrics + ") should not be " + "greater than the numGlyphs (" + numGlyphs + ")");
        numOfMetrics = numGlyphs;
        header.data[34] = (numOfMetrics & 0xff00) >> 8;
        header.data[35] = numOfMetrics & 0x00ff;
      }

      const numOfSidebearings = numGlyphs - numOfMetrics;
      const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);

      if (numMissing > 0) {
        const entries = new Uint8Array(metrics.length + numMissing * 2);
        entries.set(metrics.data);

        if (dupFirstEntry) {
          entries[metrics.length] = metrics.data[2];
          entries[metrics.length + 1] = metrics.data[3];
        }

        metrics.data = entries;
      }
    }

    function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid) {
      const glyphProfile = {
        length: 0,
        sizeOfInstructions: 0
      };

      if (sourceEnd - sourceStart <= 12) {
        return glyphProfile;
      }

      const glyf = source.subarray(sourceStart, sourceEnd);
      let contoursCount = signedInt16(glyf[0], glyf[1]);

      if (contoursCount < 0) {
        contoursCount = -1;
        writeSignedInt16(glyf, 0, contoursCount);
        dest.set(glyf, destStart);
        glyphProfile.length = glyf.length;
        return glyphProfile;
      }

      let i,
          j = 10,
          flagsCount = 0;

      for (i = 0; i < contoursCount; i++) {
        const endPoint = glyf[j] << 8 | glyf[j + 1];
        flagsCount = endPoint + 1;
        j += 2;
      }

      const instructionsStart = j;
      const instructionsLength = glyf[j] << 8 | glyf[j + 1];
      glyphProfile.sizeOfInstructions = instructionsLength;
      j += 2 + instructionsLength;
      const instructionsEnd = j;
      let coordinatesLength = 0;

      for (i = 0; i < flagsCount; i++) {
        const flag = glyf[j++];

        if (flag & 0xc0) {
          glyf[j - 1] = flag & 0x3f;
        }

        let xLength = 2;

        if (flag & 2) {
          xLength = 1;
        } else if (flag & 16) {
          xLength = 0;
        }

        let yLength = 2;

        if (flag & 4) {
          yLength = 1;
        } else if (flag & 32) {
          yLength = 0;
        }

        const xyLength = xLength + yLength;
        coordinatesLength += xyLength;

        if (flag & 8) {
          const repeat = glyf[j++];
          i += repeat;
          coordinatesLength += repeat * xyLength;
        }
      }

      if (coordinatesLength === 0) {
        return glyphProfile;
      }

      let glyphDataLength = j + coordinatesLength;

      if (glyphDataLength > glyf.length) {
        return glyphProfile;
      }

      if (!hintsValid && instructionsLength > 0) {
        dest.set(glyf.subarray(0, instructionsStart), destStart);
        dest.set([0, 0], destStart + instructionsStart);
        dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
        glyphDataLength -= instructionsLength;

        if (glyf.length - glyphDataLength > 3) {
          glyphDataLength = glyphDataLength + 3 & ~3;
        }

        glyphProfile.length = glyphDataLength;
        return glyphProfile;
      }

      if (glyf.length - glyphDataLength > 3) {
        glyphDataLength = glyphDataLength + 3 & ~3;
        dest.set(glyf.subarray(0, glyphDataLength), destStart);
        glyphProfile.length = glyphDataLength;
        return glyphProfile;
      }

      dest.set(glyf, destStart);
      glyphProfile.length = glyf.length;
      return glyphProfile;
    }

    function sanitizeHead(head, numGlyphs, locaLength) {
      const data = head.data;
      const version = int32(data[0], data[1], data[2], data[3]);

      if (version >> 16 !== 1) {
        (0, _util.info)("Attempting to fix invalid version in head table: " + version);
        data[0] = 0;
        data[1] = 1;
        data[2] = 0;
        data[3] = 0;
      }

      const indexToLocFormat = int16(data[50], data[51]);

      if (indexToLocFormat < 0 || indexToLocFormat > 1) {
        (0, _util.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
        const numGlyphsPlusOne = numGlyphs + 1;

        if (locaLength === numGlyphsPlusOne << 1) {
          data[50] = 0;
          data[51] = 0;
        } else if (locaLength === numGlyphsPlusOne << 2) {
          data[50] = 0;
          data[51] = 1;
        } else {
          throw new _util.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
        }
      }
    }

    function sanitizeGlyphLocations(loca, glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions) {
      let itemSize, itemDecode, itemEncode;

      if (isGlyphLocationsLong) {
        itemSize = 4;

        itemDecode = function fontItemDecodeLong(data, offset) {
          return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
        };

        itemEncode = function fontItemEncodeLong(data, offset, value) {
          data[offset] = value >>> 24 & 0xff;
          data[offset + 1] = value >> 16 & 0xff;
          data[offset + 2] = value >> 8 & 0xff;
          data[offset + 3] = value & 0xff;
        };
      } else {
        itemSize = 2;

        itemDecode = function fontItemDecode(data, offset) {
          return data[offset] << 9 | data[offset + 1] << 1;
        };

        itemEncode = function fontItemEncode(data, offset, value) {
          data[offset] = value >> 9 & 0xff;
          data[offset + 1] = value >> 1 & 0xff;
        };
      }

      const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
      const locaDataSize = itemSize * (1 + numGlyphsOut);
      const locaData = new Uint8Array(locaDataSize);
      locaData.set(loca.data.subarray(0, locaDataSize));
      loca.data = locaData;
      const oldGlyfData = glyf.data;
      const oldGlyfDataLength = oldGlyfData.length;
      const newGlyfData = new Uint8Array(oldGlyfDataLength);
      let i, j;
      const locaEntries = [];

      for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
        let offset = itemDecode(locaData, j);

        if (offset > oldGlyfDataLength) {
          offset = oldGlyfDataLength;
        }

        locaEntries.push({
          index: i,
          offset,
          endOffset: 0
        });
      }

      locaEntries.sort((a, b) => {
        return a.offset - b.offset;
      });

      for (i = 0; i < numGlyphs; i++) {
        locaEntries[i].endOffset = locaEntries[i + 1].offset;
      }

      locaEntries.sort((a, b) => {
        return a.index - b.index;
      });
      const missingGlyphs = Object.create(null);
      let writeOffset = 0;
      itemEncode(locaData, 0, writeOffset);

      for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
        const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid);
        const newLength = glyphProfile.length;

        if (newLength === 0) {
          missingGlyphs[i] = true;
        }

        if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
          maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
        }

        writeOffset += newLength;
        itemEncode(locaData, j, writeOffset);
      }

      if (writeOffset === 0) {
        const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);

        for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
          itemEncode(locaData, j, simpleGlyph.length);
        }

        glyf.data = simpleGlyph;
      } else if (dupFirstEntry) {
        const firstEntryLength = itemDecode(locaData, itemSize);

        if (newGlyfData.length > firstEntryLength + writeOffset) {
          glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
        } else {
          glyf.data = new Uint8Array(firstEntryLength + writeOffset);
          glyf.data.set(newGlyfData.subarray(0, writeOffset));
        }

        glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
        itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
      } else {
        glyf.data = newGlyfData.subarray(0, writeOffset);
      }

      return {
        missingGlyphs,
        maxSizeOfInstructions
      };
    }

    function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
      const start = (font.start ? font.start : 0) + post.offset;
      font.pos = start;
      const length = post.length,
            end = start + length;
      const version = font.getInt32();
      font.skip(28);
      let glyphNames;
      let valid = true;
      let i;

      switch (version) {
        case 0x00010000:
          glyphNames = _fonts_utils.MacStandardGlyphOrdering;
          break;

        case 0x00020000:
          const numGlyphs = font.getUint16();

          if (numGlyphs !== maxpNumGlyphs) {
            valid = false;
            break;
          }

          const glyphNameIndexes = [];

          for (i = 0; i < numGlyphs; ++i) {
            const index = font.getUint16();

            if (index >= 32768) {
              valid = false;
              break;
            }

            glyphNameIndexes.push(index);
          }

          if (!valid) {
            break;
          }

          const customNames = [],
                strBuf = [];

          while (font.pos < end) {
            const stringLength = font.getByte();
            strBuf.length = stringLength;

            for (i = 0; i < stringLength; ++i) {
              strBuf[i] = String.fromCharCode(font.getByte());
            }

            customNames.push(strBuf.join(""));
          }

          glyphNames = [];

          for (i = 0; i < numGlyphs; ++i) {
            const j = glyphNameIndexes[i];

            if (j < 258) {
              glyphNames.push(_fonts_utils.MacStandardGlyphOrdering[j]);
              continue;
            }

            glyphNames.push(customNames[j - 258]);
          }

          break;

        case 0x00030000:
          break;

        default:
          (0, _util.warn)("Unknown/unsupported post table version " + version);
          valid = false;

          if (propertiesObj.defaultEncoding) {
            glyphNames = propertiesObj.defaultEncoding;
          }

          break;
      }

      propertiesObj.glyphNames = glyphNames;
      return valid;
    }

    function readNameTable(nameTable) {
      const start = (font.start ? font.start : 0) + nameTable.offset;
      font.pos = start;
      const names = [[], []];
      const length = nameTable.length,
            end = start + length;
      const format = font.getUint16();
      const FORMAT_0_HEADER_LENGTH = 6;

      if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
        return names;
      }

      const numRecords = font.getUint16();
      const stringsStart = font.getUint16();
      const records = [];
      const NAME_RECORD_LENGTH = 12;
      let i, ii;

      for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
        const r = {
          platform: font.getUint16(),
          encoding: font.getUint16(),
          language: font.getUint16(),
          name: font.getUint16(),
          length: font.getUint16(),
          offset: font.getUint16()
        };

        if (r.platform === 1 && r.encoding === 0 && r.language === 0 || r.platform === 3 && r.encoding === 1 && r.language === 0x409) {
          records.push(r);
        }
      }

      for (i = 0, ii = records.length; i < ii; i++) {
        const record = records[i];

        if (record.length <= 0) {
          continue;
        }

        const pos = start + stringsStart + record.offset;

        if (pos + record.length > end) {
          continue;
        }

        font.pos = pos;
        const nameIndex = record.name;

        if (record.encoding) {
          let str = "";

          for (let j = 0, jj = record.length; j < jj; j += 2) {
            str += String.fromCharCode(font.getUint16());
          }

          names[1][nameIndex] = str;
        } else {
          names[0][nameIndex] = font.getString(record.length);
        }
      }

      return names;
    }

    const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];

    function sanitizeTTProgram(table, ttContext) {
      let data = table.data;
      let i = 0,
          j,
          n,
          b,
          funcId,
          pc,
          lastEndf = 0,
          lastDeff = 0;
      const stack = [];
      const callstack = [];
      const functionsCalled = [];
      let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
      let inFDEF = false,
          ifLevel = 0,
          inELSE = 0;

      for (let ii = data.length; i < ii;) {
        const op = data[i++];

        if (op === 0x40) {
          n = data[i++];

          if (inFDEF || inELSE) {
            i += n;
          } else {
            for (j = 0; j < n; j++) {
              stack.push(data[i++]);
            }
          }
        } else if (op === 0x41) {
          n = data[i++];

          if (inFDEF || inELSE) {
            i += n * 2;
          } else {
            for (j = 0; j < n; j++) {
              b = data[i++];
              stack.push(b << 8 | data[i++]);
            }
          }
        } else if ((op & 0xf8) === 0xb0) {
          n = op - 0xb0 + 1;

          if (inFDEF || inELSE) {
            i += n;
          } else {
            for (j = 0; j < n; j++) {
              stack.push(data[i++]);
            }
          }
        } else if ((op & 0xf8) === 0xb8) {
          n = op - 0xb8 + 1;

          if (inFDEF || inELSE) {
            i += n * 2;
          } else {
            for (j = 0; j < n; j++) {
              b = data[i++];
              stack.push(b << 8 | data[i++]);
            }
          }
        } else if (op === 0x2b && !tooComplexToFollowFunctions) {
          if (!inFDEF && !inELSE) {
            funcId = stack[stack.length - 1];

            if (isNaN(funcId)) {
              (0, _util.info)("TT: CALL empty stack (or invalid entry).");
            } else {
              ttContext.functionsUsed[funcId] = true;

              if (funcId in ttContext.functionsStackDeltas) {
                const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];

                if (newStackLength < 0) {
                  (0, _util.warn)("TT: CALL invalid functions stack delta.");
                  ttContext.hintsValid = false;
                  return;
                }

                stack.length = newStackLength;
              } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                callstack.push({
                  data,
                  i,
                  stackTop: stack.length - 1
                });
                functionsCalled.push(funcId);
                pc = ttContext.functionsDefined[funcId];

                if (!pc) {
                  (0, _util.warn)("TT: CALL non-existent function");
                  ttContext.hintsValid = false;
                  return;
                }

                data = pc.data;
                i = pc.i;
              }
            }
          }
        } else if (op === 0x2c && !tooComplexToFollowFunctions) {
          if (inFDEF || inELSE) {
            (0, _util.warn)("TT: nested FDEFs not allowed");
            tooComplexToFollowFunctions = true;
          }

          inFDEF = true;
          lastDeff = i;
          funcId = stack.pop();
          ttContext.functionsDefined[funcId] = {
            data,
            i
          };
        } else if (op === 0x2d) {
          if (inFDEF) {
            inFDEF = false;
            lastEndf = i;
          } else {
            pc = callstack.pop();

            if (!pc) {
              (0, _util.warn)("TT: ENDF bad stack");
              ttContext.hintsValid = false;
              return;
            }

            funcId = functionsCalled.pop();
            data = pc.data;
            i = pc.i;
            ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
          }
        } else if (op === 0x89) {
          if (inFDEF || inELSE) {
            (0, _util.warn)("TT: nested IDEFs not allowed");
            tooComplexToFollowFunctions = true;
          }

          inFDEF = true;
          lastDeff = i;
        } else if (op === 0x58) {
          ++ifLevel;
        } else if (op === 0x1b) {
          inELSE = ifLevel;
        } else if (op === 0x59) {
          if (inELSE === ifLevel) {
            inELSE = 0;
          }

          --ifLevel;
        } else if (op === 0x1c) {
          if (!inFDEF && !inELSE) {
            const offset = stack[stack.length - 1];

            if (offset > 0) {
              i += offset - 1;
            }
          }
        }

        if (!inFDEF && !inELSE) {
          let stackDelta = 0;

          if (op <= 0x8e) {
            stackDelta = TTOpsStackDeltas[op];
          } else if (op >= 0xc0 && op <= 0xdf) {
            stackDelta = -1;
          } else if (op >= 0xe0) {
            stackDelta = -2;
          }

          if (op >= 0x71 && op <= 0x75) {
            n = stack.pop();

            if (!isNaN(n)) {
              stackDelta = -n * 2;
            }
          }

          while (stackDelta < 0 && stack.length > 0) {
            stack.pop();
            stackDelta++;
          }

          while (stackDelta > 0) {
            stack.push(NaN);
            stackDelta--;
          }
        }
      }

      ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
      const content = [data];

      if (i > data.length) {
        content.push(new Uint8Array(i - data.length));
      }

      if (lastDeff > lastEndf) {
        (0, _util.warn)("TT: complementing a missing function tail");
        content.push(new Uint8Array([0x22, 0x2d]));
      }

      foldTTTable(table, content);
    }

    function checkInvalidFunctions(ttContext, maxFunctionDefs) {
      if (ttContext.tooComplexToFollowFunctions) {
        return;
      }

      if (ttContext.functionsDefined.length > maxFunctionDefs) {
        (0, _util.warn)("TT: more functions defined than expected");
        ttContext.hintsValid = false;
        return;
      }

      for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
        if (j > maxFunctionDefs) {
          (0, _util.warn)("TT: invalid function id: " + j);
          ttContext.hintsValid = false;
          return;
        }

        if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
          (0, _util.warn)("TT: undefined function: " + j);
          ttContext.hintsValid = false;
          return;
        }
      }
    }

    function foldTTTable(table, content) {
      if (content.length > 1) {
        let newLength = 0;
        let j, jj;

        for (j = 0, jj = content.length; j < jj; j++) {
          newLength += content[j].length;
        }

        newLength = newLength + 3 & ~3;
        const result = new Uint8Array(newLength);
        let pos = 0;

        for (j = 0, jj = content.length; j < jj; j++) {
          result.set(content[j], pos);
          pos += content[j].length;
        }

        table.data = result;
        table.length = newLength;
      }
    }

    function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
      const ttContext = {
        functionsDefined: [],
        functionsUsed: [],
        functionsStackDeltas: [],
        tooComplexToFollowFunctions: false,
        hintsValid: true
      };

      if (fpgm) {
        sanitizeTTProgram(fpgm, ttContext);
      }

      if (prep) {
        sanitizeTTProgram(prep, ttContext);
      }

      if (fpgm) {
        checkInvalidFunctions(ttContext, maxFunctionDefs);
      }

      if (cvt && cvt.length & 1) {
        const cvtData = new Uint8Array(cvt.length + 1);
        cvtData.set(cvt.data);
        cvt.data = cvtData;
      }

      return ttContext.hintsValid;
    }

    font = new _stream.Stream(new Uint8Array(font.getBytes()));
    let header, tables;

    if (isTrueTypeCollectionFile(font)) {
      const ttcData = readTrueTypeCollectionData(font, this.name);
      header = ttcData.header;
      tables = ttcData.tables;
    } else {
      header = readOpenTypeHeader(font);
      tables = readTables(font, header.numTables);
    }

    let cff, cffFile;
    const isTrueType = !tables["CFF "];

    if (!isTrueType) {
      const isComposite = properties.composite && ((properties.cidToGidMap || []).length > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));

      if (header.version === "OTTO" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
        cffFile = new _stream.Stream(tables["CFF "].data);
        cff = new _cff_font.CFFFont(cffFile, properties);
        adjustWidths(properties);
        return this.convert(name, cff, properties);
      }

      delete tables.glyf;
      delete tables.loca;
      delete tables.fpgm;
      delete tables.prep;
      delete tables["cvt "];
      this.isOpenType = true;
    } else {
      if (!tables.loca) {
        throw new _util.FormatError('Required "loca" table is not found');
      }

      if (!tables.glyf) {
        (0, _util.warn)('Required "glyf" table is not found -- trying to recover.');
        tables.glyf = {
          tag: "glyf",
          data: new Uint8Array(0)
        };
      }

      this.isOpenType = false;
    }

    if (!tables.maxp) {
      throw new _util.FormatError('Required "maxp" table is not found');
    }

    font.pos = (font.start || 0) + tables.maxp.offset;
    const version = font.getInt32();
    const numGlyphs = font.getUint16();
    let numGlyphsOut = numGlyphs + 1;
    let dupFirstEntry = true;

    if (numGlyphsOut > 0xffff) {
      dupFirstEntry = false;
      numGlyphsOut = numGlyphs;
      (0, _util.warn)("Not enough space in glyfs to duplicate first glyph.");
    }

    let maxFunctionDefs = 0;
    let maxSizeOfInstructions = 0;

    if (version >= 0x00010000 && tables.maxp.length >= 22) {
      font.pos += 8;
      const maxZones = font.getUint16();

      if (maxZones > 2) {
        tables.maxp.data[14] = 0;
        tables.maxp.data[15] = 2;
      }

      font.pos += 4;
      maxFunctionDefs = font.getUint16();
      font.pos += 4;
      maxSizeOfInstructions = font.getUint16();
    }

    tables.maxp.data[4] = numGlyphsOut >> 8;
    tables.maxp.data[5] = numGlyphsOut & 255;
    const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables["cvt "], maxFunctionDefs);

    if (!hintsValid) {
      delete tables.fpgm;
      delete tables.prep;
      delete tables["cvt "];
    }

    sanitizeMetrics(font, tables.hhea, tables.hmtx, numGlyphsOut, dupFirstEntry);

    if (!tables.head) {
      throw new _util.FormatError('Required "head" table is not found');
    }

    sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
    let missingGlyphs = Object.create(null);

    if (isTrueType) {
      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
      const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
      missingGlyphs = glyphsInfo.missingGlyphs;

      if (version >= 0x00010000 && tables.maxp.length >= 22) {
        tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
        tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
      }
    }

    if (!tables.hhea) {
      throw new _util.FormatError('Required "hhea" table is not found');
    }

    if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
      tables.hhea.data[10] = 0xff;
      tables.hhea.data[11] = 0xff;
    }

    const metricsOverride = {
      unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
      yMax: int16(tables.head.data[42], tables.head.data[43]),
      yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
      ascent: int16(tables.hhea.data[4], tables.hhea.data[5]),
      descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7])
    };
    this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
    this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;

    if (tables.post) {
      readPostScriptTable(tables.post, properties, numGlyphs);
    }

    tables.post = {
      tag: "post",
      data: createPostTable(properties)
    };
    const charCodeToGlyphId = [];

    function hasGlyph(glyphId) {
      return !missingGlyphs[glyphId];
    }

    if (properties.composite) {
      const cidToGidMap = properties.cidToGidMap || [];
      const isCidToGidMapEmpty = cidToGidMap.length === 0;
      properties.cMap.forEach(function (charCode, cid) {
        if (cid > 0xffff) {
          throw new _util.FormatError("Max size of CID is 65,535");
        }

        let glyphId = -1;

        if (isCidToGidMapEmpty) {
          glyphId = cid;
        } else if (cidToGidMap[cid] !== undefined) {
          glyphId = cidToGidMap[cid];
        }

        if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
          charCodeToGlyphId[charCode] = glyphId;
        }
      });
    } else {
      const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);
      const cmapPlatformId = cmapTable.platformId;
      const cmapEncodingId = cmapTable.encodingId;
      const cmapMappings = cmapTable.mappings;
      const cmapMappingsLength = cmapMappings.length;
      let baseEncoding = [];

      if (properties.hasEncoding && (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding")) {
        baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
      }

      if (properties.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {
        const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();

        for (let charCode = 0; charCode < 256; charCode++) {
          let glyphName;

          if (this.differences && charCode in this.differences) {
            glyphName = this.differences[charCode];
          } else if (charCode in baseEncoding && baseEncoding[charCode] !== "") {
            glyphName = baseEncoding[charCode];
          } else {
            glyphName = _encodings.StandardEncoding[charCode];
          }

          if (!glyphName) {
            continue;
          }

          const standardGlyphName = (0, _fonts_utils.recoverGlyphName)(glyphName, glyphsUnicodeMap);
          let unicodeOrCharCode;

          if (cmapPlatformId === 3 && cmapEncodingId === 1) {
            unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
          } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
            unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
          }

          for (let i = 0; i < cmapMappingsLength; ++i) {
            if (cmapMappings[i].charCode !== unicodeOrCharCode) {
              continue;
            }

            charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
            break;
          }
        }
      } else if (cmapPlatformId === 0) {
        for (let i = 0; i < cmapMappingsLength; ++i) {
          charCodeToGlyphId[cmapMappings[i].charCode] = cmapMappings[i].glyphId;
        }
      } else {
        for (let i = 0; i < cmapMappingsLength; ++i) {
          let charCode = cmapMappings[i].charCode;

          if (cmapPlatformId === 3 && charCode >= 0xf000 && charCode <= 0xf0ff) {
            charCode &= 0xff;
          }

          charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
        }
      }

      if (properties.glyphNames && (baseEncoding.length || this.differences.length)) {
        for (let i = 0; i < 256; ++i) {
          if (charCodeToGlyphId[i] !== undefined) {
            continue;
          }

          const glyphName = this.differences[i] || baseEncoding[i];

          if (!glyphName) {
            continue;
          }

          const glyphId = properties.glyphNames.indexOf(glyphName);

          if (glyphId > 0 && hasGlyph(glyphId)) {
            charCodeToGlyphId[i] = glyphId;
          }
        }
      }
    }

    if (charCodeToGlyphId.length === 0) {
      charCodeToGlyphId[0] = 0;
    }

    let glyphZeroId = numGlyphsOut - 1;

    if (!dupFirstEntry) {
      glyphZeroId = 0;
    }

    if (!properties.cssFontInfo) {
      const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId);
      this.toFontChar = newMapping.toFontChar;
      tables.cmap = {
        tag: "cmap",
        data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphsOut)
      };

      if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
        tables["OS/2"] = {
          tag: "OS/2",
          data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
        };
      }
    }

    if (!isTrueType) {
      try {
        cffFile = new _stream.Stream(tables["CFF "].data);
        const parser = new _cff_parser.CFFParser(cffFile, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
        cff = parser.parse();
        cff.duplicateFirstGlyph();
        const compiler = new _cff_parser.CFFCompiler(cff);
        tables["CFF "].data = compiler.compile();
      } catch (e) {
        (0, _util.warn)("Failed to compile font " + properties.loadedName);
      }
    }

    if (!tables.name) {
      tables.name = {
        tag: "name",
        data: createNameTable(this.name)
      };
    } else {
      const namePrototype = readNameTable(tables.name);
      tables.name.data = createNameTable(name, namePrototype);
    }

    const builder = new _opentype_file_builder.OpenTypeFileBuilder(header.version);

    for (const tableTag in tables) {
      builder.addTable(tableTag, tables[tableTag].data);
    }

    return builder.toArray();
  }

  convert(fontName, font, properties) {
    properties.fixedPitch = false;

    if (properties.builtInEncoding) {
      adjustToUnicode(properties, properties.builtInEncoding);
    }

    let glyphZeroId = 1;

    if (font instanceof _cff_font.CFFFont) {
      glyphZeroId = font.numGlyphs - 1;
    }

    const mapping = font.getGlyphMapping(properties);
    let newMapping = null;
    let newCharCodeToGlyphId = mapping;

    if (!properties.cssFontInfo) {
      newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId);
      this.toFontChar = newMapping.toFontChar;
      newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
    }

    const numGlyphs = font.numGlyphs;

    function getCharCodes(charCodeToGlyphId, glyphId) {
      let charCodes = null;

      for (const charCode in charCodeToGlyphId) {
        if (glyphId === charCodeToGlyphId[charCode]) {
          if (!charCodes) {
            charCodes = [];
          }

          charCodes.push(charCode | 0);
        }
      }

      return charCodes;
    }

    function createCharCode(charCodeToGlyphId, glyphId) {
      for (const charCode in charCodeToGlyphId) {
        if (glyphId === charCodeToGlyphId[charCode]) {
          return charCode | 0;
        }
      }

      newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
      return newMapping.nextAvailableFontCharCode++;
    }

    const seacs = font.seacs;

    if (newMapping && _fonts_utils.SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
      const matrix = properties.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      const charset = font.getCharset();
      const seacMap = Object.create(null);

      for (let glyphId in seacs) {
        glyphId |= 0;
        const seac = seacs[glyphId];
        const baseGlyphName = _encodings.StandardEncoding[seac[2]];
        const accentGlyphName = _encodings.StandardEncoding[seac[3]];
        const baseGlyphId = charset.indexOf(baseGlyphName);
        const accentGlyphId = charset.indexOf(accentGlyphName);

        if (baseGlyphId < 0 || accentGlyphId < 0) {
          continue;
        }

        const accentOffset = {
          x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
          y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
        };
        const charCodes = getCharCodes(mapping, glyphId);

        if (!charCodes) {
          continue;
        }

        for (let i = 0, ii = charCodes.length; i < ii; i++) {
          const charCode = charCodes[i];
          const charCodeToGlyphId = newMapping.charCodeToGlyphId;
          const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
          const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
          seacMap[charCode] = {
            baseFontCharCode,
            accentFontCharCode,
            accentOffset
          };
        }
      }

      properties.seacMap = seacMap;
    }

    const unitsPerEm = 1 / (properties.fontMatrix || _util.FONT_IDENTITY_MATRIX)[0];
    const builder = new _opentype_file_builder.OpenTypeFileBuilder("\x4F\x54\x54\x4F");
    builder.addTable("CFF ", font.data);
    builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
    builder.addTable("cmap", createCmapTable(newCharCodeToGlyphId, numGlyphs));
    builder.addTable("head", "\x00\x01\x00\x00" + "\x00\x00\x10\x00" + "\x00\x00\x00\x00" + "\x5F\x0F\x3C\xF5" + "\x00\x00" + safeString16(unitsPerEm) + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + "\x00\x00" + safeString16(properties.descent) + "\x0F\xFF" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\x00\x11" + "\x00\x00" + "\x00\x00" + "\x00\x00");
    builder.addTable("hhea", "\x00\x01\x00\x00" + safeString16(properties.ascent) + safeString16(properties.descent) + "\x00\x00" + "\xFF\xFF" + "\x00\x00" + "\x00\x00" + "\x00\x00" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + "\x00\x00" + string16(numGlyphs));
    builder.addTable("hmtx", function fontFieldsHmtx() {
      const charstrings = font.charstrings;
      const cffWidths = font.cff ? font.cff.widths : null;
      let hmtx = "\x00\x00\x00\x00";

      for (let i = 1, ii = numGlyphs; i < ii; i++) {
        let width = 0;

        if (charstrings) {
          const charstring = charstrings[i - 1];
          width = "width" in charstring ? charstring.width : 0;
        } else if (cffWidths) {
          width = Math.ceil(cffWidths[i] || 0);
        }

        hmtx += string16(width) + string16(0);
      }

      return hmtx;
    }());
    builder.addTable("maxp", "\x00\x00\x50\x00" + string16(numGlyphs));
    builder.addTable("name", createNameTable(fontName));
    builder.addTable("post", createPostTable(properties));
    return builder.toArray();
  }

  get spaceWidth() {
    const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
    let width;

    for (let i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
      const glyphName = possibleSpaceReplacements[i];

      if (glyphName in this.widths) {
        width = this.widths[glyphName];
        break;
      }

      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
      const glyphUnicode = glyphsUnicodeMap[glyphName];
      let charcode = 0;

      if (this.composite && this.cMap.contains(glyphUnicode)) {
        charcode = this.cMap.lookup(glyphUnicode);
      }

      if (!charcode && this.toUnicode) {
        charcode = this.toUnicode.charCodeOf(glyphUnicode);
      }

      if (charcode <= 0) {
        charcode = glyphUnicode;
      }

      width = this.widths[charcode];

      if (width) {
        break;
      }
    }

    width = width || this.defaultWidth;
    return (0, _util.shadow)(this, "spaceWidth", width);
  }

  _charToGlyph(charcode, isSpace = false) {
    let fontCharCode, width, operatorListId;
    let widthCode = charcode;

    if (this.cMap && this.cMap.contains(charcode)) {
      widthCode = this.cMap.lookup(charcode);
    }

    width = this.widths[widthCode];
    width = (0, _util.isNum)(width) ? width : this.defaultWidth;
    const vmetric = this.vmetrics && this.vmetrics[widthCode];
    let unicode = this.toUnicode.get(charcode) || this.fallbackToUnicode.get(charcode) || charcode;

    if (typeof unicode === "number") {
      unicode = String.fromCharCode(unicode);
    }

    let isInFont = (charcode in this.toFontChar);
    fontCharCode = this.toFontChar[charcode] || charcode;

    if (this.missingFile) {
      const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];

      if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
        fontCharCode = 0x20;
      }

      fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
    }

    if (this.isType3Font) {
      operatorListId = fontCharCode;
    }

    let accent = null;

    if (this.seacMap && this.seacMap[charcode]) {
      isInFont = true;
      const seac = this.seacMap[charcode];
      fontCharCode = seac.baseFontCharCode;
      accent = {
        fontChar: String.fromCodePoint(seac.accentFontCharCode),
        offset: seac.accentOffset
      };
    }

    let fontChar = "";

    if (typeof fontCharCode === "number") {
      if (fontCharCode <= 0x10ffff) {
        fontChar = String.fromCodePoint(fontCharCode);
      } else {
        (0, _util.warn)(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
      }
    }

    let glyph = this.glyphCache[charcode];

    if (!glyph || !glyph.matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
      glyph = new Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
      this.glyphCache[charcode] = glyph;
    }

    return glyph;
  }

  charsToGlyphs(chars) {
    let charsCache = this.charsCache;
    let glyphs, glyph, charcode;

    if (charsCache) {
      glyphs = charsCache[chars];

      if (glyphs) {
        return glyphs;
      }
    }

    if (!charsCache) {
      charsCache = this.charsCache = Object.create(null);
    }

    glyphs = [];
    const charsCacheKey = chars;
    let i = 0,
        ii;

    if (this.cMap) {
      const c = Object.create(null);

      while (i < chars.length) {
        this.cMap.readCharCode(chars, i, c);
        charcode = c.charcode;
        const length = c.length;
        i += length;
        const isSpace = length === 1 && chars.charCodeAt(i - 1) === 0x20;
        glyph = this._charToGlyph(charcode, isSpace);
        glyphs.push(glyph);
      }
    } else {
      for (i = 0, ii = chars.length; i < ii; ++i) {
        charcode = chars.charCodeAt(i);
        glyph = this._charToGlyph(charcode, charcode === 0x20);
        glyphs.push(glyph);
      }
    }

    return charsCache[charsCacheKey] = glyphs;
  }

  getCharPositions(chars) {
    const positions = [];

    if (this.cMap) {
      const c = Object.create(null);
      let i = 0;

      while (i < chars.length) {
        this.cMap.readCharCode(chars, i, c);
        const length = c.length;
        positions.push([i, i + length]);
        i += length;
      }
    } else {
      for (let i = 0, ii = chars.length; i < ii; ++i) {
        positions.push([i, i + 1]);
      }
    }

    return positions;
  }

  get glyphCacheValues() {
    return Object.values(this.glyphCache);
  }

  encodeString(str) {
    const buffers = [];
    const currentBuf = [];

    const hasCurrentBufErrors = () => buffers.length % 2 === 1;

    for (let i = 0, ii = str.length; i < ii; i++) {
      const unicode = str.codePointAt(i);

      if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
        i++;
      }

      if (this.toUnicode) {
        const char = String.fromCodePoint(unicode);
        const charCode = this.toUnicode.charCodeOf(char);

        if (charCode !== -1) {
          if (hasCurrentBufErrors()) {
            buffers.push(currentBuf.join(""));
            currentBuf.length = 0;
          }

          const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;

          for (let j = charCodeLength - 1; j >= 0; j--) {
            currentBuf.push(String.fromCharCode(charCode >> 8 * j & 0xff));
          }

          continue;
        }
      }

      if (!hasCurrentBufErrors()) {
        buffers.push(currentBuf.join(""));
        currentBuf.length = 0;
      }

      currentBuf.push(String.fromCodePoint(unicode));
    }

    buffers.push(currentBuf.join(""));
    return buffers;
  }

}

exports.Font = Font;

class ErrorFont {
  constructor(error) {
    this.error = error;
    this.loadedName = "g_font_error";
    this.missingFile = true;
  }

  charsToGlyphs() {
    return [];
  }

  encodeString(chars) {
    return [chars];
  }

  exportData(extraProperties = false) {
    return {
      error: this.error
    };
  }

}

exports.ErrorFont = ErrorFont;

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CFFTopDict = exports.CFFStrings = exports.CFFStandardStrings = exports.CFFPrivateDict = exports.CFFParser = exports.CFFIndex = exports.CFFHeader = exports.CFFFDSelect = exports.CFFCompiler = exports.CFFCharset = exports.CFF = void 0;

var _util = __w_pdfjs_require__(2);

var _charsets = __w_pdfjs_require__(36);

var _encodings = __w_pdfjs_require__(37);

const MAX_SUBR_NESTING = 10;
const CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
exports.CFFStandardStrings = CFFStandardStrings;
const NUM_STANDARD_CFF_STRINGS = 391;

const CFFParser = function CFFParserClosure() {
  const CharstringValidationData = [null, {
    id: "hstem",
    min: 2,
    stackClearing: true,
    stem: true
  }, null, {
    id: "vstem",
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: "vmoveto",
    min: 1,
    stackClearing: true
  }, {
    id: "rlineto",
    min: 2,
    resetStack: true
  }, {
    id: "hlineto",
    min: 1,
    resetStack: true
  }, {
    id: "vlineto",
    min: 1,
    resetStack: true
  }, {
    id: "rrcurveto",
    min: 6,
    resetStack: true
  }, null, {
    id: "callsubr",
    min: 1,
    undefStack: true
  }, {
    id: "return",
    min: 0,
    undefStack: true
  }, null, null, {
    id: "endchar",
    min: 0,
    stackClearing: true
  }, null, null, null, {
    id: "hstemhm",
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: "hintmask",
    min: 0,
    stackClearing: true
  }, {
    id: "cntrmask",
    min: 0,
    stackClearing: true
  }, {
    id: "rmoveto",
    min: 2,
    stackClearing: true
  }, {
    id: "hmoveto",
    min: 1,
    stackClearing: true
  }, {
    id: "vstemhm",
    min: 2,
    stackClearing: true,
    stem: true
  }, {
    id: "rcurveline",
    min: 8,
    resetStack: true
  }, {
    id: "rlinecurve",
    min: 8,
    resetStack: true
  }, {
    id: "vvcurveto",
    min: 4,
    resetStack: true
  }, {
    id: "hhcurveto",
    min: 4,
    resetStack: true
  }, null, {
    id: "callgsubr",
    min: 1,
    undefStack: true
  }, {
    id: "vhcurveto",
    min: 4,
    resetStack: true
  }, {
    id: "hvcurveto",
    min: 4,
    resetStack: true
  }];
  const CharstringValidationData12 = [null, null, null, {
    id: "and",
    min: 2,
    stackDelta: -1
  }, {
    id: "or",
    min: 2,
    stackDelta: -1
  }, {
    id: "not",
    min: 1,
    stackDelta: 0
  }, null, null, null, {
    id: "abs",
    min: 1,
    stackDelta: 0
  }, {
    id: "add",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] + stack[index - 1];
    }
  }, {
    id: "sub",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] - stack[index - 1];
    }
  }, {
    id: "div",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] / stack[index - 1];
    }
  }, null, {
    id: "neg",
    min: 1,
    stackDelta: 0,
    stackFn: function stack_div(stack, index) {
      stack[index - 1] = -stack[index - 1];
    }
  }, {
    id: "eq",
    min: 2,
    stackDelta: -1
  }, null, null, {
    id: "drop",
    min: 1,
    stackDelta: -1
  }, null, {
    id: "put",
    min: 2,
    stackDelta: -2
  }, {
    id: "get",
    min: 1,
    stackDelta: 0
  }, {
    id: "ifelse",
    min: 4,
    stackDelta: -3
  }, {
    id: "random",
    min: 0,
    stackDelta: 1
  }, {
    id: "mul",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] * stack[index - 1];
    }
  }, null, {
    id: "sqrt",
    min: 1,
    stackDelta: 0
  }, {
    id: "dup",
    min: 1,
    stackDelta: 1
  }, {
    id: "exch",
    min: 2,
    stackDelta: 0
  }, {
    id: "index",
    min: 2,
    stackDelta: 0
  }, {
    id: "roll",
    min: 3,
    stackDelta: -2
  }, null, null, null, {
    id: "hflex",
    min: 7,
    resetStack: true
  }, {
    id: "flex",
    min: 13,
    resetStack: true
  }, {
    id: "hflex1",
    min: 9,
    resetStack: true
  }, {
    id: "flex1",
    min: 11,
    resetStack: true
  }];

  class CFFParser {
    constructor(file, properties, seacAnalysisEnabled) {
      this.bytes = file.getBytes();
      this.properties = properties;
      this.seacAnalysisEnabled = !!seacAnalysisEnabled;
    }

    parse() {
      const properties = this.properties;
      const cff = new CFF();
      this.cff = cff;
      const header = this.parseHeader();
      const nameIndex = this.parseIndex(header.endPos);
      const topDictIndex = this.parseIndex(nameIndex.endPos);
      const stringIndex = this.parseIndex(topDictIndex.endPos);
      const globalSubrIndex = this.parseIndex(stringIndex.endPos);
      const topDictParsed = this.parseDict(topDictIndex.obj.get(0));
      const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
      cff.header = header.obj;
      cff.names = this.parseNameIndex(nameIndex.obj);
      cff.strings = this.parseStringIndex(stringIndex.obj);
      cff.topDict = topDict;
      cff.globalSubrIndex = globalSubrIndex.obj;
      this.parsePrivateDict(cff.topDict);
      cff.isCIDFont = topDict.hasName("ROS");
      const charStringOffset = topDict.getByName("CharStrings");
      const charStringIndex = this.parseIndex(charStringOffset).obj;
      const fontMatrix = topDict.getByName("FontMatrix");

      if (fontMatrix) {
        properties.fontMatrix = fontMatrix;
      }

      const fontBBox = topDict.getByName("FontBBox");

      if (fontBBox) {
        properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
        properties.descent = Math.min(fontBBox[1], fontBBox[3]);
        properties.ascentScaled = true;
      }

      let charset, encoding;

      if (cff.isCIDFont) {
        const fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;

        for (let i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
          const dictRaw = fdArrayIndex.get(i);
          const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
          this.parsePrivateDict(fontDict);
          cff.fdArray.push(fontDict);
        }

        encoding = null;
        charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
        cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
      } else {
        charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
        encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
      }

      cff.charset = charset;
      cff.encoding = encoding;
      const charStringsAndSeacs = this.parseCharStrings({
        charStrings: charStringIndex,
        localSubrIndex: topDict.privateDict.subrsIndex,
        globalSubrIndex: globalSubrIndex.obj,
        fdSelect: cff.fdSelect,
        fdArray: cff.fdArray,
        privateDict: topDict.privateDict
      });
      cff.charStrings = charStringsAndSeacs.charStrings;
      cff.seacs = charStringsAndSeacs.seacs;
      cff.widths = charStringsAndSeacs.widths;
      return cff;
    }

    parseHeader() {
      let bytes = this.bytes;
      const bytesLength = bytes.length;
      let offset = 0;

      while (offset < bytesLength && bytes[offset] !== 1) {
        ++offset;
      }

      if (offset >= bytesLength) {
        throw new _util.FormatError("Invalid CFF header");
      }

      if (offset !== 0) {
        (0, _util.info)("cff data is shifted");
        bytes = bytes.subarray(offset);
        this.bytes = bytes;
      }

      const major = bytes[0];
      const minor = bytes[1];
      const hdrSize = bytes[2];
      const offSize = bytes[3];
      const header = new CFFHeader(major, minor, hdrSize, offSize);
      return {
        obj: header,
        endPos: hdrSize
      };
    }

    parseDict(dict) {
      let pos = 0;

      function parseOperand() {
        let value = dict[pos++];

        if (value === 30) {
          return parseFloatOperand();
        } else if (value === 28) {
          value = dict[pos++];
          value = (value << 24 | dict[pos++] << 16) >> 16;
          return value;
        } else if (value === 29) {
          value = dict[pos++];
          value = value << 8 | dict[pos++];
          value = value << 8 | dict[pos++];
          value = value << 8 | dict[pos++];
          return value;
        } else if (value >= 32 && value <= 246) {
          return value - 139;
        } else if (value >= 247 && value <= 250) {
          return (value - 247) * 256 + dict[pos++] + 108;
        } else if (value >= 251 && value <= 254) {
          return -((value - 251) * 256) - dict[pos++] - 108;
        }

        (0, _util.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
        return NaN;
      }

      function parseFloatOperand() {
        let str = "";
        const eof = 15;
        const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
        const length = dict.length;

        while (pos < length) {
          const b = dict[pos++];
          const b1 = b >> 4;
          const b2 = b & 15;

          if (b1 === eof) {
            break;
          }

          str += lookup[b1];

          if (b2 === eof) {
            break;
          }

          str += lookup[b2];
        }

        return parseFloat(str);
      }

      let operands = [];
      const entries = [];
      pos = 0;
      const end = dict.length;

      while (pos < end) {
        let b = dict[pos];

        if (b <= 21) {
          if (b === 12) {
            b = b << 8 | dict[++pos];
          }

          entries.push([b, operands]);
          operands = [];
          ++pos;
        } else {
          operands.push(parseOperand());
        }
      }

      return entries;
    }

    parseIndex(pos) {
      const cffIndex = new CFFIndex();
      const bytes = this.bytes;
      const count = bytes[pos++] << 8 | bytes[pos++];
      const offsets = [];
      let end = pos;
      let i, ii;

      if (count !== 0) {
        const offsetSize = bytes[pos++];
        const startPos = pos + (count + 1) * offsetSize - 1;

        for (i = 0, ii = count + 1; i < ii; ++i) {
          let offset = 0;

          for (let j = 0; j < offsetSize; ++j) {
            offset <<= 8;
            offset += bytes[pos++];
          }

          offsets.push(startPos + offset);
        }

        end = offsets[count];
      }

      for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
        const offsetStart = offsets[i];
        const offsetEnd = offsets[i + 1];
        cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
      }

      return {
        obj: cffIndex,
        endPos: end
      };
    }

    parseNameIndex(index) {
      const names = [];

      for (let i = 0, ii = index.count; i < ii; ++i) {
        const name = index.get(i);
        names.push((0, _util.bytesToString)(name));
      }

      return names;
    }

    parseStringIndex(index) {
      const strings = new CFFStrings();

      for (let i = 0, ii = index.count; i < ii; ++i) {
        const data = index.get(i);
        strings.add((0, _util.bytesToString)(data));
      }

      return strings;
    }

    createDict(Type, dict, strings) {
      const cffDict = new Type(strings);

      for (let i = 0, ii = dict.length; i < ii; ++i) {
        const pair = dict[i];
        const key = pair[0];
        const value = pair[1];
        cffDict.setByKey(key, value);
      }

      return cffDict;
    }

    parseCharString(state, data, localSubrIndex, globalSubrIndex) {
      if (!data || state.callDepth > MAX_SUBR_NESTING) {
        return false;
      }

      let stackSize = state.stackSize;
      const stack = state.stack;
      const length = data.length;

      for (let j = 0; j < length;) {
        const value = data[j++];
        let validationCommand = null;

        if (value === 12) {
          const q = data[j++];

          if (q === 0) {
            data[j - 2] = 139;
            data[j - 1] = 22;
            stackSize = 0;
          } else {
            validationCommand = CharstringValidationData12[q];
          }
        } else if (value === 28) {
          stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
          j += 2;
          stackSize++;
        } else if (value === 14) {
          if (stackSize >= 4) {
            stackSize -= 4;

            if (this.seacAnalysisEnabled) {
              state.seac = stack.slice(stackSize, stackSize + 4);
              return false;
            }
          }

          validationCommand = CharstringValidationData[value];
        } else if (value >= 32 && value <= 246) {
          stack[stackSize] = value - 139;
          stackSize++;
        } else if (value >= 247 && value <= 254) {
          stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
          j++;
          stackSize++;
        } else if (value === 255) {
          stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
          j += 4;
          stackSize++;
        } else if (value === 19 || value === 20) {
          state.hints += stackSize >> 1;
          j += state.hints + 7 >> 3;
          stackSize %= 2;
          validationCommand = CharstringValidationData[value];
        } else if (value === 10 || value === 29) {
          let subrsIndex;

          if (value === 10) {
            subrsIndex = localSubrIndex;
          } else {
            subrsIndex = globalSubrIndex;
          }

          if (!subrsIndex) {
            validationCommand = CharstringValidationData[value];
            (0, _util.warn)("Missing subrsIndex for " + validationCommand.id);
            return false;
          }

          let bias = 32768;

          if (subrsIndex.count < 1240) {
            bias = 107;
          } else if (subrsIndex.count < 33900) {
            bias = 1131;
          }

          const subrNumber = stack[--stackSize] + bias;

          if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
            validationCommand = CharstringValidationData[value];
            (0, _util.warn)("Out of bounds subrIndex for " + validationCommand.id);
            return false;
          }

          state.stackSize = stackSize;
          state.callDepth++;
          const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);

          if (!valid) {
            return false;
          }

          state.callDepth--;
          stackSize = state.stackSize;
          continue;
        } else if (value === 11) {
          state.stackSize = stackSize;
          return true;
        } else {
          validationCommand = CharstringValidationData[value];
        }

        if (validationCommand) {
          if (validationCommand.stem) {
            state.hints += stackSize >> 1;

            if (value === 3 || value === 23) {
              state.hasVStems = true;
            } else if (state.hasVStems && (value === 1 || value === 18)) {
              (0, _util.warn)("CFF stem hints are in wrong order");
              data[j - 1] = value === 1 ? 3 : 23;
            }
          }

          if ("min" in validationCommand) {
            if (!state.undefStack && stackSize < validationCommand.min) {
              (0, _util.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
              return false;
            }
          }

          if (state.firstStackClearing && validationCommand.stackClearing) {
            state.firstStackClearing = false;
            stackSize -= validationCommand.min;

            if (stackSize >= 2 && validationCommand.stem) {
              stackSize %= 2;
            } else if (stackSize > 1) {
              (0, _util.warn)("Found too many parameters for stack-clearing command");
            }

            if (stackSize > 0) {
              state.width = stack[stackSize - 1];
            }
          }

          if ("stackDelta" in validationCommand) {
            if ("stackFn" in validationCommand) {
              validationCommand.stackFn(stack, stackSize);
            }

            stackSize += validationCommand.stackDelta;
          } else if (validationCommand.stackClearing) {
            stackSize = 0;
          } else if (validationCommand.resetStack) {
            stackSize = 0;
            state.undefStack = false;
          } else if (validationCommand.undefStack) {
            stackSize = 0;
            state.undefStack = true;
            state.firstStackClearing = false;
          }
        }
      }

      state.stackSize = stackSize;
      return true;
    }

    parseCharStrings({
      charStrings,
      localSubrIndex,
      globalSubrIndex,
      fdSelect,
      fdArray,
      privateDict
    }) {
      const seacs = [];
      const widths = [];
      const count = charStrings.count;

      for (let i = 0; i < count; i++) {
        const charstring = charStrings.get(i);
        const state = {
          callDepth: 0,
          stackSize: 0,
          stack: [],
          undefStack: true,
          hints: 0,
          firstStackClearing: true,
          seac: null,
          width: null,
          hasVStems: false
        };
        let valid = true;
        let localSubrToUse = null;
        let privateDictToUse = privateDict;

        if (fdSelect && fdArray.length) {
          const fdIndex = fdSelect.getFDIndex(i);

          if (fdIndex === -1) {
            (0, _util.warn)("Glyph index is not in fd select.");
            valid = false;
          }

          if (fdIndex >= fdArray.length) {
            (0, _util.warn)("Invalid fd index for glyph index.");
            valid = false;
          }

          if (valid) {
            privateDictToUse = fdArray[fdIndex].privateDict;
            localSubrToUse = privateDictToUse.subrsIndex;
          }
        } else if (localSubrIndex) {
          localSubrToUse = localSubrIndex;
        }

        if (valid) {
          valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
        }

        if (state.width !== null) {
          const nominalWidth = privateDictToUse.getByName("nominalWidthX");
          widths[i] = nominalWidth + state.width;
        } else {
          const defaultWidth = privateDictToUse.getByName("defaultWidthX");
          widths[i] = defaultWidth;
        }

        if (state.seac !== null) {
          seacs[i] = state.seac;
        }

        if (!valid) {
          charStrings.set(i, new Uint8Array([14]));
        }
      }

      return {
        charStrings,
        seacs,
        widths
      };
    }

    emptyPrivateDictionary(parentDict) {
      const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
      parentDict.setByKey(18, [0, 0]);
      parentDict.privateDict = privateDict;
    }

    parsePrivateDict(parentDict) {
      if (!parentDict.hasName("Private")) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }

      const privateOffset = parentDict.getByName("Private");

      if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
        parentDict.removeByName("Private");
        return;
      }

      const size = privateOffset[0];
      const offset = privateOffset[1];

      if (size === 0 || offset >= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }

      const privateDictEnd = offset + size;
      const dictData = this.bytes.subarray(offset, privateDictEnd);
      const dict = this.parseDict(dictData);
      const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
      parentDict.privateDict = privateDict;

      if (!privateDict.getByName("Subrs")) {
        return;
      }

      const subrsOffset = privateDict.getByName("Subrs");
      const relativeOffset = offset + subrsOffset;

      if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }

      const subrsIndex = this.parseIndex(relativeOffset);
      privateDict.subrsIndex = subrsIndex.obj;
    }

    parseCharsets(pos, length, strings, cid) {
      if (pos === 0) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
      } else if (pos === 1) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
      } else if (pos === 2) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
      }

      const bytes = this.bytes;
      const start = pos;
      const format = bytes[pos++];
      const charset = [cid ? 0 : ".notdef"];
      let id, count, i;
      length -= 1;

      switch (format) {
        case 0:
          for (i = 0; i < length; i++) {
            id = bytes[pos++] << 8 | bytes[pos++];
            charset.push(cid ? id : strings.get(id));
          }

          break;

        case 1:
          while (charset.length <= length) {
            id = bytes[pos++] << 8 | bytes[pos++];
            count = bytes[pos++];

            for (i = 0; i <= count; i++) {
              charset.push(cid ? id++ : strings.get(id++));
            }
          }

          break;

        case 2:
          while (charset.length <= length) {
            id = bytes[pos++] << 8 | bytes[pos++];
            count = bytes[pos++] << 8 | bytes[pos++];

            for (i = 0; i <= count; i++) {
              charset.push(cid ? id++ : strings.get(id++));
            }
          }

          break;

        default:
          throw new _util.FormatError("Unknown charset format");
      }

      const end = pos;
      const raw = bytes.subarray(start, end);
      return new CFFCharset(false, format, charset, raw);
    }

    parseEncoding(pos, properties, strings, charset) {
      const encoding = Object.create(null);
      const bytes = this.bytes;
      let predefined = false;
      let format, i, ii;
      let raw = null;

      function readSupplement() {
        const supplementsCount = bytes[pos++];

        for (i = 0; i < supplementsCount; i++) {
          const code = bytes[pos++];
          const sid = (bytes[pos++] << 8) + (bytes[pos++] & 0xff);
          encoding[code] = charset.indexOf(strings.get(sid));
        }
      }

      if (pos === 0 || pos === 1) {
        predefined = true;
        format = pos;
        const baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;

        for (i = 0, ii = charset.length; i < ii; i++) {
          const index = baseEncoding.indexOf(charset[i]);

          if (index !== -1) {
            encoding[index] = i;
          }
        }
      } else {
        const dataStart = pos;
        format = bytes[pos++];

        switch (format & 0x7f) {
          case 0:
            const glyphsCount = bytes[pos++];

            for (i = 1; i <= glyphsCount; i++) {
              encoding[bytes[pos++]] = i;
            }

            break;

          case 1:
            const rangesCount = bytes[pos++];
            let gid = 1;

            for (i = 0; i < rangesCount; i++) {
              const start = bytes[pos++];
              const left = bytes[pos++];

              for (let j = start; j <= start + left; j++) {
                encoding[j] = gid++;
              }
            }

            break;

          default:
            throw new _util.FormatError(`Unknown encoding format: ${format} in CFF`);
        }

        const dataEnd = pos;

        if (format & 0x80) {
          bytes[dataStart] &= 0x7f;
          readSupplement();
        }

        raw = bytes.subarray(dataStart, dataEnd);
      }

      format = format & 0x7f;
      return new CFFEncoding(predefined, format, encoding, raw);
    }

    parseFDSelect(pos, length) {
      const bytes = this.bytes;
      const format = bytes[pos++];
      const fdSelect = [];
      let i;

      switch (format) {
        case 0:
          for (i = 0; i < length; ++i) {
            const id = bytes[pos++];
            fdSelect.push(id);
          }

          break;

        case 3:
          const rangesCount = bytes[pos++] << 8 | bytes[pos++];

          for (i = 0; i < rangesCount; ++i) {
            let first = bytes[pos++] << 8 | bytes[pos++];

            if (i === 0 && first !== 0) {
              (0, _util.warn)("parseFDSelect: The first range must have a first GID of 0" + " -- trying to recover.");
              first = 0;
            }

            const fdIndex = bytes[pos++];
            const next = bytes[pos] << 8 | bytes[pos + 1];

            for (let j = first; j < next; ++j) {
              fdSelect.push(fdIndex);
            }
          }

          pos += 2;
          break;

        default:
          throw new _util.FormatError(`parseFDSelect: Unknown format "${format}".`);
      }

      if (fdSelect.length !== length) {
        throw new _util.FormatError("parseFDSelect: Invalid font data.");
      }

      return new CFFFDSelect(format, fdSelect);
    }

  }

  return CFFParser;
}();

exports.CFFParser = CFFParser;

class CFF {
  constructor() {
    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }

  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      (0, _util.warn)("Not enough space in charstrings to duplicate first glyph.");
      return;
    }

    const glyphZero = this.charStrings.get(0);
    this.charStrings.add(glyphZero);

    if (this.isCIDFont) {
      this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
    }
  }

  hasGlyphId(id) {
    if (id < 0 || id >= this.charStrings.count) {
      return false;
    }

    const glyph = this.charStrings.get(id);
    return glyph.length > 0;
  }

}

exports.CFF = CFF;

class CFFHeader {
  constructor(major, minor, hdrSize, offSize) {
    this.major = major;
    this.minor = minor;
    this.hdrSize = hdrSize;
    this.offSize = offSize;
  }

}

exports.CFFHeader = CFFHeader;

class CFFStrings {
  constructor() {
    this.strings = [];
  }

  get(index) {
    if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
      return CFFStandardStrings[index];
    }

    if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
      return this.strings[index - NUM_STANDARD_CFF_STRINGS];
    }

    return CFFStandardStrings[0];
  }

  getSID(str) {
    let index = CFFStandardStrings.indexOf(str);

    if (index !== -1) {
      return index;
    }

    index = this.strings.indexOf(str);

    if (index !== -1) {
      return index + NUM_STANDARD_CFF_STRINGS;
    }

    return -1;
  }

  add(value) {
    this.strings.push(value);
  }

  get count() {
    return this.strings.length;
  }

}

exports.CFFStrings = CFFStrings;

class CFFIndex {
  constructor() {
    this.objects = [];
    this.length = 0;
  }

  add(data) {
    this.length += data.length;
    this.objects.push(data);
  }

  set(index, data) {
    this.length += data.length - this.objects[index].length;
    this.objects[index] = data;
  }

  get(index) {
    return this.objects[index];
  }

  get count() {
    return this.objects.length;
  }

}

exports.CFFIndex = CFFIndex;

class CFFDict {
  constructor(tables, strings) {
    this.keyToNameMap = tables.keyToNameMap;
    this.nameToKeyMap = tables.nameToKeyMap;
    this.defaults = tables.defaults;
    this.types = tables.types;
    this.opcodes = tables.opcodes;
    this.order = tables.order;
    this.strings = strings;
    this.values = Object.create(null);
  }

  setByKey(key, value) {
    if (!(key in this.keyToNameMap)) {
      return false;
    }

    const valueLength = value.length;

    if (valueLength === 0) {
      return true;
    }

    for (let i = 0; i < valueLength; i++) {
      if (isNaN(value[i])) {
        (0, _util.warn)('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
        return true;
      }
    }

    const type = this.types[key];

    if (type === "num" || type === "sid" || type === "offset") {
      value = value[0];
    }

    this.values[key] = value;
    return true;
  }

  setByName(name, value) {
    if (!(name in this.nameToKeyMap)) {
      throw new _util.FormatError(`Invalid dictionary name "${name}"`);
    }

    this.values[this.nameToKeyMap[name]] = value;
  }

  hasName(name) {
    return this.nameToKeyMap[name] in this.values;
  }

  getByName(name) {
    if (!(name in this.nameToKeyMap)) {
      throw new _util.FormatError(`Invalid dictionary name ${name}"`);
    }

    const key = this.nameToKeyMap[name];

    if (!(key in this.values)) {
      return this.defaults[key];
    }

    return this.values[key];
  }

  removeByName(name) {
    delete this.values[this.nameToKeyMap[name]];
  }

  static createTables(layout) {
    const tables = {
      keyToNameMap: {},
      nameToKeyMap: {},
      defaults: {},
      types: {},
      opcodes: {},
      order: []
    };

    for (let i = 0, ii = layout.length; i < ii; ++i) {
      const entry = layout[i];
      const key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
      tables.keyToNameMap[key] = entry[1];
      tables.nameToKeyMap[entry[1]] = key;
      tables.types[key] = entry[2];
      tables.defaults[key] = entry[3];
      tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
      tables.order.push(key);
    }

    return tables;
  }

}

const CFFTopDict = function CFFTopDictClosure() {
  const layout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [0.001, 0, 0, 0.001, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
  let tables = null;

  class CFFTopDict extends CFFDict {
    constructor(strings) {
      if (tables === null) {
        tables = CFFDict.createTables(layout);
      }

      super(tables, strings);
      this.privateDict = null;
    }

  }

  return CFFTopDict;
}();

exports.CFFTopDict = CFFTopDict;

const CFFPrivateDict = function CFFPrivateDictClosure() {
  const layout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
  let tables = null;

  class CFFPrivateDict extends CFFDict {
    constructor(strings) {
      if (tables === null) {
        tables = CFFDict.createTables(layout);
      }

      super(tables, strings);
      this.subrsIndex = null;
    }

  }

  return CFFPrivateDict;
}();

exports.CFFPrivateDict = CFFPrivateDict;
const CFFCharsetPredefinedTypes = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};

class CFFCharset {
  constructor(predefined, format, charset, raw) {
    this.predefined = predefined;
    this.format = format;
    this.charset = charset;
    this.raw = raw;
  }

}

exports.CFFCharset = CFFCharset;

class CFFEncoding {
  constructor(predefined, format, encoding, raw) {
    this.predefined = predefined;
    this.format = format;
    this.encoding = encoding;
    this.raw = raw;
  }

}

class CFFFDSelect {
  constructor(format, fdSelect) {
    this.format = format;
    this.fdSelect = fdSelect;
  }

  getFDIndex(glyphIndex) {
    if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
      return -1;
    }

    return this.fdSelect[glyphIndex];
  }

}

exports.CFFFDSelect = CFFFDSelect;

class CFFOffsetTracker {
  constructor() {
    this.offsets = Object.create(null);
  }

  isTracking(key) {
    return key in this.offsets;
  }

  track(key, location) {
    if (key in this.offsets) {
      throw new _util.FormatError(`Already tracking location of ${key}`);
    }

    this.offsets[key] = location;
  }

  offset(value) {
    for (const key in this.offsets) {
      this.offsets[key] += value;
    }
  }

  setEntryLocation(key, values, output) {
    if (!(key in this.offsets)) {
      throw new _util.FormatError(`Not tracking location of ${key}`);
    }

    const data = output.data;
    const dataOffset = this.offsets[key];
    const size = 5;

    for (let i = 0, ii = values.length; i < ii; ++i) {
      const offset0 = i * size + dataOffset;
      const offset1 = offset0 + 1;
      const offset2 = offset0 + 2;
      const offset3 = offset0 + 3;
      const offset4 = offset0 + 4;

      if (data[offset0] !== 0x1d || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
        throw new _util.FormatError("writing to an offset that is not empty");
      }

      const value = values[i];
      data[offset0] = 0x1d;
      data[offset1] = value >> 24 & 0xff;
      data[offset2] = value >> 16 & 0xff;
      data[offset3] = value >> 8 & 0xff;
      data[offset4] = value & 0xff;
    }
  }

}

class CFFCompiler {
  constructor(cff) {
    this.cff = cff;
  }

  compile() {
    const cff = this.cff;
    const output = {
      data: [],
      length: 0,
      add: function CFFCompiler_add(data) {
        this.data = this.data.concat(data);
        this.length = this.data.length;
      }
    };
    const header = this.compileHeader(cff.header);
    output.add(header);
    const nameIndex = this.compileNameIndex(cff.names);
    output.add(nameIndex);

    if (cff.isCIDFont) {
      if (cff.topDict.hasName("FontMatrix")) {
        const base = cff.topDict.getByName("FontMatrix");
        cff.topDict.removeByName("FontMatrix");

        for (let i = 0, ii = cff.fdArray.length; i < ii; i++) {
          const subDict = cff.fdArray[i];
          let matrix = base.slice(0);

          if (subDict.hasName("FontMatrix")) {
            matrix = _util.Util.transform(matrix, subDict.getByName("FontMatrix"));
          }

          subDict.setByName("FontMatrix", matrix);
        }
      }
    }

    const xuid = cff.topDict.getByName("XUID");

    if (xuid && xuid.length > 16) {
      cff.topDict.removeByName("XUID");
    }

    cff.topDict.setByName("charset", 0);
    let compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
    output.add(compiled.output);
    const topDictTracker = compiled.trackers[0];
    const stringIndex = this.compileStringIndex(cff.strings.strings);
    output.add(stringIndex);
    const globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
    output.add(globalSubrIndex);

    if (cff.encoding && cff.topDict.hasName("Encoding")) {
      if (cff.encoding.predefined) {
        topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
      } else {
        const encoding = this.compileEncoding(cff.encoding);
        topDictTracker.setEntryLocation("Encoding", [output.length], output);
        output.add(encoding);
      }
    }

    const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
    topDictTracker.setEntryLocation("charset", [output.length], output);
    output.add(charset);
    const charStrings = this.compileCharStrings(cff.charStrings);
    topDictTracker.setEntryLocation("CharStrings", [output.length], output);
    output.add(charStrings);

    if (cff.isCIDFont) {
      topDictTracker.setEntryLocation("FDSelect", [output.length], output);
      const fdSelect = this.compileFDSelect(cff.fdSelect);
      output.add(fdSelect);
      compiled = this.compileTopDicts(cff.fdArray, output.length, true);
      topDictTracker.setEntryLocation("FDArray", [output.length], output);
      output.add(compiled.output);
      const fontDictTrackers = compiled.trackers;
      this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
    }

    this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
    output.add([0]);
    return output.data;
  }

  encodeNumber(value) {
    if (Number.isInteger(value)) {
      return this.encodeInteger(value);
    }

    return this.encodeFloat(value);
  }

  static get EncodeFloatRegExp() {
    return (0, _util.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }

  encodeFloat(num) {
    let value = num.toString();
    const m = CFFCompiler.EncodeFloatRegExp.exec(value);

    if (m) {
      const epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
      value = (Math.round(num * epsilon) / epsilon).toString();
    }

    let nibbles = "";
    let i, ii;

    for (i = 0, ii = value.length; i < ii; ++i) {
      const a = value[i];

      if (a === "e") {
        nibbles += value[++i] === "-" ? "c" : "b";
      } else if (a === ".") {
        nibbles += "a";
      } else if (a === "-") {
        nibbles += "e";
      } else {
        nibbles += a;
      }
    }

    nibbles += nibbles.length & 1 ? "f" : "ff";
    const out = [30];

    for (i = 0, ii = nibbles.length; i < ii; i += 2) {
      out.push(parseInt(nibbles.substring(i, i + 2), 16));
    }

    return out;
  }

  encodeInteger(value) {
    let code;

    if (value >= -107 && value <= 107) {
      code = [value + 139];
    } else if (value >= 108 && value <= 1131) {
      value = value - 108;
      code = [(value >> 8) + 247, value & 0xff];
    } else if (value >= -1131 && value <= -108) {
      value = -value - 108;
      code = [(value >> 8) + 251, value & 0xff];
    } else if (value >= -32768 && value <= 32767) {
      code = [0x1c, value >> 8 & 0xff, value & 0xff];
    } else {
      code = [0x1d, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff];
    }

    return code;
  }

  compileHeader(header) {
    return [header.major, header.minor, 4, header.offSize];
  }

  compileNameIndex(names) {
    const nameIndex = new CFFIndex();

    for (let i = 0, ii = names.length; i < ii; ++i) {
      const name = names[i];
      const length = Math.min(name.length, 127);
      let sanitizedName = new Array(length);

      for (let j = 0; j < length; j++) {
        let char = name[j];

        if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
          char = "_";
        }

        sanitizedName[j] = char;
      }

      sanitizedName = sanitizedName.join("");

      if (sanitizedName === "") {
        sanitizedName = "Bad_Font_Name";
      }

      nameIndex.add((0, _util.stringToBytes)(sanitizedName));
    }

    return this.compileIndex(nameIndex);
  }

  compileTopDicts(dicts, length, removeCidKeys) {
    const fontDictTrackers = [];
    let fdArrayIndex = new CFFIndex();

    for (let i = 0, ii = dicts.length; i < ii; ++i) {
      const fontDict = dicts[i];

      if (removeCidKeys) {
        fontDict.removeByName("CIDFontVersion");
        fontDict.removeByName("CIDFontRevision");
        fontDict.removeByName("CIDFontType");
        fontDict.removeByName("CIDCount");
        fontDict.removeByName("UIDBase");
      }

      const fontDictTracker = new CFFOffsetTracker();
      const fontDictData = this.compileDict(fontDict, fontDictTracker);
      fontDictTrackers.push(fontDictTracker);
      fdArrayIndex.add(fontDictData);
      fontDictTracker.offset(length);
    }

    fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
    return {
      trackers: fontDictTrackers,
      output: fdArrayIndex
    };
  }

  compilePrivateDicts(dicts, trackers, output) {
    for (let i = 0, ii = dicts.length; i < ii; ++i) {
      const fontDict = dicts[i];
      const privateDict = fontDict.privateDict;

      if (!privateDict || !fontDict.hasName("Private")) {
        throw new _util.FormatError("There must be a private dictionary.");
      }

      const privateDictTracker = new CFFOffsetTracker();
      const privateDictData = this.compileDict(privateDict, privateDictTracker);
      let outputLength = output.length;
      privateDictTracker.offset(outputLength);

      if (!privateDictData.length) {
        outputLength = 0;
      }

      trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
      output.add(privateDictData);

      if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
        const subrs = this.compileIndex(privateDict.subrsIndex);
        privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
        output.add(subrs);
      }
    }
  }

  compileDict(dict, offsetTracker) {
    let out = [];
    const order = dict.order;

    for (let i = 0; i < order.length; ++i) {
      const key = order[i];

      if (!(key in dict.values)) {
        continue;
      }

      let values = dict.values[key];
      let types = dict.types[key];

      if (!Array.isArray(types)) {
        types = [types];
      }

      if (!Array.isArray(values)) {
        values = [values];
      }

      if (values.length === 0) {
        continue;
      }

      for (let j = 0, jj = types.length; j < jj; ++j) {
        const type = types[j];
        const value = values[j];

        switch (type) {
          case "num":
          case "sid":
            out = out.concat(this.encodeNumber(value));
            break;

          case "offset":
            const name = dict.keyToNameMap[key];

            if (!offsetTracker.isTracking(name)) {
              offsetTracker.track(name, out.length);
            }

            out = out.concat([0x1d, 0, 0, 0, 0]);
            break;

          case "array":
          case "delta":
            out = out.concat(this.encodeNumber(value));

            for (let k = 1, kk = values.length; k < kk; ++k) {
              out = out.concat(this.encodeNumber(values[k]));
            }

            break;

          default:
            throw new _util.FormatError(`Unknown data type of ${type}`);
        }
      }

      out = out.concat(dict.opcodes[key]);
    }

    return out;
  }

  compileStringIndex(strings) {
    const stringIndex = new CFFIndex();

    for (let i = 0, ii = strings.length; i < ii; ++i) {
      stringIndex.add((0, _util.stringToBytes)(strings[i]));
    }

    return this.compileIndex(stringIndex);
  }

  compileGlobalSubrIndex() {
    const globalSubrIndex = this.cff.globalSubrIndex;
    this.out.writeByteArray(this.compileIndex(globalSubrIndex));
  }

  compileCharStrings(charStrings) {
    const charStringsIndex = new CFFIndex();

    for (let i = 0; i < charStrings.count; i++) {
      const glyph = charStrings.get(i);

      if (glyph.length === 0) {
        charStringsIndex.add(new Uint8Array([0x8b, 0x0e]));
        continue;
      }

      charStringsIndex.add(glyph);
    }

    return this.compileIndex(charStringsIndex);
  }

  compileCharset(charset, numGlyphs, strings, isCIDFont) {
    let out;
    const numGlyphsLessNotDef = numGlyphs - 1;

    if (isCIDFont) {
      out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 0xff, numGlyphsLessNotDef & 0xff]);
    } else {
      const length = 1 + numGlyphsLessNotDef * 2;
      out = new Uint8Array(length);
      out[0] = 0;
      let charsetIndex = 0;
      const numCharsets = charset.charset.length;
      let warned = false;

      for (let i = 1; i < out.length; i += 2) {
        let sid = 0;

        if (charsetIndex < numCharsets) {
          const name = charset.charset[charsetIndex++];
          sid = strings.getSID(name);

          if (sid === -1) {
            sid = 0;

            if (!warned) {
              warned = true;
              (0, _util.warn)(`Couldn't find ${name} in CFF strings`);
            }
          }
        }

        out[i] = sid >> 8 & 0xff;
        out[i + 1] = sid & 0xff;
      }
    }

    return this.compileTypedArray(out);
  }

  compileEncoding(encoding) {
    return this.compileTypedArray(encoding.raw);
  }

  compileFDSelect(fdSelect) {
    const format = fdSelect.format;
    let out, i;

    switch (format) {
      case 0:
        out = new Uint8Array(1 + fdSelect.fdSelect.length);
        out[0] = format;

        for (i = 0; i < fdSelect.fdSelect.length; i++) {
          out[i + 1] = fdSelect.fdSelect[i];
        }

        break;

      case 3:
        const start = 0;
        let lastFD = fdSelect.fdSelect[0];
        const ranges = [format, 0, 0, start >> 8 & 0xff, start & 0xff, lastFD];

        for (i = 1; i < fdSelect.fdSelect.length; i++) {
          const currentFD = fdSelect.fdSelect[i];

          if (currentFD !== lastFD) {
            ranges.push(i >> 8 & 0xff, i & 0xff, currentFD);
            lastFD = currentFD;
          }
        }

        const numRanges = (ranges.length - 3) / 3;
        ranges[1] = numRanges >> 8 & 0xff;
        ranges[2] = numRanges & 0xff;
        ranges.push(i >> 8 & 0xff, i & 0xff);
        out = new Uint8Array(ranges);
        break;
    }

    return this.compileTypedArray(out);
  }

  compileTypedArray(data) {
    const out = [];

    for (let i = 0, ii = data.length; i < ii; ++i) {
      out[i] = data[i];
    }

    return out;
  }

  compileIndex(index, trackers = []) {
    const objects = index.objects;
    const count = objects.length;

    if (count === 0) {
      return [0, 0, 0];
    }

    const data = [count >> 8 & 0xff, count & 0xff];
    let lastOffset = 1,
        i;

    for (i = 0; i < count; ++i) {
      lastOffset += objects[i].length;
    }

    let offsetSize;

    if (lastOffset < 0x100) {
      offsetSize = 1;
    } else if (lastOffset < 0x10000) {
      offsetSize = 2;
    } else if (lastOffset < 0x1000000) {
      offsetSize = 3;
    } else {
      offsetSize = 4;
    }

    data.push(offsetSize);
    let relativeOffset = 1;

    for (i = 0; i < count + 1; i++) {
      if (offsetSize === 1) {
        data.push(relativeOffset & 0xff);
      } else if (offsetSize === 2) {
        data.push(relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
      } else if (offsetSize === 3) {
        data.push(relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
      } else {
        data.push(relativeOffset >>> 24 & 0xff, relativeOffset >> 16 & 0xff, relativeOffset >> 8 & 0xff, relativeOffset & 0xff);
      }

      if (objects[i]) {
        relativeOffset += objects[i].length;
      }
    }

    for (i = 0; i < count; i++) {
      if (trackers[i]) {
        trackers[i].offset(data.length);
      }

      for (let j = 0, jj = objects[i].length; j < jj; j++) {
        data.push(objects[i][j]);
      }
    }

    return data;
  }

}

exports.CFFCompiler = CFFCompiler;

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ISOAdobeCharset = exports.ExpertSubsetCharset = exports.ExpertCharset = void 0;
const ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
exports.ISOAdobeCharset = ISOAdobeCharset;
const ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
exports.ExpertCharset = ExpertCharset;
const ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
exports.ExpertSubsetCharset = ExpertSubsetCharset;

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getEncoding = getEncoding;
exports.ZapfDingbatsEncoding = exports.WinAnsiEncoding = exports.SymbolSetEncoding = exports.StandardEncoding = exports.MacRomanEncoding = exports.ExpertEncoding = void 0;
const ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
exports.ExpertEncoding = ExpertEncoding;
const MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
const MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
exports.MacRomanEncoding = MacRomanEncoding;
const StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
exports.StandardEncoding = StandardEncoding;
const WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
exports.WinAnsiEncoding = WinAnsiEncoding;
const SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
exports.SymbolSetEncoding = SymbolSetEncoding;
const ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
exports.ZapfDingbatsEncoding = ZapfDingbatsEncoding;

function getEncoding(encodingName) {
  switch (encodingName) {
    case "WinAnsiEncoding":
      return WinAnsiEncoding;

    case "StandardEncoding":
      return StandardEncoding;

    case "MacRomanEncoding":
      return MacRomanEncoding;

    case "SymbolSetEncoding":
      return SymbolSetEncoding;

    case "ZapfDingbatsEncoding":
      return ZapfDingbatsEncoding;

    case "ExpertEncoding":
      return ExpertEncoding;

    case "MacExpertEncoding":
      return MacExpertEncoding;

    default:
      return null;
  }
}

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFontType = getFontType;
exports.recoverGlyphName = recoverGlyphName;
exports.type1FontGlyphMapping = type1FontGlyphMapping;
exports.SEAC_ANALYSIS_ENABLED = exports.MacStandardGlyphOrdering = exports.FontFlags = void 0;

var _util = __w_pdfjs_require__(2);

var _encodings = __w_pdfjs_require__(37);

var _glyphlist = __w_pdfjs_require__(39);

var _unicode = __w_pdfjs_require__(40);

const SEAC_ANALYSIS_ENABLED = true;
exports.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
const FontFlags = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Script: 8,
  Nonsymbolic: 32,
  Italic: 64,
  AllCap: 65536,
  SmallCap: 131072,
  ForceBold: 262144
};
exports.FontFlags = FontFlags;
const MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
exports.MacStandardGlyphOrdering = MacStandardGlyphOrdering;

function getFontType(type, subtype) {
  switch (type) {
    case "Type1":
      return subtype === "Type1C" ? _util.FontType.TYPE1C : _util.FontType.TYPE1;

    case "CIDFontType0":
      return subtype === "CIDFontType0C" ? _util.FontType.CIDFONTTYPE0C : _util.FontType.CIDFONTTYPE0;

    case "OpenType":
      return _util.FontType.OPENTYPE;

    case "TrueType":
      return _util.FontType.TRUETYPE;

    case "CIDFontType2":
      return _util.FontType.CIDFONTTYPE2;

    case "MMType1":
      return _util.FontType.MMTYPE1;

    case "Type0":
      return _util.FontType.TYPE0;

    default:
      return _util.FontType.UNKNOWN;
  }
}

function recoverGlyphName(name, glyphsUnicodeMap) {
  if (glyphsUnicodeMap[name] !== undefined) {
    return name;
  }

  const unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);

  if (unicode !== -1) {
    for (const key in glyphsUnicodeMap) {
      if (glyphsUnicodeMap[key] === unicode) {
        return key;
      }
    }
  }

  (0, _util.info)("Unable to recover a standard glyph name for: " + name);
  return name;
}

function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
  const charCodeToGlyphId = Object.create(null);
  let glyphId, charCode, baseEncoding;
  const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);

  if (properties.baseEncodingName) {
    baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);

    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);

      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  } else if (isSymbolicFont) {
    for (charCode in builtInEncoding) {
      charCodeToGlyphId[charCode] = builtInEncoding[charCode];
    }
  } else {
    baseEncoding = _encodings.StandardEncoding;

    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);

      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }

  const differences = properties.differences;
  let glyphsUnicodeMap;

  if (differences) {
    for (charCode in differences) {
      const glyphName = differences[charCode];
      glyphId = glyphNames.indexOf(glyphName);

      if (glyphId === -1) {
        if (!glyphsUnicodeMap) {
          glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
        }

        const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);

        if (standardGlyphName !== glyphName) {
          glyphId = glyphNames.indexOf(standardGlyphName);
        }
      }

      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }

  return charCodeToGlyphId;
}

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __w_pdfjs_require__) => {

__w_pdfjs_require__.r(__webpack_exports__);
/* harmony export */ __w_pdfjs_require__.d(__webpack_exports__, {
/* harmony export */   "getDingbatsGlyphsUnicode": () => (/* binding */ getDingbatsGlyphsUnicode),
/* harmony export */   "getGlyphsUnicode": () => (/* binding */ getGlyphsUnicode)
/* harmony export */ });
/* harmony import */ var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__(9);

const getGlyphsUnicode = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () {
 return [
  "A",
  0x0041,
  "AE",
  0x00c6,
  "AEacute",
  0x01fc,
  "AEmacron",
  0x01e2,
  "AEsmall",
  0xf7e6,
  "Aacute",
  0x00c1,
  "Aacutesmall",
  0xf7e1,
  "Abreve",
  0x0102,
  "Abreveacute",
  0x1eae,
  "Abrevecyrillic",
  0x04d0,
  "Abrevedotbelow",
  0x1eb6,
  "Abrevegrave",
  0x1eb0,
  "Abrevehookabove",
  0x1eb2,
  "Abrevetilde",
  0x1eb4,
  "Acaron",
  0x01cd,
  "Acircle",
  0x24b6,
  "Acircumflex",
  0x00c2,
  "Acircumflexacute",
  0x1ea4,
  "Acircumflexdotbelow",
  0x1eac,
  "Acircumflexgrave",
  0x1ea6,
  "Acircumflexhookabove",
  0x1ea8,
  "Acircumflexsmall",
  0xf7e2,
  "Acircumflextilde",
  0x1eaa,
  "Acute",
  0xf6c9,
  "Acutesmall",
  0xf7b4,
  "Acyrillic",
  0x0410,
  "Adblgrave",
  0x0200,
  "Adieresis",
  0x00c4,
  "Adieresiscyrillic",
  0x04d2,
  "Adieresismacron",
  0x01de,
  "Adieresissmall",
  0xf7e4,
  "Adotbelow",
  0x1ea0,
  "Adotmacron",
  0x01e0,
  "Agrave",
  0x00c0,
  "Agravesmall",
  0xf7e0,
  "Ahookabove",
  0x1ea2,
  "Aiecyrillic",
  0x04d4,
  "Ainvertedbreve",
  0x0202,
  "Alpha",
  0x0391,
  "Alphatonos",
  0x0386,
  "Amacron",
  0x0100,
  "Amonospace",
  0xff21,
  "Aogonek",
  0x0104,
  "Aring",
  0x00c5,
  "Aringacute",
  0x01fa,
  "Aringbelow",
  0x1e00,
  "Aringsmall",
  0xf7e5,
  "Asmall",
  0xf761,
  "Atilde",
  0x00c3,
  "Atildesmall",
  0xf7e3,
  "Aybarmenian",
  0x0531,
  "B",
  0x0042,
  "Bcircle",
  0x24b7,
  "Bdotaccent",
  0x1e02,
  "Bdotbelow",
  0x1e04,
  "Becyrillic",
  0x0411,
  "Benarmenian",
  0x0532,
  "Beta",
  0x0392,
  "Bhook",
  0x0181,
  "Blinebelow",
  0x1e06,
  "Bmonospace",
  0xff22,
  "Brevesmall",
  0xf6f4,
  "Bsmall",
  0xf762,
  "Btopbar",
  0x0182,
  "C",
  0x0043,
  "Caarmenian",
  0x053e,
  "Cacute",
  0x0106,
  "Caron",
  0xf6ca,
  "Caronsmall",
  0xf6f5,
  "Ccaron",
  0x010c,
  "Ccedilla",
  0x00c7,
  "Ccedillaacute",
  0x1e08,
  "Ccedillasmall",
  0xf7e7,
  "Ccircle",
  0x24b8,
  "Ccircumflex",
  0x0108,
  "Cdot",
  0x010a,
  "Cdotaccent",
  0x010a,
  "Cedillasmall",
  0xf7b8,
  "Chaarmenian",
  0x0549,
  "Cheabkhasiancyrillic",
  0x04bc,
  "Checyrillic",
  0x0427,
  "Chedescenderabkhasiancyrillic",
  0x04be,
  "Chedescendercyrillic",
  0x04b6,
  "Chedieresiscyrillic",
  0x04f4,
  "Cheharmenian",
  0x0543,
  "Chekhakassiancyrillic",
  0x04cb,
  "Cheverticalstrokecyrillic",
  0x04b8,
  "Chi",
  0x03a7,
  "Chook",
  0x0187,
  "Circumflexsmall",
  0xf6f6,
  "Cmonospace",
  0xff23,
  "Coarmenian",
  0x0551,
  "Csmall",
  0xf763,
  "D",
  0x0044,
  "DZ",
  0x01f1,
  "DZcaron",
  0x01c4,
  "Daarmenian",
  0x0534,
  "Dafrican",
  0x0189,
  "Dcaron",
  0x010e,
  "Dcedilla",
  0x1e10,
  "Dcircle",
  0x24b9,
  "Dcircumflexbelow",
  0x1e12,
  "Dcroat",
  0x0110,
  "Ddotaccent",
  0x1e0a,
  "Ddotbelow",
  0x1e0c,
  "Decyrillic",
  0x0414,
  "Deicoptic",
  0x03ee,
  "Delta",
  0x2206,
  "Deltagreek",
  0x0394,
  "Dhook",
  0x018a,
  "Dieresis",
  0xf6cb,
  "DieresisAcute",
  0xf6cc,
  "DieresisGrave",
  0xf6cd,
  "Dieresissmall",
  0xf7a8,
  "Digammagreek",
  0x03dc,
  "Djecyrillic",
  0x0402,
  "Dlinebelow",
  0x1e0e,
  "Dmonospace",
  0xff24,
  "Dotaccentsmall",
  0xf6f7,
  "Dslash",
  0x0110,
  "Dsmall",
  0xf764,
  "Dtopbar",
  0x018b,
  "Dz",
  0x01f2,
  "Dzcaron",
  0x01c5,
  "Dzeabkhasiancyrillic",
  0x04e0,
  "Dzecyrillic",
  0x0405,
  "Dzhecyrillic",
  0x040f,
  "E",
  0x0045,
  "Eacute",
  0x00c9,
  "Eacutesmall",
  0xf7e9,
  "Ebreve",
  0x0114,
  "Ecaron",
  0x011a,
  "Ecedillabreve",
  0x1e1c,
  "Echarmenian",
  0x0535,
  "Ecircle",
  0x24ba,
  "Ecircumflex",
  0x00ca,
  "Ecircumflexacute",
  0x1ebe,
  "Ecircumflexbelow",
  0x1e18,
  "Ecircumflexdotbelow",
  0x1ec6,
  "Ecircumflexgrave",
  0x1ec0,
  "Ecircumflexhookabove",
  0x1ec2,
  "Ecircumflexsmall",
  0xf7ea,
  "Ecircumflextilde",
  0x1ec4,
  "Ecyrillic",
  0x0404,
  "Edblgrave",
  0x0204,
  "Edieresis",
  0x00cb,
  "Edieresissmall",
  0xf7eb,
  "Edot",
  0x0116,
  "Edotaccent",
  0x0116,
  "Edotbelow",
  0x1eb8,
  "Efcyrillic",
  0x0424,
  "Egrave",
  0x00c8,
  "Egravesmall",
  0xf7e8,
  "Eharmenian",
  0x0537,
  "Ehookabove",
  0x1eba,
  "Eightroman",
  0x2167,
  "Einvertedbreve",
  0x0206,
  "Eiotifiedcyrillic",
  0x0464,
  "Elcyrillic",
  0x041b,
  "Elevenroman",
  0x216a,
  "Emacron",
  0x0112,
  "Emacronacute",
  0x1e16,
  "Emacrongrave",
  0x1e14,
  "Emcyrillic",
  0x041c,
  "Emonospace",
  0xff25,
  "Encyrillic",
  0x041d,
  "Endescendercyrillic",
  0x04a2,
  "Eng",
  0x014a,
  "Enghecyrillic",
  0x04a4,
  "Enhookcyrillic",
  0x04c7,
  "Eogonek",
  0x0118,
  "Eopen",
  0x0190,
  "Epsilon",
  0x0395,
  "Epsilontonos",
  0x0388,
  "Ercyrillic",
  0x0420,
  "Ereversed",
  0x018e,
  "Ereversedcyrillic",
  0x042d,
  "Escyrillic",
  0x0421,
  "Esdescendercyrillic",
  0x04aa,
  "Esh",
  0x01a9,
  "Esmall",
  0xf765,
  "Eta",
  0x0397,
  "Etarmenian",
  0x0538,
  "Etatonos",
  0x0389,
  "Eth",
  0x00d0,
  "Ethsmall",
  0xf7f0,
  "Etilde",
  0x1ebc,
  "Etildebelow",
  0x1e1a,
  "Euro",
  0x20ac,
  "Ezh",
  0x01b7,
  "Ezhcaron",
  0x01ee,
  "Ezhreversed",
  0x01b8,
  "F",
  0x0046,
  "Fcircle",
  0x24bb,
  "Fdotaccent",
  0x1e1e,
  "Feharmenian",
  0x0556,
  "Feicoptic",
  0x03e4,
  "Fhook",
  0x0191,
  "Fitacyrillic",
  0x0472,
  "Fiveroman",
  0x2164,
  "Fmonospace",
  0xff26,
  "Fourroman",
  0x2163,
  "Fsmall",
  0xf766,
  "G",
  0x0047,
  "GBsquare",
  0x3387,
  "Gacute",
  0x01f4,
  "Gamma",
  0x0393,
  "Gammaafrican",
  0x0194,
  "Gangiacoptic",
  0x03ea,
  "Gbreve",
  0x011e,
  "Gcaron",
  0x01e6,
  "Gcedilla",
  0x0122,
  "Gcircle",
  0x24bc,
  "Gcircumflex",
  0x011c,
  "Gcommaaccent",
  0x0122,
  "Gdot",
  0x0120,
  "Gdotaccent",
  0x0120,
  "Gecyrillic",
  0x0413,
  "Ghadarmenian",
  0x0542,
  "Ghemiddlehookcyrillic",
  0x0494,
  "Ghestrokecyrillic",
  0x0492,
  "Gheupturncyrillic",
  0x0490,
  "Ghook",
  0x0193,
  "Gimarmenian",
  0x0533,
  "Gjecyrillic",
  0x0403,
  "Gmacron",
  0x1e20,
  "Gmonospace",
  0xff27,
  "Grave",
  0xf6ce,
  "Gravesmall",
  0xf760,
  "Gsmall",
  0xf767,
  "Gsmallhook",
  0x029b,
  "Gstroke",
  0x01e4,
  "H",
  0x0048,
  "H18533",
  0x25cf,
  "H18543",
  0x25aa,
  "H18551",
  0x25ab,
  "H22073",
  0x25a1,
  "HPsquare",
  0x33cb,
  "Haabkhasiancyrillic",
  0x04a8,
  "Hadescendercyrillic",
  0x04b2,
  "Hardsigncyrillic",
  0x042a,
  "Hbar",
  0x0126,
  "Hbrevebelow",
  0x1e2a,
  "Hcedilla",
  0x1e28,
  "Hcircle",
  0x24bd,
  "Hcircumflex",
  0x0124,
  "Hdieresis",
  0x1e26,
  "Hdotaccent",
  0x1e22,
  "Hdotbelow",
  0x1e24,
  "Hmonospace",
  0xff28,
  "Hoarmenian",
  0x0540,
  "Horicoptic",
  0x03e8,
  "Hsmall",
  0xf768,
  "Hungarumlaut",
  0xf6cf,
  "Hungarumlautsmall",
  0xf6f8,
  "Hzsquare",
  0x3390,
  "I",
  0x0049,
  "IAcyrillic",
  0x042f,
  "IJ",
  0x0132,
  "IUcyrillic",
  0x042e,
  "Iacute",
  0x00cd,
  "Iacutesmall",
  0xf7ed,
  "Ibreve",
  0x012c,
  "Icaron",
  0x01cf,
  "Icircle",
  0x24be,
  "Icircumflex",
  0x00ce,
  "Icircumflexsmall",
  0xf7ee,
  "Icyrillic",
  0x0406,
  "Idblgrave",
  0x0208,
  "Idieresis",
  0x00cf,
  "Idieresisacute",
  0x1e2e,
  "Idieresiscyrillic",
  0x04e4,
  "Idieresissmall",
  0xf7ef,
  "Idot",
  0x0130,
  "Idotaccent",
  0x0130,
  "Idotbelow",
  0x1eca,
  "Iebrevecyrillic",
  0x04d6,
  "Iecyrillic",
  0x0415,
  "Ifraktur",
  0x2111,
  "Igrave",
  0x00cc,
  "Igravesmall",
  0xf7ec,
  "Ihookabove",
  0x1ec8,
  "Iicyrillic",
  0x0418,
  "Iinvertedbreve",
  0x020a,
  "Iishortcyrillic",
  0x0419,
  "Imacron",
  0x012a,
  "Imacroncyrillic",
  0x04e2,
  "Imonospace",
  0xff29,
  "Iniarmenian",
  0x053b,
  "Iocyrillic",
  0x0401,
  "Iogonek",
  0x012e,
  "Iota",
  0x0399,
  "Iotaafrican",
  0x0196,
  "Iotadieresis",
  0x03aa,
  "Iotatonos",
  0x038a,
  "Ismall",
  0xf769,
  "Istroke",
  0x0197,
  "Itilde",
  0x0128,
  "Itildebelow",
  0x1e2c,
  "Izhitsacyrillic",
  0x0474,
  "Izhitsadblgravecyrillic",
  0x0476,
  "J",
  0x004a,
  "Jaarmenian",
  0x0541,
  "Jcircle",
  0x24bf,
  "Jcircumflex",
  0x0134,
  "Jecyrillic",
  0x0408,
  "Jheharmenian",
  0x054b,
  "Jmonospace",
  0xff2a,
  "Jsmall",
  0xf76a,
  "K",
  0x004b,
  "KBsquare",
  0x3385,
  "KKsquare",
  0x33cd,
  "Kabashkircyrillic",
  0x04a0,
  "Kacute",
  0x1e30,
  "Kacyrillic",
  0x041a,
  "Kadescendercyrillic",
  0x049a,
  "Kahookcyrillic",
  0x04c3,
  "Kappa",
  0x039a,
  "Kastrokecyrillic",
  0x049e,
  "Kaverticalstrokecyrillic",
  0x049c,
  "Kcaron",
  0x01e8,
  "Kcedilla",
  0x0136,
  "Kcircle",
  0x24c0,
  "Kcommaaccent",
  0x0136,
  "Kdotbelow",
  0x1e32,
  "Keharmenian",
  0x0554,
  "Kenarmenian",
  0x053f,
  "Khacyrillic",
  0x0425,
  "Kheicoptic",
  0x03e6,
  "Khook",
  0x0198,
  "Kjecyrillic",
  0x040c,
  "Klinebelow",
  0x1e34,
  "Kmonospace",
  0xff2b,
  "Koppacyrillic",
  0x0480,
  "Koppagreek",
  0x03de,
  "Ksicyrillic",
  0x046e,
  "Ksmall",
  0xf76b,
  "L",
  0x004c,
  "LJ",
  0x01c7,
  "LL",
  0xf6bf,
  "Lacute",
  0x0139,
  "Lambda",
  0x039b,
  "Lcaron",
  0x013d,
  "Lcedilla",
  0x013b,
  "Lcircle",
  0x24c1,
  "Lcircumflexbelow",
  0x1e3c,
  "Lcommaaccent",
  0x013b,
  "Ldot",
  0x013f,
  "Ldotaccent",
  0x013f,
  "Ldotbelow",
  0x1e36,
  "Ldotbelowmacron",
  0x1e38,
  "Liwnarmenian",
  0x053c,
  "Lj",
  0x01c8,
  "Ljecyrillic",
  0x0409,
  "Llinebelow",
  0x1e3a,
  "Lmonospace",
  0xff2c,
  "Lslash",
  0x0141,
  "Lslashsmall",
  0xf6f9,
  "Lsmall",
  0xf76c,
  "M",
  0x004d,
  "MBsquare",
  0x3386,
  "Macron",
  0xf6d0,
  "Macronsmall",
  0xf7af,
  "Macute",
  0x1e3e,
  "Mcircle",
  0x24c2,
  "Mdotaccent",
  0x1e40,
  "Mdotbelow",
  0x1e42,
  "Menarmenian",
  0x0544,
  "Mmonospace",
  0xff2d,
  "Msmall",
  0xf76d,
  "Mturned",
  0x019c,
  "Mu",
  0x039c,
  "N",
  0x004e,
  "NJ",
  0x01ca,
  "Nacute",
  0x0143,
  "Ncaron",
  0x0147,
  "Ncedilla",
  0x0145,
  "Ncircle",
  0x24c3,
  "Ncircumflexbelow",
  0x1e4a,
  "Ncommaaccent",
  0x0145,
  "Ndotaccent",
  0x1e44,
  "Ndotbelow",
  0x1e46,
  "Nhookleft",
  0x019d,
  "Nineroman",
  0x2168,
  "Nj",
  0x01cb,
  "Njecyrillic",
  0x040a,
  "Nlinebelow",
  0x1e48,
  "Nmonospace",
  0xff2e,
  "Nowarmenian",
  0x0546,
  "Nsmall",
  0xf76e,
  "Ntilde",
  0x00d1,
  "Ntildesmall",
  0xf7f1,
  "Nu",
  0x039d,
  "O",
  0x004f,
  "OE",
  0x0152,
  "OEsmall",
  0xf6fa,
  "Oacute",
  0x00d3,
  "Oacutesmall",
  0xf7f3,
  "Obarredcyrillic",
  0x04e8,
  "Obarreddieresiscyrillic",
  0x04ea,
  "Obreve",
  0x014e,
  "Ocaron",
  0x01d1,
  "Ocenteredtilde",
  0x019f,
  "Ocircle",
  0x24c4,
  "Ocircumflex",
  0x00d4,
  "Ocircumflexacute",
  0x1ed0,
  "Ocircumflexdotbelow",
  0x1ed8,
  "Ocircumflexgrave",
  0x1ed2,
  "Ocircumflexhookabove",
  0x1ed4,
  "Ocircumflexsmall",
  0xf7f4,
  "Ocircumflextilde",
  0x1ed6,
  "Ocyrillic",
  0x041e,
  "Odblacute",
  0x0150,
  "Odblgrave",
  0x020c,
  "Odieresis",
  0x00d6,
  "Odieresiscyrillic",
  0x04e6,
  "Odieresissmall",
  0xf7f6,
  "Odotbelow",
  0x1ecc,
  "Ogoneksmall",
  0xf6fb,
  "Ograve",
  0x00d2,
  "Ogravesmall",
  0xf7f2,
  "Oharmenian",
  0x0555,
  "Ohm",
  0x2126,
  "Ohookabove",
  0x1ece,
  "Ohorn",
  0x01a0,
  "Ohornacute",
  0x1eda,
  "Ohorndotbelow",
  0x1ee2,
  "Ohorngrave",
  0x1edc,
  "Ohornhookabove",
  0x1ede,
  "Ohorntilde",
  0x1ee0,
  "Ohungarumlaut",
  0x0150,
  "Oi",
  0x01a2,
  "Oinvertedbreve",
  0x020e,
  "Omacron",
  0x014c,
  "Omacronacute",
  0x1e52,
  "Omacrongrave",
  0x1e50,
  "Omega",
  0x2126,
  "Omegacyrillic",
  0x0460,
  "Omegagreek",
  0x03a9,
  "Omegaroundcyrillic",
  0x047a,
  "Omegatitlocyrillic",
  0x047c,
  "Omegatonos",
  0x038f,
  "Omicron",
  0x039f,
  "Omicrontonos",
  0x038c,
  "Omonospace",
  0xff2f,
  "Oneroman",
  0x2160,
  "Oogonek",
  0x01ea,
  "Oogonekmacron",
  0x01ec,
  "Oopen",
  0x0186,
  "Oslash",
  0x00d8,
  "Oslashacute",
  0x01fe,
  "Oslashsmall",
  0xf7f8,
  "Osmall",
  0xf76f,
  "Ostrokeacute",
  0x01fe,
  "Otcyrillic",
  0x047e,
  "Otilde",
  0x00d5,
  "Otildeacute",
  0x1e4c,
  "Otildedieresis",
  0x1e4e,
  "Otildesmall",
  0xf7f5,
  "P",
  0x0050,
  "Pacute",
  0x1e54,
  "Pcircle",
  0x24c5,
  "Pdotaccent",
  0x1e56,
  "Pecyrillic",
  0x041f,
  "Peharmenian",
  0x054a,
  "Pemiddlehookcyrillic",
  0x04a6,
  "Phi",
  0x03a6,
  "Phook",
  0x01a4,
  "Pi",
  0x03a0,
  "Piwrarmenian",
  0x0553,
  "Pmonospace",
  0xff30,
  "Psi",
  0x03a8,
  "Psicyrillic",
  0x0470,
  "Psmall",
  0xf770,
  "Q",
  0x0051,
  "Qcircle",
  0x24c6,
  "Qmonospace",
  0xff31,
  "Qsmall",
  0xf771,
  "R",
  0x0052,
  "Raarmenian",
  0x054c,
  "Racute",
  0x0154,
  "Rcaron",
  0x0158,
  "Rcedilla",
  0x0156,
  "Rcircle",
  0x24c7,
  "Rcommaaccent",
  0x0156,
  "Rdblgrave",
  0x0210,
  "Rdotaccent",
  0x1e58,
  "Rdotbelow",
  0x1e5a,
  "Rdotbelowmacron",
  0x1e5c,
  "Reharmenian",
  0x0550,
  "Rfraktur",
  0x211c,
  "Rho",
  0x03a1,
  "Ringsmall",
  0xf6fc,
  "Rinvertedbreve",
  0x0212,
  "Rlinebelow",
  0x1e5e,
  "Rmonospace",
  0xff32,
  "Rsmall",
  0xf772,
  "Rsmallinverted",
  0x0281,
  "Rsmallinvertedsuperior",
  0x02b6,
  "S",
  0x0053,
  "SF010000",
  0x250c,
  "SF020000",
  0x2514,
  "SF030000",
  0x2510,
  "SF040000",
  0x2518,
  "SF050000",
  0x253c,
  "SF060000",
  0x252c,
  "SF070000",
  0x2534,
  "SF080000",
  0x251c,
  "SF090000",
  0x2524,
  "SF100000",
  0x2500,
  "SF110000",
  0x2502,
  "SF190000",
  0x2561,
  "SF200000",
  0x2562,
  "SF210000",
  0x2556,
  "SF220000",
  0x2555,
  "SF230000",
  0x2563,
  "SF240000",
  0x2551,
  "SF250000",
  0x2557,
  "SF260000",
  0x255d,
  "SF270000",
  0x255c,
  "SF280000",
  0x255b,
  "SF360000",
  0x255e,
  "SF370000",
  0x255f,
  "SF380000",
  0x255a,
  "SF390000",
  0x2554,
  "SF400000",
  0x2569,
  "SF410000",
  0x2566,
  "SF420000",
  0x2560,
  "SF430000",
  0x2550,
  "SF440000",
  0x256c,
  "SF450000",
  0x2567,
  "SF460000",
  0x2568,
  "SF470000",
  0x2564,
  "SF480000",
  0x2565,
  "SF490000",
  0x2559,
  "SF500000",
  0x2558,
  "SF510000",
  0x2552,
  "SF520000",
  0x2553,
  "SF530000",
  0x256b,
  "SF540000",
  0x256a,
  "Sacute",
  0x015a,
  "Sacutedotaccent",
  0x1e64,
  "Sampigreek",
  0x03e0,
  "Scaron",
  0x0160,
  "Scarondotaccent",
  0x1e66,
  "Scaronsmall",
  0xf6fd,
  "Scedilla",
  0x015e,
  "Schwa",
  0x018f,
  "Schwacyrillic",
  0x04d8,
  "Schwadieresiscyrillic",
  0x04da,
  "Scircle",
  0x24c8,
  "Scircumflex",
  0x015c,
  "Scommaaccent",
  0x0218,
  "Sdotaccent",
  0x1e60,
  "Sdotbelow",
  0x1e62,
  "Sdotbelowdotaccent",
  0x1e68,
  "Seharmenian",
  0x054d,
  "Sevenroman",
  0x2166,
  "Shaarmenian",
  0x0547,
  "Shacyrillic",
  0x0428,
  "Shchacyrillic",
  0x0429,
  "Sheicoptic",
  0x03e2,
  "Shhacyrillic",
  0x04ba,
  "Shimacoptic",
  0x03ec,
  "Sigma",
  0x03a3,
  "Sixroman",
  0x2165,
  "Smonospace",
  0xff33,
  "Softsigncyrillic",
  0x042c,
  "Ssmall",
  0xf773,
  "Stigmagreek",
  0x03da,
  "T",
  0x0054,
  "Tau",
  0x03a4,
  "Tbar",
  0x0166,
  "Tcaron",
  0x0164,
  "Tcedilla",
  0x0162,
  "Tcircle",
  0x24c9,
  "Tcircumflexbelow",
  0x1e70,
  "Tcommaaccent",
  0x0162,
  "Tdotaccent",
  0x1e6a,
  "Tdotbelow",
  0x1e6c,
  "Tecyrillic",
  0x0422,
  "Tedescendercyrillic",
  0x04ac,
  "Tenroman",
  0x2169,
  "Tetsecyrillic",
  0x04b4,
  "Theta",
  0x0398,
  "Thook",
  0x01ac,
  "Thorn",
  0x00de,
  "Thornsmall",
  0xf7fe,
  "Threeroman",
  0x2162,
  "Tildesmall",
  0xf6fe,
  "Tiwnarmenian",
  0x054f,
  "Tlinebelow",
  0x1e6e,
  "Tmonospace",
  0xff34,
  "Toarmenian",
  0x0539,
  "Tonefive",
  0x01bc,
  "Tonesix",
  0x0184,
  "Tonetwo",
  0x01a7,
  "Tretroflexhook",
  0x01ae,
  "Tsecyrillic",
  0x0426,
  "Tshecyrillic",
  0x040b,
  "Tsmall",
  0xf774,
  "Twelveroman",
  0x216b,
  "Tworoman",
  0x2161,
  "U",
  0x0055,
  "Uacute",
  0x00da,
  "Uacutesmall",
  0xf7fa,
  "Ubreve",
  0x016c,
  "Ucaron",
  0x01d3,
  "Ucircle",
  0x24ca,
  "Ucircumflex",
  0x00db,
  "Ucircumflexbelow",
  0x1e76,
  "Ucircumflexsmall",
  0xf7fb,
  "Ucyrillic",
  0x0423,
  "Udblacute",
  0x0170,
  "Udblgrave",
  0x0214,
  "Udieresis",
  0x00dc,
  "Udieresisacute",
  0x01d7,
  "Udieresisbelow",
  0x1e72,
  "Udieresiscaron",
  0x01d9,
  "Udieresiscyrillic",
  0x04f0,
  "Udieresisgrave",
  0x01db,
  "Udieresismacron",
  0x01d5,
  "Udieresissmall",
  0xf7fc,
  "Udotbelow",
  0x1ee4,
  "Ugrave",
  0x00d9,
  "Ugravesmall",
  0xf7f9,
  "Uhookabove",
  0x1ee6,
  "Uhorn",
  0x01af,
  "Uhornacute",
  0x1ee8,
  "Uhorndotbelow",
  0x1ef0,
  "Uhorngrave",
  0x1eea,
  "Uhornhookabove",
  0x1eec,
  "Uhorntilde",
  0x1eee,
  "Uhungarumlaut",
  0x0170,
  "Uhungarumlautcyrillic",
  0x04f2,
  "Uinvertedbreve",
  0x0216,
  "Ukcyrillic",
  0x0478,
  "Umacron",
  0x016a,
  "Umacroncyrillic",
  0x04ee,
  "Umacrondieresis",
  0x1e7a,
  "Umonospace",
  0xff35,
  "Uogonek",
  0x0172,
  "Upsilon",
  0x03a5,
  "Upsilon1",
  0x03d2,
  "Upsilonacutehooksymbolgreek",
  0x03d3,
  "Upsilonafrican",
  0x01b1,
  "Upsilondieresis",
  0x03ab,
  "Upsilondieresishooksymbolgreek",
  0x03d4,
  "Upsilonhooksymbol",
  0x03d2,
  "Upsilontonos",
  0x038e,
  "Uring",
  0x016e,
  "Ushortcyrillic",
  0x040e,
  "Usmall",
  0xf775,
  "Ustraightcyrillic",
  0x04ae,
  "Ustraightstrokecyrillic",
  0x04b0,
  "Utilde",
  0x0168,
  "Utildeacute",
  0x1e78,
  "Utildebelow",
  0x1e74,
  "V",
  0x0056,
  "Vcircle",
  0x24cb,
  "Vdotbelow",
  0x1e7e,
  "Vecyrillic",
  0x0412,
  "Vewarmenian",
  0x054e,
  "Vhook",
  0x01b2,
  "Vmonospace",
  0xff36,
  "Voarmenian",
  0x0548,
  "Vsmall",
  0xf776,
  "Vtilde",
  0x1e7c,
  "W",
  0x0057,
  "Wacute",
  0x1e82,
  "Wcircle",
  0x24cc,
  "Wcircumflex",
  0x0174,
  "Wdieresis",
  0x1e84,
  "Wdotaccent",
  0x1e86,
  "Wdotbelow",
  0x1e88,
  "Wgrave",
  0x1e80,
  "Wmonospace",
  0xff37,
  "Wsmall",
  0xf777,
  "X",
  0x0058,
  "Xcircle",
  0x24cd,
  "Xdieresis",
  0x1e8c,
  "Xdotaccent",
  0x1e8a,
  "Xeharmenian",
  0x053d,
  "Xi",
  0x039e,
  "Xmonospace",
  0xff38,
  "Xsmall",
  0xf778,
  "Y",
  0x0059,
  "Yacute",
  0x00dd,
  "Yacutesmall",
  0xf7fd,
  "Yatcyrillic",
  0x0462,
  "Ycircle",
  0x24ce,
  "Ycircumflex",
  0x0176,
  "Ydieresis",
  0x0178,
  "Ydieresissmall",
  0xf7ff,
  "Ydotaccent",
  0x1e8e,
  "Ydotbelow",
  0x1ef4,
  "Yericyrillic",
  0x042b,
  "Yerudieresiscyrillic",
  0x04f8,
  "Ygrave",
  0x1ef2,
  "Yhook",
  0x01b3,
  "Yhookabove",
  0x1ef6,
  "Yiarmenian",
  0x0545,
  "Yicyrillic",
  0x0407,
  "Yiwnarmenian",
  0x0552,
  "Ymonospace",
  0xff39,
  "Ysmall",
  0xf779,
  "Ytilde",
  0x1ef8,
  "Yusbigcyrillic",
  0x046a,
  "Yusbigiotifiedcyrillic",
  0x046c,
  "Yuslittlecyrillic",
  0x0466,
  "Yuslittleiotifiedcyrillic",
  0x0468,
  "Z",
  0x005a,
  "Zaarmenian",
  0x0536,
  "Zacute",
  0x0179,
  "Zcaron",
  0x017d,
  "Zcaronsmall",
  0xf6ff,
  "Zcircle",
  0x24cf,
  "Zcircumflex",
  0x1e90,
  "Zdot",
  0x017b,
  "Zdotaccent",
  0x017b,
  "Zdotbelow",
  0x1e92,
  "Zecyrillic",
  0x0417,
  "Zedescendercyrillic",
  0x0498,
  "Zedieresiscyrillic",
  0x04de,
  "Zeta",
  0x0396,
  "Zhearmenian",
  0x053a,
  "Zhebrevecyrillic",
  0x04c1,
  "Zhecyrillic",
  0x0416,
  "Zhedescendercyrillic",
  0x0496,
  "Zhedieresiscyrillic",
  0x04dc,
  "Zlinebelow",
  0x1e94,
  "Zmonospace",
  0xff3a,
  "Zsmall",
  0xf77a,
  "Zstroke",
  0x01b5,
  "a",
  0x0061,
  "aabengali",
  0x0986,
  "aacute",
  0x00e1,
  "aadeva",
  0x0906,
  "aagujarati",
  0x0a86,
  "aagurmukhi",
  0x0a06,
  "aamatragurmukhi",
  0x0a3e,
  "aarusquare",
  0x3303,
  "aavowelsignbengali",
  0x09be,
  "aavowelsigndeva",
  0x093e,
  "aavowelsigngujarati",
  0x0abe,
  "abbreviationmarkarmenian",
  0x055f,
  "abbreviationsigndeva",
  0x0970,
  "abengali",
  0x0985,
  "abopomofo",
  0x311a,
  "abreve",
  0x0103,
  "abreveacute",
  0x1eaf,
  "abrevecyrillic",
  0x04d1,
  "abrevedotbelow",
  0x1eb7,
  "abrevegrave",
  0x1eb1,
  "abrevehookabove",
  0x1eb3,
  "abrevetilde",
  0x1eb5,
  "acaron",
  0x01ce,
  "acircle",
  0x24d0,
  "acircumflex",
  0x00e2,
  "acircumflexacute",
  0x1ea5,
  "acircumflexdotbelow",
  0x1ead,
  "acircumflexgrave",
  0x1ea7,
  "acircumflexhookabove",
  0x1ea9,
  "acircumflextilde",
  0x1eab,
  "acute",
  0x00b4,
  "acutebelowcmb",
  0x0317,
  "acutecmb",
  0x0301,
  "acutecomb",
  0x0301,
  "acutedeva",
  0x0954,
  "acutelowmod",
  0x02cf,
  "acutetonecmb",
  0x0341,
  "acyrillic",
  0x0430,
  "adblgrave",
  0x0201,
  "addakgurmukhi",
  0x0a71,
  "adeva",
  0x0905,
  "adieresis",
  0x00e4,
  "adieresiscyrillic",
  0x04d3,
  "adieresismacron",
  0x01df,
  "adotbelow",
  0x1ea1,
  "adotmacron",
  0x01e1,
  "ae",
  0x00e6,
  "aeacute",
  0x01fd,
  "aekorean",
  0x3150,
  "aemacron",
  0x01e3,
  "afii00208",
  0x2015,
  "afii08941",
  0x20a4,
  "afii10017",
  0x0410,
  "afii10018",
  0x0411,
  "afii10019",
  0x0412,
  "afii10020",
  0x0413,
  "afii10021",
  0x0414,
  "afii10022",
  0x0415,
  "afii10023",
  0x0401,
  "afii10024",
  0x0416,
  "afii10025",
  0x0417,
  "afii10026",
  0x0418,
  "afii10027",
  0x0419,
  "afii10028",
  0x041a,
  "afii10029",
  0x041b,
  "afii10030",
  0x041c,
  "afii10031",
  0x041d,
  "afii10032",
  0x041e,
  "afii10033",
  0x041f,
  "afii10034",
  0x0420,
  "afii10035",
  0x0421,
  "afii10036",
  0x0422,
  "afii10037",
  0x0423,
  "afii10038",
  0x0424,
  "afii10039",
  0x0425,
  "afii10040",
  0x0426,
  "afii10041",
  0x0427,
  "afii10042",
  0x0428,
  "afii10043",
  0x0429,
  "afii10044",
  0x042a,
  "afii10045",
  0x042b,
  "afii10046",
  0x042c,
  "afii10047",
  0x042d,
  "afii10048",
  0x042e,
  "afii10049",
  0x042f,
  "afii10050",
  0x0490,
  "afii10051",
  0x0402,
  "afii10052",
  0x0403,
  "afii10053",
  0x0404,
  "afii10054",
  0x0405,
  "afii10055",
  0x0406,
  "afii10056",
  0x0407,
  "afii10057",
  0x0408,
  "afii10058",
  0x0409,
  "afii10059",
  0x040a,
  "afii10060",
  0x040b,
  "afii10061",
  0x040c,
  "afii10062",
  0x040e,
  "afii10063",
  0xf6c4,
  "afii10064",
  0xf6c5,
  "afii10065",
  0x0430,
  "afii10066",
  0x0431,
  "afii10067",
  0x0432,
  "afii10068",
  0x0433,
  "afii10069",
  0x0434,
  "afii10070",
  0x0435,
  "afii10071",
  0x0451,
  "afii10072",
  0x0436,
  "afii10073",
  0x0437,
  "afii10074",
  0x0438,
  "afii10075",
  0x0439,
  "afii10076",
  0x043a,
  "afii10077",
  0x043b,
  "afii10078",
  0x043c,
  "afii10079",
  0x043d,
  "afii10080",
  0x043e,
  "afii10081",
  0x043f,
  "afii10082",
  0x0440,
  "afii10083",
  0x0441,
  "afii10084",
  0x0442,
  "afii10085",
  0x0443,
  "afii10086",
  0x0444,
  "afii10087",
  0x0445,
  "afii10088",
  0x0446,
  "afii10089",
  0x0447,
  "afii10090",
  0x0448,
  "afii10091",
  0x0449,
  "afii10092",
  0x044a,
  "afii10093",
  0x044b,
  "afii10094",
  0x044c,
  "afii10095",
  0x044d,
  "afii10096",
  0x044e,
  "afii10097",
  0x044f,
  "afii10098",
  0x0491,
  "afii10099",
  0x0452,
  "afii10100",
  0x0453,
  "afii10101",
  0x0454,
  "afii10102",
  0x0455,
  "afii10103",
  0x0456,
  "afii10104",
  0x0457,
  "afii10105",
  0x0458,
  "afii10106",
  0x0459,
  "afii10107",
  0x045a,
  "afii10108",
  0x045b,
  "afii10109",
  0x045c,
  "afii10110",
  0x045e,
  "afii10145",
  0x040f,
  "afii10146",
  0x0462,
  "afii10147",
  0x0472,
  "afii10148",
  0x0474,
  "afii10192",
  0xf6c6,
  "afii10193",
  0x045f,
  "afii10194",
  0x0463,
  "afii10195",
  0x0473,
  "afii10196",
  0x0475,
  "afii10831",
  0xf6c7,
  "afii10832",
  0xf6c8,
  "afii10846",
  0x04d9,
  "afii299",
  0x200e,
  "afii300",
  0x200f,
  "afii301",
  0x200d,
  "afii57381",
  0x066a,
  "afii57388",
  0x060c,
  "afii57392",
  0x0660,
  "afii57393",
  0x0661,
  "afii57394",
  0x0662,
  "afii57395",
  0x0663,
  "afii57396",
  0x0664,
  "afii57397",
  0x0665,
  "afii57398",
  0x0666,
  "afii57399",
  0x0667,
  "afii57400",
  0x0668,
  "afii57401",
  0x0669,
  "afii57403",
  0x061b,
  "afii57407",
  0x061f,
  "afii57409",
  0x0621,
  "afii57410",
  0x0622,
  "afii57411",
  0x0623,
  "afii57412",
  0x0624,
  "afii57413",
  0x0625,
  "afii57414",
  0x0626,
  "afii57415",
  0x0627,
  "afii57416",
  0x0628,
  "afii57417",
  0x0629,
  "afii57418",
  0x062a,
  "afii57419",
  0x062b,
  "afii57420",
  0x062c,
  "afii57421",
  0x062d,
  "afii57422",
  0x062e,
  "afii57423",
  0x062f,
  "afii57424",
  0x0630,
  "afii57425",
  0x0631,
  "afii57426",
  0x0632,
  "afii57427",
  0x0633,
  "afii57428",
  0x0634,
  "afii57429",
  0x0635,
  "afii57430",
  0x0636,
  "afii57431",
  0x0637,
  "afii57432",
  0x0638,
  "afii57433",
  0x0639,
  "afii57434",
  0x063a,
  "afii57440",
  0x0640,
  "afii57441",
  0x0641,
  "afii57442",
  0x0642,
  "afii57443",
  0x0643,
  "afii57444",
  0x0644,
  "afii57445",
  0x0645,
  "afii57446",
  0x0646,
  "afii57448",
  0x0648,
  "afii57449",
  0x0649,
  "afii57450",
  0x064a,
  "afii57451",
  0x064b,
  "afii57452",
  0x064c,
  "afii57453",
  0x064d,
  "afii57454",
  0x064e,
  "afii57455",
  0x064f,
  "afii57456",
  0x0650,
  "afii57457",
  0x0651,
  "afii57458",
  0x0652,
  "afii57470",
  0x0647,
  "afii57505",
  0x06a4,
  "afii57506",
  0x067e,
  "afii57507",
  0x0686,
  "afii57508",
  0x0698,
  "afii57509",
  0x06af,
  "afii57511",
  0x0679,
  "afii57512",
  0x0688,
  "afii57513",
  0x0691,
  "afii57514",
  0x06ba,
  "afii57519",
  0x06d2,
  "afii57534",
  0x06d5,
  "afii57636",
  0x20aa,
  "afii57645",
  0x05be,
  "afii57658",
  0x05c3,
  "afii57664",
  0x05d0,
  "afii57665",
  0x05d1,
  "afii57666",
  0x05d2,
  "afii57667",
  0x05d3,
  "afii57668",
  0x05d4,
  "afii57669",
  0x05d5,
  "afii57670",
  0x05d6,
  "afii57671",
  0x05d7,
  "afii57672",
  0x05d8,
  "afii57673",
  0x05d9,
  "afii57674",
  0x05da,
  "afii57675",
  0x05db,
  "afii57676",
  0x05dc,
  "afii57677",
  0x05dd,
  "afii57678",
  0x05de,
  "afii57679",
  0x05df,
  "afii57680",
  0x05e0,
  "afii57681",
  0x05e1,
  "afii57682",
  0x05e2,
  "afii57683",
  0x05e3,
  "afii57684",
  0x05e4,
  "afii57685",
  0x05e5,
  "afii57686",
  0x05e6,
  "afii57687",
  0x05e7,
  "afii57688",
  0x05e8,
  "afii57689",
  0x05e9,
  "afii57690",
  0x05ea,
  "afii57694",
  0xfb2a,
  "afii57695",
  0xfb2b,
  "afii57700",
  0xfb4b,
  "afii57705",
  0xfb1f,
  "afii57716",
  0x05f0,
  "afii57717",
  0x05f1,
  "afii57718",
  0x05f2,
  "afii57723",
  0xfb35,
  "afii57793",
  0x05b4,
  "afii57794",
  0x05b5,
  "afii57795",
  0x05b6,
  "afii57796",
  0x05bb,
  "afii57797",
  0x05b8,
  "afii57798",
  0x05b7,
  "afii57799",
  0x05b0,
  "afii57800",
  0x05b2,
  "afii57801",
  0x05b1,
  "afii57802",
  0x05b3,
  "afii57803",
  0x05c2,
  "afii57804",
  0x05c1,
  "afii57806",
  0x05b9,
  "afii57807",
  0x05bc,
  "afii57839",
  0x05bd,
  "afii57841",
  0x05bf,
  "afii57842",
  0x05c0,
  "afii57929",
  0x02bc,
  "afii61248",
  0x2105,
  "afii61289",
  0x2113,
  "afii61352",
  0x2116,
  "afii61573",
  0x202c,
  "afii61574",
  0x202d,
  "afii61575",
  0x202e,
  "afii61664",
  0x200c,
  "afii63167",
  0x066d,
  "afii64937",
  0x02bd,
  "agrave",
  0x00e0,
  "agujarati",
  0x0a85,
  "agurmukhi",
  0x0a05,
  "ahiragana",
  0x3042,
  "ahookabove",
  0x1ea3,
  "aibengali",
  0x0990,
  "aibopomofo",
  0x311e,
  "aideva",
  0x0910,
  "aiecyrillic",
  0x04d5,
  "aigujarati",
  0x0a90,
  "aigurmukhi",
  0x0a10,
  "aimatragurmukhi",
  0x0a48,
  "ainarabic",
  0x0639,
  "ainfinalarabic",
  0xfeca,
  "aininitialarabic",
  0xfecb,
  "ainmedialarabic",
  0xfecc,
  "ainvertedbreve",
  0x0203,
  "aivowelsignbengali",
  0x09c8,
  "aivowelsigndeva",
  0x0948,
  "aivowelsigngujarati",
  0x0ac8,
  "akatakana",
  0x30a2,
  "akatakanahalfwidth",
  0xff71,
  "akorean",
  0x314f,
  "alef",
  0x05d0,
  "alefarabic",
  0x0627,
  "alefdageshhebrew",
  0xfb30,
  "aleffinalarabic",
  0xfe8e,
  "alefhamzaabovearabic",
  0x0623,
  "alefhamzaabovefinalarabic",
  0xfe84,
  "alefhamzabelowarabic",
  0x0625,
  "alefhamzabelowfinalarabic",
  0xfe88,
  "alefhebrew",
  0x05d0,
  "aleflamedhebrew",
  0xfb4f,
  "alefmaddaabovearabic",
  0x0622,
  "alefmaddaabovefinalarabic",
  0xfe82,
  "alefmaksuraarabic",
  0x0649,
  "alefmaksurafinalarabic",
  0xfef0,
  "alefmaksurainitialarabic",
  0xfef3,
  "alefmaksuramedialarabic",
  0xfef4,
  "alefpatahhebrew",
  0xfb2e,
  "alefqamatshebrew",
  0xfb2f,
  "aleph",
  0x2135,
  "allequal",
  0x224c,
  "alpha",
  0x03b1,
  "alphatonos",
  0x03ac,
  "amacron",
  0x0101,
  "amonospace",
  0xff41,
  "ampersand",
  0x0026,
  "ampersandmonospace",
  0xff06,
  "ampersandsmall",
  0xf726,
  "amsquare",
  0x33c2,
  "anbopomofo",
  0x3122,
  "angbopomofo",
  0x3124,
  "angbracketleft",
  0x3008,
  "angbracketright",
  0x3009,
  "angkhankhuthai",
  0x0e5a,
  "angle",
  0x2220,
  "anglebracketleft",
  0x3008,
  "anglebracketleftvertical",
  0xfe3f,
  "anglebracketright",
  0x3009,
  "anglebracketrightvertical",
  0xfe40,
  "angleleft",
  0x2329,
  "angleright",
  0x232a,
  "angstrom",
  0x212b,
  "anoteleia",
  0x0387,
  "anudattadeva",
  0x0952,
  "anusvarabengali",
  0x0982,
  "anusvaradeva",
  0x0902,
  "anusvaragujarati",
  0x0a82,
  "aogonek",
  0x0105,
  "apaatosquare",
  0x3300,
  "aparen",
  0x249c,
  "apostrophearmenian",
  0x055a,
  "apostrophemod",
  0x02bc,
  "apple",
  0xf8ff,
  "approaches",
  0x2250,
  "approxequal",
  0x2248,
  "approxequalorimage",
  0x2252,
  "approximatelyequal",
  0x2245,
  "araeaekorean",
  0x318e,
  "araeakorean",
  0x318d,
  "arc",
  0x2312,
  "arighthalfring",
  0x1e9a,
  "aring",
  0x00e5,
  "aringacute",
  0x01fb,
  "aringbelow",
  0x1e01,
  "arrowboth",
  0x2194,
  "arrowdashdown",
  0x21e3,
  "arrowdashleft",
  0x21e0,
  "arrowdashright",
  0x21e2,
  "arrowdashup",
  0x21e1,
  "arrowdblboth",
  0x21d4,
  "arrowdbldown",
  0x21d3,
  "arrowdblleft",
  0x21d0,
  "arrowdblright",
  0x21d2,
  "arrowdblup",
  0x21d1,
  "arrowdown",
  0x2193,
  "arrowdownleft",
  0x2199,
  "arrowdownright",
  0x2198,
  "arrowdownwhite",
  0x21e9,
  "arrowheaddownmod",
  0x02c5,
  "arrowheadleftmod",
  0x02c2,
  "arrowheadrightmod",
  0x02c3,
  "arrowheadupmod",
  0x02c4,
  "arrowhorizex",
  0xf8e7,
  "arrowleft",
  0x2190,
  "arrowleftdbl",
  0x21d0,
  "arrowleftdblstroke",
  0x21cd,
  "arrowleftoverright",
  0x21c6,
  "arrowleftwhite",
  0x21e6,
  "arrowright",
  0x2192,
  "arrowrightdblstroke",
  0x21cf,
  "arrowrightheavy",
  0x279e,
  "arrowrightoverleft",
  0x21c4,
  "arrowrightwhite",
  0x21e8,
  "arrowtableft",
  0x21e4,
  "arrowtabright",
  0x21e5,
  "arrowup",
  0x2191,
  "arrowupdn",
  0x2195,
  "arrowupdnbse",
  0x21a8,
  "arrowupdownbase",
  0x21a8,
  "arrowupleft",
  0x2196,
  "arrowupleftofdown",
  0x21c5,
  "arrowupright",
  0x2197,
  "arrowupwhite",
  0x21e7,
  "arrowvertex",
  0xf8e6,
  "asciicircum",
  0x005e,
  "asciicircummonospace",
  0xff3e,
  "asciitilde",
  0x007e,
  "asciitildemonospace",
  0xff5e,
  "ascript",
  0x0251,
  "ascriptturned",
  0x0252,
  "asmallhiragana",
  0x3041,
  "asmallkatakana",
  0x30a1,
  "asmallkatakanahalfwidth",
  0xff67,
  "asterisk",
  0x002a,
  "asteriskaltonearabic",
  0x066d,
  "asteriskarabic",
  0x066d,
  "asteriskmath",
  0x2217,
  "asteriskmonospace",
  0xff0a,
  "asterisksmall",
  0xfe61,
  "asterism",
  0x2042,
  "asuperior",
  0xf6e9,
  "asymptoticallyequal",
  0x2243,
  "at",
  0x0040,
  "atilde",
  0x00e3,
  "atmonospace",
  0xff20,
  "atsmall",
  0xfe6b,
  "aturned",
  0x0250,
  "aubengali",
  0x0994,
  "aubopomofo",
  0x3120,
  "audeva",
  0x0914,
  "augujarati",
  0x0a94,
  "augurmukhi",
  0x0a14,
  "aulengthmarkbengali",
  0x09d7,
  "aumatragurmukhi",
  0x0a4c,
  "auvowelsignbengali",
  0x09cc,
  "auvowelsigndeva",
  0x094c,
  "auvowelsigngujarati",
  0x0acc,
  "avagrahadeva",
  0x093d,
  "aybarmenian",
  0x0561,
  "ayin",
  0x05e2,
  "ayinaltonehebrew",
  0xfb20,
  "ayinhebrew",
  0x05e2,
  "b",
  0x0062,
  "babengali",
  0x09ac,
  "backslash",
  0x005c,
  "backslashmonospace",
  0xff3c,
  "badeva",
  0x092c,
  "bagujarati",
  0x0aac,
  "bagurmukhi",
  0x0a2c,
  "bahiragana",
  0x3070,
  "bahtthai",
  0x0e3f,
  "bakatakana",
  0x30d0,
  "bar",
  0x007c,
  "barmonospace",
  0xff5c,
  "bbopomofo",
  0x3105,
  "bcircle",
  0x24d1,
  "bdotaccent",
  0x1e03,
  "bdotbelow",
  0x1e05,
  "beamedsixteenthnotes",
  0x266c,
  "because",
  0x2235,
  "becyrillic",
  0x0431,
  "beharabic",
  0x0628,
  "behfinalarabic",
  0xfe90,
  "behinitialarabic",
  0xfe91,
  "behiragana",
  0x3079,
  "behmedialarabic",
  0xfe92,
  "behmeeminitialarabic",
  0xfc9f,
  "behmeemisolatedarabic",
  0xfc08,
  "behnoonfinalarabic",
  0xfc6d,
  "bekatakana",
  0x30d9,
  "benarmenian",
  0x0562,
  "bet",
  0x05d1,
  "beta",
  0x03b2,
  "betasymbolgreek",
  0x03d0,
  "betdagesh",
  0xfb31,
  "betdageshhebrew",
  0xfb31,
  "bethebrew",
  0x05d1,
  "betrafehebrew",
  0xfb4c,
  "bhabengali",
  0x09ad,
  "bhadeva",
  0x092d,
  "bhagujarati",
  0x0aad,
  "bhagurmukhi",
  0x0a2d,
  "bhook",
  0x0253,
  "bihiragana",
  0x3073,
  "bikatakana",
  0x30d3,
  "bilabialclick",
  0x0298,
  "bindigurmukhi",
  0x0a02,
  "birusquare",
  0x3331,
  "blackcircle",
  0x25cf,
  "blackdiamond",
  0x25c6,
  "blackdownpointingtriangle",
  0x25bc,
  "blackleftpointingpointer",
  0x25c4,
  "blackleftpointingtriangle",
  0x25c0,
  "blacklenticularbracketleft",
  0x3010,
  "blacklenticularbracketleftvertical",
  0xfe3b,
  "blacklenticularbracketright",
  0x3011,
  "blacklenticularbracketrightvertical",
  0xfe3c,
  "blacklowerlefttriangle",
  0x25e3,
  "blacklowerrighttriangle",
  0x25e2,
  "blackrectangle",
  0x25ac,
  "blackrightpointingpointer",
  0x25ba,
  "blackrightpointingtriangle",
  0x25b6,
  "blacksmallsquare",
  0x25aa,
  "blacksmilingface",
  0x263b,
  "blacksquare",
  0x25a0,
  "blackstar",
  0x2605,
  "blackupperlefttriangle",
  0x25e4,
  "blackupperrighttriangle",
  0x25e5,
  "blackuppointingsmalltriangle",
  0x25b4,
  "blackuppointingtriangle",
  0x25b2,
  "blank",
  0x2423,
  "blinebelow",
  0x1e07,
  "block",
  0x2588,
  "bmonospace",
  0xff42,
  "bobaimaithai",
  0x0e1a,
  "bohiragana",
  0x307c,
  "bokatakana",
  0x30dc,
  "bparen",
  0x249d,
  "bqsquare",
  0x33c3,
  "braceex",
  0xf8f4,
  "braceleft",
  0x007b,
  "braceleftbt",
  0xf8f3,
  "braceleftmid",
  0xf8f2,
  "braceleftmonospace",
  0xff5b,
  "braceleftsmall",
  0xfe5b,
  "bracelefttp",
  0xf8f1,
  "braceleftvertical",
  0xfe37,
  "braceright",
  0x007d,
  "bracerightbt",
  0xf8fe,
  "bracerightmid",
  0xf8fd,
  "bracerightmonospace",
  0xff5d,
  "bracerightsmall",
  0xfe5c,
  "bracerighttp",
  0xf8fc,
  "bracerightvertical",
  0xfe38,
  "bracketleft",
  0x005b,
  "bracketleftbt",
  0xf8f0,
  "bracketleftex",
  0xf8ef,
  "bracketleftmonospace",
  0xff3b,
  "bracketlefttp",
  0xf8ee,
  "bracketright",
  0x005d,
  "bracketrightbt",
  0xf8fb,
  "bracketrightex",
  0xf8fa,
  "bracketrightmonospace",
  0xff3d,
  "bracketrighttp",
  0xf8f9,
  "breve",
  0x02d8,
  "brevebelowcmb",
  0x032e,
  "brevecmb",
  0x0306,
  "breveinvertedbelowcmb",
  0x032f,
  "breveinvertedcmb",
  0x0311,
  "breveinverteddoublecmb",
  0x0361,
  "bridgebelowcmb",
  0x032a,
  "bridgeinvertedbelowcmb",
  0x033a,
  "brokenbar",
  0x00a6,
  "bstroke",
  0x0180,
  "bsuperior",
  0xf6ea,
  "btopbar",
  0x0183,
  "buhiragana",
  0x3076,
  "bukatakana",
  0x30d6,
  "bullet",
  0x2022,
  "bulletinverse",
  0x25d8,
  "bulletoperator",
  0x2219,
  "bullseye",
  0x25ce,
  "c",
  0x0063,
  "caarmenian",
  0x056e,
  "cabengali",
  0x099a,
  "cacute",
  0x0107,
  "cadeva",
  0x091a,
  "cagujarati",
  0x0a9a,
  "cagurmukhi",
  0x0a1a,
  "calsquare",
  0x3388,
  "candrabindubengali",
  0x0981,
  "candrabinducmb",
  0x0310,
  "candrabindudeva",
  0x0901,
  "candrabindugujarati",
  0x0a81,
  "capslock",
  0x21ea,
  "careof",
  0x2105,
  "caron",
  0x02c7,
  "caronbelowcmb",
  0x032c,
  "caroncmb",
  0x030c,
  "carriagereturn",
  0x21b5,
  "cbopomofo",
  0x3118,
  "ccaron",
  0x010d,
  "ccedilla",
  0x00e7,
  "ccedillaacute",
  0x1e09,
  "ccircle",
  0x24d2,
  "ccircumflex",
  0x0109,
  "ccurl",
  0x0255,
  "cdot",
  0x010b,
  "cdotaccent",
  0x010b,
  "cdsquare",
  0x33c5,
  "cedilla",
  0x00b8,
  "cedillacmb",
  0x0327,
  "cent",
  0x00a2,
  "centigrade",
  0x2103,
  "centinferior",
  0xf6df,
  "centmonospace",
  0xffe0,
  "centoldstyle",
  0xf7a2,
  "centsuperior",
  0xf6e0,
  "chaarmenian",
  0x0579,
  "chabengali",
  0x099b,
  "chadeva",
  0x091b,
  "chagujarati",
  0x0a9b,
  "chagurmukhi",
  0x0a1b,
  "chbopomofo",
  0x3114,
  "cheabkhasiancyrillic",
  0x04bd,
  "checkmark",
  0x2713,
  "checyrillic",
  0x0447,
  "chedescenderabkhasiancyrillic",
  0x04bf,
  "chedescendercyrillic",
  0x04b7,
  "chedieresiscyrillic",
  0x04f5,
  "cheharmenian",
  0x0573,
  "chekhakassiancyrillic",
  0x04cc,
  "cheverticalstrokecyrillic",
  0x04b9,
  "chi",
  0x03c7,
  "chieuchacirclekorean",
  0x3277,
  "chieuchaparenkorean",
  0x3217,
  "chieuchcirclekorean",
  0x3269,
  "chieuchkorean",
  0x314a,
  "chieuchparenkorean",
  0x3209,
  "chochangthai",
  0x0e0a,
  "chochanthai",
  0x0e08,
  "chochingthai",
  0x0e09,
  "chochoethai",
  0x0e0c,
  "chook",
  0x0188,
  "cieucacirclekorean",
  0x3276,
  "cieucaparenkorean",
  0x3216,
  "cieuccirclekorean",
  0x3268,
  "cieuckorean",
  0x3148,
  "cieucparenkorean",
  0x3208,
  "cieucuparenkorean",
  0x321c,
  "circle",
  0x25cb,
  "circlecopyrt",
  0x00a9,
  "circlemultiply",
  0x2297,
  "circleot",
  0x2299,
  "circleplus",
  0x2295,
  "circlepostalmark",
  0x3036,
  "circlewithlefthalfblack",
  0x25d0,
  "circlewithrighthalfblack",
  0x25d1,
  "circumflex",
  0x02c6,
  "circumflexbelowcmb",
  0x032d,
  "circumflexcmb",
  0x0302,
  "clear",
  0x2327,
  "clickalveolar",
  0x01c2,
  "clickdental",
  0x01c0,
  "clicklateral",
  0x01c1,
  "clickretroflex",
  0x01c3,
  "club",
  0x2663,
  "clubsuitblack",
  0x2663,
  "clubsuitwhite",
  0x2667,
  "cmcubedsquare",
  0x33a4,
  "cmonospace",
  0xff43,
  "cmsquaredsquare",
  0x33a0,
  "coarmenian",
  0x0581,
  "colon",
  0x003a,
  "colonmonetary",
  0x20a1,
  "colonmonospace",
  0xff1a,
  "colonsign",
  0x20a1,
  "colonsmall",
  0xfe55,
  "colontriangularhalfmod",
  0x02d1,
  "colontriangularmod",
  0x02d0,
  "comma",
  0x002c,
  "commaabovecmb",
  0x0313,
  "commaaboverightcmb",
  0x0315,
  "commaaccent",
  0xf6c3,
  "commaarabic",
  0x060c,
  "commaarmenian",
  0x055d,
  "commainferior",
  0xf6e1,
  "commamonospace",
  0xff0c,
  "commareversedabovecmb",
  0x0314,
  "commareversedmod",
  0x02bd,
  "commasmall",
  0xfe50,
  "commasuperior",
  0xf6e2,
  "commaturnedabovecmb",
  0x0312,
  "commaturnedmod",
  0x02bb,
  "compass",
  0x263c,
  "congruent",
  0x2245,
  "contourintegral",
  0x222e,
  "control",
  0x2303,
  "controlACK",
  0x0006,
  "controlBEL",
  0x0007,
  "controlBS",
  0x0008,
  "controlCAN",
  0x0018,
  "controlCR",
  0x000d,
  "controlDC1",
  0x0011,
  "controlDC2",
  0x0012,
  "controlDC3",
  0x0013,
  "controlDC4",
  0x0014,
  "controlDEL",
  0x007f,
  "controlDLE",
  0x0010,
  "controlEM",
  0x0019,
  "controlENQ",
  0x0005,
  "controlEOT",
  0x0004,
  "controlESC",
  0x001b,
  "controlETB",
  0x0017,
  "controlETX",
  0x0003,
  "controlFF",
  0x000c,
  "controlFS",
  0x001c,
  "controlGS",
  0x001d,
  "controlHT",
  0x0009,
  "controlLF",
  0x000a,
  "controlNAK",
  0x0015,
  "controlNULL",
  0x0000,
  "controlRS",
  0x001e,
  "controlSI",
  0x000f,
  "controlSO",
  0x000e,
  "controlSOT",
  0x0002,
  "controlSTX",
  0x0001,
  "controlSUB",
  0x001a,
  "controlSYN",
  0x0016,
  "controlUS",
  0x001f,
  "controlVT",
  0x000b,
  "copyright",
  0x00a9,
  "copyrightsans",
  0xf8e9,
  "copyrightserif",
  0xf6d9,
  "cornerbracketleft",
  0x300c,
  "cornerbracketlefthalfwidth",
  0xff62,
  "cornerbracketleftvertical",
  0xfe41,
  "cornerbracketright",
  0x300d,
  "cornerbracketrighthalfwidth",
  0xff63,
  "cornerbracketrightvertical",
  0xfe42,
  "corporationsquare",
  0x337f,
  "cosquare",
  0x33c7,
  "coverkgsquare",
  0x33c6,
  "cparen",
  0x249e,
  "cruzeiro",
  0x20a2,
  "cstretched",
  0x0297,
  "curlyand",
  0x22cf,
  "curlyor",
  0x22ce,
  "currency",
  0x00a4,
  "cyrBreve",
  0xf6d1,
  "cyrFlex",
  0xf6d2,
  "cyrbreve",
  0xf6d4,
  "cyrflex",
  0xf6d5,
  "d",
  0x0064,
  "daarmenian",
  0x0564,
  "dabengali",
  0x09a6,
  "dadarabic",
  0x0636,
  "dadeva",
  0x0926,
  "dadfinalarabic",
  0xfebe,
  "dadinitialarabic",
  0xfebf,
  "dadmedialarabic",
  0xfec0,
  "dagesh",
  0x05bc,
  "dageshhebrew",
  0x05bc,
  "dagger",
  0x2020,
  "daggerdbl",
  0x2021,
  "dagujarati",
  0x0aa6,
  "dagurmukhi",
  0x0a26,
  "dahiragana",
  0x3060,
  "dakatakana",
  0x30c0,
  "dalarabic",
  0x062f,
  "dalet",
  0x05d3,
  "daletdagesh",
  0xfb33,
  "daletdageshhebrew",
  0xfb33,
  "dalethebrew",
  0x05d3,
  "dalfinalarabic",
  0xfeaa,
  "dammaarabic",
  0x064f,
  "dammalowarabic",
  0x064f,
  "dammatanaltonearabic",
  0x064c,
  "dammatanarabic",
  0x064c,
  "danda",
  0x0964,
  "dargahebrew",
  0x05a7,
  "dargalefthebrew",
  0x05a7,
  "dasiapneumatacyrilliccmb",
  0x0485,
  "dblGrave",
  0xf6d3,
  "dblanglebracketleft",
  0x300a,
  "dblanglebracketleftvertical",
  0xfe3d,
  "dblanglebracketright",
  0x300b,
  "dblanglebracketrightvertical",
  0xfe3e,
  "dblarchinvertedbelowcmb",
  0x032b,
  "dblarrowleft",
  0x21d4,
  "dblarrowright",
  0x21d2,
  "dbldanda",
  0x0965,
  "dblgrave",
  0xf6d6,
  "dblgravecmb",
  0x030f,
  "dblintegral",
  0x222c,
  "dbllowline",
  0x2017,
  "dbllowlinecmb",
  0x0333,
  "dbloverlinecmb",
  0x033f,
  "dblprimemod",
  0x02ba,
  "dblverticalbar",
  0x2016,
  "dblverticallineabovecmb",
  0x030e,
  "dbopomofo",
  0x3109,
  "dbsquare",
  0x33c8,
  "dcaron",
  0x010f,
  "dcedilla",
  0x1e11,
  "dcircle",
  0x24d3,
  "dcircumflexbelow",
  0x1e13,
  "dcroat",
  0x0111,
  "ddabengali",
  0x09a1,
  "ddadeva",
  0x0921,
  "ddagujarati",
  0x0aa1,
  "ddagurmukhi",
  0x0a21,
  "ddalarabic",
  0x0688,
  "ddalfinalarabic",
  0xfb89,
  "dddhadeva",
  0x095c,
  "ddhabengali",
  0x09a2,
  "ddhadeva",
  0x0922,
  "ddhagujarati",
  0x0aa2,
  "ddhagurmukhi",
  0x0a22,
  "ddotaccent",
  0x1e0b,
  "ddotbelow",
  0x1e0d,
  "decimalseparatorarabic",
  0x066b,
  "decimalseparatorpersian",
  0x066b,
  "decyrillic",
  0x0434,
  "degree",
  0x00b0,
  "dehihebrew",
  0x05ad,
  "dehiragana",
  0x3067,
  "deicoptic",
  0x03ef,
  "dekatakana",
  0x30c7,
  "deleteleft",
  0x232b,
  "deleteright",
  0x2326,
  "delta",
  0x03b4,
  "deltaturned",
  0x018d,
  "denominatorminusonenumeratorbengali",
  0x09f8,
  "dezh",
  0x02a4,
  "dhabengali",
  0x09a7,
  "dhadeva",
  0x0927,
  "dhagujarati",
  0x0aa7,
  "dhagurmukhi",
  0x0a27,
  "dhook",
  0x0257,
  "dialytikatonos",
  0x0385,
  "dialytikatonoscmb",
  0x0344,
  "diamond",
  0x2666,
  "diamondsuitwhite",
  0x2662,
  "dieresis",
  0x00a8,
  "dieresisacute",
  0xf6d7,
  "dieresisbelowcmb",
  0x0324,
  "dieresiscmb",
  0x0308,
  "dieresisgrave",
  0xf6d8,
  "dieresistonos",
  0x0385,
  "dihiragana",
  0x3062,
  "dikatakana",
  0x30c2,
  "dittomark",
  0x3003,
  "divide",
  0x00f7,
  "divides",
  0x2223,
  "divisionslash",
  0x2215,
  "djecyrillic",
  0x0452,
  "dkshade",
  0x2593,
  "dlinebelow",
  0x1e0f,
  "dlsquare",
  0x3397,
  "dmacron",
  0x0111,
  "dmonospace",
  0xff44,
  "dnblock",
  0x2584,
  "dochadathai",
  0x0e0e,
  "dodekthai",
  0x0e14,
  "dohiragana",
  0x3069,
  "dokatakana",
  0x30c9,
  "dollar",
  0x0024,
  "dollarinferior",
  0xf6e3,
  "dollarmonospace",
  0xff04,
  "dollaroldstyle",
  0xf724,
  "dollarsmall",
  0xfe69,
  "dollarsuperior",
  0xf6e4,
  "dong",
  0x20ab,
  "dorusquare",
  0x3326,
  "dotaccent",
  0x02d9,
  "dotaccentcmb",
  0x0307,
  "dotbelowcmb",
  0x0323,
  "dotbelowcomb",
  0x0323,
  "dotkatakana",
  0x30fb,
  "dotlessi",
  0x0131,
  "dotlessj",
  0xf6be,
  "dotlessjstrokehook",
  0x0284,
  "dotmath",
  0x22c5,
  "dottedcircle",
  0x25cc,
  "doubleyodpatah",
  0xfb1f,
  "doubleyodpatahhebrew",
  0xfb1f,
  "downtackbelowcmb",
  0x031e,
  "downtackmod",
  0x02d5,
  "dparen",
  0x249f,
  "dsuperior",
  0xf6eb,
  "dtail",
  0x0256,
  "dtopbar",
  0x018c,
  "duhiragana",
  0x3065,
  "dukatakana",
  0x30c5,
  "dz",
  0x01f3,
  "dzaltone",
  0x02a3,
  "dzcaron",
  0x01c6,
  "dzcurl",
  0x02a5,
  "dzeabkhasiancyrillic",
  0x04e1,
  "dzecyrillic",
  0x0455,
  "dzhecyrillic",
  0x045f,
  "e",
  0x0065,
  "eacute",
  0x00e9,
  "earth",
  0x2641,
  "ebengali",
  0x098f,
  "ebopomofo",
  0x311c,
  "ebreve",
  0x0115,
  "ecandradeva",
  0x090d,
  "ecandragujarati",
  0x0a8d,
  "ecandravowelsigndeva",
  0x0945,
  "ecandravowelsigngujarati",
  0x0ac5,
  "ecaron",
  0x011b,
  "ecedillabreve",
  0x1e1d,
  "echarmenian",
  0x0565,
  "echyiwnarmenian",
  0x0587,
  "ecircle",
  0x24d4,
  "ecircumflex",
  0x00ea,
  "ecircumflexacute",
  0x1ebf,
  "ecircumflexbelow",
  0x1e19,
  "ecircumflexdotbelow",
  0x1ec7,
  "ecircumflexgrave",
  0x1ec1,
  "ecircumflexhookabove",
  0x1ec3,
  "ecircumflextilde",
  0x1ec5,
  "ecyrillic",
  0x0454,
  "edblgrave",
  0x0205,
  "edeva",
  0x090f,
  "edieresis",
  0x00eb,
  "edot",
  0x0117,
  "edotaccent",
  0x0117,
  "edotbelow",
  0x1eb9,
  "eegurmukhi",
  0x0a0f,
  "eematragurmukhi",
  0x0a47,
  "efcyrillic",
  0x0444,
  "egrave",
  0x00e8,
  "egujarati",
  0x0a8f,
  "eharmenian",
  0x0567,
  "ehbopomofo",
  0x311d,
  "ehiragana",
  0x3048,
  "ehookabove",
  0x1ebb,
  "eibopomofo",
  0x311f,
  "eight",
  0x0038,
  "eightarabic",
  0x0668,
  "eightbengali",
  0x09ee,
  "eightcircle",
  0x2467,
  "eightcircleinversesansserif",
  0x2791,
  "eightdeva",
  0x096e,
  "eighteencircle",
  0x2471,
  "eighteenparen",
  0x2485,
  "eighteenperiod",
  0x2499,
  "eightgujarati",
  0x0aee,
  "eightgurmukhi",
  0x0a6e,
  "eighthackarabic",
  0x0668,
  "eighthangzhou",
  0x3028,
  "eighthnotebeamed",
  0x266b,
  "eightideographicparen",
  0x3227,
  "eightinferior",
  0x2088,
  "eightmonospace",
  0xff18,
  "eightoldstyle",
  0xf738,
  "eightparen",
  0x247b,
  "eightperiod",
  0x248f,
  "eightpersian",
  0x06f8,
  "eightroman",
  0x2177,
  "eightsuperior",
  0x2078,
  "eightthai",
  0x0e58,
  "einvertedbreve",
  0x0207,
  "eiotifiedcyrillic",
  0x0465,
  "ekatakana",
  0x30a8,
  "ekatakanahalfwidth",
  0xff74,
  "ekonkargurmukhi",
  0x0a74,
  "ekorean",
  0x3154,
  "elcyrillic",
  0x043b,
  "element",
  0x2208,
  "elevencircle",
  0x246a,
  "elevenparen",
  0x247e,
  "elevenperiod",
  0x2492,
  "elevenroman",
  0x217a,
  "ellipsis",
  0x2026,
  "ellipsisvertical",
  0x22ee,
  "emacron",
  0x0113,
  "emacronacute",
  0x1e17,
  "emacrongrave",
  0x1e15,
  "emcyrillic",
  0x043c,
  "emdash",
  0x2014,
  "emdashvertical",
  0xfe31,
  "emonospace",
  0xff45,
  "emphasismarkarmenian",
  0x055b,
  "emptyset",
  0x2205,
  "enbopomofo",
  0x3123,
  "encyrillic",
  0x043d,
  "endash",
  0x2013,
  "endashvertical",
  0xfe32,
  "endescendercyrillic",
  0x04a3,
  "eng",
  0x014b,
  "engbopomofo",
  0x3125,
  "enghecyrillic",
  0x04a5,
  "enhookcyrillic",
  0x04c8,
  "enspace",
  0x2002,
  "eogonek",
  0x0119,
  "eokorean",
  0x3153,
  "eopen",
  0x025b,
  "eopenclosed",
  0x029a,
  "eopenreversed",
  0x025c,
  "eopenreversedclosed",
  0x025e,
  "eopenreversedhook",
  0x025d,
  "eparen",
  0x24a0,
  "epsilon",
  0x03b5,
  "epsilontonos",
  0x03ad,
  "equal",
  0x003d,
  "equalmonospace",
  0xff1d,
  "equalsmall",
  0xfe66,
  "equalsuperior",
  0x207c,
  "equivalence",
  0x2261,
  "erbopomofo",
  0x3126,
  "ercyrillic",
  0x0440,
  "ereversed",
  0x0258,
  "ereversedcyrillic",
  0x044d,
  "escyrillic",
  0x0441,
  "esdescendercyrillic",
  0x04ab,
  "esh",
  0x0283,
  "eshcurl",
  0x0286,
  "eshortdeva",
  0x090e,
  "eshortvowelsigndeva",
  0x0946,
  "eshreversedloop",
  0x01aa,
  "eshsquatreversed",
  0x0285,
  "esmallhiragana",
  0x3047,
  "esmallkatakana",
  0x30a7,
  "esmallkatakanahalfwidth",
  0xff6a,
  "estimated",
  0x212e,
  "esuperior",
  0xf6ec,
  "eta",
  0x03b7,
  "etarmenian",
  0x0568,
  "etatonos",
  0x03ae,
  "eth",
  0x00f0,
  "etilde",
  0x1ebd,
  "etildebelow",
  0x1e1b,
  "etnahtafoukhhebrew",
  0x0591,
  "etnahtafoukhlefthebrew",
  0x0591,
  "etnahtahebrew",
  0x0591,
  "etnahtalefthebrew",
  0x0591,
  "eturned",
  0x01dd,
  "eukorean",
  0x3161,
  "euro",
  0x20ac,
  "evowelsignbengali",
  0x09c7,
  "evowelsigndeva",
  0x0947,
  "evowelsigngujarati",
  0x0ac7,
  "exclam",
  0x0021,
  "exclamarmenian",
  0x055c,
  "exclamdbl",
  0x203c,
  "exclamdown",
  0x00a1,
  "exclamdownsmall",
  0xf7a1,
  "exclammonospace",
  0xff01,
  "exclamsmall",
  0xf721,
  "existential",
  0x2203,
  "ezh",
  0x0292,
  "ezhcaron",
  0x01ef,
  "ezhcurl",
  0x0293,
  "ezhreversed",
  0x01b9,
  "ezhtail",
  0x01ba,
  "f",
  0x0066,
  "fadeva",
  0x095e,
  "fagurmukhi",
  0x0a5e,
  "fahrenheit",
  0x2109,
  "fathaarabic",
  0x064e,
  "fathalowarabic",
  0x064e,
  "fathatanarabic",
  0x064b,
  "fbopomofo",
  0x3108,
  "fcircle",
  0x24d5,
  "fdotaccent",
  0x1e1f,
  "feharabic",
  0x0641,
  "feharmenian",
  0x0586,
  "fehfinalarabic",
  0xfed2,
  "fehinitialarabic",
  0xfed3,
  "fehmedialarabic",
  0xfed4,
  "feicoptic",
  0x03e5,
  "female",
  0x2640,
  "ff",
  0xfb00,
  "f_f",
  0xfb00,
  "ffi",
  0xfb03,
  "ffl",
  0xfb04,
  "fi",
  0xfb01,
  "fifteencircle",
  0x246e,
  "fifteenparen",
  0x2482,
  "fifteenperiod",
  0x2496,
  "figuredash",
  0x2012,
  "filledbox",
  0x25a0,
  "filledrect",
  0x25ac,
  "finalkaf",
  0x05da,
  "finalkafdagesh",
  0xfb3a,
  "finalkafdageshhebrew",
  0xfb3a,
  "finalkafhebrew",
  0x05da,
  "finalmem",
  0x05dd,
  "finalmemhebrew",
  0x05dd,
  "finalnun",
  0x05df,
  "finalnunhebrew",
  0x05df,
  "finalpe",
  0x05e3,
  "finalpehebrew",
  0x05e3,
  "finaltsadi",
  0x05e5,
  "finaltsadihebrew",
  0x05e5,
  "firsttonechinese",
  0x02c9,
  "fisheye",
  0x25c9,
  "fitacyrillic",
  0x0473,
  "five",
  0x0035,
  "fivearabic",
  0x0665,
  "fivebengali",
  0x09eb,
  "fivecircle",
  0x2464,
  "fivecircleinversesansserif",
  0x278e,
  "fivedeva",
  0x096b,
  "fiveeighths",
  0x215d,
  "fivegujarati",
  0x0aeb,
  "fivegurmukhi",
  0x0a6b,
  "fivehackarabic",
  0x0665,
  "fivehangzhou",
  0x3025,
  "fiveideographicparen",
  0x3224,
  "fiveinferior",
  0x2085,
  "fivemonospace",
  0xff15,
  "fiveoldstyle",
  0xf735,
  "fiveparen",
  0x2478,
  "fiveperiod",
  0x248c,
  "fivepersian",
  0x06f5,
  "fiveroman",
  0x2174,
  "fivesuperior",
  0x2075,
  "fivethai",
  0x0e55,
  "fl",
  0xfb02,
  "florin",
  0x0192,
  "fmonospace",
  0xff46,
  "fmsquare",
  0x3399,
  "fofanthai",
  0x0e1f,
  "fofathai",
  0x0e1d,
  "fongmanthai",
  0x0e4f,
  "forall",
  0x2200,
  "four",
  0x0034,
  "fourarabic",
  0x0664,
  "fourbengali",
  0x09ea,
  "fourcircle",
  0x2463,
  "fourcircleinversesansserif",
  0x278d,
  "fourdeva",
  0x096a,
  "fourgujarati",
  0x0aea,
  "fourgurmukhi",
  0x0a6a,
  "fourhackarabic",
  0x0664,
  "fourhangzhou",
  0x3024,
  "fourideographicparen",
  0x3223,
  "fourinferior",
  0x2084,
  "fourmonospace",
  0xff14,
  "fournumeratorbengali",
  0x09f7,
  "fouroldstyle",
  0xf734,
  "fourparen",
  0x2477,
  "fourperiod",
  0x248b,
  "fourpersian",
  0x06f4,
  "fourroman",
  0x2173,
  "foursuperior",
  0x2074,
  "fourteencircle",
  0x246d,
  "fourteenparen",
  0x2481,
  "fourteenperiod",
  0x2495,
  "fourthai",
  0x0e54,
  "fourthtonechinese",
  0x02cb,
  "fparen",
  0x24a1,
  "fraction",
  0x2044,
  "franc",
  0x20a3,
  "g",
  0x0067,
  "gabengali",
  0x0997,
  "gacute",
  0x01f5,
  "gadeva",
  0x0917,
  "gafarabic",
  0x06af,
  "gaffinalarabic",
  0xfb93,
  "gafinitialarabic",
  0xfb94,
  "gafmedialarabic",
  0xfb95,
  "gagujarati",
  0x0a97,
  "gagurmukhi",
  0x0a17,
  "gahiragana",
  0x304c,
  "gakatakana",
  0x30ac,
  "gamma",
  0x03b3,
  "gammalatinsmall",
  0x0263,
  "gammasuperior",
  0x02e0,
  "gangiacoptic",
  0x03eb,
  "gbopomofo",
  0x310d,
  "gbreve",
  0x011f,
  "gcaron",
  0x01e7,
  "gcedilla",
  0x0123,
  "gcircle",
  0x24d6,
  "gcircumflex",
  0x011d,
  "gcommaaccent",
  0x0123,
  "gdot",
  0x0121,
  "gdotaccent",
  0x0121,
  "gecyrillic",
  0x0433,
  "gehiragana",
  0x3052,
  "gekatakana",
  0x30b2,
  "geometricallyequal",
  0x2251,
  "gereshaccenthebrew",
  0x059c,
  "gereshhebrew",
  0x05f3,
  "gereshmuqdamhebrew",
  0x059d,
  "germandbls",
  0x00df,
  "gershayimaccenthebrew",
  0x059e,
  "gershayimhebrew",
  0x05f4,
  "getamark",
  0x3013,
  "ghabengali",
  0x0998,
  "ghadarmenian",
  0x0572,
  "ghadeva",
  0x0918,
  "ghagujarati",
  0x0a98,
  "ghagurmukhi",
  0x0a18,
  "ghainarabic",
  0x063a,
  "ghainfinalarabic",
  0xfece,
  "ghaininitialarabic",
  0xfecf,
  "ghainmedialarabic",
  0xfed0,
  "ghemiddlehookcyrillic",
  0x0495,
  "ghestrokecyrillic",
  0x0493,
  "gheupturncyrillic",
  0x0491,
  "ghhadeva",
  0x095a,
  "ghhagurmukhi",
  0x0a5a,
  "ghook",
  0x0260,
  "ghzsquare",
  0x3393,
  "gihiragana",
  0x304e,
  "gikatakana",
  0x30ae,
  "gimarmenian",
  0x0563,
  "gimel",
  0x05d2,
  "gimeldagesh",
  0xfb32,
  "gimeldageshhebrew",
  0xfb32,
  "gimelhebrew",
  0x05d2,
  "gjecyrillic",
  0x0453,
  "glottalinvertedstroke",
  0x01be,
  "glottalstop",
  0x0294,
  "glottalstopinverted",
  0x0296,
  "glottalstopmod",
  0x02c0,
  "glottalstopreversed",
  0x0295,
  "glottalstopreversedmod",
  0x02c1,
  "glottalstopreversedsuperior",
  0x02e4,
  "glottalstopstroke",
  0x02a1,
  "glottalstopstrokereversed",
  0x02a2,
  "gmacron",
  0x1e21,
  "gmonospace",
  0xff47,
  "gohiragana",
  0x3054,
  "gokatakana",
  0x30b4,
  "gparen",
  0x24a2,
  "gpasquare",
  0x33ac,
  "gradient",
  0x2207,
  "grave",
  0x0060,
  "gravebelowcmb",
  0x0316,
  "gravecmb",
  0x0300,
  "gravecomb",
  0x0300,
  "gravedeva",
  0x0953,
  "gravelowmod",
  0x02ce,
  "gravemonospace",
  0xff40,
  "gravetonecmb",
  0x0340,
  "greater",
  0x003e,
  "greaterequal",
  0x2265,
  "greaterequalorless",
  0x22db,
  "greatermonospace",
  0xff1e,
  "greaterorequivalent",
  0x2273,
  "greaterorless",
  0x2277,
  "greateroverequal",
  0x2267,
  "greatersmall",
  0xfe65,
  "gscript",
  0x0261,
  "gstroke",
  0x01e5,
  "guhiragana",
  0x3050,
  "guillemotleft",
  0x00ab,
  "guillemotright",
  0x00bb,
  "guilsinglleft",
  0x2039,
  "guilsinglright",
  0x203a,
  "gukatakana",
  0x30b0,
  "guramusquare",
  0x3318,
  "gysquare",
  0x33c9,
  "h",
  0x0068,
  "haabkhasiancyrillic",
  0x04a9,
  "haaltonearabic",
  0x06c1,
  "habengali",
  0x09b9,
  "hadescendercyrillic",
  0x04b3,
  "hadeva",
  0x0939,
  "hagujarati",
  0x0ab9,
  "hagurmukhi",
  0x0a39,
  "haharabic",
  0x062d,
  "hahfinalarabic",
  0xfea2,
  "hahinitialarabic",
  0xfea3,
  "hahiragana",
  0x306f,
  "hahmedialarabic",
  0xfea4,
  "haitusquare",
  0x332a,
  "hakatakana",
  0x30cf,
  "hakatakanahalfwidth",
  0xff8a,
  "halantgurmukhi",
  0x0a4d,
  "hamzaarabic",
  0x0621,
  "hamzalowarabic",
  0x0621,
  "hangulfiller",
  0x3164,
  "hardsigncyrillic",
  0x044a,
  "harpoonleftbarbup",
  0x21bc,
  "harpoonrightbarbup",
  0x21c0,
  "hasquare",
  0x33ca,
  "hatafpatah",
  0x05b2,
  "hatafpatah16",
  0x05b2,
  "hatafpatah23",
  0x05b2,
  "hatafpatah2f",
  0x05b2,
  "hatafpatahhebrew",
  0x05b2,
  "hatafpatahnarrowhebrew",
  0x05b2,
  "hatafpatahquarterhebrew",
  0x05b2,
  "hatafpatahwidehebrew",
  0x05b2,
  "hatafqamats",
  0x05b3,
  "hatafqamats1b",
  0x05b3,
  "hatafqamats28",
  0x05b3,
  "hatafqamats34",
  0x05b3,
  "hatafqamatshebrew",
  0x05b3,
  "hatafqamatsnarrowhebrew",
  0x05b3,
  "hatafqamatsquarterhebrew",
  0x05b3,
  "hatafqamatswidehebrew",
  0x05b3,
  "hatafsegol",
  0x05b1,
  "hatafsegol17",
  0x05b1,
  "hatafsegol24",
  0x05b1,
  "hatafsegol30",
  0x05b1,
  "hatafsegolhebrew",
  0x05b1,
  "hatafsegolnarrowhebrew",
  0x05b1,
  "hatafsegolquarterhebrew",
  0x05b1,
  "hatafsegolwidehebrew",
  0x05b1,
  "hbar",
  0x0127,
  "hbopomofo",
  0x310f,
  "hbrevebelow",
  0x1e2b,
  "hcedilla",
  0x1e29,
  "hcircle",
  0x24d7,
  "hcircumflex",
  0x0125,
  "hdieresis",
  0x1e27,
  "hdotaccent",
  0x1e23,
  "hdotbelow",
  0x1e25,
  "he",
  0x05d4,
  "heart",
  0x2665,
  "heartsuitblack",
  0x2665,
  "heartsuitwhite",
  0x2661,
  "hedagesh",
  0xfb34,
  "hedageshhebrew",
  0xfb34,
  "hehaltonearabic",
  0x06c1,
  "heharabic",
  0x0647,
  "hehebrew",
  0x05d4,
  "hehfinalaltonearabic",
  0xfba7,
  "hehfinalalttwoarabic",
  0xfeea,
  "hehfinalarabic",
  0xfeea,
  "hehhamzaabovefinalarabic",
  0xfba5,
  "hehhamzaaboveisolatedarabic",
  0xfba4,
  "hehinitialaltonearabic",
  0xfba8,
  "hehinitialarabic",
  0xfeeb,
  "hehiragana",
  0x3078,
  "hehmedialaltonearabic",
  0xfba9,
  "hehmedialarabic",
  0xfeec,
  "heiseierasquare",
  0x337b,
  "hekatakana",
  0x30d8,
  "hekatakanahalfwidth",
  0xff8d,
  "hekutaarusquare",
  0x3336,
  "henghook",
  0x0267,
  "herutusquare",
  0x3339,
  "het",
  0x05d7,
  "hethebrew",
  0x05d7,
  "hhook",
  0x0266,
  "hhooksuperior",
  0x02b1,
  "hieuhacirclekorean",
  0x327b,
  "hieuhaparenkorean",
  0x321b,
  "hieuhcirclekorean",
  0x326d,
  "hieuhkorean",
  0x314e,
  "hieuhparenkorean",
  0x320d,
  "hihiragana",
  0x3072,
  "hikatakana",
  0x30d2,
  "hikatakanahalfwidth",
  0xff8b,
  "hiriq",
  0x05b4,
  "hiriq14",
  0x05b4,
  "hiriq21",
  0x05b4,
  "hiriq2d",
  0x05b4,
  "hiriqhebrew",
  0x05b4,
  "hiriqnarrowhebrew",
  0x05b4,
  "hiriqquarterhebrew",
  0x05b4,
  "hiriqwidehebrew",
  0x05b4,
  "hlinebelow",
  0x1e96,
  "hmonospace",
  0xff48,
  "hoarmenian",
  0x0570,
  "hohipthai",
  0x0e2b,
  "hohiragana",
  0x307b,
  "hokatakana",
  0x30db,
  "hokatakanahalfwidth",
  0xff8e,
  "holam",
  0x05b9,
  "holam19",
  0x05b9,
  "holam26",
  0x05b9,
  "holam32",
  0x05b9,
  "holamhebrew",
  0x05b9,
  "holamnarrowhebrew",
  0x05b9,
  "holamquarterhebrew",
  0x05b9,
  "holamwidehebrew",
  0x05b9,
  "honokhukthai",
  0x0e2e,
  "hookabovecomb",
  0x0309,
  "hookcmb",
  0x0309,
  "hookpalatalizedbelowcmb",
  0x0321,
  "hookretroflexbelowcmb",
  0x0322,
  "hoonsquare",
  0x3342,
  "horicoptic",
  0x03e9,
  "horizontalbar",
  0x2015,
  "horncmb",
  0x031b,
  "hotsprings",
  0x2668,
  "house",
  0x2302,
  "hparen",
  0x24a3,
  "hsuperior",
  0x02b0,
  "hturned",
  0x0265,
  "huhiragana",
  0x3075,
  "huiitosquare",
  0x3333,
  "hukatakana",
  0x30d5,
  "hukatakanahalfwidth",
  0xff8c,
  "hungarumlaut",
  0x02dd,
  "hungarumlautcmb",
  0x030b,
  "hv",
  0x0195,
  "hyphen",
  0x002d,
  "hypheninferior",
  0xf6e5,
  "hyphenmonospace",
  0xff0d,
  "hyphensmall",
  0xfe63,
  "hyphensuperior",
  0xf6e6,
  "hyphentwo",
  0x2010,
  "i",
  0x0069,
  "iacute",
  0x00ed,
  "iacyrillic",
  0x044f,
  "ibengali",
  0x0987,
  "ibopomofo",
  0x3127,
  "ibreve",
  0x012d,
  "icaron",
  0x01d0,
  "icircle",
  0x24d8,
  "icircumflex",
  0x00ee,
  "icyrillic",
  0x0456,
  "idblgrave",
  0x0209,
  "ideographearthcircle",
  0x328f,
  "ideographfirecircle",
  0x328b,
  "ideographicallianceparen",
  0x323f,
  "ideographiccallparen",
  0x323a,
  "ideographiccentrecircle",
  0x32a5,
  "ideographicclose",
  0x3006,
  "ideographiccomma",
  0x3001,
  "ideographiccommaleft",
  0xff64,
  "ideographiccongratulationparen",
  0x3237,
  "ideographiccorrectcircle",
  0x32a3,
  "ideographicearthparen",
  0x322f,
  "ideographicenterpriseparen",
  0x323d,
  "ideographicexcellentcircle",
  0x329d,
  "ideographicfestivalparen",
  0x3240,
  "ideographicfinancialcircle",
  0x3296,
  "ideographicfinancialparen",
  0x3236,
  "ideographicfireparen",
  0x322b,
  "ideographichaveparen",
  0x3232,
  "ideographichighcircle",
  0x32a4,
  "ideographiciterationmark",
  0x3005,
  "ideographiclaborcircle",
  0x3298,
  "ideographiclaborparen",
  0x3238,
  "ideographicleftcircle",
  0x32a7,
  "ideographiclowcircle",
  0x32a6,
  "ideographicmedicinecircle",
  0x32a9,
  "ideographicmetalparen",
  0x322e,
  "ideographicmoonparen",
  0x322a,
  "ideographicnameparen",
  0x3234,
  "ideographicperiod",
  0x3002,
  "ideographicprintcircle",
  0x329e,
  "ideographicreachparen",
  0x3243,
  "ideographicrepresentparen",
  0x3239,
  "ideographicresourceparen",
  0x323e,
  "ideographicrightcircle",
  0x32a8,
  "ideographicsecretcircle",
  0x3299,
  "ideographicselfparen",
  0x3242,
  "ideographicsocietyparen",
  0x3233,
  "ideographicspace",
  0x3000,
  "ideographicspecialparen",
  0x3235,
  "ideographicstockparen",
  0x3231,
  "ideographicstudyparen",
  0x323b,
  "ideographicsunparen",
  0x3230,
  "ideographicsuperviseparen",
  0x323c,
  "ideographicwaterparen",
  0x322c,
  "ideographicwoodparen",
  0x322d,
  "ideographiczero",
  0x3007,
  "ideographmetalcircle",
  0x328e,
  "ideographmooncircle",
  0x328a,
  "ideographnamecircle",
  0x3294,
  "ideographsuncircle",
  0x3290,
  "ideographwatercircle",
  0x328c,
  "ideographwoodcircle",
  0x328d,
  "ideva",
  0x0907,
  "idieresis",
  0x00ef,
  "idieresisacute",
  0x1e2f,
  "idieresiscyrillic",
  0x04e5,
  "idotbelow",
  0x1ecb,
  "iebrevecyrillic",
  0x04d7,
  "iecyrillic",
  0x0435,
  "ieungacirclekorean",
  0x3275,
  "ieungaparenkorean",
  0x3215,
  "ieungcirclekorean",
  0x3267,
  "ieungkorean",
  0x3147,
  "ieungparenkorean",
  0x3207,
  "igrave",
  0x00ec,
  "igujarati",
  0x0a87,
  "igurmukhi",
  0x0a07,
  "ihiragana",
  0x3044,
  "ihookabove",
  0x1ec9,
  "iibengali",
  0x0988,
  "iicyrillic",
  0x0438,
  "iideva",
  0x0908,
  "iigujarati",
  0x0a88,
  "iigurmukhi",
  0x0a08,
  "iimatragurmukhi",
  0x0a40,
  "iinvertedbreve",
  0x020b,
  "iishortcyrillic",
  0x0439,
  "iivowelsignbengali",
  0x09c0,
  "iivowelsigndeva",
  0x0940,
  "iivowelsigngujarati",
  0x0ac0,
  "ij",
  0x0133,
  "ikatakana",
  0x30a4,
  "ikatakanahalfwidth",
  0xff72,
  "ikorean",
  0x3163,
  "ilde",
  0x02dc,
  "iluyhebrew",
  0x05ac,
  "imacron",
  0x012b,
  "imacroncyrillic",
  0x04e3,
  "imageorapproximatelyequal",
  0x2253,
  "imatragurmukhi",
  0x0a3f,
  "imonospace",
  0xff49,
  "increment",
  0x2206,
  "infinity",
  0x221e,
  "iniarmenian",
  0x056b,
  "integral",
  0x222b,
  "integralbottom",
  0x2321,
  "integralbt",
  0x2321,
  "integralex",
  0xf8f5,
  "integraltop",
  0x2320,
  "integraltp",
  0x2320,
  "intersection",
  0x2229,
  "intisquare",
  0x3305,
  "invbullet",
  0x25d8,
  "invcircle",
  0x25d9,
  "invsmileface",
  0x263b,
  "iocyrillic",
  0x0451,
  "iogonek",
  0x012f,
  "iota",
  0x03b9,
  "iotadieresis",
  0x03ca,
  "iotadieresistonos",
  0x0390,
  "iotalatin",
  0x0269,
  "iotatonos",
  0x03af,
  "iparen",
  0x24a4,
  "irigurmukhi",
  0x0a72,
  "ismallhiragana",
  0x3043,
  "ismallkatakana",
  0x30a3,
  "ismallkatakanahalfwidth",
  0xff68,
  "issharbengali",
  0x09fa,
  "istroke",
  0x0268,
  "isuperior",
  0xf6ed,
  "iterationhiragana",
  0x309d,
  "iterationkatakana",
  0x30fd,
  "itilde",
  0x0129,
  "itildebelow",
  0x1e2d,
  "iubopomofo",
  0x3129,
  "iucyrillic",
  0x044e,
  "ivowelsignbengali",
  0x09bf,
  "ivowelsigndeva",
  0x093f,
  "ivowelsigngujarati",
  0x0abf,
  "izhitsacyrillic",
  0x0475,
  "izhitsadblgravecyrillic",
  0x0477,
  "j",
  0x006a,
  "jaarmenian",
  0x0571,
  "jabengali",
  0x099c,
  "jadeva",
  0x091c,
  "jagujarati",
  0x0a9c,
  "jagurmukhi",
  0x0a1c,
  "jbopomofo",
  0x3110,
  "jcaron",
  0x01f0,
  "jcircle",
  0x24d9,
  "jcircumflex",
  0x0135,
  "jcrossedtail",
  0x029d,
  "jdotlessstroke",
  0x025f,
  "jecyrillic",
  0x0458,
  "jeemarabic",
  0x062c,
  "jeemfinalarabic",
  0xfe9e,
  "jeeminitialarabic",
  0xfe9f,
  "jeemmedialarabic",
  0xfea0,
  "jeharabic",
  0x0698,
  "jehfinalarabic",
  0xfb8b,
  "jhabengali",
  0x099d,
  "jhadeva",
  0x091d,
  "jhagujarati",
  0x0a9d,
  "jhagurmukhi",
  0x0a1d,
  "jheharmenian",
  0x057b,
  "jis",
  0x3004,
  "jmonospace",
  0xff4a,
  "jparen",
  0x24a5,
  "jsuperior",
  0x02b2,
  "k",
  0x006b,
  "kabashkircyrillic",
  0x04a1,
  "kabengali",
  0x0995,
  "kacute",
  0x1e31,
  "kacyrillic",
  0x043a,
  "kadescendercyrillic",
  0x049b,
  "kadeva",
  0x0915,
  "kaf",
  0x05db,
  "kafarabic",
  0x0643,
  "kafdagesh",
  0xfb3b,
  "kafdageshhebrew",
  0xfb3b,
  "kaffinalarabic",
  0xfeda,
  "kafhebrew",
  0x05db,
  "kafinitialarabic",
  0xfedb,
  "kafmedialarabic",
  0xfedc,
  "kafrafehebrew",
  0xfb4d,
  "kagujarati",
  0x0a95,
  "kagurmukhi",
  0x0a15,
  "kahiragana",
  0x304b,
  "kahookcyrillic",
  0x04c4,
  "kakatakana",
  0x30ab,
  "kakatakanahalfwidth",
  0xff76,
  "kappa",
  0x03ba,
  "kappasymbolgreek",
  0x03f0,
  "kapyeounmieumkorean",
  0x3171,
  "kapyeounphieuphkorean",
  0x3184,
  "kapyeounpieupkorean",
  0x3178,
  "kapyeounssangpieupkorean",
  0x3179,
  "karoriisquare",
  0x330d,
  "kashidaautoarabic",
  0x0640,
  "kashidaautonosidebearingarabic",
  0x0640,
  "kasmallkatakana",
  0x30f5,
  "kasquare",
  0x3384,
  "kasraarabic",
  0x0650,
  "kasratanarabic",
  0x064d,
  "kastrokecyrillic",
  0x049f,
  "katahiraprolongmarkhalfwidth",
  0xff70,
  "kaverticalstrokecyrillic",
  0x049d,
  "kbopomofo",
  0x310e,
  "kcalsquare",
  0x3389,
  "kcaron",
  0x01e9,
  "kcedilla",
  0x0137,
  "kcircle",
  0x24da,
  "kcommaaccent",
  0x0137,
  "kdotbelow",
  0x1e33,
  "keharmenian",
  0x0584,
  "kehiragana",
  0x3051,
  "kekatakana",
  0x30b1,
  "kekatakanahalfwidth",
  0xff79,
  "kenarmenian",
  0x056f,
  "kesmallkatakana",
  0x30f6,
  "kgreenlandic",
  0x0138,
  "khabengali",
  0x0996,
  "khacyrillic",
  0x0445,
  "khadeva",
  0x0916,
  "khagujarati",
  0x0a96,
  "khagurmukhi",
  0x0a16,
  "khaharabic",
  0x062e,
  "khahfinalarabic",
  0xfea6,
  "khahinitialarabic",
  0xfea7,
  "khahmedialarabic",
  0xfea8,
  "kheicoptic",
  0x03e7,
  "khhadeva",
  0x0959,
  "khhagurmukhi",
  0x0a59,
  "khieukhacirclekorean",
  0x3278,
  "khieukhaparenkorean",
  0x3218,
  "khieukhcirclekorean",
  0x326a,
  "khieukhkorean",
  0x314b,
  "khieukhparenkorean",
  0x320a,
  "khokhaithai",
  0x0e02,
  "khokhonthai",
  0x0e05,
  "khokhuatthai",
  0x0e03,
  "khokhwaithai",
  0x0e04,
  "khomutthai",
  0x0e5b,
  "khook",
  0x0199,
  "khorakhangthai",
  0x0e06,
  "khzsquare",
  0x3391,
  "kihiragana",
  0x304d,
  "kikatakana",
  0x30ad,
  "kikatakanahalfwidth",
  0xff77,
  "kiroguramusquare",
  0x3315,
  "kiromeetorusquare",
  0x3316,
  "kirosquare",
  0x3314,
  "kiyeokacirclekorean",
  0x326e,
  "kiyeokaparenkorean",
  0x320e,
  "kiyeokcirclekorean",
  0x3260,
  "kiyeokkorean",
  0x3131,
  "kiyeokparenkorean",
  0x3200,
  "kiyeoksioskorean",
  0x3133,
  "kjecyrillic",
  0x045c,
  "klinebelow",
  0x1e35,
  "klsquare",
  0x3398,
  "kmcubedsquare",
  0x33a6,
  "kmonospace",
  0xff4b,
  "kmsquaredsquare",
  0x33a2,
  "kohiragana",
  0x3053,
  "kohmsquare",
  0x33c0,
  "kokaithai",
  0x0e01,
  "kokatakana",
  0x30b3,
  "kokatakanahalfwidth",
  0xff7a,
  "kooposquare",
  0x331e,
  "koppacyrillic",
  0x0481,
  "koreanstandardsymbol",
  0x327f,
  "koroniscmb",
  0x0343,
  "kparen",
  0x24a6,
  "kpasquare",
  0x33aa,
  "ksicyrillic",
  0x046f,
  "ktsquare",
  0x33cf,
  "kturned",
  0x029e,
  "kuhiragana",
  0x304f,
  "kukatakana",
  0x30af,
  "kukatakanahalfwidth",
  0xff78,
  "kvsquare",
  0x33b8,
  "kwsquare",
  0x33be,
  "l",
  0x006c,
  "labengali",
  0x09b2,
  "lacute",
  0x013a,
  "ladeva",
  0x0932,
  "lagujarati",
  0x0ab2,
  "lagurmukhi",
  0x0a32,
  "lakkhangyaothai",
  0x0e45,
  "lamaleffinalarabic",
  0xfefc,
  "lamalefhamzaabovefinalarabic",
  0xfef8,
  "lamalefhamzaaboveisolatedarabic",
  0xfef7,
  "lamalefhamzabelowfinalarabic",
  0xfefa,
  "lamalefhamzabelowisolatedarabic",
  0xfef9,
  "lamalefisolatedarabic",
  0xfefb,
  "lamalefmaddaabovefinalarabic",
  0xfef6,
  "lamalefmaddaaboveisolatedarabic",
  0xfef5,
  "lamarabic",
  0x0644,
  "lambda",
  0x03bb,
  "lambdastroke",
  0x019b,
  "lamed",
  0x05dc,
  "lameddagesh",
  0xfb3c,
  "lameddageshhebrew",
  0xfb3c,
  "lamedhebrew",
  0x05dc,
  "lamfinalarabic",
  0xfede,
  "lamhahinitialarabic",
  0xfcca,
  "laminitialarabic",
  0xfedf,
  "lamjeeminitialarabic",
  0xfcc9,
  "lamkhahinitialarabic",
  0xfccb,
  "lamlamhehisolatedarabic",
  0xfdf2,
  "lammedialarabic",
  0xfee0,
  "lammeemhahinitialarabic",
  0xfd88,
  "lammeeminitialarabic",
  0xfccc,
  "largecircle",
  0x25ef,
  "lbar",
  0x019a,
  "lbelt",
  0x026c,
  "lbopomofo",
  0x310c,
  "lcaron",
  0x013e,
  "lcedilla",
  0x013c,
  "lcircle",
  0x24db,
  "lcircumflexbelow",
  0x1e3d,
  "lcommaaccent",
  0x013c,
  "ldot",
  0x0140,
  "ldotaccent",
  0x0140,
  "ldotbelow",
  0x1e37,
  "ldotbelowmacron",
  0x1e39,
  "leftangleabovecmb",
  0x031a,
  "lefttackbelowcmb",
  0x0318,
  "less",
  0x003c,
  "lessequal",
  0x2264,
  "lessequalorgreater",
  0x22da,
  "lessmonospace",
  0xff1c,
  "lessorequivalent",
  0x2272,
  "lessorgreater",
  0x2276,
  "lessoverequal",
  0x2266,
  "lesssmall",
  0xfe64,
  "lezh",
  0x026e,
  "lfblock",
  0x258c,
  "lhookretroflex",
  0x026d,
  "lira",
  0x20a4,
  "liwnarmenian",
  0x056c,
  "lj",
  0x01c9,
  "ljecyrillic",
  0x0459,
  "ll",
  0xf6c0,
  "lladeva",
  0x0933,
  "llagujarati",
  0x0ab3,
  "llinebelow",
  0x1e3b,
  "llladeva",
  0x0934,
  "llvocalicbengali",
  0x09e1,
  "llvocalicdeva",
  0x0961,
  "llvocalicvowelsignbengali",
  0x09e3,
  "llvocalicvowelsigndeva",
  0x0963,
  "lmiddletilde",
  0x026b,
  "lmonospace",
  0xff4c,
  "lmsquare",
  0x33d0,
  "lochulathai",
  0x0e2c,
  "logicaland",
  0x2227,
  "logicalnot",
  0x00ac,
  "logicalnotreversed",
  0x2310,
  "logicalor",
  0x2228,
  "lolingthai",
  0x0e25,
  "longs",
  0x017f,
  "lowlinecenterline",
  0xfe4e,
  "lowlinecmb",
  0x0332,
  "lowlinedashed",
  0xfe4d,
  "lozenge",
  0x25ca,
  "lparen",
  0x24a7,
  "lslash",
  0x0142,
  "lsquare",
  0x2113,
  "lsuperior",
  0xf6ee,
  "ltshade",
  0x2591,
  "luthai",
  0x0e26,
  "lvocalicbengali",
  0x098c,
  "lvocalicdeva",
  0x090c,
  "lvocalicvowelsignbengali",
  0x09e2,
  "lvocalicvowelsigndeva",
  0x0962,
  "lxsquare",
  0x33d3,
  "m",
  0x006d,
  "mabengali",
  0x09ae,
  "macron",
  0x00af,
  "macronbelowcmb",
  0x0331,
  "macroncmb",
  0x0304,
  "macronlowmod",
  0x02cd,
  "macronmonospace",
  0xffe3,
  "macute",
  0x1e3f,
  "madeva",
  0x092e,
  "magujarati",
  0x0aae,
  "magurmukhi",
  0x0a2e,
  "mahapakhhebrew",
  0x05a4,
  "mahapakhlefthebrew",
  0x05a4,
  "mahiragana",
  0x307e,
  "maichattawalowleftthai",
  0xf895,
  "maichattawalowrightthai",
  0xf894,
  "maichattawathai",
  0x0e4b,
  "maichattawaupperleftthai",
  0xf893,
  "maieklowleftthai",
  0xf88c,
  "maieklowrightthai",
  0xf88b,
  "maiekthai",
  0x0e48,
  "maiekupperleftthai",
  0xf88a,
  "maihanakatleftthai",
  0xf884,
  "maihanakatthai",
  0x0e31,
  "maitaikhuleftthai",
  0xf889,
  "maitaikhuthai",
  0x0e47,
  "maitholowleftthai",
  0xf88f,
  "maitholowrightthai",
  0xf88e,
  "maithothai",
  0x0e49,
  "maithoupperleftthai",
  0xf88d,
  "maitrilowleftthai",
  0xf892,
  "maitrilowrightthai",
  0xf891,
  "maitrithai",
  0x0e4a,
  "maitriupperleftthai",
  0xf890,
  "maiyamokthai",
  0x0e46,
  "makatakana",
  0x30de,
  "makatakanahalfwidth",
  0xff8f,
  "male",
  0x2642,
  "mansyonsquare",
  0x3347,
  "maqafhebrew",
  0x05be,
  "mars",
  0x2642,
  "masoracirclehebrew",
  0x05af,
  "masquare",
  0x3383,
  "mbopomofo",
  0x3107,
  "mbsquare",
  0x33d4,
  "mcircle",
  0x24dc,
  "mcubedsquare",
  0x33a5,
  "mdotaccent",
  0x1e41,
  "mdotbelow",
  0x1e43,
  "meemarabic",
  0x0645,
  "meemfinalarabic",
  0xfee2,
  "meeminitialarabic",
  0xfee3,
  "meemmedialarabic",
  0xfee4,
  "meemmeeminitialarabic",
  0xfcd1,
  "meemmeemisolatedarabic",
  0xfc48,
  "meetorusquare",
  0x334d,
  "mehiragana",
  0x3081,
  "meizierasquare",
  0x337e,
  "mekatakana",
  0x30e1,
  "mekatakanahalfwidth",
  0xff92,
  "mem",
  0x05de,
  "memdagesh",
  0xfb3e,
  "memdageshhebrew",
  0xfb3e,
  "memhebrew",
  0x05de,
  "menarmenian",
  0x0574,
  "merkhahebrew",
  0x05a5,
  "merkhakefulahebrew",
  0x05a6,
  "merkhakefulalefthebrew",
  0x05a6,
  "merkhalefthebrew",
  0x05a5,
  "mhook",
  0x0271,
  "mhzsquare",
  0x3392,
  "middledotkatakanahalfwidth",
  0xff65,
  "middot",
  0x00b7,
  "mieumacirclekorean",
  0x3272,
  "mieumaparenkorean",
  0x3212,
  "mieumcirclekorean",
  0x3264,
  "mieumkorean",
  0x3141,
  "mieumpansioskorean",
  0x3170,
  "mieumparenkorean",
  0x3204,
  "mieumpieupkorean",
  0x316e,
  "mieumsioskorean",
  0x316f,
  "mihiragana",
  0x307f,
  "mikatakana",
  0x30df,
  "mikatakanahalfwidth",
  0xff90,
  "minus",
  0x2212,
  "minusbelowcmb",
  0x0320,
  "minuscircle",
  0x2296,
  "minusmod",
  0x02d7,
  "minusplus",
  0x2213,
  "minute",
  0x2032,
  "miribaarusquare",
  0x334a,
  "mirisquare",
  0x3349,
  "mlonglegturned",
  0x0270,
  "mlsquare",
  0x3396,
  "mmcubedsquare",
  0x33a3,
  "mmonospace",
  0xff4d,
  "mmsquaredsquare",
  0x339f,
  "mohiragana",
  0x3082,
  "mohmsquare",
  0x33c1,
  "mokatakana",
  0x30e2,
  "mokatakanahalfwidth",
  0xff93,
  "molsquare",
  0x33d6,
  "momathai",
  0x0e21,
  "moverssquare",
  0x33a7,
  "moverssquaredsquare",
  0x33a8,
  "mparen",
  0x24a8,
  "mpasquare",
  0x33ab,
  "mssquare",
  0x33b3,
  "msuperior",
  0xf6ef,
  "mturned",
  0x026f,
  "mu",
  0x00b5,
  "mu1",
  0x00b5,
  "muasquare",
  0x3382,
  "muchgreater",
  0x226b,
  "muchless",
  0x226a,
  "mufsquare",
  0x338c,
  "mugreek",
  0x03bc,
  "mugsquare",
  0x338d,
  "muhiragana",
  0x3080,
  "mukatakana",
  0x30e0,
  "mukatakanahalfwidth",
  0xff91,
  "mulsquare",
  0x3395,
  "multiply",
  0x00d7,
  "mumsquare",
  0x339b,
  "munahhebrew",
  0x05a3,
  "munahlefthebrew",
  0x05a3,
  "musicalnote",
  0x266a,
  "musicalnotedbl",
  0x266b,
  "musicflatsign",
  0x266d,
  "musicsharpsign",
  0x266f,
  "mussquare",
  0x33b2,
  "muvsquare",
  0x33b6,
  "muwsquare",
  0x33bc,
  "mvmegasquare",
  0x33b9,
  "mvsquare",
  0x33b7,
  "mwmegasquare",
  0x33bf,
  "mwsquare",
  0x33bd,
  "n",
  0x006e,
  "nabengali",
  0x09a8,
  "nabla",
  0x2207,
  "nacute",
  0x0144,
  "nadeva",
  0x0928,
  "nagujarati",
  0x0aa8,
  "nagurmukhi",
  0x0a28,
  "nahiragana",
  0x306a,
  "nakatakana",
  0x30ca,
  "nakatakanahalfwidth",
  0xff85,
  "napostrophe",
  0x0149,
  "nasquare",
  0x3381,
  "nbopomofo",
  0x310b,
  "nbspace",
  0x00a0,
  "ncaron",
  0x0148,
  "ncedilla",
  0x0146,
  "ncircle",
  0x24dd,
  "ncircumflexbelow",
  0x1e4b,
  "ncommaaccent",
  0x0146,
  "ndotaccent",
  0x1e45,
  "ndotbelow",
  0x1e47,
  "nehiragana",
  0x306d,
  "nekatakana",
  0x30cd,
  "nekatakanahalfwidth",
  0xff88,
  "newsheqelsign",
  0x20aa,
  "nfsquare",
  0x338b,
  "ngabengali",
  0x0999,
  "ngadeva",
  0x0919,
  "ngagujarati",
  0x0a99,
  "ngagurmukhi",
  0x0a19,
  "ngonguthai",
  0x0e07,
  "nhiragana",
  0x3093,
  "nhookleft",
  0x0272,
  "nhookretroflex",
  0x0273,
  "nieunacirclekorean",
  0x326f,
  "nieunaparenkorean",
  0x320f,
  "nieuncieuckorean",
  0x3135,
  "nieuncirclekorean",
  0x3261,
  "nieunhieuhkorean",
  0x3136,
  "nieunkorean",
  0x3134,
  "nieunpansioskorean",
  0x3168,
  "nieunparenkorean",
  0x3201,
  "nieunsioskorean",
  0x3167,
  "nieuntikeutkorean",
  0x3166,
  "nihiragana",
  0x306b,
  "nikatakana",
  0x30cb,
  "nikatakanahalfwidth",
  0xff86,
  "nikhahitleftthai",
  0xf899,
  "nikhahitthai",
  0x0e4d,
  "nine",
  0x0039,
  "ninearabic",
  0x0669,
  "ninebengali",
  0x09ef,
  "ninecircle",
  0x2468,
  "ninecircleinversesansserif",
  0x2792,
  "ninedeva",
  0x096f,
  "ninegujarati",
  0x0aef,
  "ninegurmukhi",
  0x0a6f,
  "ninehackarabic",
  0x0669,
  "ninehangzhou",
  0x3029,
  "nineideographicparen",
  0x3228,
  "nineinferior",
  0x2089,
  "ninemonospace",
  0xff19,
  "nineoldstyle",
  0xf739,
  "nineparen",
  0x247c,
  "nineperiod",
  0x2490,
  "ninepersian",
  0x06f9,
  "nineroman",
  0x2178,
  "ninesuperior",
  0x2079,
  "nineteencircle",
  0x2472,
  "nineteenparen",
  0x2486,
  "nineteenperiod",
  0x249a,
  "ninethai",
  0x0e59,
  "nj",
  0x01cc,
  "njecyrillic",
  0x045a,
  "nkatakana",
  0x30f3,
  "nkatakanahalfwidth",
  0xff9d,
  "nlegrightlong",
  0x019e,
  "nlinebelow",
  0x1e49,
  "nmonospace",
  0xff4e,
  "nmsquare",
  0x339a,
  "nnabengali",
  0x09a3,
  "nnadeva",
  0x0923,
  "nnagujarati",
  0x0aa3,
  "nnagurmukhi",
  0x0a23,
  "nnnadeva",
  0x0929,
  "nohiragana",
  0x306e,
  "nokatakana",
  0x30ce,
  "nokatakanahalfwidth",
  0xff89,
  "nonbreakingspace",
  0x00a0,
  "nonenthai",
  0x0e13,
  "nonuthai",
  0x0e19,
  "noonarabic",
  0x0646,
  "noonfinalarabic",
  0xfee6,
  "noonghunnaarabic",
  0x06ba,
  "noonghunnafinalarabic",
  0xfb9f,
  "nooninitialarabic",
  0xfee7,
  "noonjeeminitialarabic",
  0xfcd2,
  "noonjeemisolatedarabic",
  0xfc4b,
  "noonmedialarabic",
  0xfee8,
  "noonmeeminitialarabic",
  0xfcd5,
  "noonmeemisolatedarabic",
  0xfc4e,
  "noonnoonfinalarabic",
  0xfc8d,
  "notcontains",
  0x220c,
  "notelement",
  0x2209,
  "notelementof",
  0x2209,
  "notequal",
  0x2260,
  "notgreater",
  0x226f,
  "notgreaternorequal",
  0x2271,
  "notgreaternorless",
  0x2279,
  "notidentical",
  0x2262,
  "notless",
  0x226e,
  "notlessnorequal",
  0x2270,
  "notparallel",
  0x2226,
  "notprecedes",
  0x2280,
  "notsubset",
  0x2284,
  "notsucceeds",
  0x2281,
  "notsuperset",
  0x2285,
  "nowarmenian",
  0x0576,
  "nparen",
  0x24a9,
  "nssquare",
  0x33b1,
  "nsuperior",
  0x207f,
  "ntilde",
  0x00f1,
  "nu",
  0x03bd,
  "nuhiragana",
  0x306c,
  "nukatakana",
  0x30cc,
  "nukatakanahalfwidth",
  0xff87,
  "nuktabengali",
  0x09bc,
  "nuktadeva",
  0x093c,
  "nuktagujarati",
  0x0abc,
  "nuktagurmukhi",
  0x0a3c,
  "numbersign",
  0x0023,
  "numbersignmonospace",
  0xff03,
  "numbersignsmall",
  0xfe5f,
  "numeralsigngreek",
  0x0374,
  "numeralsignlowergreek",
  0x0375,
  "numero",
  0x2116,
  "nun",
  0x05e0,
  "nundagesh",
  0xfb40,
  "nundageshhebrew",
  0xfb40,
  "nunhebrew",
  0x05e0,
  "nvsquare",
  0x33b5,
  "nwsquare",
  0x33bb,
  "nyabengali",
  0x099e,
  "nyadeva",
  0x091e,
  "nyagujarati",
  0x0a9e,
  "nyagurmukhi",
  0x0a1e,
  "o",
  0x006f,
  "oacute",
  0x00f3,
  "oangthai",
  0x0e2d,
  "obarred",
  0x0275,
  "obarredcyrillic",
  0x04e9,
  "obarreddieresiscyrillic",
  0x04eb,
  "obengali",
  0x0993,
  "obopomofo",
  0x311b,
  "obreve",
  0x014f,
  "ocandradeva",
  0x0911,
  "ocandragujarati",
  0x0a91,
  "ocandravowelsigndeva",
  0x0949,
  "ocandravowelsigngujarati",
  0x0ac9,
  "ocaron",
  0x01d2,
  "ocircle",
  0x24de,
  "ocircumflex",
  0x00f4,
  "ocircumflexacute",
  0x1ed1,
  "ocircumflexdotbelow",
  0x1ed9,
  "ocircumflexgrave",
  0x1ed3,
  "ocircumflexhookabove",
  0x1ed5,
  "ocircumflextilde",
  0x1ed7,
  "ocyrillic",
  0x043e,
  "odblacute",
  0x0151,
  "odblgrave",
  0x020d,
  "odeva",
  0x0913,
  "odieresis",
  0x00f6,
  "odieresiscyrillic",
  0x04e7,
  "odotbelow",
  0x1ecd,
  "oe",
  0x0153,
  "oekorean",
  0x315a,
  "ogonek",
  0x02db,
  "ogonekcmb",
  0x0328,
  "ograve",
  0x00f2,
  "ogujarati",
  0x0a93,
  "oharmenian",
  0x0585,
  "ohiragana",
  0x304a,
  "ohookabove",
  0x1ecf,
  "ohorn",
  0x01a1,
  "ohornacute",
  0x1edb,
  "ohorndotbelow",
  0x1ee3,
  "ohorngrave",
  0x1edd,
  "ohornhookabove",
  0x1edf,
  "ohorntilde",
  0x1ee1,
  "ohungarumlaut",
  0x0151,
  "oi",
  0x01a3,
  "oinvertedbreve",
  0x020f,
  "okatakana",
  0x30aa,
  "okatakanahalfwidth",
  0xff75,
  "okorean",
  0x3157,
  "olehebrew",
  0x05ab,
  "omacron",
  0x014d,
  "omacronacute",
  0x1e53,
  "omacrongrave",
  0x1e51,
  "omdeva",
  0x0950,
  "omega",
  0x03c9,
  "omega1",
  0x03d6,
  "omegacyrillic",
  0x0461,
  "omegalatinclosed",
  0x0277,
  "omegaroundcyrillic",
  0x047b,
  "omegatitlocyrillic",
  0x047d,
  "omegatonos",
  0x03ce,
  "omgujarati",
  0x0ad0,
  "omicron",
  0x03bf,
  "omicrontonos",
  0x03cc,
  "omonospace",
  0xff4f,
  "one",
  0x0031,
  "onearabic",
  0x0661,
  "onebengali",
  0x09e7,
  "onecircle",
  0x2460,
  "onecircleinversesansserif",
  0x278a,
  "onedeva",
  0x0967,
  "onedotenleader",
  0x2024,
  "oneeighth",
  0x215b,
  "onefitted",
  0xf6dc,
  "onegujarati",
  0x0ae7,
  "onegurmukhi",
  0x0a67,
  "onehackarabic",
  0x0661,
  "onehalf",
  0x00bd,
  "onehangzhou",
  0x3021,
  "oneideographicparen",
  0x3220,
  "oneinferior",
  0x2081,
  "onemonospace",
  0xff11,
  "onenumeratorbengali",
  0x09f4,
  "oneoldstyle",
  0xf731,
  "oneparen",
  0x2474,
  "oneperiod",
  0x2488,
  "onepersian",
  0x06f1,
  "onequarter",
  0x00bc,
  "oneroman",
  0x2170,
  "onesuperior",
  0x00b9,
  "onethai",
  0x0e51,
  "onethird",
  0x2153,
  "oogonek",
  0x01eb,
  "oogonekmacron",
  0x01ed,
  "oogurmukhi",
  0x0a13,
  "oomatragurmukhi",
  0x0a4b,
  "oopen",
  0x0254,
  "oparen",
  0x24aa,
  "openbullet",
  0x25e6,
  "option",
  0x2325,
  "ordfeminine",
  0x00aa,
  "ordmasculine",
  0x00ba,
  "orthogonal",
  0x221f,
  "oshortdeva",
  0x0912,
  "oshortvowelsigndeva",
  0x094a,
  "oslash",
  0x00f8,
  "oslashacute",
  0x01ff,
  "osmallhiragana",
  0x3049,
  "osmallkatakana",
  0x30a9,
  "osmallkatakanahalfwidth",
  0xff6b,
  "ostrokeacute",
  0x01ff,
  "osuperior",
  0xf6f0,
  "otcyrillic",
  0x047f,
  "otilde",
  0x00f5,
  "otildeacute",
  0x1e4d,
  "otildedieresis",
  0x1e4f,
  "oubopomofo",
  0x3121,
  "overline",
  0x203e,
  "overlinecenterline",
  0xfe4a,
  "overlinecmb",
  0x0305,
  "overlinedashed",
  0xfe49,
  "overlinedblwavy",
  0xfe4c,
  "overlinewavy",
  0xfe4b,
  "overscore",
  0x00af,
  "ovowelsignbengali",
  0x09cb,
  "ovowelsigndeva",
  0x094b,
  "ovowelsigngujarati",
  0x0acb,
  "p",
  0x0070,
  "paampssquare",
  0x3380,
  "paasentosquare",
  0x332b,
  "pabengali",
  0x09aa,
  "pacute",
  0x1e55,
  "padeva",
  0x092a,
  "pagedown",
  0x21df,
  "pageup",
  0x21de,
  "pagujarati",
  0x0aaa,
  "pagurmukhi",
  0x0a2a,
  "pahiragana",
  0x3071,
  "paiyannoithai",
  0x0e2f,
  "pakatakana",
  0x30d1,
  "palatalizationcyrilliccmb",
  0x0484,
  "palochkacyrillic",
  0x04c0,
  "pansioskorean",
  0x317f,
  "paragraph",
  0x00b6,
  "parallel",
  0x2225,
  "parenleft",
  0x0028,
  "parenleftaltonearabic",
  0xfd3e,
  "parenleftbt",
  0xf8ed,
  "parenleftex",
  0xf8ec,
  "parenleftinferior",
  0x208d,
  "parenleftmonospace",
  0xff08,
  "parenleftsmall",
  0xfe59,
  "parenleftsuperior",
  0x207d,
  "parenlefttp",
  0xf8eb,
  "parenleftvertical",
  0xfe35,
  "parenright",
  0x0029,
  "parenrightaltonearabic",
  0xfd3f,
  "parenrightbt",
  0xf8f8,
  "parenrightex",
  0xf8f7,
  "parenrightinferior",
  0x208e,
  "parenrightmonospace",
  0xff09,
  "parenrightsmall",
  0xfe5a,
  "parenrightsuperior",
  0x207e,
  "parenrighttp",
  0xf8f6,
  "parenrightvertical",
  0xfe36,
  "partialdiff",
  0x2202,
  "paseqhebrew",
  0x05c0,
  "pashtahebrew",
  0x0599,
  "pasquare",
  0x33a9,
  "patah",
  0x05b7,
  "patah11",
  0x05b7,
  "patah1d",
  0x05b7,
  "patah2a",
  0x05b7,
  "patahhebrew",
  0x05b7,
  "patahnarrowhebrew",
  0x05b7,
  "patahquarterhebrew",
  0x05b7,
  "patahwidehebrew",
  0x05b7,
  "pazerhebrew",
  0x05a1,
  "pbopomofo",
  0x3106,
  "pcircle",
  0x24df,
  "pdotaccent",
  0x1e57,
  "pe",
  0x05e4,
  "pecyrillic",
  0x043f,
  "pedagesh",
  0xfb44,
  "pedageshhebrew",
  0xfb44,
  "peezisquare",
  0x333b,
  "pefinaldageshhebrew",
  0xfb43,
  "peharabic",
  0x067e,
  "peharmenian",
  0x057a,
  "pehebrew",
  0x05e4,
  "pehfinalarabic",
  0xfb57,
  "pehinitialarabic",
  0xfb58,
  "pehiragana",
  0x307a,
  "pehmedialarabic",
  0xfb59,
  "pekatakana",
  0x30da,
  "pemiddlehookcyrillic",
  0x04a7,
  "perafehebrew",
  0xfb4e,
  "percent",
  0x0025,
  "percentarabic",
  0x066a,
  "percentmonospace",
  0xff05,
  "percentsmall",
  0xfe6a,
  "period",
  0x002e,
  "periodarmenian",
  0x0589,
  "periodcentered",
  0x00b7,
  "periodhalfwidth",
  0xff61,
  "periodinferior",
  0xf6e7,
  "periodmonospace",
  0xff0e,
  "periodsmall",
  0xfe52,
  "periodsuperior",
  0xf6e8,
  "perispomenigreekcmb",
  0x0342,
  "perpendicular",
  0x22a5,
  "perthousand",
  0x2030,
  "peseta",
  0x20a7,
  "pfsquare",
  0x338a,
  "phabengali",
  0x09ab,
  "phadeva",
  0x092b,
  "phagujarati",
  0x0aab,
  "phagurmukhi",
  0x0a2b,
  "phi",
  0x03c6,
  "phi1",
  0x03d5,
  "phieuphacirclekorean",
  0x327a,
  "phieuphaparenkorean",
  0x321a,
  "phieuphcirclekorean",
  0x326c,
  "phieuphkorean",
  0x314d,
  "phieuphparenkorean",
  0x320c,
  "philatin",
  0x0278,
  "phinthuthai",
  0x0e3a,
  "phisymbolgreek",
  0x03d5,
  "phook",
  0x01a5,
  "phophanthai",
  0x0e1e,
  "phophungthai",
  0x0e1c,
  "phosamphaothai",
  0x0e20,
  "pi",
  0x03c0,
  "pieupacirclekorean",
  0x3273,
  "pieupaparenkorean",
  0x3213,
  "pieupcieuckorean",
  0x3176,
  "pieupcirclekorean",
  0x3265,
  "pieupkiyeokkorean",
  0x3172,
  "pieupkorean",
  0x3142,
  "pieupparenkorean",
  0x3205,
  "pieupsioskiyeokkorean",
  0x3174,
  "pieupsioskorean",
  0x3144,
  "pieupsiostikeutkorean",
  0x3175,
  "pieupthieuthkorean",
  0x3177,
  "pieuptikeutkorean",
  0x3173,
  "pihiragana",
  0x3074,
  "pikatakana",
  0x30d4,
  "pisymbolgreek",
  0x03d6,
  "piwrarmenian",
  0x0583,
  "plus",
  0x002b,
  "plusbelowcmb",
  0x031f,
  "pluscircle",
  0x2295,
  "plusminus",
  0x00b1,
  "plusmod",
  0x02d6,
  "plusmonospace",
  0xff0b,
  "plussmall",
  0xfe62,
  "plussuperior",
  0x207a,
  "pmonospace",
  0xff50,
  "pmsquare",
  0x33d8,
  "pohiragana",
  0x307d,
  "pointingindexdownwhite",
  0x261f,
  "pointingindexleftwhite",
  0x261c,
  "pointingindexrightwhite",
  0x261e,
  "pointingindexupwhite",
  0x261d,
  "pokatakana",
  0x30dd,
  "poplathai",
  0x0e1b,
  "postalmark",
  0x3012,
  "postalmarkface",
  0x3020,
  "pparen",
  0x24ab,
  "precedes",
  0x227a,
  "prescription",
  0x211e,
  "primemod",
  0x02b9,
  "primereversed",
  0x2035,
  "product",
  0x220f,
  "projective",
  0x2305,
  "prolongedkana",
  0x30fc,
  "propellor",
  0x2318,
  "propersubset",
  0x2282,
  "propersuperset",
  0x2283,
  "proportion",
  0x2237,
  "proportional",
  0x221d,
  "psi",
  0x03c8,
  "psicyrillic",
  0x0471,
  "psilipneumatacyrilliccmb",
  0x0486,
  "pssquare",
  0x33b0,
  "puhiragana",
  0x3077,
  "pukatakana",
  0x30d7,
  "pvsquare",
  0x33b4,
  "pwsquare",
  0x33ba,
  "q",
  0x0071,
  "qadeva",
  0x0958,
  "qadmahebrew",
  0x05a8,
  "qafarabic",
  0x0642,
  "qaffinalarabic",
  0xfed6,
  "qafinitialarabic",
  0xfed7,
  "qafmedialarabic",
  0xfed8,
  "qamats",
  0x05b8,
  "qamats10",
  0x05b8,
  "qamats1a",
  0x05b8,
  "qamats1c",
  0x05b8,
  "qamats27",
  0x05b8,
  "qamats29",
  0x05b8,
  "qamats33",
  0x05b8,
  "qamatsde",
  0x05b8,
  "qamatshebrew",
  0x05b8,
  "qamatsnarrowhebrew",
  0x05b8,
  "qamatsqatanhebrew",
  0x05b8,
  "qamatsqatannarrowhebrew",
  0x05b8,
  "qamatsqatanquarterhebrew",
  0x05b8,
  "qamatsqatanwidehebrew",
  0x05b8,
  "qamatsquarterhebrew",
  0x05b8,
  "qamatswidehebrew",
  0x05b8,
  "qarneyparahebrew",
  0x059f,
  "qbopomofo",
  0x3111,
  "qcircle",
  0x24e0,
  "qhook",
  0x02a0,
  "qmonospace",
  0xff51,
  "qof",
  0x05e7,
  "qofdagesh",
  0xfb47,
  "qofdageshhebrew",
  0xfb47,
  "qofhebrew",
  0x05e7,
  "qparen",
  0x24ac,
  "quarternote",
  0x2669,
  "qubuts",
  0x05bb,
  "qubuts18",
  0x05bb,
  "qubuts25",
  0x05bb,
  "qubuts31",
  0x05bb,
  "qubutshebrew",
  0x05bb,
  "qubutsnarrowhebrew",
  0x05bb,
  "qubutsquarterhebrew",
  0x05bb,
  "qubutswidehebrew",
  0x05bb,
  "question",
  0x003f,
  "questionarabic",
  0x061f,
  "questionarmenian",
  0x055e,
  "questiondown",
  0x00bf,
  "questiondownsmall",
  0xf7bf,
  "questiongreek",
  0x037e,
  "questionmonospace",
  0xff1f,
  "questionsmall",
  0xf73f,
  "quotedbl",
  0x0022,
  "quotedblbase",
  0x201e,
  "quotedblleft",
  0x201c,
  "quotedblmonospace",
  0xff02,
  "quotedblprime",
  0x301e,
  "quotedblprimereversed",
  0x301d,
  "quotedblright",
  0x201d,
  "quoteleft",
  0x2018,
  "quoteleftreversed",
  0x201b,
  "quotereversed",
  0x201b,
  "quoteright",
  0x2019,
  "quoterightn",
  0x0149,
  "quotesinglbase",
  0x201a,
  "quotesingle",
  0x0027,
  "quotesinglemonospace",
  0xff07,
  "r",
  0x0072,
  "raarmenian",
  0x057c,
  "rabengali",
  0x09b0,
  "racute",
  0x0155,
  "radeva",
  0x0930,
  "radical",
  0x221a,
  "radicalex",
  0xf8e5,
  "radoverssquare",
  0x33ae,
  "radoverssquaredsquare",
  0x33af,
  "radsquare",
  0x33ad,
  "rafe",
  0x05bf,
  "rafehebrew",
  0x05bf,
  "ragujarati",
  0x0ab0,
  "ragurmukhi",
  0x0a30,
  "rahiragana",
  0x3089,
  "rakatakana",
  0x30e9,
  "rakatakanahalfwidth",
  0xff97,
  "ralowerdiagonalbengali",
  0x09f1,
  "ramiddlediagonalbengali",
  0x09f0,
  "ramshorn",
  0x0264,
  "ratio",
  0x2236,
  "rbopomofo",
  0x3116,
  "rcaron",
  0x0159,
  "rcedilla",
  0x0157,
  "rcircle",
  0x24e1,
  "rcommaaccent",
  0x0157,
  "rdblgrave",
  0x0211,
  "rdotaccent",
  0x1e59,
  "rdotbelow",
  0x1e5b,
  "rdotbelowmacron",
  0x1e5d,
  "referencemark",
  0x203b,
  "reflexsubset",
  0x2286,
  "reflexsuperset",
  0x2287,
  "registered",
  0x00ae,
  "registersans",
  0xf8e8,
  "registerserif",
  0xf6da,
  "reharabic",
  0x0631,
  "reharmenian",
  0x0580,
  "rehfinalarabic",
  0xfeae,
  "rehiragana",
  0x308c,
  "rekatakana",
  0x30ec,
  "rekatakanahalfwidth",
  0xff9a,
  "resh",
  0x05e8,
  "reshdageshhebrew",
  0xfb48,
  "reshhebrew",
  0x05e8,
  "reversedtilde",
  0x223d,
  "reviahebrew",
  0x0597,
  "reviamugrashhebrew",
  0x0597,
  "revlogicalnot",
  0x2310,
  "rfishhook",
  0x027e,
  "rfishhookreversed",
  0x027f,
  "rhabengali",
  0x09dd,
  "rhadeva",
  0x095d,
  "rho",
  0x03c1,
  "rhook",
  0x027d,
  "rhookturned",
  0x027b,
  "rhookturnedsuperior",
  0x02b5,
  "rhosymbolgreek",
  0x03f1,
  "rhotichookmod",
  0x02de,
  "rieulacirclekorean",
  0x3271,
  "rieulaparenkorean",
  0x3211,
  "rieulcirclekorean",
  0x3263,
  "rieulhieuhkorean",
  0x3140,
  "rieulkiyeokkorean",
  0x313a,
  "rieulkiyeoksioskorean",
  0x3169,
  "rieulkorean",
  0x3139,
  "rieulmieumkorean",
  0x313b,
  "rieulpansioskorean",
  0x316c,
  "rieulparenkorean",
  0x3203,
  "rieulphieuphkorean",
  0x313f,
  "rieulpieupkorean",
  0x313c,
  "rieulpieupsioskorean",
  0x316b,
  "rieulsioskorean",
  0x313d,
  "rieulthieuthkorean",
  0x313e,
  "rieultikeutkorean",
  0x316a,
  "rieulyeorinhieuhkorean",
  0x316d,
  "rightangle",
  0x221f,
  "righttackbelowcmb",
  0x0319,
  "righttriangle",
  0x22bf,
  "rihiragana",
  0x308a,
  "rikatakana",
  0x30ea,
  "rikatakanahalfwidth",
  0xff98,
  "ring",
  0x02da,
  "ringbelowcmb",
  0x0325,
  "ringcmb",
  0x030a,
  "ringhalfleft",
  0x02bf,
  "ringhalfleftarmenian",
  0x0559,
  "ringhalfleftbelowcmb",
  0x031c,
  "ringhalfleftcentered",
  0x02d3,
  "ringhalfright",
  0x02be,
  "ringhalfrightbelowcmb",
  0x0339,
  "ringhalfrightcentered",
  0x02d2,
  "rinvertedbreve",
  0x0213,
  "rittorusquare",
  0x3351,
  "rlinebelow",
  0x1e5f,
  "rlongleg",
  0x027c,
  "rlonglegturned",
  0x027a,
  "rmonospace",
  0xff52,
  "rohiragana",
  0x308d,
  "rokatakana",
  0x30ed,
  "rokatakanahalfwidth",
  0xff9b,
  "roruathai",
  0x0e23,
  "rparen",
  0x24ad,
  "rrabengali",
  0x09dc,
  "rradeva",
  0x0931,
  "rragurmukhi",
  0x0a5c,
  "rreharabic",
  0x0691,
  "rrehfinalarabic",
  0xfb8d,
  "rrvocalicbengali",
  0x09e0,
  "rrvocalicdeva",
  0x0960,
  "rrvocalicgujarati",
  0x0ae0,
  "rrvocalicvowelsignbengali",
  0x09c4,
  "rrvocalicvowelsigndeva",
  0x0944,
  "rrvocalicvowelsigngujarati",
  0x0ac4,
  "rsuperior",
  0xf6f1,
  "rtblock",
  0x2590,
  "rturned",
  0x0279,
  "rturnedsuperior",
  0x02b4,
  "ruhiragana",
  0x308b,
  "rukatakana",
  0x30eb,
  "rukatakanahalfwidth",
  0xff99,
  "rupeemarkbengali",
  0x09f2,
  "rupeesignbengali",
  0x09f3,
  "rupiah",
  0xf6dd,
  "ruthai",
  0x0e24,
  "rvocalicbengali",
  0x098b,
  "rvocalicdeva",
  0x090b,
  "rvocalicgujarati",
  0x0a8b,
  "rvocalicvowelsignbengali",
  0x09c3,
  "rvocalicvowelsigndeva",
  0x0943,
  "rvocalicvowelsigngujarati",
  0x0ac3,
  "s",
  0x0073,
  "sabengali",
  0x09b8,
  "sacute",
  0x015b,
  "sacutedotaccent",
  0x1e65,
  "sadarabic",
  0x0635,
  "sadeva",
  0x0938,
  "sadfinalarabic",
  0xfeba,
  "sadinitialarabic",
  0xfebb,
  "sadmedialarabic",
  0xfebc,
  "sagujarati",
  0x0ab8,
  "sagurmukhi",
  0x0a38,
  "sahiragana",
  0x3055,
  "sakatakana",
  0x30b5,
  "sakatakanahalfwidth",
  0xff7b,
  "sallallahoualayhewasallamarabic",
  0xfdfa,
  "samekh",
  0x05e1,
  "samekhdagesh",
  0xfb41,
  "samekhdageshhebrew",
  0xfb41,
  "samekhhebrew",
  0x05e1,
  "saraaathai",
  0x0e32,
  "saraaethai",
  0x0e41,
  "saraaimaimalaithai",
  0x0e44,
  "saraaimaimuanthai",
  0x0e43,
  "saraamthai",
  0x0e33,
  "saraathai",
  0x0e30,
  "saraethai",
  0x0e40,
  "saraiileftthai",
  0xf886,
  "saraiithai",
  0x0e35,
  "saraileftthai",
  0xf885,
  "saraithai",
  0x0e34,
  "saraothai",
  0x0e42,
  "saraueeleftthai",
  0xf888,
  "saraueethai",
  0x0e37,
  "saraueleftthai",
  0xf887,
  "sarauethai",
  0x0e36,
  "sarauthai",
  0x0e38,
  "sarauuthai",
  0x0e39,
  "sbopomofo",
  0x3119,
  "scaron",
  0x0161,
  "scarondotaccent",
  0x1e67,
  "scedilla",
  0x015f,
  "schwa",
  0x0259,
  "schwacyrillic",
  0x04d9,
  "schwadieresiscyrillic",
  0x04db,
  "schwahook",
  0x025a,
  "scircle",
  0x24e2,
  "scircumflex",
  0x015d,
  "scommaaccent",
  0x0219,
  "sdotaccent",
  0x1e61,
  "sdotbelow",
  0x1e63,
  "sdotbelowdotaccent",
  0x1e69,
  "seagullbelowcmb",
  0x033c,
  "second",
  0x2033,
  "secondtonechinese",
  0x02ca,
  "section",
  0x00a7,
  "seenarabic",
  0x0633,
  "seenfinalarabic",
  0xfeb2,
  "seeninitialarabic",
  0xfeb3,
  "seenmedialarabic",
  0xfeb4,
  "segol",
  0x05b6,
  "segol13",
  0x05b6,
  "segol1f",
  0x05b6,
  "segol2c",
  0x05b6,
  "segolhebrew",
  0x05b6,
  "segolnarrowhebrew",
  0x05b6,
  "segolquarterhebrew",
  0x05b6,
  "segoltahebrew",
  0x0592,
  "segolwidehebrew",
  0x05b6,
  "seharmenian",
  0x057d,
  "sehiragana",
  0x305b,
  "sekatakana",
  0x30bb,
  "sekatakanahalfwidth",
  0xff7e,
  "semicolon",
  0x003b,
  "semicolonarabic",
  0x061b,
  "semicolonmonospace",
  0xff1b,
  "semicolonsmall",
  0xfe54,
  "semivoicedmarkkana",
  0x309c,
  "semivoicedmarkkanahalfwidth",
  0xff9f,
  "sentisquare",
  0x3322,
  "sentosquare",
  0x3323,
  "seven",
  0x0037,
  "sevenarabic",
  0x0667,
  "sevenbengali",
  0x09ed,
  "sevencircle",
  0x2466,
  "sevencircleinversesansserif",
  0x2790,
  "sevendeva",
  0x096d,
  "seveneighths",
  0x215e,
  "sevengujarati",
  0x0aed,
  "sevengurmukhi",
  0x0a6d,
  "sevenhackarabic",
  0x0667,
  "sevenhangzhou",
  0x3027,
  "sevenideographicparen",
  0x3226,
  "seveninferior",
  0x2087,
  "sevenmonospace",
  0xff17,
  "sevenoldstyle",
  0xf737,
  "sevenparen",
  0x247a,
  "sevenperiod",
  0x248e,
  "sevenpersian",
  0x06f7,
  "sevenroman",
  0x2176,
  "sevensuperior",
  0x2077,
  "seventeencircle",
  0x2470,
  "seventeenparen",
  0x2484,
  "seventeenperiod",
  0x2498,
  "seventhai",
  0x0e57,
  "sfthyphen",
  0x00ad,
  "shaarmenian",
  0x0577,
  "shabengali",
  0x09b6,
  "shacyrillic",
  0x0448,
  "shaddaarabic",
  0x0651,
  "shaddadammaarabic",
  0xfc61,
  "shaddadammatanarabic",
  0xfc5e,
  "shaddafathaarabic",
  0xfc60,
  "shaddakasraarabic",
  0xfc62,
  "shaddakasratanarabic",
  0xfc5f,
  "shade",
  0x2592,
  "shadedark",
  0x2593,
  "shadelight",
  0x2591,
  "shademedium",
  0x2592,
  "shadeva",
  0x0936,
  "shagujarati",
  0x0ab6,
  "shagurmukhi",
  0x0a36,
  "shalshelethebrew",
  0x0593,
  "shbopomofo",
  0x3115,
  "shchacyrillic",
  0x0449,
  "sheenarabic",
  0x0634,
  "sheenfinalarabic",
  0xfeb6,
  "sheeninitialarabic",
  0xfeb7,
  "sheenmedialarabic",
  0xfeb8,
  "sheicoptic",
  0x03e3,
  "sheqel",
  0x20aa,
  "sheqelhebrew",
  0x20aa,
  "sheva",
  0x05b0,
  "sheva115",
  0x05b0,
  "sheva15",
  0x05b0,
  "sheva22",
  0x05b0,
  "sheva2e",
  0x05b0,
  "shevahebrew",
  0x05b0,
  "shevanarrowhebrew",
  0x05b0,
  "shevaquarterhebrew",
  0x05b0,
  "shevawidehebrew",
  0x05b0,
  "shhacyrillic",
  0x04bb,
  "shimacoptic",
  0x03ed,
  "shin",
  0x05e9,
  "shindagesh",
  0xfb49,
  "shindageshhebrew",
  0xfb49,
  "shindageshshindot",
  0xfb2c,
  "shindageshshindothebrew",
  0xfb2c,
  "shindageshsindot",
  0xfb2d,
  "shindageshsindothebrew",
  0xfb2d,
  "shindothebrew",
  0x05c1,
  "shinhebrew",
  0x05e9,
  "shinshindot",
  0xfb2a,
  "shinshindothebrew",
  0xfb2a,
  "shinsindot",
  0xfb2b,
  "shinsindothebrew",
  0xfb2b,
  "shook",
  0x0282,
  "sigma",
  0x03c3,
  "sigma1",
  0x03c2,
  "sigmafinal",
  0x03c2,
  "sigmalunatesymbolgreek",
  0x03f2,
  "sihiragana",
  0x3057,
  "sikatakana",
  0x30b7,
  "sikatakanahalfwidth",
  0xff7c,
  "siluqhebrew",
  0x05bd,
  "siluqlefthebrew",
  0x05bd,
  "similar",
  0x223c,
  "sindothebrew",
  0x05c2,
  "siosacirclekorean",
  0x3274,
  "siosaparenkorean",
  0x3214,
  "sioscieuckorean",
  0x317e,
  "sioscirclekorean",
  0x3266,
  "sioskiyeokkorean",
  0x317a,
  "sioskorean",
  0x3145,
  "siosnieunkorean",
  0x317b,
  "siosparenkorean",
  0x3206,
  "siospieupkorean",
  0x317d,
  "siostikeutkorean",
  0x317c,
  "six",
  0x0036,
  "sixarabic",
  0x0666,
  "sixbengali",
  0x09ec,
  "sixcircle",
  0x2465,
  "sixcircleinversesansserif",
  0x278f,
  "sixdeva",
  0x096c,
  "sixgujarati",
  0x0aec,
  "sixgurmukhi",
  0x0a6c,
  "sixhackarabic",
  0x0666,
  "sixhangzhou",
  0x3026,
  "sixideographicparen",
  0x3225,
  "sixinferior",
  0x2086,
  "sixmonospace",
  0xff16,
  "sixoldstyle",
  0xf736,
  "sixparen",
  0x2479,
  "sixperiod",
  0x248d,
  "sixpersian",
  0x06f6,
  "sixroman",
  0x2175,
  "sixsuperior",
  0x2076,
  "sixteencircle",
  0x246f,
  "sixteencurrencydenominatorbengali",
  0x09f9,
  "sixteenparen",
  0x2483,
  "sixteenperiod",
  0x2497,
  "sixthai",
  0x0e56,
  "slash",
  0x002f,
  "slashmonospace",
  0xff0f,
  "slong",
  0x017f,
  "slongdotaccent",
  0x1e9b,
  "smileface",
  0x263a,
  "smonospace",
  0xff53,
  "sofpasuqhebrew",
  0x05c3,
  "softhyphen",
  0x00ad,
  "softsigncyrillic",
  0x044c,
  "sohiragana",
  0x305d,
  "sokatakana",
  0x30bd,
  "sokatakanahalfwidth",
  0xff7f,
  "soliduslongoverlaycmb",
  0x0338,
  "solidusshortoverlaycmb",
  0x0337,
  "sorusithai",
  0x0e29,
  "sosalathai",
  0x0e28,
  "sosothai",
  0x0e0b,
  "sosuathai",
  0x0e2a,
  "space",
  0x0020,
  "spacehackarabic",
  0x0020,
  "spade",
  0x2660,
  "spadesuitblack",
  0x2660,
  "spadesuitwhite",
  0x2664,
  "sparen",
  0x24ae,
  "squarebelowcmb",
  0x033b,
  "squarecc",
  0x33c4,
  "squarecm",
  0x339d,
  "squarediagonalcrosshatchfill",
  0x25a9,
  "squarehorizontalfill",
  0x25a4,
  "squarekg",
  0x338f,
  "squarekm",
  0x339e,
  "squarekmcapital",
  0x33ce,
  "squareln",
  0x33d1,
  "squarelog",
  0x33d2,
  "squaremg",
  0x338e,
  "squaremil",
  0x33d5,
  "squaremm",
  0x339c,
  "squaremsquared",
  0x33a1,
  "squareorthogonalcrosshatchfill",
  0x25a6,
  "squareupperlefttolowerrightfill",
  0x25a7,
  "squareupperrighttolowerleftfill",
  0x25a8,
  "squareverticalfill",
  0x25a5,
  "squarewhitewithsmallblack",
  0x25a3,
  "srsquare",
  0x33db,
  "ssabengali",
  0x09b7,
  "ssadeva",
  0x0937,
  "ssagujarati",
  0x0ab7,
  "ssangcieuckorean",
  0x3149,
  "ssanghieuhkorean",
  0x3185,
  "ssangieungkorean",
  0x3180,
  "ssangkiyeokkorean",
  0x3132,
  "ssangnieunkorean",
  0x3165,
  "ssangpieupkorean",
  0x3143,
  "ssangsioskorean",
  0x3146,
  "ssangtikeutkorean",
  0x3138,
  "ssuperior",
  0xf6f2,
  "sterling",
  0x00a3,
  "sterlingmonospace",
  0xffe1,
  "strokelongoverlaycmb",
  0x0336,
  "strokeshortoverlaycmb",
  0x0335,
  "subset",
  0x2282,
  "subsetnotequal",
  0x228a,
  "subsetorequal",
  0x2286,
  "succeeds",
  0x227b,
  "suchthat",
  0x220b,
  "suhiragana",
  0x3059,
  "sukatakana",
  0x30b9,
  "sukatakanahalfwidth",
  0xff7d,
  "sukunarabic",
  0x0652,
  "summation",
  0x2211,
  "sun",
  0x263c,
  "superset",
  0x2283,
  "supersetnotequal",
  0x228b,
  "supersetorequal",
  0x2287,
  "svsquare",
  0x33dc,
  "syouwaerasquare",
  0x337c,
  "t",
  0x0074,
  "tabengali",
  0x09a4,
  "tackdown",
  0x22a4,
  "tackleft",
  0x22a3,
  "tadeva",
  0x0924,
  "tagujarati",
  0x0aa4,
  "tagurmukhi",
  0x0a24,
  "taharabic",
  0x0637,
  "tahfinalarabic",
  0xfec2,
  "tahinitialarabic",
  0xfec3,
  "tahiragana",
  0x305f,
  "tahmedialarabic",
  0xfec4,
  "taisyouerasquare",
  0x337d,
  "takatakana",
  0x30bf,
  "takatakanahalfwidth",
  0xff80,
  "tatweelarabic",
  0x0640,
  "tau",
  0x03c4,
  "tav",
  0x05ea,
  "tavdages",
  0xfb4a,
  "tavdagesh",
  0xfb4a,
  "tavdageshhebrew",
  0xfb4a,
  "tavhebrew",
  0x05ea,
  "tbar",
  0x0167,
  "tbopomofo",
  0x310a,
  "tcaron",
  0x0165,
  "tccurl",
  0x02a8,
  "tcedilla",
  0x0163,
  "tcheharabic",
  0x0686,
  "tchehfinalarabic",
  0xfb7b,
  "tchehinitialarabic",
  0xfb7c,
  "tchehmedialarabic",
  0xfb7d,
  "tcircle",
  0x24e3,
  "tcircumflexbelow",
  0x1e71,
  "tcommaaccent",
  0x0163,
  "tdieresis",
  0x1e97,
  "tdotaccent",
  0x1e6b,
  "tdotbelow",
  0x1e6d,
  "tecyrillic",
  0x0442,
  "tedescendercyrillic",
  0x04ad,
  "teharabic",
  0x062a,
  "tehfinalarabic",
  0xfe96,
  "tehhahinitialarabic",
  0xfca2,
  "tehhahisolatedarabic",
  0xfc0c,
  "tehinitialarabic",
  0xfe97,
  "tehiragana",
  0x3066,
  "tehjeeminitialarabic",
  0xfca1,
  "tehjeemisolatedarabic",
  0xfc0b,
  "tehmarbutaarabic",
  0x0629,
  "tehmarbutafinalarabic",
  0xfe94,
  "tehmedialarabic",
  0xfe98,
  "tehmeeminitialarabic",
  0xfca4,
  "tehmeemisolatedarabic",
  0xfc0e,
  "tehnoonfinalarabic",
  0xfc73,
  "tekatakana",
  0x30c6,
  "tekatakanahalfwidth",
  0xff83,
  "telephone",
  0x2121,
  "telephoneblack",
  0x260e,
  "telishagedolahebrew",
  0x05a0,
  "telishaqetanahebrew",
  0x05a9,
  "tencircle",
  0x2469,
  "tenideographicparen",
  0x3229,
  "tenparen",
  0x247d,
  "tenperiod",
  0x2491,
  "tenroman",
  0x2179,
  "tesh",
  0x02a7,
  "tet",
  0x05d8,
  "tetdagesh",
  0xfb38,
  "tetdageshhebrew",
  0xfb38,
  "tethebrew",
  0x05d8,
  "tetsecyrillic",
  0x04b5,
  "tevirhebrew",
  0x059b,
  "tevirlefthebrew",
  0x059b,
  "thabengali",
  0x09a5,
  "thadeva",
  0x0925,
  "thagujarati",
  0x0aa5,
  "thagurmukhi",
  0x0a25,
  "thalarabic",
  0x0630,
  "thalfinalarabic",
  0xfeac,
  "thanthakhatlowleftthai",
  0xf898,
  "thanthakhatlowrightthai",
  0xf897,
  "thanthakhatthai",
  0x0e4c,
  "thanthakhatupperleftthai",
  0xf896,
  "theharabic",
  0x062b,
  "thehfinalarabic",
  0xfe9a,
  "thehinitialarabic",
  0xfe9b,
  "thehmedialarabic",
  0xfe9c,
  "thereexists",
  0x2203,
  "therefore",
  0x2234,
  "theta",
  0x03b8,
  "theta1",
  0x03d1,
  "thetasymbolgreek",
  0x03d1,
  "thieuthacirclekorean",
  0x3279,
  "thieuthaparenkorean",
  0x3219,
  "thieuthcirclekorean",
  0x326b,
  "thieuthkorean",
  0x314c,
  "thieuthparenkorean",
  0x320b,
  "thirteencircle",
  0x246c,
  "thirteenparen",
  0x2480,
  "thirteenperiod",
  0x2494,
  "thonangmonthothai",
  0x0e11,
  "thook",
  0x01ad,
  "thophuthaothai",
  0x0e12,
  "thorn",
  0x00fe,
  "thothahanthai",
  0x0e17,
  "thothanthai",
  0x0e10,
  "thothongthai",
  0x0e18,
  "thothungthai",
  0x0e16,
  "thousandcyrillic",
  0x0482,
  "thousandsseparatorarabic",
  0x066c,
  "thousandsseparatorpersian",
  0x066c,
  "three",
  0x0033,
  "threearabic",
  0x0663,
  "threebengali",
  0x09e9,
  "threecircle",
  0x2462,
  "threecircleinversesansserif",
  0x278c,
  "threedeva",
  0x0969,
  "threeeighths",
  0x215c,
  "threegujarati",
  0x0ae9,
  "threegurmukhi",
  0x0a69,
  "threehackarabic",
  0x0663,
  "threehangzhou",
  0x3023,
  "threeideographicparen",
  0x3222,
  "threeinferior",
  0x2083,
  "threemonospace",
  0xff13,
  "threenumeratorbengali",
  0x09f6,
  "threeoldstyle",
  0xf733,
  "threeparen",
  0x2476,
  "threeperiod",
  0x248a,
  "threepersian",
  0x06f3,
  "threequarters",
  0x00be,
  "threequartersemdash",
  0xf6de,
  "threeroman",
  0x2172,
  "threesuperior",
  0x00b3,
  "threethai",
  0x0e53,
  "thzsquare",
  0x3394,
  "tihiragana",
  0x3061,
  "tikatakana",
  0x30c1,
  "tikatakanahalfwidth",
  0xff81,
  "tikeutacirclekorean",
  0x3270,
  "tikeutaparenkorean",
  0x3210,
  "tikeutcirclekorean",
  0x3262,
  "tikeutkorean",
  0x3137,
  "tikeutparenkorean",
  0x3202,
  "tilde",
  0x02dc,
  "tildebelowcmb",
  0x0330,
  "tildecmb",
  0x0303,
  "tildecomb",
  0x0303,
  "tildedoublecmb",
  0x0360,
  "tildeoperator",
  0x223c,
  "tildeoverlaycmb",
  0x0334,
  "tildeverticalcmb",
  0x033e,
  "timescircle",
  0x2297,
  "tipehahebrew",
  0x0596,
  "tipehalefthebrew",
  0x0596,
  "tippigurmukhi",
  0x0a70,
  "titlocyrilliccmb",
  0x0483,
  "tiwnarmenian",
  0x057f,
  "tlinebelow",
  0x1e6f,
  "tmonospace",
  0xff54,
  "toarmenian",
  0x0569,
  "tohiragana",
  0x3068,
  "tokatakana",
  0x30c8,
  "tokatakanahalfwidth",
  0xff84,
  "tonebarextrahighmod",
  0x02e5,
  "tonebarextralowmod",
  0x02e9,
  "tonebarhighmod",
  0x02e6,
  "tonebarlowmod",
  0x02e8,
  "tonebarmidmod",
  0x02e7,
  "tonefive",
  0x01bd,
  "tonesix",
  0x0185,
  "tonetwo",
  0x01a8,
  "tonos",
  0x0384,
  "tonsquare",
  0x3327,
  "topatakthai",
  0x0e0f,
  "tortoiseshellbracketleft",
  0x3014,
  "tortoiseshellbracketleftsmall",
  0xfe5d,
  "tortoiseshellbracketleftvertical",
  0xfe39,
  "tortoiseshellbracketright",
  0x3015,
  "tortoiseshellbracketrightsmall",
  0xfe5e,
  "tortoiseshellbracketrightvertical",
  0xfe3a,
  "totaothai",
  0x0e15,
  "tpalatalhook",
  0x01ab,
  "tparen",
  0x24af,
  "trademark",
  0x2122,
  "trademarksans",
  0xf8ea,
  "trademarkserif",
  0xf6db,
  "tretroflexhook",
  0x0288,
  "triagdn",
  0x25bc,
  "triaglf",
  0x25c4,
  "triagrt",
  0x25ba,
  "triagup",
  0x25b2,
  "ts",
  0x02a6,
  "tsadi",
  0x05e6,
  "tsadidagesh",
  0xfb46,
  "tsadidageshhebrew",
  0xfb46,
  "tsadihebrew",
  0x05e6,
  "tsecyrillic",
  0x0446,
  "tsere",
  0x05b5,
  "tsere12",
  0x05b5,
  "tsere1e",
  0x05b5,
  "tsere2b",
  0x05b5,
  "tserehebrew",
  0x05b5,
  "tserenarrowhebrew",
  0x05b5,
  "tserequarterhebrew",
  0x05b5,
  "tserewidehebrew",
  0x05b5,
  "tshecyrillic",
  0x045b,
  "tsuperior",
  0xf6f3,
  "ttabengali",
  0x099f,
  "ttadeva",
  0x091f,
  "ttagujarati",
  0x0a9f,
  "ttagurmukhi",
  0x0a1f,
  "tteharabic",
  0x0679,
  "ttehfinalarabic",
  0xfb67,
  "ttehinitialarabic",
  0xfb68,
  "ttehmedialarabic",
  0xfb69,
  "tthabengali",
  0x09a0,
  "tthadeva",
  0x0920,
  "tthagujarati",
  0x0aa0,
  "tthagurmukhi",
  0x0a20,
  "tturned",
  0x0287,
  "tuhiragana",
  0x3064,
  "tukatakana",
  0x30c4,
  "tukatakanahalfwidth",
  0xff82,
  "tusmallhiragana",
  0x3063,
  "tusmallkatakana",
  0x30c3,
  "tusmallkatakanahalfwidth",
  0xff6f,
  "twelvecircle",
  0x246b,
  "twelveparen",
  0x247f,
  "twelveperiod",
  0x2493,
  "twelveroman",
  0x217b,
  "twentycircle",
  0x2473,
  "twentyhangzhou",
  0x5344,
  "twentyparen",
  0x2487,
  "twentyperiod",
  0x249b,
  "two",
  0x0032,
  "twoarabic",
  0x0662,
  "twobengali",
  0x09e8,
  "twocircle",
  0x2461,
  "twocircleinversesansserif",
  0x278b,
  "twodeva",
  0x0968,
  "twodotenleader",
  0x2025,
  "twodotleader",
  0x2025,
  "twodotleadervertical",
  0xfe30,
  "twogujarati",
  0x0ae8,
  "twogurmukhi",
  0x0a68,
  "twohackarabic",
  0x0662,
  "twohangzhou",
  0x3022,
  "twoideographicparen",
  0x3221,
  "twoinferior",
  0x2082,
  "twomonospace",
  0xff12,
  "twonumeratorbengali",
  0x09f5,
  "twooldstyle",
  0xf732,
  "twoparen",
  0x2475,
  "twoperiod",
  0x2489,
  "twopersian",
  0x06f2,
  "tworoman",
  0x2171,
  "twostroke",
  0x01bb,
  "twosuperior",
  0x00b2,
  "twothai",
  0x0e52,
  "twothirds",
  0x2154,
  "u",
  0x0075,
  "uacute",
  0x00fa,
  "ubar",
  0x0289,
  "ubengali",
  0x0989,
  "ubopomofo",
  0x3128,
  "ubreve",
  0x016d,
  "ucaron",
  0x01d4,
  "ucircle",
  0x24e4,
  "ucircumflex",
  0x00fb,
  "ucircumflexbelow",
  0x1e77,
  "ucyrillic",
  0x0443,
  "udattadeva",
  0x0951,
  "udblacute",
  0x0171,
  "udblgrave",
  0x0215,
  "udeva",
  0x0909,
  "udieresis",
  0x00fc,
  "udieresisacute",
  0x01d8,
  "udieresisbelow",
  0x1e73,
  "udieresiscaron",
  0x01da,
  "udieresiscyrillic",
  0x04f1,
  "udieresisgrave",
  0x01dc,
  "udieresismacron",
  0x01d6,
  "udotbelow",
  0x1ee5,
  "ugrave",
  0x00f9,
  "ugujarati",
  0x0a89,
  "ugurmukhi",
  0x0a09,
  "uhiragana",
  0x3046,
  "uhookabove",
  0x1ee7,
  "uhorn",
  0x01b0,
  "uhornacute",
  0x1ee9,
  "uhorndotbelow",
  0x1ef1,
  "uhorngrave",
  0x1eeb,
  "uhornhookabove",
  0x1eed,
  "uhorntilde",
  0x1eef,
  "uhungarumlaut",
  0x0171,
  "uhungarumlautcyrillic",
  0x04f3,
  "uinvertedbreve",
  0x0217,
  "ukatakana",
  0x30a6,
  "ukatakanahalfwidth",
  0xff73,
  "ukcyrillic",
  0x0479,
  "ukorean",
  0x315c,
  "umacron",
  0x016b,
  "umacroncyrillic",
  0x04ef,
  "umacrondieresis",
  0x1e7b,
  "umatragurmukhi",
  0x0a41,
  "umonospace",
  0xff55,
  "underscore",
  0x005f,
  "underscoredbl",
  0x2017,
  "underscoremonospace",
  0xff3f,
  "underscorevertical",
  0xfe33,
  "underscorewavy",
  0xfe4f,
  "union",
  0x222a,
  "universal",
  0x2200,
  "uogonek",
  0x0173,
  "uparen",
  0x24b0,
  "upblock",
  0x2580,
  "upperdothebrew",
  0x05c4,
  "upsilon",
  0x03c5,
  "upsilondieresis",
  0x03cb,
  "upsilondieresistonos",
  0x03b0,
  "upsilonlatin",
  0x028a,
  "upsilontonos",
  0x03cd,
  "uptackbelowcmb",
  0x031d,
  "uptackmod",
  0x02d4,
  "uragurmukhi",
  0x0a73,
  "uring",
  0x016f,
  "ushortcyrillic",
  0x045e,
  "usmallhiragana",
  0x3045,
  "usmallkatakana",
  0x30a5,
  "usmallkatakanahalfwidth",
  0xff69,
  "ustraightcyrillic",
  0x04af,
  "ustraightstrokecyrillic",
  0x04b1,
  "utilde",
  0x0169,
  "utildeacute",
  0x1e79,
  "utildebelow",
  0x1e75,
  "uubengali",
  0x098a,
  "uudeva",
  0x090a,
  "uugujarati",
  0x0a8a,
  "uugurmukhi",
  0x0a0a,
  "uumatragurmukhi",
  0x0a42,
  "uuvowelsignbengali",
  0x09c2,
  "uuvowelsigndeva",
  0x0942,
  "uuvowelsigngujarati",
  0x0ac2,
  "uvowelsignbengali",
  0x09c1,
  "uvowelsigndeva",
  0x0941,
  "uvowelsigngujarati",
  0x0ac1,
  "v",
  0x0076,
  "vadeva",
  0x0935,
  "vagujarati",
  0x0ab5,
  "vagurmukhi",
  0x0a35,
  "vakatakana",
  0x30f7,
  "vav",
  0x05d5,
  "vavdagesh",
  0xfb35,
  "vavdagesh65",
  0xfb35,
  "vavdageshhebrew",
  0xfb35,
  "vavhebrew",
  0x05d5,
  "vavholam",
  0xfb4b,
  "vavholamhebrew",
  0xfb4b,
  "vavvavhebrew",
  0x05f0,
  "vavyodhebrew",
  0x05f1,
  "vcircle",
  0x24e5,
  "vdotbelow",
  0x1e7f,
  "vecyrillic",
  0x0432,
  "veharabic",
  0x06a4,
  "vehfinalarabic",
  0xfb6b,
  "vehinitialarabic",
  0xfb6c,
  "vehmedialarabic",
  0xfb6d,
  "vekatakana",
  0x30f9,
  "venus",
  0x2640,
  "verticalbar",
  0x007c,
  "verticallineabovecmb",
  0x030d,
  "verticallinebelowcmb",
  0x0329,
  "verticallinelowmod",
  0x02cc,
  "verticallinemod",
  0x02c8,
  "vewarmenian",
  0x057e,
  "vhook",
  0x028b,
  "vikatakana",
  0x30f8,
  "viramabengali",
  0x09cd,
  "viramadeva",
  0x094d,
  "viramagujarati",
  0x0acd,
  "visargabengali",
  0x0983,
  "visargadeva",
  0x0903,
  "visargagujarati",
  0x0a83,
  "vmonospace",
  0xff56,
  "voarmenian",
  0x0578,
  "voicediterationhiragana",
  0x309e,
  "voicediterationkatakana",
  0x30fe,
  "voicedmarkkana",
  0x309b,
  "voicedmarkkanahalfwidth",
  0xff9e,
  "vokatakana",
  0x30fa,
  "vparen",
  0x24b1,
  "vtilde",
  0x1e7d,
  "vturned",
  0x028c,
  "vuhiragana",
  0x3094,
  "vukatakana",
  0x30f4,
  "w",
  0x0077,
  "wacute",
  0x1e83,
  "waekorean",
  0x3159,
  "wahiragana",
  0x308f,
  "wakatakana",
  0x30ef,
  "wakatakanahalfwidth",
  0xff9c,
  "wakorean",
  0x3158,
  "wasmallhiragana",
  0x308e,
  "wasmallkatakana",
  0x30ee,
  "wattosquare",
  0x3357,
  "wavedash",
  0x301c,
  "wavyunderscorevertical",
  0xfe34,
  "wawarabic",
  0x0648,
  "wawfinalarabic",
  0xfeee,
  "wawhamzaabovearabic",
  0x0624,
  "wawhamzaabovefinalarabic",
  0xfe86,
  "wbsquare",
  0x33dd,
  "wcircle",
  0x24e6,
  "wcircumflex",
  0x0175,
  "wdieresis",
  0x1e85,
  "wdotaccent",
  0x1e87,
  "wdotbelow",
  0x1e89,
  "wehiragana",
  0x3091,
  "weierstrass",
  0x2118,
  "wekatakana",
  0x30f1,
  "wekorean",
  0x315e,
  "weokorean",
  0x315d,
  "wgrave",
  0x1e81,
  "whitebullet",
  0x25e6,
  "whitecircle",
  0x25cb,
  "whitecircleinverse",
  0x25d9,
  "whitecornerbracketleft",
  0x300e,
  "whitecornerbracketleftvertical",
  0xfe43,
  "whitecornerbracketright",
  0x300f,
  "whitecornerbracketrightvertical",
  0xfe44,
  "whitediamond",
  0x25c7,
  "whitediamondcontainingblacksmalldiamond",
  0x25c8,
  "whitedownpointingsmalltriangle",
  0x25bf,
  "whitedownpointingtriangle",
  0x25bd,
  "whiteleftpointingsmalltriangle",
  0x25c3,
  "whiteleftpointingtriangle",
  0x25c1,
  "whitelenticularbracketleft",
  0x3016,
  "whitelenticularbracketright",
  0x3017,
  "whiterightpointingsmalltriangle",
  0x25b9,
  "whiterightpointingtriangle",
  0x25b7,
  "whitesmallsquare",
  0x25ab,
  "whitesmilingface",
  0x263a,
  "whitesquare",
  0x25a1,
  "whitestar",
  0x2606,
  "whitetelephone",
  0x260f,
  "whitetortoiseshellbracketleft",
  0x3018,
  "whitetortoiseshellbracketright",
  0x3019,
  "whiteuppointingsmalltriangle",
  0x25b5,
  "whiteuppointingtriangle",
  0x25b3,
  "wihiragana",
  0x3090,
  "wikatakana",
  0x30f0,
  "wikorean",
  0x315f,
  "wmonospace",
  0xff57,
  "wohiragana",
  0x3092,
  "wokatakana",
  0x30f2,
  "wokatakanahalfwidth",
  0xff66,
  "won",
  0x20a9,
  "wonmonospace",
  0xffe6,
  "wowaenthai",
  0x0e27,
  "wparen",
  0x24b2,
  "wring",
  0x1e98,
  "wsuperior",
  0x02b7,
  "wturned",
  0x028d,
  "wynn",
  0x01bf,
  "x",
  0x0078,
  "xabovecmb",
  0x033d,
  "xbopomofo",
  0x3112,
  "xcircle",
  0x24e7,
  "xdieresis",
  0x1e8d,
  "xdotaccent",
  0x1e8b,
  "xeharmenian",
  0x056d,
  "xi",
  0x03be,
  "xmonospace",
  0xff58,
  "xparen",
  0x24b3,
  "xsuperior",
  0x02e3,
  "y",
  0x0079,
  "yaadosquare",
  0x334e,
  "yabengali",
  0x09af,
  "yacute",
  0x00fd,
  "yadeva",
  0x092f,
  "yaekorean",
  0x3152,
  "yagujarati",
  0x0aaf,
  "yagurmukhi",
  0x0a2f,
  "yahiragana",
  0x3084,
  "yakatakana",
  0x30e4,
  "yakatakanahalfwidth",
  0xff94,
  "yakorean",
  0x3151,
  "yamakkanthai",
  0x0e4e,
  "yasmallhiragana",
  0x3083,
  "yasmallkatakana",
  0x30e3,
  "yasmallkatakanahalfwidth",
  0xff6c,
  "yatcyrillic",
  0x0463,
  "ycircle",
  0x24e8,
  "ycircumflex",
  0x0177,
  "ydieresis",
  0x00ff,
  "ydotaccent",
  0x1e8f,
  "ydotbelow",
  0x1ef5,
  "yeharabic",
  0x064a,
  "yehbarreearabic",
  0x06d2,
  "yehbarreefinalarabic",
  0xfbaf,
  "yehfinalarabic",
  0xfef2,
  "yehhamzaabovearabic",
  0x0626,
  "yehhamzaabovefinalarabic",
  0xfe8a,
  "yehhamzaaboveinitialarabic",
  0xfe8b,
  "yehhamzaabovemedialarabic",
  0xfe8c,
  "yehinitialarabic",
  0xfef3,
  "yehmedialarabic",
  0xfef4,
  "yehmeeminitialarabic",
  0xfcdd,
  "yehmeemisolatedarabic",
  0xfc58,
  "yehnoonfinalarabic",
  0xfc94,
  "yehthreedotsbelowarabic",
  0x06d1,
  "yekorean",
  0x3156,
  "yen",
  0x00a5,
  "yenmonospace",
  0xffe5,
  "yeokorean",
  0x3155,
  "yeorinhieuhkorean",
  0x3186,
  "yerahbenyomohebrew",
  0x05aa,
  "yerahbenyomolefthebrew",
  0x05aa,
  "yericyrillic",
  0x044b,
  "yerudieresiscyrillic",
  0x04f9,
  "yesieungkorean",
  0x3181,
  "yesieungpansioskorean",
  0x3183,
  "yesieungsioskorean",
  0x3182,
  "yetivhebrew",
  0x059a,
  "ygrave",
  0x1ef3,
  "yhook",
  0x01b4,
  "yhookabove",
  0x1ef7,
  "yiarmenian",
  0x0575,
  "yicyrillic",
  0x0457,
  "yikorean",
  0x3162,
  "yinyang",
  0x262f,
  "yiwnarmenian",
  0x0582,
  "ymonospace",
  0xff59,
  "yod",
  0x05d9,
  "yoddagesh",
  0xfb39,
  "yoddageshhebrew",
  0xfb39,
  "yodhebrew",
  0x05d9,
  "yodyodhebrew",
  0x05f2,
  "yodyodpatahhebrew",
  0xfb1f,
  "yohiragana",
  0x3088,
  "yoikorean",
  0x3189,
  "yokatakana",
  0x30e8,
  "yokatakanahalfwidth",
  0xff96,
  "yokorean",
  0x315b,
  "yosmallhiragana",
  0x3087,
  "yosmallkatakana",
  0x30e7,
  "yosmallkatakanahalfwidth",
  0xff6e,
  "yotgreek",
  0x03f3,
  "yoyaekorean",
  0x3188,
  "yoyakorean",
  0x3187,
  "yoyakthai",
  0x0e22,
  "yoyingthai",
  0x0e0d,
  "yparen",
  0x24b4,
  "ypogegrammeni",
  0x037a,
  "ypogegrammenigreekcmb",
  0x0345,
  "yr",
  0x01a6,
  "yring",
  0x1e99,
  "ysuperior",
  0x02b8,
  "ytilde",
  0x1ef9,
  "yturned",
  0x028e,
  "yuhiragana",
  0x3086,
  "yuikorean",
  0x318c,
  "yukatakana",
  0x30e6,
  "yukatakanahalfwidth",
  0xff95,
  "yukorean",
  0x3160,
  "yusbigcyrillic",
  0x046b,
  "yusbigiotifiedcyrillic",
  0x046d,
  "yuslittlecyrillic",
  0x0467,
  "yuslittleiotifiedcyrillic",
  0x0469,
  "yusmallhiragana",
  0x3085,
  "yusmallkatakana",
  0x30e5,
  "yusmallkatakanahalfwidth",
  0xff6d,
  "yuyekorean",
  0x318b,
  "yuyeokorean",
  0x318a,
  "yyabengali",
  0x09df,
  "yyadeva",
  0x095f,
  "z",
  0x007a,
  "zaarmenian",
  0x0566,
  "zacute",
  0x017a,
  "zadeva",
  0x095b,
  "zagurmukhi",
  0x0a5b,
  "zaharabic",
  0x0638,
  "zahfinalarabic",
  0xfec6,
  "zahinitialarabic",
  0xfec7,
  "zahiragana",
  0x3056,
  "zahmedialarabic",
  0xfec8,
  "zainarabic",
  0x0632,
  "zainfinalarabic",
  0xfeb0,
  "zakatakana",
  0x30b6,
  "zaqefgadolhebrew",
  0x0595,
  "zaqefqatanhebrew",
  0x0594,
  "zarqahebrew",
  0x0598,
  "zayin",
  0x05d6,
  "zayindagesh",
  0xfb36,
  "zayindageshhebrew",
  0xfb36,
  "zayinhebrew",
  0x05d6,
  "zbopomofo",
  0x3117,
  "zcaron",
  0x017e,
  "zcircle",
  0x24e9,
  "zcircumflex",
  0x1e91,
  "zcurl",
  0x0291,
  "zdot",
  0x017c,
  "zdotaccent",
  0x017c,
  "zdotbelow",
  0x1e93,
  "zecyrillic",
  0x0437,
  "zedescendercyrillic",
  0x0499,
  "zedieresiscyrillic",
  0x04df,
  "zehiragana",
  0x305c,
  "zekatakana",
  0x30bc,
  "zero",
  0x0030,
  "zeroarabic",
  0x0660,
  "zerobengali",
  0x09e6,
  "zerodeva",
  0x0966,
  "zerogujarati",
  0x0ae6,
  "zerogurmukhi",
  0x0a66,
  "zerohackarabic",
  0x0660,
  "zeroinferior",
  0x2080,
  "zeromonospace",
  0xff10,
  "zerooldstyle",
  0xf730,
  "zeropersian",
  0x06f0,
  "zerosuperior",
  0x2070,
  "zerothai",
  0x0e50,
  "zerowidthjoiner",
  0xfeff,
  "zerowidthnonjoiner",
  0x200c,
  "zerowidthspace",
  0x200b,
  "zeta",
  0x03b6,
  "zhbopomofo",
  0x3113,
  "zhearmenian",
  0x056a,
  "zhebrevecyrillic",
  0x04c2,
  "zhecyrillic",
  0x0436,
  "zhedescendercyrillic",
  0x0497,
  "zhedieresiscyrillic",
  0x04dd,
  "zihiragana",
  0x3058,
  "zikatakana",
  0x30b8,
  "zinorhebrew",
  0x05ae,
  "zlinebelow",
  0x1e95,
  "zmonospace",
  0xff5a,
  "zohiragana",
  0x305e,
  "zokatakana",
  0x30be,
  "zparen",
  0x24b5,
  "zretroflexhook",
  0x0290,
  "zstroke",
  0x01b6,
  "zuhiragana",
  0x305a,
  "zukatakana",
  0x30ba,
  ".notdef",
  0x0000,
  "angbracketleftbig",
  0x2329,
  "angbracketleftBig",
  0x2329,
  "angbracketleftbigg",
  0x2329,
  "angbracketleftBigg",
  0x2329,
  "angbracketrightBig",
  0x232a,
  "angbracketrightbig",
  0x232a,
  "angbracketrightBigg",
  0x232a,
  "angbracketrightbigg",
  0x232a,
  "arrowhookleft",
  0x21aa,
  "arrowhookright",
  0x21a9,
  "arrowlefttophalf",
  0x21bc,
  "arrowleftbothalf",
  0x21bd,
  "arrownortheast",
  0x2197,
  "arrownorthwest",
  0x2196,
  "arrowrighttophalf",
  0x21c0,
  "arrowrightbothalf",
  0x21c1,
  "arrowsoutheast",
  0x2198,
  "arrowsouthwest",
  0x2199,
  "backslashbig",
  0x2216,
  "backslashBig",
  0x2216,
  "backslashBigg",
  0x2216,
  "backslashbigg",
  0x2216,
  "bardbl",
  0x2016,
  "bracehtipdownleft",
  0xfe37,
  "bracehtipdownright",
  0xfe37,
  "bracehtipupleft",
  0xfe38,
  "bracehtipupright",
  0xfe38,
  "braceleftBig",
  0x007b,
  "braceleftbig",
  0x007b,
  "braceleftbigg",
  0x007b,
  "braceleftBigg",
  0x007b,
  "bracerightBig",
  0x007d,
  "bracerightbig",
  0x007d,
  "bracerightbigg",
  0x007d,
  "bracerightBigg",
  0x007d,
  "bracketleftbig",
  0x005b,
  "bracketleftBig",
  0x005b,
  "bracketleftbigg",
  0x005b,
  "bracketleftBigg",
  0x005b,
  "bracketrightBig",
  0x005d,
  "bracketrightbig",
  0x005d,
  "bracketrightbigg",
  0x005d,
  "bracketrightBigg",
  0x005d,
  "ceilingleftbig",
  0x2308,
  "ceilingleftBig",
  0x2308,
  "ceilingleftBigg",
  0x2308,
  "ceilingleftbigg",
  0x2308,
  "ceilingrightbig",
  0x2309,
  "ceilingrightBig",
  0x2309,
  "ceilingrightbigg",
  0x2309,
  "ceilingrightBigg",
  0x2309,
  "circledotdisplay",
  0x2299,
  "circledottext",
  0x2299,
  "circlemultiplydisplay",
  0x2297,
  "circlemultiplytext",
  0x2297,
  "circleplusdisplay",
  0x2295,
  "circleplustext",
  0x2295,
  "contintegraldisplay",
  0x222e,
  "contintegraltext",
  0x222e,
  "coproductdisplay",
  0x2210,
  "coproducttext",
  0x2210,
  "floorleftBig",
  0x230a,
  "floorleftbig",
  0x230a,
  "floorleftbigg",
  0x230a,
  "floorleftBigg",
  0x230a,
  "floorrightbig",
  0x230b,
  "floorrightBig",
  0x230b,
  "floorrightBigg",
  0x230b,
  "floorrightbigg",
  0x230b,
  "hatwide",
  0x0302,
  "hatwider",
  0x0302,
  "hatwidest",
  0x0302,
  "intercal",
  0x1d40,
  "integraldisplay",
  0x222b,
  "integraltext",
  0x222b,
  "intersectiondisplay",
  0x22c2,
  "intersectiontext",
  0x22c2,
  "logicalanddisplay",
  0x2227,
  "logicalandtext",
  0x2227,
  "logicalordisplay",
  0x2228,
  "logicalortext",
  0x2228,
  "parenleftBig",
  0x0028,
  "parenleftbig",
  0x0028,
  "parenleftBigg",
  0x0028,
  "parenleftbigg",
  0x0028,
  "parenrightBig",
  0x0029,
  "parenrightbig",
  0x0029,
  "parenrightBigg",
  0x0029,
  "parenrightbigg",
  0x0029,
  "prime",
  0x2032,
  "productdisplay",
  0x220f,
  "producttext",
  0x220f,
  "radicalbig",
  0x221a,
  "radicalBig",
  0x221a,
  "radicalBigg",
  0x221a,
  "radicalbigg",
  0x221a,
  "radicalbt",
  0x221a,
  "radicaltp",
  0x221a,
  "radicalvertex",
  0x221a,
  "slashbig",
  0x002f,
  "slashBig",
  0x002f,
  "slashBigg",
  0x002f,
  "slashbigg",
  0x002f,
  "summationdisplay",
  0x2211,
  "summationtext",
  0x2211,
  "tildewide",
  0x02dc,
  "tildewider",
  0x02dc,
  "tildewidest",
  0x02dc,
  "uniondisplay",
  0x22c3,
  "unionmultidisplay",
  0x228e,
  "unionmultitext",
  0x228e,
  "unionsqdisplay",
  0x2294,
  "unionsqtext",
  0x2294,
  "uniontext",
  0x22c3,
  "vextenddouble",
  0x2225,
  "vextendsingle",
  0x2223
 ];
});
const getDingbatsGlyphsUnicode = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () {
 return [
  "space",
  0x0020,
  "a1",
  0x2701,
  "a2",
  0x2702,
  "a202",
  0x2703,
  "a3",
  0x2704,
  "a4",
  0x260e,
  "a5",
  0x2706,
  "a119",
  0x2707,
  "a118",
  0x2708,
  "a117",
  0x2709,
  "a11",
  0x261b,
  "a12",
  0x261e,
  "a13",
  0x270c,
  "a14",
  0x270d,
  "a15",
  0x270e,
  "a16",
  0x270f,
  "a105",
  0x2710,
  "a17",
  0x2711,
  "a18",
  0x2712,
  "a19",
  0x2713,
  "a20",
  0x2714,
  "a21",
  0x2715,
  "a22",
  0x2716,
  "a23",
  0x2717,
  "a24",
  0x2718,
  "a25",
  0x2719,
  "a26",
  0x271a,
  "a27",
  0x271b,
  "a28",
  0x271c,
  "a6",
  0x271d,
  "a7",
  0x271e,
  "a8",
  0x271f,
  "a9",
  0x2720,
  "a10",
  0x2721,
  "a29",
  0x2722,
  "a30",
  0x2723,
  "a31",
  0x2724,
  "a32",
  0x2725,
  "a33",
  0x2726,
  "a34",
  0x2727,
  "a35",
  0x2605,
  "a36",
  0x2729,
  "a37",
  0x272a,
  "a38",
  0x272b,
  "a39",
  0x272c,
  "a40",
  0x272d,
  "a41",
  0x272e,
  "a42",
  0x272f,
  "a43",
  0x2730,
  "a44",
  0x2731,
  "a45",
  0x2732,
  "a46",
  0x2733,
  "a47",
  0x2734,
  "a48",
  0x2735,
  "a49",
  0x2736,
  "a50",
  0x2737,
  "a51",
  0x2738,
  "a52",
  0x2739,
  "a53",
  0x273a,
  "a54",
  0x273b,
  "a55",
  0x273c,
  "a56",
  0x273d,
  "a57",
  0x273e,
  "a58",
  0x273f,
  "a59",
  0x2740,
  "a60",
  0x2741,
  "a61",
  0x2742,
  "a62",
  0x2743,
  "a63",
  0x2744,
  "a64",
  0x2745,
  "a65",
  0x2746,
  "a66",
  0x2747,
  "a67",
  0x2748,
  "a68",
  0x2749,
  "a69",
  0x274a,
  "a70",
  0x274b,
  "a71",
  0x25cf,
  "a72",
  0x274d,
  "a73",
  0x25a0,
  "a74",
  0x274f,
  "a203",
  0x2750,
  "a75",
  0x2751,
  "a204",
  0x2752,
  "a76",
  0x25b2,
  "a77",
  0x25bc,
  "a78",
  0x25c6,
  "a79",
  0x2756,
  "a81",
  0x25d7,
  "a82",
  0x2758,
  "a83",
  0x2759,
  "a84",
  0x275a,
  "a97",
  0x275b,
  "a98",
  0x275c,
  "a99",
  0x275d,
  "a100",
  0x275e,
  "a101",
  0x2761,
  "a102",
  0x2762,
  "a103",
  0x2763,
  "a104",
  0x2764,
  "a106",
  0x2765,
  "a107",
  0x2766,
  "a108",
  0x2767,
  "a112",
  0x2663,
  "a111",
  0x2666,
  "a110",
  0x2665,
  "a109",
  0x2660,
  "a120",
  0x2460,
  "a121",
  0x2461,
  "a122",
  0x2462,
  "a123",
  0x2463,
  "a124",
  0x2464,
  "a125",
  0x2465,
  "a126",
  0x2466,
  "a127",
  0x2467,
  "a128",
  0x2468,
  "a129",
  0x2469,
  "a130",
  0x2776,
  "a131",
  0x2777,
  "a132",
  0x2778,
  "a133",
  0x2779,
  "a134",
  0x277a,
  "a135",
  0x277b,
  "a136",
  0x277c,
  "a137",
  0x277d,
  "a138",
  0x277e,
  "a139",
  0x277f,
  "a140",
  0x2780,
  "a141",
  0x2781,
  "a142",
  0x2782,
  "a143",
  0x2783,
  "a144",
  0x2784,
  "a145",
  0x2785,
  "a146",
  0x2786,
  "a147",
  0x2787,
  "a148",
  0x2788,
  "a149",
  0x2789,
  "a150",
  0x278a,
  "a151",
  0x278b,
  "a152",
  0x278c,
  "a153",
  0x278d,
  "a154",
  0x278e,
  "a155",
  0x278f,
  "a156",
  0x2790,
  "a157",
  0x2791,
  "a158",
  0x2792,
  "a159",
  0x2793,
  "a160",
  0x2794,
  "a161",
  0x2192,
  "a163",
  0x2194,
  "a164",
  0x2195,
  "a196",
  0x2798,
  "a165",
  0x2799,
  "a192",
  0x279a,
  "a166",
  0x279b,
  "a167",
  0x279c,
  "a168",
  0x279d,
  "a169",
  0x279e,
  "a170",
  0x279f,
  "a171",
  0x27a0,
  "a172",
  0x27a1,
  "a173",
  0x27a2,
  "a162",
  0x27a3,
  "a174",
  0x27a4,
  "a175",
  0x27a5,
  "a176",
  0x27a6,
  "a177",
  0x27a7,
  "a178",
  0x27a8,
  "a179",
  0x27a9,
  "a193",
  0x27aa,
  "a180",
  0x27ab,
  "a199",
  0x27ac,
  "a181",
  0x27ad,
  "a200",
  0x27ae,
  "a182",
  0x27af,
  "a201",
  0x27b1,
  "a183",
  0x27b2,
  "a184",
  0x27b3,
  "a197",
  0x27b4,
  "a185",
  0x27b5,
  "a194",
  0x27b6,
  "a198",
  0x27b7,
  "a186",
  0x27b8,
  "a195",
  0x27b9,
  "a187",
  0x27ba,
  "a188",
  0x27bb,
  "a189",
  0x27bc,
  "a190",
  0x27bd,
  "a191",
  0x27be,
  "a89",
  0x2768,
  "a90",
  0x2769,
  "a93",
  0x276a,
  "a94",
  0x276b,
  "a91",
  0x276c,
  "a92",
  0x276d,
  "a205",
  0x276e,
  "a85",
  0x276f,
  "a206",
  0x2770,
  "a86",
  0x2771,
  "a87",
  0x2772,
  "a88",
  0x2773,
  "a95",
  0x2774,
  "a96",
  0x2775,
  ".notdef",
  0x0000
 ];
});


/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __w_pdfjs_require__) => {

__w_pdfjs_require__.r(__webpack_exports__);
/* harmony export */ __w_pdfjs_require__.d(__webpack_exports__, {
/* harmony export */   "getNormalizedUnicodes": () => (/* binding */ getNormalizedUnicodes),
/* harmony export */   "getUnicodeForGlyph": () => (/* binding */ getUnicodeForGlyph),
/* harmony export */   "getUnicodeRangeFor": () => (/* binding */ getUnicodeRangeFor),
/* harmony export */   "mapSpecialUnicodeValues": () => (/* binding */ mapSpecialUnicodeValues),
/* harmony export */   "reverseIfRtl": () => (/* binding */ reverseIfRtl)
/* harmony export */ });
/* harmony import */ var _core_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __w_pdfjs_require__(9);

const getSpecialPUASymbols = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getLookupTableFactory)(function (t) {
 t[63721] = 0x00a9;
 t[63193] = 0x00a9;
 t[63720] = 0x00ae;
 t[63194] = 0x00ae;
 t[63722] = 0x2122;
 t[63195] = 0x2122;
 t[63729] = 0x23a7;
 t[63730] = 0x23a8;
 t[63731] = 0x23a9;
 t[63740] = 0x23ab;
 t[63741] = 0x23ac;
 t[63742] = 0x23ad;
 t[63726] = 0x23a1;
 t[63727] = 0x23a2;
 t[63728] = 0x23a3;
 t[63737] = 0x23a4;
 t[63738] = 0x23a5;
 t[63739] = 0x23a6;
 t[63723] = 0x239b;
 t[63724] = 0x239c;
 t[63725] = 0x239d;
 t[63734] = 0x239e;
 t[63735] = 0x239f;
 t[63736] = 0x23a0;
});
function mapSpecialUnicodeValues(code) {
 if (code >= 0xfff0 && code <= 0xffff) {
  return 0;
 } else if (code >= 0xf600 && code <= 0xf8ff) {
  return getSpecialPUASymbols()[code] || code;
 } else if (code === 0x00ad) {
  return 0x002d;
 }
 return code;
}
function getUnicodeForGlyph(name, glyphsUnicodeMap) {
 let unicode = glyphsUnicodeMap[name];
 if (unicode !== undefined) {
  return unicode;
 }
 if (!name) {
  return -1;
 }
 if (name[0] === "u") {
  const nameLen = name.length;
  let hexStr;
  if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
   hexStr = name.substring(3);
  } else if (nameLen >= 5 && nameLen <= 7) {
   hexStr = name.substring(1);
  } else {
   return -1;
  }
  if (hexStr === hexStr.toUpperCase()) {
   unicode = parseInt(hexStr, 16);
   if (unicode >= 0) {
    return unicode;
   }
  }
 }
 return -1;
}
const UnicodeRanges = [
 {
  begin: 0x0000,
  end: 0x007f
 },
 {
  begin: 0x0080,
  end: 0x00ff
 },
 {
  begin: 0x0100,
  end: 0x017f
 },
 {
  begin: 0x0180,
  end: 0x024f
 },
 {
  begin: 0x0250,
  end: 0x02af
 },
 {
  begin: 0x02b0,
  end: 0x02ff
 },
 {
  begin: 0x0300,
  end: 0x036f
 },
 {
  begin: 0x0370,
  end: 0x03ff
 },
 {
  begin: 0x2c80,
  end: 0x2cff
 },
 {
  begin: 0x0400,
  end: 0x04ff
 },
 {
  begin: 0x0530,
  end: 0x058f
 },
 {
  begin: 0x0590,
  end: 0x05ff
 },
 {
  begin: 0xa500,
  end: 0xa63f
 },
 {
  begin: 0x0600,
  end: 0x06ff
 },
 {
  begin: 0x07c0,
  end: 0x07ff
 },
 {
  begin: 0x0900,
  end: 0x097f
 },
 {
  begin: 0x0980,
  end: 0x09ff
 },
 {
  begin: 0x0a00,
  end: 0x0a7f
 },
 {
  begin: 0x0a80,
  end: 0x0aff
 },
 {
  begin: 0x0b00,
  end: 0x0b7f
 },
 {
  begin: 0x0b80,
  end: 0x0bff
 },
 {
  begin: 0x0c00,
  end: 0x0c7f
 },
 {
  begin: 0x0c80,
  end: 0x0cff
 },
 {
  begin: 0x0d00,
  end: 0x0d7f
 },
 {
  begin: 0x0e00,
  end: 0x0e7f
 },
 {
  begin: 0x0e80,
  end: 0x0eff
 },
 {
  begin: 0x10a0,
  end: 0x10ff
 },
 {
  begin: 0x1b00,
  end: 0x1b7f
 },
 {
  begin: 0x1100,
  end: 0x11ff
 },
 {
  begin: 0x1e00,
  end: 0x1eff
 },
 {
  begin: 0x1f00,
  end: 0x1fff
 },
 {
  begin: 0x2000,
  end: 0x206f
 },
 {
  begin: 0x2070,
  end: 0x209f
 },
 {
  begin: 0x20a0,
  end: 0x20cf
 },
 {
  begin: 0x20d0,
  end: 0x20ff
 },
 {
  begin: 0x2100,
  end: 0x214f
 },
 {
  begin: 0x2150,
  end: 0x218f
 },
 {
  begin: 0x2190,
  end: 0x21ff
 },
 {
  begin: 0x2200,
  end: 0x22ff
 },
 {
  begin: 0x2300,
  end: 0x23ff
 },
 {
  begin: 0x2400,
  end: 0x243f
 },
 {
  begin: 0x2440,
  end: 0x245f
 },
 {
  begin: 0x2460,
  end: 0x24ff
 },
 {
  begin: 0x2500,
  end: 0x257f
 },
 {
  begin: 0x2580,
  end: 0x259f
 },
 {
  begin: 0x25a0,
  end: 0x25ff
 },
 {
  begin: 0x2600,
  end: 0x26ff
 },
 {
  begin: 0x2700,
  end: 0x27bf
 },
 {
  begin: 0x3000,
  end: 0x303f
 },
 {
  begin: 0x3040,
  end: 0x309f
 },
 {
  begin: 0x30a0,
  end: 0x30ff
 },
 {
  begin: 0x3100,
  end: 0x312f
 },
 {
  begin: 0x3130,
  end: 0x318f
 },
 {
  begin: 0xa840,
  end: 0xa87f
 },
 {
  begin: 0x3200,
  end: 0x32ff
 },
 {
  begin: 0x3300,
  end: 0x33ff
 },
 {
  begin: 0xac00,
  end: 0xd7af
 },
 {
  begin: 0xd800,
  end: 0xdfff
 },
 {
  begin: 0x10900,
  end: 0x1091f
 },
 {
  begin: 0x4e00,
  end: 0x9fff
 },
 {
  begin: 0xe000,
  end: 0xf8ff
 },
 {
  begin: 0x31c0,
  end: 0x31ef
 },
 {
  begin: 0xfb00,
  end: 0xfb4f
 },
 {
  begin: 0xfb50,
  end: 0xfdff
 },
 {
  begin: 0xfe20,
  end: 0xfe2f
 },
 {
  begin: 0xfe10,
  end: 0xfe1f
 },
 {
  begin: 0xfe50,
  end: 0xfe6f
 },
 {
  begin: 0xfe70,
  end: 0xfeff
 },
 {
  begin: 0xff00,
  end: 0xffef
 },
 {
  begin: 0xfff0,
  end: 0xffff
 },
 {
  begin: 0x0f00,
  end: 0x0fff
 },
 {
  begin: 0x0700,
  end: 0x074f
 },
 {
  begin: 0x0780,
  end: 0x07bf
 },
 {
  begin: 0x0d80,
  end: 0x0dff
 },
 {
  begin: 0x1000,
  end: 0x109f
 },
 {
  begin: 0x1200,
  end: 0x137f
 },
 {
  begin: 0x13a0,
  end: 0x13ff
 },
 {
  begin: 0x1400,
  end: 0x167f
 },
 {
  begin: 0x1680,
  end: 0x169f
 },
 {
  begin: 0x16a0,
  end: 0x16ff
 },
 {
  begin: 0x1780,
  end: 0x17ff
 },
 {
  begin: 0x1800,
  end: 0x18af
 },
 {
  begin: 0x2800,
  end: 0x28ff
 },
 {
  begin: 0xa000,
  end: 0xa48f
 },
 {
  begin: 0x1700,
  end: 0x171f
 },
 {
  begin: 0x10300,
  end: 0x1032f
 },
 {
  begin: 0x10330,
  end: 0x1034f
 },
 {
  begin: 0x10400,
  end: 0x1044f
 },
 {
  begin: 0x1d000,
  end: 0x1d0ff
 },
 {
  begin: 0x1d400,
  end: 0x1d7ff
 },
 {
  begin: 0xff000,
  end: 0xffffd
 },
 {
  begin: 0xfe00,
  end: 0xfe0f
 },
 {
  begin: 0xe0000,
  end: 0xe007f
 },
 {
  begin: 0x1900,
  end: 0x194f
 },
 {
  begin: 0x1950,
  end: 0x197f
 },
 {
  begin: 0x1980,
  end: 0x19df
 },
 {
  begin: 0x1a00,
  end: 0x1a1f
 },
 {
  begin: 0x2c00,
  end: 0x2c5f
 },
 {
  begin: 0x2d30,
  end: 0x2d7f
 },
 {
  begin: 0x4dc0,
  end: 0x4dff
 },
 {
  begin: 0xa800,
  end: 0xa82f
 },
 {
  begin: 0x10000,
  end: 0x1007f
 },
 {
  begin: 0x10140,
  end: 0x1018f
 },
 {
  begin: 0x10380,
  end: 0x1039f
 },
 {
  begin: 0x103a0,
  end: 0x103df
 },
 {
  begin: 0x10450,
  end: 0x1047f
 },
 {
  begin: 0x10480,
  end: 0x104af
 },
 {
  begin: 0x10800,
  end: 0x1083f
 },
 {
  begin: 0x10a00,
  end: 0x10a5f
 },
 {
  begin: 0x1d300,
  end: 0x1d35f
 },
 {
  begin: 0x12000,
  end: 0x123ff
 },
 {
  begin: 0x1d360,
  end: 0x1d37f
 },
 {
  begin: 0x1b80,
  end: 0x1bbf
 },
 {
  begin: 0x1c00,
  end: 0x1c4f
 },
 {
  begin: 0x1c50,
  end: 0x1c7f
 },
 {
  begin: 0xa880,
  end: 0xa8df
 },
 {
  begin: 0xa900,
  end: 0xa92f
 },
 {
  begin: 0xa930,
  end: 0xa95f
 },
 {
  begin: 0xaa00,
  end: 0xaa5f
 },
 {
  begin: 0x10190,
  end: 0x101cf
 },
 {
  begin: 0x101d0,
  end: 0x101ff
 },
 {
  begin: 0x102a0,
  end: 0x102df
 },
 {
  begin: 0x1f030,
  end: 0x1f09f
 }
];
function getUnicodeRangeFor(value) {
 for (let i = 0, ii = UnicodeRanges.length; i < ii; i++) {
  const range = UnicodeRanges[i];
  if (value >= range.begin && value < range.end) {
   return i;
  }
 }
 return -1;
}
function isRTLRangeFor(value) {
 let range = UnicodeRanges[13];
 if (value >= range.begin && value < range.end) {
  return true;
 }
 range = UnicodeRanges[11];
 if (value >= range.begin && value < range.end) {
  return true;
 }
 return false;
}
const getNormalizedUnicodes = (0,_core_utils_js__WEBPACK_IMPORTED_MODULE_0__.getArrayLookupTableFactory)(function () {
 return [
  "\u00A8",
  "\u0020\u0308",
  "\u00AF",
  "\u0020\u0304",
  "\u00B4",
  "\u0020\u0301",
  "\u00B5",
  "\u03BC",
  "\u00B8",
  "\u0020\u0327",
  "\u0132",
  "\u0049\u004A",
  "\u0133",
  "\u0069\u006A",
  "\u013F",
  "\u004C\u00B7",
  "\u0140",
  "\u006C\u00B7",
  "\u0149",
  "\u02BC\u006E",
  "\u017F",
  "\u0073",
  "\u01C4",
  "\u0044\u017D",
  "\u01C5",
  "\u0044\u017E",
  "\u01C6",
  "\u0064\u017E",
  "\u01C7",
  "\u004C\u004A",
  "\u01C8",
  "\u004C\u006A",
  "\u01C9",
  "\u006C\u006A",
  "\u01CA",
  "\u004E\u004A",
  "\u01CB",
  "\u004E\u006A",
  "\u01CC",
  "\u006E\u006A",
  "\u01F1",
  "\u0044\u005A",
  "\u01F2",
  "\u0044\u007A",
  "\u01F3",
  "\u0064\u007A",
  "\u02D8",
  "\u0020\u0306",
  "\u02D9",
  "\u0020\u0307",
  "\u02DA",
  "\u0020\u030A",
  "\u02DB",
  "\u0020\u0328",
  "\u02DC",
  "\u0020\u0303",
  "\u02DD",
  "\u0020\u030B",
  "\u037A",
  "\u0020\u0345",
  "\u0384",
  "\u0020\u0301",
  "\u03D0",
  "\u03B2",
  "\u03D1",
  "\u03B8",
  "\u03D2",
  "\u03A5",
  "\u03D5",
  "\u03C6",
  "\u03D6",
  "\u03C0",
  "\u03F0",
  "\u03BA",
  "\u03F1",
  "\u03C1",
  "\u03F2",
  "\u03C2",
  "\u03F4",
  "\u0398",
  "\u03F5",
  "\u03B5",
  "\u03F9",
  "\u03A3",
  "\u0587",
  "\u0565\u0582",
  "\u0675",
  "\u0627\u0674",
  "\u0676",
  "\u0648\u0674",
  "\u0677",
  "\u06C7\u0674",
  "\u0678",
  "\u064A\u0674",
  "\u0E33",
  "\u0E4D\u0E32",
  "\u0EB3",
  "\u0ECD\u0EB2",
  "\u0EDC",
  "\u0EAB\u0E99",
  "\u0EDD",
  "\u0EAB\u0EA1",
  "\u0F77",
  "\u0FB2\u0F81",
  "\u0F79",
  "\u0FB3\u0F81",
  "\u1E9A",
  "\u0061\u02BE",
  "\u1FBD",
  "\u0020\u0313",
  "\u1FBF",
  "\u0020\u0313",
  "\u1FC0",
  "\u0020\u0342",
  "\u1FFE",
  "\u0020\u0314",
  "\u2002",
  "\u0020",
  "\u2003",
  "\u0020",
  "\u2004",
  "\u0020",
  "\u2005",
  "\u0020",
  "\u2006",
  "\u0020",
  "\u2008",
  "\u0020",
  "\u2009",
  "\u0020",
  "\u200A",
  "\u0020",
  "\u2017",
  "\u0020\u0333",
  "\u2024",
  "\u002E",
  "\u2025",
  "\u002E\u002E",
  "\u2026",
  "\u002E\u002E\u002E",
  "\u2033",
  "\u2032\u2032",
  "\u2034",
  "\u2032\u2032\u2032",
  "\u2036",
  "\u2035\u2035",
  "\u2037",
  "\u2035\u2035\u2035",
  "\u203C",
  "\u0021\u0021",
  "\u203E",
  "\u0020\u0305",
  "\u2047",
  "\u003F\u003F",
  "\u2048",
  "\u003F\u0021",
  "\u2049",
  "\u0021\u003F",
  "\u2057",
  "\u2032\u2032\u2032\u2032",
  "\u205F",
  "\u0020",
  "\u20A8",
  "\u0052\u0073",
  "\u2100",
  "\u0061\u002F\u0063",
  "\u2101",
  "\u0061\u002F\u0073",
  "\u2103",
  "\u00B0\u0043",
  "\u2105",
  "\u0063\u002F\u006F",
  "\u2106",
  "\u0063\u002F\u0075",
  "\u2107",
  "\u0190",
  "\u2109",
  "\u00B0\u0046",
  "\u2116",
  "\u004E\u006F",
  "\u2121",
  "\u0054\u0045\u004C",
  "\u2135",
  "\u05D0",
  "\u2136",
  "\u05D1",
  "\u2137",
  "\u05D2",
  "\u2138",
  "\u05D3",
  "\u213B",
  "\u0046\u0041\u0058",
  "\u2160",
  "\u0049",
  "\u2161",
  "\u0049\u0049",
  "\u2162",
  "\u0049\u0049\u0049",
  "\u2163",
  "\u0049\u0056",
  "\u2164",
  "\u0056",
  "\u2165",
  "\u0056\u0049",
  "\u2166",
  "\u0056\u0049\u0049",
  "\u2167",
  "\u0056\u0049\u0049\u0049",
  "\u2168",
  "\u0049\u0058",
  "\u2169",
  "\u0058",
  "\u216A",
  "\u0058\u0049",
  "\u216B",
  "\u0058\u0049\u0049",
  "\u216C",
  "\u004C",
  "\u216D",
  "\u0043",
  "\u216E",
  "\u0044",
  "\u216F",
  "\u004D",
  "\u2170",
  "\u0069",
  "\u2171",
  "\u0069\u0069",
  "\u2172",
  "\u0069\u0069\u0069",
  "\u2173",
  "\u0069\u0076",
  "\u2174",
  "\u0076",
  "\u2175",
  "\u0076\u0069",
  "\u2176",
  "\u0076\u0069\u0069",
  "\u2177",
  "\u0076\u0069\u0069\u0069",
  "\u2178",
  "\u0069\u0078",
  "\u2179",
  "\u0078",
  "\u217A",
  "\u0078\u0069",
  "\u217B",
  "\u0078\u0069\u0069",
  "\u217C",
  "\u006C",
  "\u217D",
  "\u0063",
  "\u217E",
  "\u0064",
  "\u217F",
  "\u006D",
  "\u222C",
  "\u222B\u222B",
  "\u222D",
  "\u222B\u222B\u222B",
  "\u222F",
  "\u222E\u222E",
  "\u2230",
  "\u222E\u222E\u222E",
  "\u2474",
  "\u0028\u0031\u0029",
  "\u2475",
  "\u0028\u0032\u0029",
  "\u2476",
  "\u0028\u0033\u0029",
  "\u2477",
  "\u0028\u0034\u0029",
  "\u2478",
  "\u0028\u0035\u0029",
  "\u2479",
  "\u0028\u0036\u0029",
  "\u247A",
  "\u0028\u0037\u0029",
  "\u247B",
  "\u0028\u0038\u0029",
  "\u247C",
  "\u0028\u0039\u0029",
  "\u247D",
  "\u0028\u0031\u0030\u0029",
  "\u247E",
  "\u0028\u0031\u0031\u0029",
  "\u247F",
  "\u0028\u0031\u0032\u0029",
  "\u2480",
  "\u0028\u0031\u0033\u0029",
  "\u2481",
  "\u0028\u0031\u0034\u0029",
  "\u2482",
  "\u0028\u0031\u0035\u0029",
  "\u2483",
  "\u0028\u0031\u0036\u0029",
  "\u2484",
  "\u0028\u0031\u0037\u0029",
  "\u2485",
  "\u0028\u0031\u0038\u0029",
  "\u2486",
  "\u0028\u0031\u0039\u0029",
  "\u2487",
  "\u0028\u0032\u0030\u0029",
  "\u2488",
  "\u0031\u002E",
  "\u2489",
  "\u0032\u002E",
  "\u248A",
  "\u0033\u002E",
  "\u248B",
  "\u0034\u002E",
  "\u248C",
  "\u0035\u002E",
  "\u248D",
  "\u0036\u002E",
  "\u248E",
  "\u0037\u002E",
  "\u248F",
  "\u0038\u002E",
  "\u2490",
  "\u0039\u002E",
  "\u2491",
  "\u0031\u0030\u002E",
  "\u2492",
  "\u0031\u0031\u002E",
  "\u2493",
  "\u0031\u0032\u002E",
  "\u2494",
  "\u0031\u0033\u002E",
  "\u2495",
  "\u0031\u0034\u002E",
  "\u2496",
  "\u0031\u0035\u002E",
  "\u2497",
  "\u0031\u0036\u002E",
  "\u2498",
  "\u0031\u0037\u002E",
  "\u2499",
  "\u0031\u0038\u002E",
  "\u249A",
  "\u0031\u0039\u002E",
  "\u249B",
  "\u0032\u0030\u002E",
  "\u249C",
  "\u0028\u0061\u0029",
  "\u249D",
  "\u0028\u0062\u0029",
  "\u249E",
  "\u0028\u0063\u0029",
  "\u249F",
  "\u0028\u0064\u0029",
  "\u24A0",
  "\u0028\u0065\u0029",
  "\u24A1",
  "\u0028\u0066\u0029",
  "\u24A2",
  "\u0028\u0067\u0029",
  "\u24A3",
  "\u0028\u0068\u0029",
  "\u24A4",
  "\u0028\u0069\u0029",
  "\u24A5",
  "\u0028\u006A\u0029",
  "\u24A6",
  "\u0028\u006B\u0029",
  "\u24A7",
  "\u0028\u006C\u0029",
  "\u24A8",
  "\u0028\u006D\u0029",
  "\u24A9",
  "\u0028\u006E\u0029",
  "\u24AA",
  "\u0028\u006F\u0029",
  "\u24AB",
  "\u0028\u0070\u0029",
  "\u24AC",
  "\u0028\u0071\u0029",
  "\u24AD",
  "\u0028\u0072\u0029",
  "\u24AE",
  "\u0028\u0073\u0029",
  "\u24AF",
  "\u0028\u0074\u0029",
  "\u24B0",
  "\u0028\u0075\u0029",
  "\u24B1",
  "\u0028\u0076\u0029",
  "\u24B2",
  "\u0028\u0077\u0029",
  "\u24B3",
  "\u0028\u0078\u0029",
  "\u24B4",
  "\u0028\u0079\u0029",
  "\u24B5",
  "\u0028\u007A\u0029",
  "\u2A0C",
  "\u222B\u222B\u222B\u222B",
  "\u2A74",
  "\u003A\u003A\u003D",
  "\u2A75",
  "\u003D\u003D",
  "\u2A76",
  "\u003D\u003D\u003D",
  "\u2E9F",
  "\u6BCD",
  "\u2EF3",
  "\u9F9F",
  "\u2F00",
  "\u4E00",
  "\u2F01",
  "\u4E28",
  "\u2F02",
  "\u4E36",
  "\u2F03",
  "\u4E3F",
  "\u2F04",
  "\u4E59",
  "\u2F05",
  "\u4E85",
  "\u2F06",
  "\u4E8C",
  "\u2F07",
  "\u4EA0",
  "\u2F08",
  "\u4EBA",
  "\u2F09",
  "\u513F",
  "\u2F0A",
  "\u5165",
  "\u2F0B",
  "\u516B",
  "\u2F0C",
  "\u5182",
  "\u2F0D",
  "\u5196",
  "\u2F0E",
  "\u51AB",
  "\u2F0F",
  "\u51E0",
  "\u2F10",
  "\u51F5",
  "\u2F11",
  "\u5200",
  "\u2F12",
  "\u529B",
  "\u2F13",
  "\u52F9",
  "\u2F14",
  "\u5315",
  "\u2F15",
  "\u531A",
  "\u2F16",
  "\u5338",
  "\u2F17",
  "\u5341",
  "\u2F18",
  "\u535C",
  "\u2F19",
  "\u5369",
  "\u2F1A",
  "\u5382",
  "\u2F1B",
  "\u53B6",
  "\u2F1C",
  "\u53C8",
  "\u2F1D",
  "\u53E3",
  "\u2F1E",
  "\u56D7",
  "\u2F1F",
  "\u571F",
  "\u2F20",
  "\u58EB",
  "\u2F21",
  "\u5902",
  "\u2F22",
  "\u590A",
  "\u2F23",
  "\u5915",
  "\u2F24",
  "\u5927",
  "\u2F25",
  "\u5973",
  "\u2F26",
  "\u5B50",
  "\u2F27",
  "\u5B80",
  "\u2F28",
  "\u5BF8",
  "\u2F29",
  "\u5C0F",
  "\u2F2A",
  "\u5C22",
  "\u2F2B",
  "\u5C38",
  "\u2F2C",
  "\u5C6E",
  "\u2F2D",
  "\u5C71",
  "\u2F2E",
  "\u5DDB",
  "\u2F2F",
  "\u5DE5",
  "\u2F30",
  "\u5DF1",
  "\u2F31",
  "\u5DFE",
  "\u2F32",
  "\u5E72",
  "\u2F33",
  "\u5E7A",
  "\u2F34",
  "\u5E7F",
  "\u2F35",
  "\u5EF4",
  "\u2F36",
  "\u5EFE",
  "\u2F37",
  "\u5F0B",
  "\u2F38",
  "\u5F13",
  "\u2F39",
  "\u5F50",
  "\u2F3A",
  "\u5F61",
  "\u2F3B",
  "\u5F73",
  "\u2F3C",
  "\u5FC3",
  "\u2F3D",
  "\u6208",
  "\u2F3E",
  "\u6236",
  "\u2F3F",
  "\u624B",
  "\u2F40",
  "\u652F",
  "\u2F41",
  "\u6534",
  "\u2F42",
  "\u6587",
  "\u2F43",
  "\u6597",
  "\u2F44",
  "\u65A4",
  "\u2F45",
  "\u65B9",
  "\u2F46",
  "\u65E0",
  "\u2F47",
  "\u65E5",
  "\u2F48",
  "\u66F0",
  "\u2F49",
  "\u6708",
  "\u2F4A",
  "\u6728",
  "\u2F4B",
  "\u6B20",
  "\u2F4C",
  "\u6B62",
  "\u2F4D",
  "\u6B79",
  "\u2F4E",
  "\u6BB3",
  "\u2F4F",
  "\u6BCB",
  "\u2F50",
  "\u6BD4",
  "\u2F51",
  "\u6BDB",
  "\u2F52",
  "\u6C0F",
  "\u2F53",
  "\u6C14",
  "\u2F54",
  "\u6C34",
  "\u2F55",
  "\u706B",
  "\u2F56",
  "\u722A",
  "\u2F57",
  "\u7236",
  "\u2F58",
  "\u723B",
  "\u2F59",
  "\u723F",
  "\u2F5A",
  "\u7247",
  "\u2F5B",
  "\u7259",
  "\u2F5C",
  "\u725B",
  "\u2F5D",
  "\u72AC",
  "\u2F5E",
  "\u7384",
  "\u2F5F",
  "\u7389",
  "\u2F60",
  "\u74DC",
  "\u2F61",
  "\u74E6",
  "\u2F62",
  "\u7518",
  "\u2F63",
  "\u751F",
  "\u2F64",
  "\u7528",
  "\u2F65",
  "\u7530",
  "\u2F66",
  "\u758B",
  "\u2F67",
  "\u7592",
  "\u2F68",
  "\u7676",
  "\u2F69",
  "\u767D",
  "\u2F6A",
  "\u76AE",
  "\u2F6B",
  "\u76BF",
  "\u2F6C",
  "\u76EE",
  "\u2F6D",
  "\u77DB",
  "\u2F6E",
  "\u77E2",
  "\u2F6F",
  "\u77F3",
  "\u2F70",
  "\u793A",
  "\u2F71",
  "\u79B8",
  "\u2F72",
  "\u79BE",
  "\u2F73",
  "\u7A74",
  "\u2F74",
  "\u7ACB",
  "\u2F75",
  "\u7AF9",
  "\u2F76",
  "\u7C73",
  "\u2F77",
  "\u7CF8",
  "\u2F78",
  "\u7F36",
  "\u2F79",
  "\u7F51",
  "\u2F7A",
  "\u7F8A",
  "\u2F7B",
  "\u7FBD",
  "\u2F7C",
  "\u8001",
  "\u2F7D",
  "\u800C",
  "\u2F7E",
  "\u8012",
  "\u2F7F",
  "\u8033",
  "\u2F80",
  "\u807F",
  "\u2F81",
  "\u8089",
  "\u2F82",
  "\u81E3",
  "\u2F83",
  "\u81EA",
  "\u2F84",
  "\u81F3",
  "\u2F85",
  "\u81FC",
  "\u2F86",
  "\u820C",
  "\u2F87",
  "\u821B",
  "\u2F88",
  "\u821F",
  "\u2F89",
  "\u826E",
  "\u2F8A",
  "\u8272",
  "\u2F8B",
  "\u8278",
  "\u2F8C",
  "\u864D",
  "\u2F8D",
  "\u866B",
  "\u2F8E",
  "\u8840",
  "\u2F8F",
  "\u884C",
  "\u2F90",
  "\u8863",
  "\u2F91",
  "\u897E",
  "\u2F92",
  "\u898B",
  "\u2F93",
  "\u89D2",
  "\u2F94",
  "\u8A00",
  "\u2F95",
  "\u8C37",
  "\u2F96",
  "\u8C46",
  "\u2F97",
  "\u8C55",
  "\u2F98",
  "\u8C78",
  "\u2F99",
  "\u8C9D",
  "\u2F9A",
  "\u8D64",
  "\u2F9B",
  "\u8D70",
  "\u2F9C",
  "\u8DB3",
  "\u2F9D",
  "\u8EAB",
  "\u2F9E",
  "\u8ECA",
  "\u2F9F",
  "\u8F9B",
  "\u2FA0",
  "\u8FB0",
  "\u2FA1",
  "\u8FB5",
  "\u2FA2",
  "\u9091",
  "\u2FA3",
  "\u9149",
  "\u2FA4",
  "\u91C6",
  "\u2FA5",
  "\u91CC",
  "\u2FA6",
  "\u91D1",
  "\u2FA7",
  "\u9577",
  "\u2FA8",
  "\u9580",
  "\u2FA9",
  "\u961C",
  "\u2FAA",
  "\u96B6",
  "\u2FAB",
  "\u96B9",
  "\u2FAC",
  "\u96E8",
  "\u2FAD",
  "\u9751",
  "\u2FAE",
  "\u975E",
  "\u2FAF",
  "\u9762",
  "\u2FB0",
  "\u9769",
  "\u2FB1",
  "\u97CB",
  "\u2FB2",
  "\u97ED",
  "\u2FB3",
  "\u97F3",
  "\u2FB4",
  "\u9801",
  "\u2FB5",
  "\u98A8",
  "\u2FB6",
  "\u98DB",
  "\u2FB7",
  "\u98DF",
  "\u2FB8",
  "\u9996",
  "\u2FB9",
  "\u9999",
  "\u2FBA",
  "\u99AC",
  "\u2FBB",
  "\u9AA8",
  "\u2FBC",
  "\u9AD8",
  "\u2FBD",
  "\u9ADF",
  "\u2FBE",
  "\u9B25",
  "\u2FBF",
  "\u9B2F",
  "\u2FC0",
  "\u9B32",
  "\u2FC1",
  "\u9B3C",
  "\u2FC2",
  "\u9B5A",
  "\u2FC3",
  "\u9CE5",
  "\u2FC4",
  "\u9E75",
  "\u2FC5",
  "\u9E7F",
  "\u2FC6",
  "\u9EA5",
  "\u2FC7",
  "\u9EBB",
  "\u2FC8",
  "\u9EC3",
  "\u2FC9",
  "\u9ECD",
  "\u2FCA",
  "\u9ED1",
  "\u2FCB",
  "\u9EF9",
  "\u2FCC",
  "\u9EFD",
  "\u2FCD",
  "\u9F0E",
  "\u2FCE",
  "\u9F13",
  "\u2FCF",
  "\u9F20",
  "\u2FD0",
  "\u9F3B",
  "\u2FD1",
  "\u9F4A",
  "\u2FD2",
  "\u9F52",
  "\u2FD3",
  "\u9F8D",
  "\u2FD4",
  "\u9F9C",
  "\u2FD5",
  "\u9FA0",
  "\u3036",
  "\u3012",
  "\u3038",
  "\u5341",
  "\u3039",
  "\u5344",
  "\u303A",
  "\u5345",
  "\u309B",
  "\u0020\u3099",
  "\u309C",
  "\u0020\u309A",
  "\u3131",
  "\u1100",
  "\u3132",
  "\u1101",
  "\u3133",
  "\u11AA",
  "\u3134",
  "\u1102",
  "\u3135",
  "\u11AC",
  "\u3136",
  "\u11AD",
  "\u3137",
  "\u1103",
  "\u3138",
  "\u1104",
  "\u3139",
  "\u1105",
  "\u313A",
  "\u11B0",
  "\u313B",
  "\u11B1",
  "\u313C",
  "\u11B2",
  "\u313D",
  "\u11B3",
  "\u313E",
  "\u11B4",
  "\u313F",
  "\u11B5",
  "\u3140",
  "\u111A",
  "\u3141",
  "\u1106",
  "\u3142",
  "\u1107",
  "\u3143",
  "\u1108",
  "\u3144",
  "\u1121",
  "\u3145",
  "\u1109",
  "\u3146",
  "\u110A",
  "\u3147",
  "\u110B",
  "\u3148",
  "\u110C",
  "\u3149",
  "\u110D",
  "\u314A",
  "\u110E",
  "\u314B",
  "\u110F",
  "\u314C",
  "\u1110",
  "\u314D",
  "\u1111",
  "\u314E",
  "\u1112",
  "\u314F",
  "\u1161",
  "\u3150",
  "\u1162",
  "\u3151",
  "\u1163",
  "\u3152",
  "\u1164",
  "\u3153",
  "\u1165",
  "\u3154",
  "\u1166",
  "\u3155",
  "\u1167",
  "\u3156",
  "\u1168",
  "\u3157",
  "\u1169",
  "\u3158",
  "\u116A",
  "\u3159",
  "\u116B",
  "\u315A",
  "\u116C",
  "\u315B",
  "\u116D",
  "\u315C",
  "\u116E",
  "\u315D",
  "\u116F",
  "\u315E",
  "\u1170",
  "\u315F",
  "\u1171",
  "\u3160",
  "\u1172",
  "\u3161",
  "\u1173",
  "\u3162",
  "\u1174",
  "\u3163",
  "\u1175",
  "\u3164",
  "\u1160",
  "\u3165",
  "\u1114",
  "\u3166",
  "\u1115",
  "\u3167",
  "\u11C7",
  "\u3168",
  "\u11C8",
  "\u3169",
  "\u11CC",
  "\u316A",
  "\u11CE",
  "\u316B",
  "\u11D3",
  "\u316C",
  "\u11D7",
  "\u316D",
  "\u11D9",
  "\u316E",
  "\u111C",
  "\u316F",
  "\u11DD",
  "\u3170",
  "\u11DF",
  "\u3171",
  "\u111D",
  "\u3172",
  "\u111E",
  "\u3173",
  "\u1120",
  "\u3174",
  "\u1122",
  "\u3175",
  "\u1123",
  "\u3176",
  "\u1127",
  "\u3177",
  "\u1129",
  "\u3178",
  "\u112B",
  "\u3179",
  "\u112C",
  "\u317A",
  "\u112D",
  "\u317B",
  "\u112E",
  "\u317C",
  "\u112F",
  "\u317D",
  "\u1132",
  "\u317E",
  "\u1136",
  "\u317F",
  "\u1140",
  "\u3180",
  "\u1147",
  "\u3181",
  "\u114C",
  "\u3182",
  "\u11F1",
  "\u3183",
  "\u11F2",
  "\u3184",
  "\u1157",
  "\u3185",
  "\u1158",
  "\u3186",
  "\u1159",
  "\u3187",
  "\u1184",
  "\u3188",
  "\u1185",
  "\u3189",
  "\u1188",
  "\u318A",
  "\u1191",
  "\u318B",
  "\u1192",
  "\u318C",
  "\u1194",
  "\u318D",
  "\u119E",
  "\u318E",
  "\u11A1",
  "\u3200",
  "\u0028\u1100\u0029",
  "\u3201",
  "\u0028\u1102\u0029",
  "\u3202",
  "\u0028\u1103\u0029",
  "\u3203",
  "\u0028\u1105\u0029",
  "\u3204",
  "\u0028\u1106\u0029",
  "\u3205",
  "\u0028\u1107\u0029",
  "\u3206",
  "\u0028\u1109\u0029",
  "\u3207",
  "\u0028\u110B\u0029",
  "\u3208",
  "\u0028\u110C\u0029",
  "\u3209",
  "\u0028\u110E\u0029",
  "\u320A",
  "\u0028\u110F\u0029",
  "\u320B",
  "\u0028\u1110\u0029",
  "\u320C",
  "\u0028\u1111\u0029",
  "\u320D",
  "\u0028\u1112\u0029",
  "\u320E",
  "\u0028\u1100\u1161\u0029",
  "\u320F",
  "\u0028\u1102\u1161\u0029",
  "\u3210",
  "\u0028\u1103\u1161\u0029",
  "\u3211",
  "\u0028\u1105\u1161\u0029",
  "\u3212",
  "\u0028\u1106\u1161\u0029",
  "\u3213",
  "\u0028\u1107\u1161\u0029",
  "\u3214",
  "\u0028\u1109\u1161\u0029",
  "\u3215",
  "\u0028\u110B\u1161\u0029",
  "\u3216",
  "\u0028\u110C\u1161\u0029",
  "\u3217",
  "\u0028\u110E\u1161\u0029",
  "\u3218",
  "\u0028\u110F\u1161\u0029",
  "\u3219",
  "\u0028\u1110\u1161\u0029",
  "\u321A",
  "\u0028\u1111\u1161\u0029",
  "\u321B",
  "\u0028\u1112\u1161\u0029",
  "\u321C",
  "\u0028\u110C\u116E\u0029",
  "\u321D",
  "\u0028\u110B\u1169\u110C\u1165\u11AB\u0029",
  "\u321E",
  "\u0028\u110B\u1169\u1112\u116E\u0029",
  "\u3220",
  "\u0028\u4E00\u0029",
  "\u3221",
  "\u0028\u4E8C\u0029",
  "\u3222",
  "\u0028\u4E09\u0029",
  "\u3223",
  "\u0028\u56DB\u0029",
  "\u3224",
  "\u0028\u4E94\u0029",
  "\u3225",
  "\u0028\u516D\u0029",
  "\u3226",
  "\u0028\u4E03\u0029",
  "\u3227",
  "\u0028\u516B\u0029",
  "\u3228",
  "\u0028\u4E5D\u0029",
  "\u3229",
  "\u0028\u5341\u0029",
  "\u322A",
  "\u0028\u6708\u0029",
  "\u322B",
  "\u0028\u706B\u0029",
  "\u322C",
  "\u0028\u6C34\u0029",
  "\u322D",
  "\u0028\u6728\u0029",
  "\u322E",
  "\u0028\u91D1\u0029",
  "\u322F",
  "\u0028\u571F\u0029",
  "\u3230",
  "\u0028\u65E5\u0029",
  "\u3231",
  "\u0028\u682A\u0029",
  "\u3232",
  "\u0028\u6709\u0029",
  "\u3233",
  "\u0028\u793E\u0029",
  "\u3234",
  "\u0028\u540D\u0029",
  "\u3235",
  "\u0028\u7279\u0029",
  "\u3236",
  "\u0028\u8CA1\u0029",
  "\u3237",
  "\u0028\u795D\u0029",
  "\u3238",
  "\u0028\u52B4\u0029",
  "\u3239",
  "\u0028\u4EE3\u0029",
  "\u323A",
  "\u0028\u547C\u0029",
  "\u323B",
  "\u0028\u5B66\u0029",
  "\u323C",
  "\u0028\u76E3\u0029",
  "\u323D",
  "\u0028\u4F01\u0029",
  "\u323E",
  "\u0028\u8CC7\u0029",
  "\u323F",
  "\u0028\u5354\u0029",
  "\u3240",
  "\u0028\u796D\u0029",
  "\u3241",
  "\u0028\u4F11\u0029",
  "\u3242",
  "\u0028\u81EA\u0029",
  "\u3243",
  "\u0028\u81F3\u0029",
  "\u32C0",
  "\u0031\u6708",
  "\u32C1",
  "\u0032\u6708",
  "\u32C2",
  "\u0033\u6708",
  "\u32C3",
  "\u0034\u6708",
  "\u32C4",
  "\u0035\u6708",
  "\u32C5",
  "\u0036\u6708",
  "\u32C6",
  "\u0037\u6708",
  "\u32C7",
  "\u0038\u6708",
  "\u32C8",
  "\u0039\u6708",
  "\u32C9",
  "\u0031\u0030\u6708",
  "\u32CA",
  "\u0031\u0031\u6708",
  "\u32CB",
  "\u0031\u0032\u6708",
  "\u3358",
  "\u0030\u70B9",
  "\u3359",
  "\u0031\u70B9",
  "\u335A",
  "\u0032\u70B9",
  "\u335B",
  "\u0033\u70B9",
  "\u335C",
  "\u0034\u70B9",
  "\u335D",
  "\u0035\u70B9",
  "\u335E",
  "\u0036\u70B9",
  "\u335F",
  "\u0037\u70B9",
  "\u3360",
  "\u0038\u70B9",
  "\u3361",
  "\u0039\u70B9",
  "\u3362",
  "\u0031\u0030\u70B9",
  "\u3363",
  "\u0031\u0031\u70B9",
  "\u3364",
  "\u0031\u0032\u70B9",
  "\u3365",
  "\u0031\u0033\u70B9",
  "\u3366",
  "\u0031\u0034\u70B9",
  "\u3367",
  "\u0031\u0035\u70B9",
  "\u3368",
  "\u0031\u0036\u70B9",
  "\u3369",
  "\u0031\u0037\u70B9",
  "\u336A",
  "\u0031\u0038\u70B9",
  "\u336B",
  "\u0031\u0039\u70B9",
  "\u336C",
  "\u0032\u0030\u70B9",
  "\u336D",
  "\u0032\u0031\u70B9",
  "\u336E",
  "\u0032\u0032\u70B9",
  "\u336F",
  "\u0032\u0033\u70B9",
  "\u3370",
  "\u0032\u0034\u70B9",
  "\u33E0",
  "\u0031\u65E5",
  "\u33E1",
  "\u0032\u65E5",
  "\u33E2",
  "\u0033\u65E5",
  "\u33E3",
  "\u0034\u65E5",
  "\u33E4",
  "\u0035\u65E5",
  "\u33E5",
  "\u0036\u65E5",
  "\u33E6",
  "\u0037\u65E5",
  "\u33E7",
  "\u0038\u65E5",
  "\u33E8",
  "\u0039\u65E5",
  "\u33E9",
  "\u0031\u0030\u65E5",
  "\u33EA",
  "\u0031\u0031\u65E5",
  "\u33EB",
  "\u0031\u0032\u65E5",
  "\u33EC",
  "\u0031\u0033\u65E5",
  "\u33ED",
  "\u0031\u0034\u65E5",
  "\u33EE",
  "\u0031\u0035\u65E5",
  "\u33EF",
  "\u0031\u0036\u65E5",
  "\u33F0",
  "\u0031\u0037\u65E5",
  "\u33F1",
  "\u0031\u0038\u65E5",
  "\u33F2",
  "\u0031\u0039\u65E5",
  "\u33F3",
  "\u0032\u0030\u65E5",
  "\u33F4",
  "\u0032\u0031\u65E5",
  "\u33F5",
  "\u0032\u0032\u65E5",
  "\u33F6",
  "\u0032\u0033\u65E5",
  "\u33F7",
  "\u0032\u0034\u65E5",
  "\u33F8",
  "\u0032\u0035\u65E5",
  "\u33F9",
  "\u0032\u0036\u65E5",
  "\u33FA",
  "\u0032\u0037\u65E5",
  "\u33FB",
  "\u0032\u0038\u65E5",
  "\u33FC",
  "\u0032\u0039\u65E5",
  "\u33FD",
  "\u0033\u0030\u65E5",
  "\u33FE",
  "\u0033\u0031\u65E5",
  "\uFB00",
  "\u0066\u0066",
  "\uFB01",
  "\u0066\u0069",
  "\uFB02",
  "\u0066\u006C",
  "\uFB03",
  "\u0066\u0066\u0069",
  "\uFB04",
  "\u0066\u0066\u006C",
  "\uFB05",
  "\u017F\u0074",
  "\uFB06",
  "\u0073\u0074",
  "\uFB13",
  "\u0574\u0576",
  "\uFB14",
  "\u0574\u0565",
  "\uFB15",
  "\u0574\u056B",
  "\uFB16",
  "\u057E\u0576",
  "\uFB17",
  "\u0574\u056D",
  "\uFB4F",
  "\u05D0\u05DC",
  "\uFB50",
  "\u0671",
  "\uFB51",
  "\u0671",
  "\uFB52",
  "\u067B",
  "\uFB53",
  "\u067B",
  "\uFB54",
  "\u067B",
  "\uFB55",
  "\u067B",
  "\uFB56",
  "\u067E",
  "\uFB57",
  "\u067E",
  "\uFB58",
  "\u067E",
  "\uFB59",
  "\u067E",
  "\uFB5A",
  "\u0680",
  "\uFB5B",
  "\u0680",
  "\uFB5C",
  "\u0680",
  "\uFB5D",
  "\u0680",
  "\uFB5E",
  "\u067A",
  "\uFB5F",
  "\u067A",
  "\uFB60",
  "\u067A",
  "\uFB61",
  "\u067A",
  "\uFB62",
  "\u067F",
  "\uFB63",
  "\u067F",
  "\uFB64",
  "\u067F",
  "\uFB65",
  "\u067F",
  "\uFB66",
  "\u0679",
  "\uFB67",
  "\u0679",
  "\uFB68",
  "\u0679",
  "\uFB69",
  "\u0679",
  "\uFB6A",
  "\u06A4",
  "\uFB6B",
  "\u06A4",
  "\uFB6C",
  "\u06A4",
  "\uFB6D",
  "\u06A4",
  "\uFB6E",
  "\u06A6",
  "\uFB6F",
  "\u06A6",
  "\uFB70",
  "\u06A6",
  "\uFB71",
  "\u06A6",
  "\uFB72",
  "\u0684",
  "\uFB73",
  "\u0684",
  "\uFB74",
  "\u0684",
  "\uFB75",
  "\u0684",
  "\uFB76",
  "\u0683",
  "\uFB77",
  "\u0683",
  "\uFB78",
  "\u0683",
  "\uFB79",
  "\u0683",
  "\uFB7A",
  "\u0686",
  "\uFB7B",
  "\u0686",
  "\uFB7C",
  "\u0686",
  "\uFB7D",
  "\u0686",
  "\uFB7E",
  "\u0687",
  "\uFB7F",
  "\u0687",
  "\uFB80",
  "\u0687",
  "\uFB81",
  "\u0687",
  "\uFB82",
  "\u068D",
  "\uFB83",
  "\u068D",
  "\uFB84",
  "\u068C",
  "\uFB85",
  "\u068C",
  "\uFB86",
  "\u068E",
  "\uFB87",
  "\u068E",
  "\uFB88",
  "\u0688",
  "\uFB89",
  "\u0688",
  "\uFB8A",
  "\u0698",
  "\uFB8B",
  "\u0698",
  "\uFB8C",
  "\u0691",
  "\uFB8D",
  "\u0691",
  "\uFB8E",
  "\u06A9",
  "\uFB8F",
  "\u06A9",
  "\uFB90",
  "\u06A9",
  "\uFB91",
  "\u06A9",
  "\uFB92",
  "\u06AF",
  "\uFB93",
  "\u06AF",
  "\uFB94",
  "\u06AF",
  "\uFB95",
  "\u06AF",
  "\uFB96",
  "\u06B3",
  "\uFB97",
  "\u06B3",
  "\uFB98",
  "\u06B3",
  "\uFB99",
  "\u06B3",
  "\uFB9A",
  "\u06B1",
  "\uFB9B",
  "\u06B1",
  "\uFB9C",
  "\u06B1",
  "\uFB9D",
  "\u06B1",
  "\uFB9E",
  "\u06BA",
  "\uFB9F",
  "\u06BA",
  "\uFBA0",
  "\u06BB",
  "\uFBA1",
  "\u06BB",
  "\uFBA2",
  "\u06BB",
  "\uFBA3",
  "\u06BB",
  "\uFBA4",
  "\u06C0",
  "\uFBA5",
  "\u06C0",
  "\uFBA6",
  "\u06C1",
  "\uFBA7",
  "\u06C1",
  "\uFBA8",
  "\u06C1",
  "\uFBA9",
  "\u06C1",
  "\uFBAA",
  "\u06BE",
  "\uFBAB",
  "\u06BE",
  "\uFBAC",
  "\u06BE",
  "\uFBAD",
  "\u06BE",
  "\uFBAE",
  "\u06D2",
  "\uFBAF",
  "\u06D2",
  "\uFBB0",
  "\u06D3",
  "\uFBB1",
  "\u06D3",
  "\uFBD3",
  "\u06AD",
  "\uFBD4",
  "\u06AD",
  "\uFBD5",
  "\u06AD",
  "\uFBD6",
  "\u06AD",
  "\uFBD7",
  "\u06C7",
  "\uFBD8",
  "\u06C7",
  "\uFBD9",
  "\u06C6",
  "\uFBDA",
  "\u06C6",
  "\uFBDB",
  "\u06C8",
  "\uFBDC",
  "\u06C8",
  "\uFBDD",
  "\u0677",
  "\uFBDE",
  "\u06CB",
  "\uFBDF",
  "\u06CB",
  "\uFBE0",
  "\u06C5",
  "\uFBE1",
  "\u06C5",
  "\uFBE2",
  "\u06C9",
  "\uFBE3",
  "\u06C9",
  "\uFBE4",
  "\u06D0",
  "\uFBE5",
  "\u06D0",
  "\uFBE6",
  "\u06D0",
  "\uFBE7",
  "\u06D0",
  "\uFBE8",
  "\u0649",
  "\uFBE9",
  "\u0649",
  "\uFBEA",
  "\u0626\u0627",
  "\uFBEB",
  "\u0626\u0627",
  "\uFBEC",
  "\u0626\u06D5",
  "\uFBED",
  "\u0626\u06D5",
  "\uFBEE",
  "\u0626\u0648",
  "\uFBEF",
  "\u0626\u0648",
  "\uFBF0",
  "\u0626\u06C7",
  "\uFBF1",
  "\u0626\u06C7",
  "\uFBF2",
  "\u0626\u06C6",
  "\uFBF3",
  "\u0626\u06C6",
  "\uFBF4",
  "\u0626\u06C8",
  "\uFBF5",
  "\u0626\u06C8",
  "\uFBF6",
  "\u0626\u06D0",
  "\uFBF7",
  "\u0626\u06D0",
  "\uFBF8",
  "\u0626\u06D0",
  "\uFBF9",
  "\u0626\u0649",
  "\uFBFA",
  "\u0626\u0649",
  "\uFBFB",
  "\u0626\u0649",
  "\uFBFC",
  "\u06CC",
  "\uFBFD",
  "\u06CC",
  "\uFBFE",
  "\u06CC",
  "\uFBFF",
  "\u06CC",
  "\uFC00",
  "\u0626\u062C",
  "\uFC01",
  "\u0626\u062D",
  "\uFC02",
  "\u0626\u0645",
  "\uFC03",
  "\u0626\u0649",
  "\uFC04",
  "\u0626\u064A",
  "\uFC05",
  "\u0628\u062C",
  "\uFC06",
  "\u0628\u062D",
  "\uFC07",
  "\u0628\u062E",
  "\uFC08",
  "\u0628\u0645",
  "\uFC09",
  "\u0628\u0649",
  "\uFC0A",
  "\u0628\u064A",
  "\uFC0B",
  "\u062A\u062C",
  "\uFC0C",
  "\u062A\u062D",
  "\uFC0D",
  "\u062A\u062E",
  "\uFC0E",
  "\u062A\u0645",
  "\uFC0F",
  "\u062A\u0649",
  "\uFC10",
  "\u062A\u064A",
  "\uFC11",
  "\u062B\u062C",
  "\uFC12",
  "\u062B\u0645",
  "\uFC13",
  "\u062B\u0649",
  "\uFC14",
  "\u062B\u064A",
  "\uFC15",
  "\u062C\u062D",
  "\uFC16",
  "\u062C\u0645",
  "\uFC17",
  "\u062D\u062C",
  "\uFC18",
  "\u062D\u0645",
  "\uFC19",
  "\u062E\u062C",
  "\uFC1A",
  "\u062E\u062D",
  "\uFC1B",
  "\u062E\u0645",
  "\uFC1C",
  "\u0633\u062C",
  "\uFC1D",
  "\u0633\u062D",
  "\uFC1E",
  "\u0633\u062E",
  "\uFC1F",
  "\u0633\u0645",
  "\uFC20",
  "\u0635\u062D",
  "\uFC21",
  "\u0635\u0645",
  "\uFC22",
  "\u0636\u062C",
  "\uFC23",
  "\u0636\u062D",
  "\uFC24",
  "\u0636\u062E",
  "\uFC25",
  "\u0636\u0645",
  "\uFC26",
  "\u0637\u062D",
  "\uFC27",
  "\u0637\u0645",
  "\uFC28",
  "\u0638\u0645",
  "\uFC29",
  "\u0639\u062C",
  "\uFC2A",
  "\u0639\u0645",
  "\uFC2B",
  "\u063A\u062C",
  "\uFC2C",
  "\u063A\u0645",
  "\uFC2D",
  "\u0641\u062C",
  "\uFC2E",
  "\u0641\u062D",
  "\uFC2F",
  "\u0641\u062E",
  "\uFC30",
  "\u0641\u0645",
  "\uFC31",
  "\u0641\u0649",
  "\uFC32",
  "\u0641\u064A",
  "\uFC33",
  "\u0642\u062D",
  "\uFC34",
  "\u0642\u0645",
  "\uFC35",
  "\u0642\u0649",
  "\uFC36",
  "\u0642\u064A",
  "\uFC37",
  "\u0643\u0627",
  "\uFC38",
  "\u0643\u062C",
  "\uFC39",
  "\u0643\u062D",
  "\uFC3A",
  "\u0643\u062E",
  "\uFC3B",
  "\u0643\u0644",
  "\uFC3C",
  "\u0643\u0645",
  "\uFC3D",
  "\u0643\u0649",
  "\uFC3E",
  "\u0643\u064A",
  "\uFC3F",
  "\u0644\u062C",
  "\uFC40",
  "\u0644\u062D",
  "\uFC41",
  "\u0644\u062E",
  "\uFC42",
  "\u0644\u0645",
  "\uFC43",
  "\u0644\u0649",
  "\uFC44",
  "\u0644\u064A",
  "\uFC45",
  "\u0645\u062C",
  "\uFC46",
  "\u0645\u062D",
  "\uFC47",
  "\u0645\u062E",
  "\uFC48",
  "\u0645\u0645",
  "\uFC49",
  "\u0645\u0649",
  "\uFC4A",
  "\u0645\u064A",
  "\uFC4B",
  "\u0646\u062C",
  "\uFC4C",
  "\u0646\u062D",
  "\uFC4D",
  "\u0646\u062E",
  "\uFC4E",
  "\u0646\u0645",
  "\uFC4F",
  "\u0646\u0649",
  "\uFC50",
  "\u0646\u064A",
  "\uFC51",
  "\u0647\u062C",
  "\uFC52",
  "\u0647\u0645",
  "\uFC53",
  "\u0647\u0649",
  "\uFC54",
  "\u0647\u064A",
  "\uFC55",
  "\u064A\u062C",
  "\uFC56",
  "\u064A\u062D",
  "\uFC57",
  "\u064A\u062E",
  "\uFC58",
  "\u064A\u0645",
  "\uFC59",
  "\u064A\u0649",
  "\uFC5A",
  "\u064A\u064A",
  "\uFC5B",
  "\u0630\u0670",
  "\uFC5C",
  "\u0631\u0670",
  "\uFC5D",
  "\u0649\u0670",
  "\uFC5E",
  "\u0020\u064C\u0651",
  "\uFC5F",
  "\u0020\u064D\u0651",
  "\uFC60",
  "\u0020\u064E\u0651",
  "\uFC61",
  "\u0020\u064F\u0651",
  "\uFC62",
  "\u0020\u0650\u0651",
  "\uFC63",
  "\u0020\u0651\u0670",
  "\uFC64",
  "\u0626\u0631",
  "\uFC65",
  "\u0626\u0632",
  "\uFC66",
  "\u0626\u0645",
  "\uFC67",
  "\u0626\u0646",
  "\uFC68",
  "\u0626\u0649",
  "\uFC69",
  "\u0626\u064A",
  "\uFC6A",
  "\u0628\u0631",
  "\uFC6B",
  "\u0628\u0632",
  "\uFC6C",
  "\u0628\u0645",
  "\uFC6D",
  "\u0628\u0646",
  "\uFC6E",
  "\u0628\u0649",
  "\uFC6F",
  "\u0628\u064A",
  "\uFC70",
  "\u062A\u0631",
  "\uFC71",
  "\u062A\u0632",
  "\uFC72",
  "\u062A\u0645",
  "\uFC73",
  "\u062A\u0646",
  "\uFC74",
  "\u062A\u0649",
  "\uFC75",
  "\u062A\u064A",
  "\uFC76",
  "\u062B\u0631",
  "\uFC77",
  "\u062B\u0632",
  "\uFC78",
  "\u062B\u0645",
  "\uFC79",
  "\u062B\u0646",
  "\uFC7A",
  "\u062B\u0649",
  "\uFC7B",
  "\u062B\u064A",
  "\uFC7C",
  "\u0641\u0649",
  "\uFC7D",
  "\u0641\u064A",
  "\uFC7E",
  "\u0642\u0649",
  "\uFC7F",
  "\u0642\u064A",
  "\uFC80",
  "\u0643\u0627",
  "\uFC81",
  "\u0643\u0644",
  "\uFC82",
  "\u0643\u0645",
  "\uFC83",
  "\u0643\u0649",
  "\uFC84",
  "\u0643\u064A",
  "\uFC85",
  "\u0644\u0645",
  "\uFC86",
  "\u0644\u0649",
  "\uFC87",
  "\u0644\u064A",
  "\uFC88",
  "\u0645\u0627",
  "\uFC89",
  "\u0645\u0645",
  "\uFC8A",
  "\u0646\u0631",
  "\uFC8B",
  "\u0646\u0632",
  "\uFC8C",
  "\u0646\u0645",
  "\uFC8D",
  "\u0646\u0646",
  "\uFC8E",
  "\u0646\u0649",
  "\uFC8F",
  "\u0646\u064A",
  "\uFC90",
  "\u0649\u0670",
  "\uFC91",
  "\u064A\u0631",
  "\uFC92",
  "\u064A\u0632",
  "\uFC93",
  "\u064A\u0645",
  "\uFC94",
  "\u064A\u0646",
  "\uFC95",
  "\u064A\u0649",
  "\uFC96",
  "\u064A\u064A",
  "\uFC97",
  "\u0626\u062C",
  "\uFC98",
  "\u0626\u062D",
  "\uFC99",
  "\u0626\u062E",
  "\uFC9A",
  "\u0626\u0645",
  "\uFC9B",
  "\u0626\u0647",
  "\uFC9C",
  "\u0628\u062C",
  "\uFC9D",
  "\u0628\u062D",
  "\uFC9E",
  "\u0628\u062E",
  "\uFC9F",
  "\u0628\u0645",
  "\uFCA0",
  "\u0628\u0647",
  "\uFCA1",
  "\u062A\u062C",
  "\uFCA2",
  "\u062A\u062D",
  "\uFCA3",
  "\u062A\u062E",
  "\uFCA4",
  "\u062A\u0645",
  "\uFCA5",
  "\u062A\u0647",
  "\uFCA6",
  "\u062B\u0645",
  "\uFCA7",
  "\u062C\u062D",
  "\uFCA8",
  "\u062C\u0645",
  "\uFCA9",
  "\u062D\u062C",
  "\uFCAA",
  "\u062D\u0645",
  "\uFCAB",
  "\u062E\u062C",
  "\uFCAC",
  "\u062E\u0645",
  "\uFCAD",
  "\u0633\u062C",
  "\uFCAE",
  "\u0633\u062D",
  "\uFCAF",
  "\u0633\u062E",
  "\uFCB0",
  "\u0633\u0645",
  "\uFCB1",
  "\u0635\u062D",
  "\uFCB2",
  "\u0635\u062E",
  "\uFCB3",
  "\u0635\u0645",
  "\uFCB4",
  "\u0636\u062C",
  "\uFCB5",
  "\u0636\u062D",
  "\uFCB6",
  "\u0636\u062E",
  "\uFCB7",
  "\u0636\u0645",
  "\uFCB8",
  "\u0637\u062D",
  "\uFCB9",
  "\u0638\u0645",
  "\uFCBA",
  "\u0639\u062C",
  "\uFCBB",
  "\u0639\u0645",
  "\uFCBC",
  "\u063A\u062C",
  "\uFCBD",
  "\u063A\u0645",
  "\uFCBE",
  "\u0641\u062C",
  "\uFCBF",
  "\u0641\u062D",
  "\uFCC0",
  "\u0641\u062E",
  "\uFCC1",
  "\u0641\u0645",
  "\uFCC2",
  "\u0642\u062D",
  "\uFCC3",
  "\u0642\u0645",
  "\uFCC4",
  "\u0643\u062C",
  "\uFCC5",
  "\u0643\u062D",
  "\uFCC6",
  "\u0643\u062E",
  "\uFCC7",
  "\u0643\u0644",
  "\uFCC8",
  "\u0643\u0645",
  "\uFCC9",
  "\u0644\u062C",
  "\uFCCA",
  "\u0644\u062D",
  "\uFCCB",
  "\u0644\u062E",
  "\uFCCC",
  "\u0644\u0645",
  "\uFCCD",
  "\u0644\u0647",
  "\uFCCE",
  "\u0645\u062C",
  "\uFCCF",
  "\u0645\u062D",
  "\uFCD0",
  "\u0645\u062E",
  "\uFCD1",
  "\u0645\u0645",
  "\uFCD2",
  "\u0646\u062C",
  "\uFCD3",
  "\u0646\u062D",
  "\uFCD4",
  "\u0646\u062E",
  "\uFCD5",
  "\u0646\u0645",
  "\uFCD6",
  "\u0646\u0647",
  "\uFCD7",
  "\u0647\u062C",
  "\uFCD8",
  "\u0647\u0645",
  "\uFCD9",
  "\u0647\u0670",
  "\uFCDA",
  "\u064A\u062C",
  "\uFCDB",
  "\u064A\u062D",
  "\uFCDC",
  "\u064A\u062E",
  "\uFCDD",
  "\u064A\u0645",
  "\uFCDE",
  "\u064A\u0647",
  "\uFCDF",
  "\u0626\u0645",
  "\uFCE0",
  "\u0626\u0647",
  "\uFCE1",
  "\u0628\u0645",
  "\uFCE2",
  "\u0628\u0647",
  "\uFCE3",
  "\u062A\u0645",
  "\uFCE4",
  "\u062A\u0647",
  "\uFCE5",
  "\u062B\u0645",
  "\uFCE6",
  "\u062B\u0647",
  "\uFCE7",
  "\u0633\u0645",
  "\uFCE8",
  "\u0633\u0647",
  "\uFCE9",
  "\u0634\u0645",
  "\uFCEA",
  "\u0634\u0647",
  "\uFCEB",
  "\u0643\u0644",
  "\uFCEC",
  "\u0643\u0645",
  "\uFCED",
  "\u0644\u0645",
  "\uFCEE",
  "\u0646\u0645",
  "\uFCEF",
  "\u0646\u0647",
  "\uFCF0",
  "\u064A\u0645",
  "\uFCF1",
  "\u064A\u0647",
  "\uFCF2",
  "\u0640\u064E\u0651",
  "\uFCF3",
  "\u0640\u064F\u0651",
  "\uFCF4",
  "\u0640\u0650\u0651",
  "\uFCF5",
  "\u0637\u0649",
  "\uFCF6",
  "\u0637\u064A",
  "\uFCF7",
  "\u0639\u0649",
  "\uFCF8",
  "\u0639\u064A",
  "\uFCF9",
  "\u063A\u0649",
  "\uFCFA",
  "\u063A\u064A",
  "\uFCFB",
  "\u0633\u0649",
  "\uFCFC",
  "\u0633\u064A",
  "\uFCFD",
  "\u0634\u0649",
  "\uFCFE",
  "\u0634\u064A",
  "\uFCFF",
  "\u062D\u0649",
  "\uFD00",
  "\u062D\u064A",
  "\uFD01",
  "\u062C\u0649",
  "\uFD02",
  "\u062C\u064A",
  "\uFD03",
  "\u062E\u0649",
  "\uFD04",
  "\u062E\u064A",
  "\uFD05",
  "\u0635\u0649",
  "\uFD06",
  "\u0635\u064A",
  "\uFD07",
  "\u0636\u0649",
  "\uFD08",
  "\u0636\u064A",
  "\uFD09",
  "\u0634\u062C",
  "\uFD0A",
  "\u0634\u062D",
  "\uFD0B",
  "\u0634\u062E",
  "\uFD0C",
  "\u0634\u0645",
  "\uFD0D",
  "\u0634\u0631",
  "\uFD0E",
  "\u0633\u0631",
  "\uFD0F",
  "\u0635\u0631",
  "\uFD10",
  "\u0636\u0631",
  "\uFD11",
  "\u0637\u0649",
  "\uFD12",
  "\u0637\u064A",
  "\uFD13",
  "\u0639\u0649",
  "\uFD14",
  "\u0639\u064A",
  "\uFD15",
  "\u063A\u0649",
  "\uFD16",
  "\u063A\u064A",
  "\uFD17",
  "\u0633\u0649",
  "\uFD18",
  "\u0633\u064A",
  "\uFD19",
  "\u0634\u0649",
  "\uFD1A",
  "\u0634\u064A",
  "\uFD1B",
  "\u062D\u0649",
  "\uFD1C",
  "\u062D\u064A",
  "\uFD1D",
  "\u062C\u0649",
  "\uFD1E",
  "\u062C\u064A",
  "\uFD1F",
  "\u062E\u0649",
  "\uFD20",
  "\u062E\u064A",
  "\uFD21",
  "\u0635\u0649",
  "\uFD22",
  "\u0635\u064A",
  "\uFD23",
  "\u0636\u0649",
  "\uFD24",
  "\u0636\u064A",
  "\uFD25",
  "\u0634\u062C",
  "\uFD26",
  "\u0634\u062D",
  "\uFD27",
  "\u0634\u062E",
  "\uFD28",
  "\u0634\u0645",
  "\uFD29",
  "\u0634\u0631",
  "\uFD2A",
  "\u0633\u0631",
  "\uFD2B",
  "\u0635\u0631",
  "\uFD2C",
  "\u0636\u0631",
  "\uFD2D",
  "\u0634\u062C",
  "\uFD2E",
  "\u0634\u062D",
  "\uFD2F",
  "\u0634\u062E",
  "\uFD30",
  "\u0634\u0645",
  "\uFD31",
  "\u0633\u0647",
  "\uFD32",
  "\u0634\u0647",
  "\uFD33",
  "\u0637\u0645",
  "\uFD34",
  "\u0633\u062C",
  "\uFD35",
  "\u0633\u062D",
  "\uFD36",
  "\u0633\u062E",
  "\uFD37",
  "\u0634\u062C",
  "\uFD38",
  "\u0634\u062D",
  "\uFD39",
  "\u0634\u062E",
  "\uFD3A",
  "\u0637\u0645",
  "\uFD3B",
  "\u0638\u0645",
  "\uFD3C",
  "\u0627\u064B",
  "\uFD3D",
  "\u0627\u064B",
  "\uFD50",
  "\u062A\u062C\u0645",
  "\uFD51",
  "\u062A\u062D\u062C",
  "\uFD52",
  "\u062A\u062D\u062C",
  "\uFD53",
  "\u062A\u062D\u0645",
  "\uFD54",
  "\u062A\u062E\u0645",
  "\uFD55",
  "\u062A\u0645\u062C",
  "\uFD56",
  "\u062A\u0645\u062D",
  "\uFD57",
  "\u062A\u0645\u062E",
  "\uFD58",
  "\u062C\u0645\u062D",
  "\uFD59",
  "\u062C\u0645\u062D",
  "\uFD5A",
  "\u062D\u0645\u064A",
  "\uFD5B",
  "\u062D\u0645\u0649",
  "\uFD5C",
  "\u0633\u062D\u062C",
  "\uFD5D",
  "\u0633\u062C\u062D",
  "\uFD5E",
  "\u0633\u062C\u0649",
  "\uFD5F",
  "\u0633\u0645\u062D",
  "\uFD60",
  "\u0633\u0645\u062D",
  "\uFD61",
  "\u0633\u0645\u062C",
  "\uFD62",
  "\u0633\u0645\u0645",
  "\uFD63",
  "\u0633\u0645\u0645",
  "\uFD64",
  "\u0635\u062D\u062D",
  "\uFD65",
  "\u0635\u062D\u062D",
  "\uFD66",
  "\u0635\u0645\u0645",
  "\uFD67",
  "\u0634\u062D\u0645",
  "\uFD68",
  "\u0634\u062D\u0645",
  "\uFD69",
  "\u0634\u062C\u064A",
  "\uFD6A",
  "\u0634\u0645\u062E",
  "\uFD6B",
  "\u0634\u0645\u062E",
  "\uFD6C",
  "\u0634\u0645\u0645",
  "\uFD6D",
  "\u0634\u0645\u0645",
  "\uFD6E",
  "\u0636\u062D\u0649",
  "\uFD6F",
  "\u0636\u062E\u0645",
  "\uFD70",
  "\u0636\u062E\u0645",
  "\uFD71",
  "\u0637\u0645\u062D",
  "\uFD72",
  "\u0637\u0645\u062D",
  "\uFD73",
  "\u0637\u0645\u0645",
  "\uFD74",
  "\u0637\u0645\u064A",
  "\uFD75",
  "\u0639\u062C\u0645",
  "\uFD76",
  "\u0639\u0645\u0645",
  "\uFD77",
  "\u0639\u0645\u0645",
  "\uFD78",
  "\u0639\u0645\u0649",
  "\uFD79",
  "\u063A\u0645\u0645",
  "\uFD7A",
  "\u063A\u0645\u064A",
  "\uFD7B",
  "\u063A\u0645\u0649",
  "\uFD7C",
  "\u0641\u062E\u0645",
  "\uFD7D",
  "\u0641\u062E\u0645",
  "\uFD7E",
  "\u0642\u0645\u062D",
  "\uFD7F",
  "\u0642\u0645\u0645",
  "\uFD80",
  "\u0644\u062D\u0645",
  "\uFD81",
  "\u0644\u062D\u064A",
  "\uFD82",
  "\u0644\u062D\u0649",
  "\uFD83",
  "\u0644\u062C\u062C",
  "\uFD84",
  "\u0644\u062C\u062C",
  "\uFD85",
  "\u0644\u062E\u0645",
  "\uFD86",
  "\u0644\u062E\u0645",
  "\uFD87",
  "\u0644\u0645\u062D",
  "\uFD88",
  "\u0644\u0645\u062D",
  "\uFD89",
  "\u0645\u062D\u062C",
  "\uFD8A",
  "\u0645\u062D\u0645",
  "\uFD8B",
  "\u0645\u062D\u064A",
  "\uFD8C",
  "\u0645\u062C\u062D",
  "\uFD8D",
  "\u0645\u062C\u0645",
  "\uFD8E",
  "\u0645\u062E\u062C",
  "\uFD8F",
  "\u0645\u062E\u0645",
  "\uFD92",
  "\u0645\u062C\u062E",
  "\uFD93",
  "\u0647\u0645\u062C",
  "\uFD94",
  "\u0647\u0645\u0645",
  "\uFD95",
  "\u0646\u062D\u0645",
  "\uFD96",
  "\u0646\u062D\u0649",
  "\uFD97",
  "\u0646\u062C\u0645",
  "\uFD98",
  "\u0646\u062C\u0645",
  "\uFD99",
  "\u0646\u062C\u0649",
  "\uFD9A",
  "\u0646\u0645\u064A",
  "\uFD9B",
  "\u0646\u0645\u0649",
  "\uFD9C",
  "\u064A\u0645\u0645",
  "\uFD9D",
  "\u064A\u0645\u0645",
  "\uFD9E",
  "\u0628\u062E\u064A",
  "\uFD9F",
  "\u062A\u062C\u064A",
  "\uFDA0",
  "\u062A\u062C\u0649",
  "\uFDA1",
  "\u062A\u062E\u064A",
  "\uFDA2",
  "\u062A\u062E\u0649",
  "\uFDA3",
  "\u062A\u0645\u064A",
  "\uFDA4",
  "\u062A\u0645\u0649",
  "\uFDA5",
  "\u062C\u0645\u064A",
  "\uFDA6",
  "\u062C\u062D\u0649",
  "\uFDA7",
  "\u062C\u0645\u0649",
  "\uFDA8",
  "\u0633\u062E\u0649",
  "\uFDA9",
  "\u0635\u062D\u064A",
  "\uFDAA",
  "\u0634\u062D\u064A",
  "\uFDAB",
  "\u0636\u062D\u064A",
  "\uFDAC",
  "\u0644\u062C\u064A",
  "\uFDAD",
  "\u0644\u0645\u064A",
  "\uFDAE",
  "\u064A\u062D\u064A",
  "\uFDAF",
  "\u064A\u062C\u064A",
  "\uFDB0",
  "\u064A\u0645\u064A",
  "\uFDB1",
  "\u0645\u0645\u064A",
  "\uFDB2",
  "\u0642\u0645\u064A",
  "\uFDB3",
  "\u0646\u062D\u064A",
  "\uFDB4",
  "\u0642\u0645\u062D",
  "\uFDB5",
  "\u0644\u062D\u0645",
  "\uFDB6",
  "\u0639\u0645\u064A",
  "\uFDB7",
  "\u0643\u0645\u064A",
  "\uFDB8",
  "\u0646\u062C\u062D",
  "\uFDB9",
  "\u0645\u062E\u064A",
  "\uFDBA",
  "\u0644\u062C\u0645",
  "\uFDBB",
  "\u0643\u0645\u0645",
  "\uFDBC",
  "\u0644\u062C\u0645",
  "\uFDBD",
  "\u0646\u062C\u062D",
  "\uFDBE",
  "\u062C\u062D\u064A",
  "\uFDBF",
  "\u062D\u062C\u064A",
  "\uFDC0",
  "\u0645\u062C\u064A",
  "\uFDC1",
  "\u0641\u0645\u064A",
  "\uFDC2",
  "\u0628\u062D\u064A",
  "\uFDC3",
  "\u0643\u0645\u0645",
  "\uFDC4",
  "\u0639\u062C\u0645",
  "\uFDC5",
  "\u0635\u0645\u0645",
  "\uFDC6",
  "\u0633\u062E\u064A",
  "\uFDC7",
  "\u0646\u062C\u064A",
  "\uFE49",
  "\u203E",
  "\uFE4A",
  "\u203E",
  "\uFE4B",
  "\u203E",
  "\uFE4C",
  "\u203E",
  "\uFE4D",
  "\u005F",
  "\uFE4E",
  "\u005F",
  "\uFE4F",
  "\u005F",
  "\uFE80",
  "\u0621",
  "\uFE81",
  "\u0622",
  "\uFE82",
  "\u0622",
  "\uFE83",
  "\u0623",
  "\uFE84",
  "\u0623",
  "\uFE85",
  "\u0624",
  "\uFE86",
  "\u0624",
  "\uFE87",
  "\u0625",
  "\uFE88",
  "\u0625",
  "\uFE89",
  "\u0626",
  "\uFE8A",
  "\u0626",
  "\uFE8B",
  "\u0626",
  "\uFE8C",
  "\u0626",
  "\uFE8D",
  "\u0627",
  "\uFE8E",
  "\u0627",
  "\uFE8F",
  "\u0628",
  "\uFE90",
  "\u0628",
  "\uFE91",
  "\u0628",
  "\uFE92",
  "\u0628",
  "\uFE93",
  "\u0629",
  "\uFE94",
  "\u0629",
  "\uFE95",
  "\u062A",
  "\uFE96",
  "\u062A",
  "\uFE97",
  "\u062A",
  "\uFE98",
  "\u062A",
  "\uFE99",
  "\u062B",
  "\uFE9A",
  "\u062B",
  "\uFE9B",
  "\u062B",
  "\uFE9C",
  "\u062B",
  "\uFE9D",
  "\u062C",
  "\uFE9E",
  "\u062C",
  "\uFE9F",
  "\u062C",
  "\uFEA0",
  "\u062C",
  "\uFEA1",
  "\u062D",
  "\uFEA2",
  "\u062D",
  "\uFEA3",
  "\u062D",
  "\uFEA4",
  "\u062D",
  "\uFEA5",
  "\u062E",
  "\uFEA6",
  "\u062E",
  "\uFEA7",
  "\u062E",
  "\uFEA8",
  "\u062E",
  "\uFEA9",
  "\u062F",
  "\uFEAA",
  "\u062F",
  "\uFEAB",
  "\u0630",
  "\uFEAC",
  "\u0630",
  "\uFEAD",
  "\u0631",
  "\uFEAE",
  "\u0631",
  "\uFEAF",
  "\u0632",
  "\uFEB0",
  "\u0632",
  "\uFEB1",
  "\u0633",
  "\uFEB2",
  "\u0633",
  "\uFEB3",
  "\u0633",
  "\uFEB4",
  "\u0633",
  "\uFEB5",
  "\u0634",
  "\uFEB6",
  "\u0634",
  "\uFEB7",
  "\u0634",
  "\uFEB8",
  "\u0634",
  "\uFEB9",
  "\u0635",
  "\uFEBA",
  "\u0635",
  "\uFEBB",
  "\u0635",
  "\uFEBC",
  "\u0635",
  "\uFEBD",
  "\u0636",
  "\uFEBE",
  "\u0636",
  "\uFEBF",
  "\u0636",
  "\uFEC0",
  "\u0636",
  "\uFEC1",
  "\u0637",
  "\uFEC2",
  "\u0637",
  "\uFEC3",
  "\u0637",
  "\uFEC4",
  "\u0637",
  "\uFEC5",
  "\u0638",
  "\uFEC6",
  "\u0638",
  "\uFEC7",
  "\u0638",
  "\uFEC8",
  "\u0638",
  "\uFEC9",
  "\u0639",
  "\uFECA",
  "\u0639",
  "\uFECB",
  "\u0639",
  "\uFECC",
  "\u0639",
  "\uFECD",
  "\u063A",
  "\uFECE",
  "\u063A",
  "\uFECF",
  "\u063A",
  "\uFED0",
  "\u063A",
  "\uFED1",
  "\u0641",
  "\uFED2",
  "\u0641",
  "\uFED3",
  "\u0641",
  "\uFED4",
  "\u0641",
  "\uFED5",
  "\u0642",
  "\uFED6",
  "\u0642",
  "\uFED7",
  "\u0642",
  "\uFED8",
  "\u0642",
  "\uFED9",
  "\u0643",
  "\uFEDA",
  "\u0643",
  "\uFEDB",
  "\u0643",
  "\uFEDC",
  "\u0643",
  "\uFEDD",
  "\u0644",
  "\uFEDE",
  "\u0644",
  "\uFEDF",
  "\u0644",
  "\uFEE0",
  "\u0644",
  "\uFEE1",
  "\u0645",
  "\uFEE2",
  "\u0645",
  "\uFEE3",
  "\u0645",
  "\uFEE4",
  "\u0645",
  "\uFEE5",
  "\u0646",
  "\uFEE6",
  "\u0646",
  "\uFEE7",
  "\u0646",
  "\uFEE8",
  "\u0646",
  "\uFEE9",
  "\u0647",
  "\uFEEA",
  "\u0647",
  "\uFEEB",
  "\u0647",
  "\uFEEC",
  "\u0647",
  "\uFEED",
  "\u0648",
  "\uFEEE",
  "\u0648",
  "\uFEEF",
  "\u0649",
  "\uFEF0",
  "\u0649",
  "\uFEF1",
  "\u064A",
  "\uFEF2",
  "\u064A",
  "\uFEF3",
  "\u064A",
  "\uFEF4",
  "\u064A",
  "\uFEF5",
  "\u0644\u0622",
  "\uFEF6",
  "\u0644\u0622",
  "\uFEF7",
  "\u0644\u0623",
  "\uFEF8",
  "\u0644\u0623",
  "\uFEF9",
  "\u0644\u0625",
  "\uFEFA",
  "\u0644\u0625",
  "\uFEFB",
  "\u0644\u0627",
  "\uFEFC",
  "\u0644\u0627"
 ];
});
function reverseIfRtl(chars) {
 const charsLength = chars.length;
 if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
  return chars;
 }
 const buf = [];
 for (let ii = charsLength - 1; ii >= 0; ii--) {
  buf.push(chars[ii]);
 }
 return buf.join("");
}


/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getSymbolsFonts = exports.getSupplementalGlyphMapForCalibri = exports.getSupplementalGlyphMapForArialBlack = exports.getStdFontMap = exports.getSerifFonts = exports.getNonStdFontMap = exports.getGlyphMapForStandardFonts = void 0;

var _core_utils = __w_pdfjs_require__(9);

const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.ArialNarrow = "Helvetica";
  t["ArialNarrow-Bold"] = "Helvetica-Bold";
  t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialNarrow-Italic"] = "Helvetica-Oblique";
  t.ArialBlack = "Helvetica";
  t["ArialBlack-Bold"] = "Helvetica-Bold";
  t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialBlack-Italic"] = "Helvetica-Oblique";
  t["Arial-Black"] = "Helvetica";
  t["Arial-Black-Bold"] = "Helvetica-Bold";
  t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Black-Italic"] = "Helvetica-Oblique";
  t.Arial = "Helvetica";
  t["Arial-Bold"] = "Helvetica-Bold";
  t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Italic"] = "Helvetica-Oblique";
  t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
  t["Arial-BoldMT"] = "Helvetica-Bold";
  t["Arial-ItalicMT"] = "Helvetica-Oblique";
  t.ArialMT = "Helvetica";
  t["Courier-Bold"] = "Courier-Bold";
  t["Courier-BoldItalic"] = "Courier-BoldOblique";
  t["Courier-Italic"] = "Courier-Oblique";
  t.CourierNew = "Courier";
  t["CourierNew-Bold"] = "Courier-Bold";
  t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
  t["CourierNew-Italic"] = "Courier-Oblique";
  t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
  t["CourierNewPS-BoldMT"] = "Courier-Bold";
  t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
  t.CourierNewPSMT = "Courier";
  t.Helvetica = "Helvetica";
  t["Helvetica-Bold"] = "Helvetica-Bold";
  t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
  t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
  t["Helvetica-Italic"] = "Helvetica-Oblique";
  t["Helvetica-Oblique"] = "Helvetica-Oblique";
  t["Symbol-Bold"] = "Symbol";
  t["Symbol-BoldItalic"] = "Symbol";
  t["Symbol-Italic"] = "Symbol";
  t.TimesNewRoman = "Times-Roman";
  t["TimesNewRoman-Bold"] = "Times-Bold";
  t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRoman-Italic"] = "Times-Italic";
  t.TimesNewRomanPS = "Times-Roman";
  t["TimesNewRomanPS-Bold"] = "Times-Bold";
  t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
  t["TimesNewRomanPS-Italic"] = "Times-Italic";
  t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
  t.TimesNewRomanPSMT = "Times-Roman";
  t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
  t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
});
exports.getStdFontMap = getStdFontMap;
const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Calibri = "Helvetica";
  t["Calibri-Bold"] = "Helvetica-Bold";
  t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
  t["Calibri-Italic"] = "Helvetica-Oblique";
  t.CenturyGothic = "Helvetica";
  t["CenturyGothic-Bold"] = "Helvetica-Bold";
  t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
  t["CenturyGothic-Italic"] = "Helvetica-Oblique";
  t.ComicSansMS = "Comic Sans MS";
  t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
  t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
  t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
  t.LucidaConsole = "Courier";
  t["LucidaConsole-Bold"] = "Courier-Bold";
  t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
  t["LucidaConsole-Italic"] = "Courier-Oblique";
  t["LucidaSans-Demi"] = "Helvetica-Bold";
  t["MS-Gothic"] = "MS Gothic";
  t["MS-Gothic-Bold"] = "MS Gothic-Bold";
  t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
  t["MS-Gothic-Italic"] = "MS Gothic-Italic";
  t["MS-Mincho"] = "MS Mincho";
  t["MS-Mincho-Bold"] = "MS Mincho-Bold";
  t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
  t["MS-Mincho-Italic"] = "MS Mincho-Italic";
  t["MS-PGothic"] = "MS PGothic";
  t["MS-PGothic-Bold"] = "MS PGothic-Bold";
  t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
  t["MS-PGothic-Italic"] = "MS PGothic-Italic";
  t["MS-PMincho"] = "MS PMincho";
  t["MS-PMincho-Bold"] = "MS PMincho-Bold";
  t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
  t["MS-PMincho-Italic"] = "MS PMincho-Italic";
  t.NuptialScript = "Times-Italic";
  t.SegoeUISymbol = "Helvetica";
  t.Wingdings = "ZapfDingbats";
  t["Wingdings-Regular"] = "ZapfDingbats";
});
exports.getNonStdFontMap = getNonStdFontMap;
const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t["Adobe Jenson"] = true;
  t["Adobe Text"] = true;
  t.Albertus = true;
  t.Aldus = true;
  t.Alexandria = true;
  t.Algerian = true;
  t["American Typewriter"] = true;
  t.Antiqua = true;
  t.Apex = true;
  t.Arno = true;
  t.Aster = true;
  t.Aurora = true;
  t.Baskerville = true;
  t.Bell = true;
  t.Bembo = true;
  t["Bembo Schoolbook"] = true;
  t.Benguiat = true;
  t["Berkeley Old Style"] = true;
  t["Bernhard Modern"] = true;
  t["Berthold City"] = true;
  t.Bodoni = true;
  t["Bauer Bodoni"] = true;
  t["Book Antiqua"] = true;
  t.Bookman = true;
  t["Bordeaux Roman"] = true;
  t["Californian FB"] = true;
  t.Calisto = true;
  t.Calvert = true;
  t.Capitals = true;
  t.Cambria = true;
  t.Cartier = true;
  t.Caslon = true;
  t.Catull = true;
  t.Centaur = true;
  t["Century Old Style"] = true;
  t["Century Schoolbook"] = true;
  t.Chaparral = true;
  t["Charis SIL"] = true;
  t.Cheltenham = true;
  t["Cholla Slab"] = true;
  t.Clarendon = true;
  t.Clearface = true;
  t.Cochin = true;
  t.Colonna = true;
  t["Computer Modern"] = true;
  t["Concrete Roman"] = true;
  t.Constantia = true;
  t["Cooper Black"] = true;
  t.Corona = true;
  t.Ecotype = true;
  t.Egyptienne = true;
  t.Elephant = true;
  t.Excelsior = true;
  t.Fairfield = true;
  t["FF Scala"] = true;
  t.Folkard = true;
  t.Footlight = true;
  t.FreeSerif = true;
  t["Friz Quadrata"] = true;
  t.Garamond = true;
  t.Gentium = true;
  t.Georgia = true;
  t.Gloucester = true;
  t["Goudy Old Style"] = true;
  t["Goudy Schoolbook"] = true;
  t["Goudy Pro Font"] = true;
  t.Granjon = true;
  t["Guardian Egyptian"] = true;
  t.Heather = true;
  t.Hercules = true;
  t["High Tower Text"] = true;
  t.Hiroshige = true;
  t["Hoefler Text"] = true;
  t["Humana Serif"] = true;
  t.Imprint = true;
  t["Ionic No. 5"] = true;
  t.Janson = true;
  t.Joanna = true;
  t.Korinna = true;
  t.Lexicon = true;
  t["Liberation Serif"] = true;
  t["Linux Libertine"] = true;
  t.Literaturnaya = true;
  t.Lucida = true;
  t["Lucida Bright"] = true;
  t.Melior = true;
  t.Memphis = true;
  t.Miller = true;
  t.Minion = true;
  t.Modern = true;
  t["Mona Lisa"] = true;
  t["Mrs Eaves"] = true;
  t["MS Serif"] = true;
  t["Museo Slab"] = true;
  t["New York"] = true;
  t["Nimbus Roman"] = true;
  t["NPS Rawlinson Roadway"] = true;
  t.NuptialScript = true;
  t.Palatino = true;
  t.Perpetua = true;
  t.Plantin = true;
  t["Plantin Schoolbook"] = true;
  t.Playbill = true;
  t["Poor Richard"] = true;
  t["Rawlinson Roadway"] = true;
  t.Renault = true;
  t.Requiem = true;
  t.Rockwell = true;
  t.Roman = true;
  t["Rotis Serif"] = true;
  t.Sabon = true;
  t.Scala = true;
  t.Seagull = true;
  t.Sistina = true;
  t.Souvenir = true;
  t.STIX = true;
  t["Stone Informal"] = true;
  t["Stone Serif"] = true;
  t.Sylfaen = true;
  t.Times = true;
  t.Trajan = true;
  t["Trinité"] = true;
  t["Trump Mediaeval"] = true;
  t.Utopia = true;
  t["Vale Type"] = true;
  t["Bitstream Vera"] = true;
  t["Vera Serif"] = true;
  t.Versailles = true;
  t.Wanted = true;
  t.Weiss = true;
  t["Wide Latin"] = true;
  t.Windsor = true;
  t.XITS = true;
});
exports.getSerifFonts = getSerifFonts;
const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Dingbats = true;
  t.Symbol = true;
  t.ZapfDingbats = true;
});
exports.getSymbolsFonts = getSymbolsFonts;
const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[2] = 10;
  t[3] = 32;
  t[4] = 33;
  t[5] = 34;
  t[6] = 35;
  t[7] = 36;
  t[8] = 37;
  t[9] = 38;
  t[10] = 39;
  t[11] = 40;
  t[12] = 41;
  t[13] = 42;
  t[14] = 43;
  t[15] = 44;
  t[16] = 45;
  t[17] = 46;
  t[18] = 47;
  t[19] = 48;
  t[20] = 49;
  t[21] = 50;
  t[22] = 51;
  t[23] = 52;
  t[24] = 53;
  t[25] = 54;
  t[26] = 55;
  t[27] = 56;
  t[28] = 57;
  t[29] = 58;
  t[30] = 894;
  t[31] = 60;
  t[32] = 61;
  t[33] = 62;
  t[34] = 63;
  t[35] = 64;
  t[36] = 65;
  t[37] = 66;
  t[38] = 67;
  t[39] = 68;
  t[40] = 69;
  t[41] = 70;
  t[42] = 71;
  t[43] = 72;
  t[44] = 73;
  t[45] = 74;
  t[46] = 75;
  t[47] = 76;
  t[48] = 77;
  t[49] = 78;
  t[50] = 79;
  t[51] = 80;
  t[52] = 81;
  t[53] = 82;
  t[54] = 83;
  t[55] = 84;
  t[56] = 85;
  t[57] = 86;
  t[58] = 87;
  t[59] = 88;
  t[60] = 89;
  t[61] = 90;
  t[62] = 91;
  t[63] = 92;
  t[64] = 93;
  t[65] = 94;
  t[66] = 95;
  t[67] = 96;
  t[68] = 97;
  t[69] = 98;
  t[70] = 99;
  t[71] = 100;
  t[72] = 101;
  t[73] = 102;
  t[74] = 103;
  t[75] = 104;
  t[76] = 105;
  t[77] = 106;
  t[78] = 107;
  t[79] = 108;
  t[80] = 109;
  t[81] = 110;
  t[82] = 111;
  t[83] = 112;
  t[84] = 113;
  t[85] = 114;
  t[86] = 115;
  t[87] = 116;
  t[88] = 117;
  t[89] = 118;
  t[90] = 119;
  t[91] = 120;
  t[92] = 121;
  t[93] = 122;
  t[94] = 123;
  t[95] = 124;
  t[96] = 125;
  t[97] = 126;
  t[98] = 196;
  t[99] = 197;
  t[100] = 199;
  t[101] = 201;
  t[102] = 209;
  t[103] = 214;
  t[104] = 220;
  t[105] = 225;
  t[106] = 224;
  t[107] = 226;
  t[108] = 228;
  t[109] = 227;
  t[110] = 229;
  t[111] = 231;
  t[112] = 233;
  t[113] = 232;
  t[114] = 234;
  t[115] = 235;
  t[116] = 237;
  t[117] = 236;
  t[118] = 238;
  t[119] = 239;
  t[120] = 241;
  t[121] = 243;
  t[122] = 242;
  t[123] = 244;
  t[124] = 246;
  t[125] = 245;
  t[126] = 250;
  t[127] = 249;
  t[128] = 251;
  t[129] = 252;
  t[130] = 8224;
  t[131] = 176;
  t[132] = 162;
  t[133] = 163;
  t[134] = 167;
  t[135] = 8226;
  t[136] = 182;
  t[137] = 223;
  t[138] = 174;
  t[139] = 169;
  t[140] = 8482;
  t[141] = 180;
  t[142] = 168;
  t[143] = 8800;
  t[144] = 198;
  t[145] = 216;
  t[146] = 8734;
  t[147] = 177;
  t[148] = 8804;
  t[149] = 8805;
  t[150] = 165;
  t[151] = 181;
  t[152] = 8706;
  t[153] = 8721;
  t[154] = 8719;
  t[156] = 8747;
  t[157] = 170;
  t[158] = 186;
  t[159] = 8486;
  t[160] = 230;
  t[161] = 248;
  t[162] = 191;
  t[163] = 161;
  t[164] = 172;
  t[165] = 8730;
  t[166] = 402;
  t[167] = 8776;
  t[168] = 8710;
  t[169] = 171;
  t[170] = 187;
  t[171] = 8230;
  t[210] = 218;
  t[223] = 711;
  t[224] = 321;
  t[225] = 322;
  t[227] = 353;
  t[229] = 382;
  t[234] = 253;
  t[252] = 263;
  t[253] = 268;
  t[254] = 269;
  t[258] = 258;
  t[260] = 260;
  t[261] = 261;
  t[265] = 280;
  t[266] = 281;
  t[268] = 283;
  t[269] = 313;
  t[275] = 323;
  t[276] = 324;
  t[278] = 328;
  t[284] = 345;
  t[285] = 346;
  t[286] = 347;
  t[292] = 367;
  t[295] = 377;
  t[296] = 378;
  t[298] = 380;
  t[305] = 963;
  t[306] = 964;
  t[307] = 966;
  t[308] = 8215;
  t[309] = 8252;
  t[310] = 8319;
  t[311] = 8359;
  t[312] = 8592;
  t[313] = 8593;
  t[337] = 9552;
  t[493] = 1039;
  t[494] = 1040;
  t[705] = 1524;
  t[706] = 8362;
  t[710] = 64288;
  t[711] = 64298;
  t[759] = 1617;
  t[761] = 1776;
  t[763] = 1778;
  t[775] = 1652;
  t[777] = 1764;
  t[778] = 1780;
  t[779] = 1781;
  t[780] = 1782;
  t[782] = 771;
  t[783] = 64726;
  t[786] = 8363;
  t[788] = 8532;
  t[790] = 768;
  t[791] = 769;
  t[792] = 768;
  t[795] = 803;
  t[797] = 64336;
  t[798] = 64337;
  t[799] = 64342;
  t[800] = 64343;
  t[801] = 64344;
  t[802] = 64345;
  t[803] = 64362;
  t[804] = 64363;
  t[805] = 64364;
  t[2424] = 7821;
  t[2425] = 7822;
  t[2426] = 7823;
  t[2427] = 7824;
  t[2428] = 7825;
  t[2429] = 7826;
  t[2430] = 7827;
  t[2433] = 7682;
  t[2678] = 8045;
  t[2679] = 8046;
  t[2830] = 1552;
  t[2838] = 686;
  t[2840] = 751;
  t[2842] = 753;
  t[2843] = 754;
  t[2844] = 755;
  t[2846] = 757;
  t[2856] = 767;
  t[2857] = 848;
  t[2858] = 849;
  t[2862] = 853;
  t[2863] = 854;
  t[2864] = 855;
  t[2865] = 861;
  t[2866] = 862;
  t[2906] = 7460;
  t[2908] = 7462;
  t[2909] = 7463;
  t[2910] = 7464;
  t[2912] = 7466;
  t[2913] = 7467;
  t[2914] = 7468;
  t[2916] = 7470;
  t[2917] = 7471;
  t[2918] = 7472;
  t[2920] = 7474;
  t[2921] = 7475;
  t[2922] = 7476;
  t[2924] = 7478;
  t[2925] = 7479;
  t[2926] = 7480;
  t[2928] = 7482;
  t[2929] = 7483;
  t[2930] = 7484;
  t[2932] = 7486;
  t[2933] = 7487;
  t[2934] = 7488;
  t[2936] = 7490;
  t[2937] = 7491;
  t[2938] = 7492;
  t[2940] = 7494;
  t[2941] = 7495;
  t[2942] = 7496;
  t[2944] = 7498;
  t[2946] = 7500;
  t[2948] = 7502;
  t[2950] = 7504;
  t[2951] = 7505;
  t[2952] = 7506;
  t[2954] = 7508;
  t[2955] = 7509;
  t[2956] = 7510;
  t[2958] = 7512;
  t[2959] = 7513;
  t[2960] = 7514;
  t[2962] = 7516;
  t[2963] = 7517;
  t[2964] = 7518;
  t[2966] = 7520;
  t[2967] = 7521;
  t[2968] = 7522;
  t[2970] = 7524;
  t[2971] = 7525;
  t[2972] = 7526;
  t[2974] = 7528;
  t[2975] = 7529;
  t[2976] = 7530;
  t[2978] = 1537;
  t[2979] = 1538;
  t[2980] = 1539;
  t[2982] = 1549;
  t[2983] = 1551;
  t[2984] = 1552;
  t[2986] = 1554;
  t[2987] = 1555;
  t[2988] = 1556;
  t[2990] = 1623;
  t[2991] = 1624;
  t[2995] = 1775;
  t[2999] = 1791;
  t[3002] = 64290;
  t[3003] = 64291;
  t[3004] = 64292;
  t[3006] = 64294;
  t[3007] = 64295;
  t[3008] = 64296;
  t[3011] = 1900;
  t[3014] = 8223;
  t[3015] = 8244;
  t[3017] = 7532;
  t[3018] = 7533;
  t[3019] = 7534;
  t[3075] = 7590;
  t[3076] = 7591;
  t[3079] = 7594;
  t[3080] = 7595;
  t[3083] = 7598;
  t[3084] = 7599;
  t[3087] = 7602;
  t[3088] = 7603;
  t[3091] = 7606;
  t[3092] = 7607;
  t[3095] = 7610;
  t[3096] = 7611;
  t[3099] = 7614;
  t[3100] = 7615;
  t[3103] = 7618;
  t[3104] = 7619;
  t[3107] = 8337;
  t[3108] = 8338;
  t[3116] = 1884;
  t[3119] = 1885;
  t[3120] = 1885;
  t[3123] = 1886;
  t[3124] = 1886;
  t[3127] = 1887;
  t[3128] = 1887;
  t[3131] = 1888;
  t[3132] = 1888;
  t[3135] = 1889;
  t[3136] = 1889;
  t[3139] = 1890;
  t[3140] = 1890;
  t[3143] = 1891;
  t[3144] = 1891;
  t[3147] = 1892;
  t[3148] = 1892;
  t[3153] = 580;
  t[3154] = 581;
  t[3157] = 584;
  t[3158] = 585;
  t[3161] = 588;
  t[3162] = 589;
  t[3165] = 891;
  t[3166] = 892;
  t[3169] = 1274;
  t[3170] = 1275;
  t[3173] = 1278;
  t[3174] = 1279;
  t[3181] = 7622;
  t[3182] = 7623;
  t[3282] = 11799;
  t[3316] = 578;
  t[3379] = 42785;
  t[3393] = 1159;
  t[3416] = 8377;
});
exports.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[227] = 322;
  t[264] = 261;
  t[291] = 346;
});
exports.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function (t) {
  t[1] = 32;
  t[4] = 65;
  t[17] = 66;
  t[18] = 67;
  t[24] = 68;
  t[28] = 69;
  t[38] = 70;
  t[39] = 71;
  t[44] = 72;
  t[47] = 73;
  t[58] = 74;
  t[60] = 75;
  t[62] = 76;
  t[68] = 77;
  t[69] = 78;
  t[75] = 79;
  t[87] = 80;
  t[89] = 81;
  t[90] = 82;
  t[94] = 83;
  t[100] = 84;
  t[104] = 85;
  t[115] = 86;
  t[116] = 87;
  t[121] = 88;
  t[122] = 89;
  t[127] = 90;
  t[258] = 97;
  t[268] = 261;
  t[271] = 98;
  t[272] = 99;
  t[273] = 263;
  t[282] = 100;
  t[286] = 101;
  t[295] = 281;
  t[296] = 102;
  t[336] = 103;
  t[346] = 104;
  t[349] = 105;
  t[361] = 106;
  t[364] = 107;
  t[367] = 108;
  t[371] = 322;
  t[373] = 109;
  t[374] = 110;
  t[381] = 111;
  t[383] = 243;
  t[393] = 112;
  t[395] = 113;
  t[396] = 114;
  t[400] = 115;
  t[401] = 347;
  t[410] = 116;
  t[437] = 117;
  t[448] = 118;
  t[449] = 119;
  t[454] = 120;
  t[455] = 121;
  t[460] = 122;
  t[463] = 380;
  t[853] = 44;
  t[855] = 58;
  t[856] = 46;
  t[876] = 47;
  t[878] = 45;
  t[882] = 45;
  t[894] = 40;
  t[895] = 41;
  t[896] = 91;
  t[897] = 93;
  t[923] = 64;
  t[1004] = 48;
  t[1005] = 49;
  t[1006] = 50;
  t[1007] = 51;
  t[1008] = 52;
  t[1009] = 53;
  t[1010] = 54;
  t[1011] = 55;
  t[1012] = 56;
  t[1013] = 57;
  t[1081] = 37;
  t[1085] = 43;
  t[1086] = 45;
});
exports.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ToUnicodeMap = exports.IdentityToUnicodeMap = void 0;

var _util = __w_pdfjs_require__(2);

class ToUnicodeMap {
  constructor(cmap = []) {
    this._map = cmap;
  }

  get length() {
    return this._map.length;
  }

  forEach(callback) {
    for (const charCode in this._map) {
      callback(charCode, this._map[charCode].charCodeAt(0));
    }
  }

  has(i) {
    return this._map[i] !== undefined;
  }

  get(i) {
    return this._map[i];
  }

  charCodeOf(value) {
    const map = this._map;

    if (map.length <= 0x10000) {
      return map.indexOf(value);
    }

    for (const charCode in map) {
      if (map[charCode] === value) {
        return charCode | 0;
      }
    }

    return -1;
  }

  amend(map) {
    for (const charCode in map) {
      this._map[charCode] = map[charCode];
    }
  }

}

exports.ToUnicodeMap = ToUnicodeMap;

class IdentityToUnicodeMap {
  constructor(firstChar, lastChar) {
    this.firstChar = firstChar;
    this.lastChar = lastChar;
  }

  get length() {
    return this.lastChar + 1 - this.firstChar;
  }

  forEach(callback) {
    for (let i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
      callback(i, i);
    }
  }

  has(i) {
    return this.firstChar <= i && i <= this.lastChar;
  }

  get(i) {
    if (this.firstChar <= i && i <= this.lastChar) {
      return String.fromCharCode(i);
    }

    return undefined;
  }

  charCodeOf(v) {
    return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
  }

  amend(map) {
    (0, _util.unreachable)("Should not call amend()");
  }

}

exports.IdentityToUnicodeMap = IdentityToUnicodeMap;

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CFFFont = void 0;

var _cff_parser = __w_pdfjs_require__(35);

var _fonts_utils = __w_pdfjs_require__(38);

var _util = __w_pdfjs_require__(2);

class CFFFont {
  constructor(file, properties) {
    this.properties = properties;
    const parser = new _cff_parser.CFFParser(file, properties, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    this.cff = parser.parse();
    this.cff.duplicateFirstGlyph();
    const compiler = new _cff_parser.CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;

    try {
      this.data = compiler.compile();
    } catch (e) {
      (0, _util.warn)("Failed to compile font " + properties.loadedName);
      this.data = file;
    }

    this._createBuiltInEncoding();
  }

  get numGlyphs() {
    return this.cff.charStrings.count;
  }

  getCharset() {
    return this.cff.charset.charset;
  }

  getGlyphMapping() {
    const cff = this.cff;
    const properties = this.properties;
    const charsets = cff.charset.charset;
    let charCodeToGlyphId;
    let glyphId;

    if (properties.composite) {
      charCodeToGlyphId = Object.create(null);
      let charCode;

      if (cff.isCIDFont) {
        for (glyphId = 0; glyphId < charsets.length; glyphId++) {
          const cid = charsets[glyphId];
          charCode = properties.cMap.charCodeOf(cid);
          charCodeToGlyphId[charCode] = glyphId;
        }
      } else {
        for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
          charCode = properties.cMap.charCodeOf(glyphId);
          charCodeToGlyphId[charCode] = glyphId;
        }
      }

      return charCodeToGlyphId;
    }

    const encoding = cff.encoding ? cff.encoding.encoding : null;
    charCodeToGlyphId = (0, _fonts_utils.type1FontGlyphMapping)(properties, encoding, charsets);
    return charCodeToGlyphId;
  }

  hasGlyphId(id) {
    return this.cff.hasGlyphId(id);
  }

  _createBuiltInEncoding() {
    const {
      charset,
      encoding
    } = this.cff;

    if (!charset || !encoding) {
      return;
    }

    const charsets = charset.charset,
          encodings = encoding.encoding;
    const map = [];

    for (const charCode in encodings) {
      const glyphId = encodings[charCode];

      if (glyphId >= 0) {
        const glyphName = charsets[glyphId];

        if (glyphName) {
          map[charCode] = glyphName;
        }
      }
    }

    if (map.length > 0) {
      this.properties.builtInEncoding = map;
    }
  }

}

exports.CFFFont = CFFFont;

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontRendererFactory = void 0;

var _util = __w_pdfjs_require__(2);

var _cff_parser = __w_pdfjs_require__(35);

var _glyphlist = __w_pdfjs_require__(39);

var _encodings = __w_pdfjs_require__(37);

var _stream = __w_pdfjs_require__(10);

function getLong(data, offset) {
  return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
}

function getUshort(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}

function getSubroutineBias(subrs) {
  const numSubrs = subrs.length;
  let bias = 32768;

  if (numSubrs < 1240) {
    bias = 107;
  } else if (numSubrs < 33900) {
    bias = 1131;
  }

  return bias;
}

function parseCmap(data, start, end) {
  const offset = getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16);
  const format = getUshort(data, start + offset);
  let ranges, p, i;

  if (format === 4) {
    getUshort(data, start + offset + 2);
    const segCount = getUshort(data, start + offset + 6) >> 1;
    p = start + offset + 14;
    ranges = [];

    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i] = {
        end: getUshort(data, p)
      };
    }

    p += 2;

    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].start = getUshort(data, p);
    }

    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].idDelta = getUshort(data, p);
    }

    for (i = 0; i < segCount; i++, p += 2) {
      let idOffset = getUshort(data, p);

      if (idOffset === 0) {
        continue;
      }

      ranges[i].ids = [];

      for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
        ranges[i].ids[j] = getUshort(data, p + idOffset);
        idOffset += 2;
      }
    }

    return ranges;
  } else if (format === 12) {
    getLong(data, start + offset + 4);
    const groups = getLong(data, start + offset + 12);
    p = start + offset + 16;
    ranges = [];

    for (i = 0; i < groups; i++) {
      ranges.push({
        start: getLong(data, p),
        end: getLong(data, p + 4),
        idDelta: getLong(data, p + 8) - getLong(data, p)
      });
      p += 12;
    }

    return ranges;
  }

  throw new _util.FormatError(`unsupported cmap: ${format}`);
}

function parseCff(data, start, end, seacAnalysisEnabled) {
  const properties = {};
  const parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
  const cff = parser.parse();
  return {
    glyphs: cff.charStrings.objects,
    subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects,
    gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects,
    isCFFCIDFont: cff.isCIDFont,
    fdSelect: cff.fdSelect,
    fdArray: cff.fdArray
  };
}

function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
  let itemSize, itemDecode;

  if (isGlyphLocationsLong) {
    itemSize = 4;

    itemDecode = function fontItemDecodeLong(data, offset) {
      return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
    };
  } else {
    itemSize = 2;

    itemDecode = function fontItemDecode(data, offset) {
      return data[offset] << 9 | data[offset + 1] << 1;
    };
  }

  const glyphs = [];
  let startOffset = itemDecode(loca, 0);

  for (let j = itemSize; j < loca.length; j += itemSize) {
    const endOffset = itemDecode(loca, j);
    glyphs.push(glyf.subarray(startOffset, endOffset));
    startOffset = endOffset;
  }

  return glyphs;
}

function lookupCmap(ranges, unicode) {
  const code = unicode.codePointAt(0);
  let gid = 0,
      l = 0,
      r = ranges.length - 1;

  while (l < r) {
    const c = l + r + 1 >> 1;

    if (code < ranges[c].start) {
      r = c - 1;
    } else {
      l = c;
    }
  }

  if (ranges[l].start <= code && code <= ranges[l].end) {
    gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 0xffff;
  }

  return {
    charCode: code,
    glyphId: gid
  };
}

function compileGlyf(code, cmds, font) {
  function moveTo(x, y) {
    cmds.push({
      cmd: "moveTo",
      args: [x, y]
    });
  }

  function lineTo(x, y) {
    cmds.push({
      cmd: "lineTo",
      args: [x, y]
    });
  }

  function quadraticCurveTo(xa, ya, x, y) {
    cmds.push({
      cmd: "quadraticCurveTo",
      args: [xa, ya, x, y]
    });
  }

  let i = 0;
  const numberOfContours = (code[i] << 24 | code[i + 1] << 16) >> 16;
  let flags;
  let x = 0,
      y = 0;
  i += 10;

  if (numberOfContours < 0) {
    do {
      flags = code[i] << 8 | code[i + 1];
      const glyphIndex = code[i + 2] << 8 | code[i + 3];
      i += 4;
      let arg1, arg2;

      if (flags & 0x01) {
        arg1 = (code[i] << 24 | code[i + 1] << 16) >> 16;
        arg2 = (code[i + 2] << 24 | code[i + 3] << 16) >> 16;
        i += 4;
      } else {
        arg1 = code[i++];
        arg2 = code[i++];
      }

      if (flags & 0x02) {
        x = arg1;
        y = arg2;
      } else {
        x = 0;
        y = 0;
      }

      let scaleX = 1,
          scaleY = 1,
          scale01 = 0,
          scale10 = 0;

      if (flags & 0x08) {
        scaleX = scaleY = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
        i += 2;
      } else if (flags & 0x40) {
        scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
        scaleY = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
        i += 4;
      } else if (flags & 0x80) {
        scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
        scale01 = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
        scale10 = (code[i + 4] << 24 | code[i + 5] << 16) / 1073741824;
        scaleY = (code[i + 6] << 24 | code[i + 7] << 16) / 1073741824;
        i += 8;
      }

      const subglyph = font.glyphs[glyphIndex];

      if (subglyph) {
        cmds.push({
          cmd: "save"
        });
        cmds.push({
          cmd: "transform",
          args: [scaleX, scale01, scale10, scaleY, x, y]
        });
        compileGlyf(subglyph, cmds, font);
        cmds.push({
          cmd: "restore"
        });
      }
    } while (flags & 0x20);
  } else {
    const endPtsOfContours = [];
    let j, jj;

    for (j = 0; j < numberOfContours; j++) {
      endPtsOfContours.push(code[i] << 8 | code[i + 1]);
      i += 2;
    }

    const instructionLength = code[i] << 8 | code[i + 1];
    i += 2 + instructionLength;
    const numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    const points = [];

    while (points.length < numberOfPoints) {
      flags = code[i++];
      let repeat = 1;

      if (flags & 0x08) {
        repeat += code[i++];
      }

      while (repeat-- > 0) {
        points.push({
          flags
        });
      }
    }

    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 0x12) {
        case 0x00:
          x += (code[i] << 24 | code[i + 1] << 16) >> 16;
          i += 2;
          break;

        case 0x02:
          x -= code[i++];
          break;

        case 0x12:
          x += code[i++];
          break;
      }

      points[j].x = x;
    }

    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 0x24) {
        case 0x00:
          y += (code[i] << 24 | code[i + 1] << 16) >> 16;
          i += 2;
          break;

        case 0x04:
          y -= code[i++];
          break;

        case 0x24:
          y += code[i++];
          break;
      }

      points[j].y = y;
    }

    let startPoint = 0;

    for (i = 0; i < numberOfContours; i++) {
      const endPoint = endPtsOfContours[i];
      const contour = points.slice(startPoint, endPoint + 1);

      if (contour[0].flags & 1) {
        contour.push(contour[0]);
      } else if (contour[contour.length - 1].flags & 1) {
        contour.unshift(contour[contour.length - 1]);
      } else {
        const p = {
          flags: 1,
          x: (contour[0].x + contour[contour.length - 1].x) / 2,
          y: (contour[0].y + contour[contour.length - 1].y) / 2
        };
        contour.unshift(p);
        contour.push(p);
      }

      moveTo(contour[0].x, contour[0].y);

      for (j = 1, jj = contour.length; j < jj; j++) {
        if (contour[j].flags & 1) {
          lineTo(contour[j].x, contour[j].y);
        } else if (contour[j + 1].flags & 1) {
          quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
          j++;
        } else {
          quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
        }
      }

      startPoint = endPoint + 1;
    }
  }
}

function compileCharString(charStringCode, cmds, font, glyphId) {
  function moveTo(x, y) {
    cmds.push({
      cmd: "moveTo",
      args: [x, y]
    });
  }

  function lineTo(x, y) {
    cmds.push({
      cmd: "lineTo",
      args: [x, y]
    });
  }

  function bezierCurveTo(x1, y1, x2, y2, x, y) {
    cmds.push({
      cmd: "bezierCurveTo",
      args: [x1, y1, x2, y2, x, y]
    });
  }

  const stack = [];
  let x = 0,
      y = 0;
  let stems = 0;

  function parse(code) {
    let i = 0;

    while (i < code.length) {
      let stackClean = false;
      let v = code[i++];
      let xa, xb, ya, yb, y1, y2, y3, n, subrCode;

      switch (v) {
        case 1:
          stems += stack.length >> 1;
          stackClean = true;
          break;

        case 3:
          stems += stack.length >> 1;
          stackClean = true;
          break;

        case 4:
          y += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;

        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }

          break;

        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            lineTo(x, y);

            if (stack.length === 0) {
              break;
            }

            y += stack.shift();
            lineTo(x, y);
          }

          break;

        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            lineTo(x, y);

            if (stack.length === 0) {
              break;
            }

            x += stack.shift();
            lineTo(x, y);
          }

          break;

        case 8:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }

          break;

        case 10:
          n = stack.pop();
          subrCode = null;

          if (font.isCFFCIDFont) {
            const fdIndex = font.fdSelect.getFDIndex(glyphId);

            if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
              const fontDict = font.fdArray[fdIndex];
              let subrs;

              if (fontDict.privateDict && fontDict.privateDict.subrsIndex) {
                subrs = fontDict.privateDict.subrsIndex.objects;
              }

              if (subrs) {
                n += getSubroutineBias(subrs);
                subrCode = subrs[n];
              }
            } else {
              (0, _util.warn)("Invalid fd index for glyph index.");
            }
          } else {
            subrCode = font.subrs[n + font.subrsBias];
          }

          if (subrCode) {
            parse(subrCode);
          }

          break;

        case 11:
          return;

        case 12:
          v = code[i++];

          switch (v) {
            case 34:
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y1 = y + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y, xb, y1, x, y1);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y, x, y);
              break;

            case 35:
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              stack.pop();
              break;

            case 36:
              xa = x + stack.shift();
              y1 = y + stack.shift();
              xb = xa + stack.shift();
              y2 = y1 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y2, x, y2);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y3 = y2 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y2, xb, y3, x, y);
              break;

            case 37:
              const x0 = x,
                    y0 = y;
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb;
              y = yb;

              if (Math.abs(x - x0) > Math.abs(y - y0)) {
                x += stack.shift();
              } else {
                y += stack.shift();
              }

              bezierCurveTo(xa, ya, xb, yb, x, y);
              break;

            default:
              throw new _util.FormatError(`unknown operator: 12 ${v}`);
          }

          break;

        case 14:
          if (stack.length >= 4) {
            const achar = stack.pop();
            const bchar = stack.pop();
            y = stack.pop();
            x = stack.pop();
            cmds.push({
              cmd: "save"
            });
            cmds.push({
              cmd: "translate",
              args: [x, y]
            });
            let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
            cmds.push({
              cmd: "restore"
            });
            cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
          }

          return;

        case 18:
          stems += stack.length >> 1;
          stackClean = true;
          break;

        case 19:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;

        case 20:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;

        case 21:
          y += stack.pop();
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;

        case 22:
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;

        case 23:
          stems += stack.length >> 1;
          stackClean = true;
          break;

        case 24:
          while (stack.length > 2) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }

          x += stack.shift();
          y += stack.shift();
          lineTo(x, y);
          break;

        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }

          xa = x + stack.shift();
          ya = y + stack.shift();
          xb = xa + stack.shift();
          yb = ya + stack.shift();
          x = xb + stack.shift();
          y = yb + stack.shift();
          bezierCurveTo(xa, ya, xb, yb, x, y);
          break;

        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }

          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb;
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }

          break;

        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }

          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb;
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }

          break;

        case 28:
          stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
          i += 2;
          break;

        case 29:
          n = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[n];

          if (subrCode) {
            parse(subrCode);
          }

          break;

        case 30:
          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);

            if (stack.length === 0) {
              break;
            }

            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }

          break;

        case 31:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);

            if (stack.length === 0) {
              break;
            }

            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }

          break;

        default:
          if (v < 32) {
            throw new _util.FormatError(`unknown operator: ${v}`);
          }

          if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            stack.push((v - 247) * 256 + code[i++] + 108);
          } else if (v < 255) {
            stack.push(-(v - 251) * 256 - code[i++] - 108);
          } else {
            stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
            i += 4;
          }

          break;
      }

      if (stackClean) {
        stack.length = 0;
      }
    }
  }

  parse(charStringCode);
}

const NOOP = [];

class CompiledFont {
  constructor(fontMatrix) {
    if (this.constructor === CompiledFont) {
      (0, _util.unreachable)("Cannot initialize CompiledFont.");
    }

    this.fontMatrix = fontMatrix;
    this.compiledGlyphs = Object.create(null);
    this.compiledCharCodeToGlyphId = Object.create(null);
  }

  getPathJs(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    let fn = this.compiledGlyphs[glyphId];

    if (!fn) {
      try {
        fn = this.compileGlyph(this.glyphs[glyphId], glyphId);
        this.compiledGlyphs[glyphId] = fn;
      } catch (ex) {
        this.compiledGlyphs[glyphId] = NOOP;

        if (this.compiledCharCodeToGlyphId[charCode] === undefined) {
          this.compiledCharCodeToGlyphId[charCode] = glyphId;
        }

        throw ex;
      }
    }

    if (this.compiledCharCodeToGlyphId[charCode] === undefined) {
      this.compiledCharCodeToGlyphId[charCode] = glyphId;
    }

    return fn;
  }

  compileGlyph(code, glyphId) {
    if (!code || code.length === 0 || code[0] === 14) {
      return NOOP;
    }

    let fontMatrix = this.fontMatrix;

    if (this.isCFFCIDFont) {
      const fdIndex = this.fdSelect.getFDIndex(glyphId);

      if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
        const fontDict = this.fdArray[fdIndex];
        fontMatrix = fontDict.getByName("FontMatrix") || _util.FONT_IDENTITY_MATRIX;
      } else {
        (0, _util.warn)("Invalid fd index for glyph index.");
      }
    }

    const cmds = [];
    cmds.push({
      cmd: "save"
    });
    cmds.push({
      cmd: "transform",
      args: fontMatrix.slice()
    });
    cmds.push({
      cmd: "scale",
      args: ["size", "-size"]
    });
    this.compileGlyphImpl(code, cmds, glyphId);
    cmds.push({
      cmd: "restore"
    });
    return cmds;
  }

  compileGlyphImpl() {
    (0, _util.unreachable)("Children classes should implement this.");
  }

  hasBuiltPath(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    return this.compiledGlyphs[glyphId] !== undefined && this.compiledCharCodeToGlyphId[charCode] !== undefined;
  }

}

class TrueTypeCompiled extends CompiledFont {
  constructor(glyphs, cmap, fontMatrix) {
    super(fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0]);
    this.glyphs = glyphs;
    this.cmap = cmap;
  }

  compileGlyphImpl(code, cmds) {
    compileGlyf(code, cmds, this);
  }

}

class Type2Compiled extends CompiledFont {
  constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
    super(fontMatrix || [0.001, 0, 0, 0.001, 0, 0]);
    this.glyphs = cffInfo.glyphs;
    this.gsubrs = cffInfo.gsubrs || [];
    this.subrs = cffInfo.subrs || [];
    this.cmap = cmap;
    this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
    this.gsubrsBias = getSubroutineBias(this.gsubrs);
    this.subrsBias = getSubroutineBias(this.subrs);
    this.isCFFCIDFont = cffInfo.isCFFCIDFont;
    this.fdSelect = cffInfo.fdSelect;
    this.fdArray = cffInfo.fdArray;
  }

  compileGlyphImpl(code, cmds, glyphId) {
    compileCharString(code, cmds, this, glyphId);
  }

}

class FontRendererFactory {
  static create(font, seacAnalysisEnabled) {
    const data = new Uint8Array(font.data);
    let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
    const numTables = getUshort(data, 4);

    for (let i = 0, p = 12; i < numTables; i++, p += 16) {
      const tag = (0, _util.bytesToString)(data.subarray(p, p + 4));
      const offset = getLong(data, p + 8);
      const length = getLong(data, p + 12);

      switch (tag) {
        case "cmap":
          cmap = parseCmap(data, offset, offset + length);
          break;

        case "glyf":
          glyf = data.subarray(offset, offset + length);
          break;

        case "loca":
          loca = data.subarray(offset, offset + length);
          break;

        case "head":
          unitsPerEm = getUshort(data, offset + 18);
          indexToLocFormat = getUshort(data, offset + 50);
          break;

        case "CFF ":
          cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
          break;
      }
    }

    if (glyf) {
      const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
      return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
    }

    return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
  }

}

exports.FontRendererFactory = FontRendererFactory;

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OpenTypeFileBuilder = void 0;

var _core_utils = __w_pdfjs_require__(9);

var _util = __w_pdfjs_require__(2);

function writeInt16(dest, offset, num) {
  dest[offset] = num >> 8 & 0xff;
  dest[offset + 1] = num & 0xff;
}

function writeInt32(dest, offset, num) {
  dest[offset] = num >> 24 & 0xff;
  dest[offset + 1] = num >> 16 & 0xff;
  dest[offset + 2] = num >> 8 & 0xff;
  dest[offset + 3] = num & 0xff;
}

function writeData(dest, offset, data) {
  if (data instanceof Uint8Array) {
    dest.set(data, offset);
  } else if (typeof data === "string") {
    for (let i = 0, ii = data.length; i < ii; i++) {
      dest[offset++] = data.charCodeAt(i) & 0xff;
    }
  } else {
    for (let i = 0, ii = data.length; i < ii; i++) {
      dest[offset++] = data[i] & 0xff;
    }
  }
}

const OTF_HEADER_SIZE = 12;
const OTF_TABLE_ENTRY_SIZE = 16;

class OpenTypeFileBuilder {
  constructor(sfnt) {
    this.sfnt = sfnt;
    this.tables = Object.create(null);
  }

  static getSearchParams(entriesCount, entrySize) {
    let maxPower2 = 1,
        log2 = 0;

    while ((maxPower2 ^ entriesCount) > maxPower2) {
      maxPower2 <<= 1;
      log2++;
    }

    const searchRange = maxPower2 * entrySize;
    return {
      range: searchRange,
      entry: log2,
      rangeShift: entrySize * entriesCount - searchRange
    };
  }

  toArray() {
    let sfnt = this.sfnt;
    const tables = this.tables;
    const tablesNames = Object.keys(tables);
    tablesNames.sort();
    const numTables = tablesNames.length;
    let i, j, jj, table, tableName;
    let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
    const tableOffsets = [offset];

    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      const paddedLength = (table.length + 3 & ~3) >>> 0;
      offset += paddedLength;
      tableOffsets.push(offset);
    }

    const file = new Uint8Array(offset);

    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      writeData(file, tableOffsets[i], table);
    }

    if (sfnt === "true") {
      sfnt = (0, _util.string32)(0x00010000);
    }

    file[0] = sfnt.charCodeAt(0) & 0xff;
    file[1] = sfnt.charCodeAt(1) & 0xff;
    file[2] = sfnt.charCodeAt(2) & 0xff;
    file[3] = sfnt.charCodeAt(3) & 0xff;
    writeInt16(file, 4, numTables);
    const searchParams = OpenTypeFileBuilder.getSearchParams(numTables, 16);
    writeInt16(file, 6, searchParams.range);
    writeInt16(file, 8, searchParams.entry);
    writeInt16(file, 10, searchParams.rangeShift);
    offset = OTF_HEADER_SIZE;

    for (i = 0; i < numTables; i++) {
      tableName = tablesNames[i];
      file[offset] = tableName.charCodeAt(0) & 0xff;
      file[offset + 1] = tableName.charCodeAt(1) & 0xff;
      file[offset + 2] = tableName.charCodeAt(2) & 0xff;
      file[offset + 3] = tableName.charCodeAt(3) & 0xff;
      let checksum = 0;

      for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
        const quad = (0, _core_utils.readUint32)(file, j);
        checksum = checksum + quad >>> 0;
      }

      writeInt32(file, offset + 4, checksum);
      writeInt32(file, offset + 8, tableOffsets[i]);
      writeInt32(file, offset + 12, tables[tableName].length);
      offset += OTF_TABLE_ENTRY_SIZE;
    }

    return file;
  }

  addTable(tag, data) {
    if (tag in this.tables) {
      throw new Error("Table " + tag + " already exists");
    }

    this.tables[tag] = data;
  }

}

exports.OpenTypeFileBuilder = OpenTypeFileBuilder;

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Type1Font = void 0;

var _cff_parser = __w_pdfjs_require__(35);

var _fonts_utils = __w_pdfjs_require__(38);

var _core_utils = __w_pdfjs_require__(9);

var _stream = __w_pdfjs_require__(10);

var _type1_parser = __w_pdfjs_require__(47);

var _util = __w_pdfjs_require__(2);

function findBlock(streamBytes, signature, startIndex) {
  const streamBytesLength = streamBytes.length;
  const signatureLength = signature.length;
  const scanLength = streamBytesLength - signatureLength;
  let i = startIndex,
      found = false;

  while (i < scanLength) {
    let j = 0;

    while (j < signatureLength && streamBytes[i + j] === signature[j]) {
      j++;
    }

    if (j >= signatureLength) {
      i += j;

      while (i < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i])) {
        i++;
      }

      found = true;
      break;
    }

    i++;
  }

  return {
    found,
    length: i
  };
}

function getHeaderBlock(stream, suggestedLength) {
  const EEXEC_SIGNATURE = [0x65, 0x65, 0x78, 0x65, 0x63];
  const streamStartPos = stream.pos;
  let headerBytes, headerBytesLength, block;

  try {
    headerBytes = stream.getBytes(suggestedLength);
    headerBytesLength = headerBytes.length;
  } catch (ex) {}

  if (headerBytesLength === suggestedLength) {
    block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);

    if (block.found && block.length === suggestedLength) {
      return {
        stream: new _stream.Stream(headerBytes),
        length: suggestedLength
      };
    }
  }

  (0, _util.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
  stream.pos = streamStartPos;
  const SCAN_BLOCK_LENGTH = 2048;
  let actualLength;

  while (true) {
    const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
    block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);

    if (block.length === 0) {
      break;
    }

    stream.pos += block.length;

    if (block.found) {
      actualLength = stream.pos - streamStartPos;
      break;
    }
  }

  stream.pos = streamStartPos;

  if (actualLength) {
    return {
      stream: new _stream.Stream(stream.getBytes(actualLength)),
      length: actualLength
    };
  }

  (0, _util.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
  return {
    stream: new _stream.Stream(stream.getBytes(suggestedLength)),
    length: suggestedLength
  };
}

function getEexecBlock(stream, suggestedLength) {
  const eexecBytes = stream.getBytes();
  return {
    stream: new _stream.Stream(eexecBytes),
    length: eexecBytes.length
  };
}

class Type1Font {
  constructor(name, file, properties) {
    const PFB_HEADER_SIZE = 6;
    let headerBlockLength = properties.length1;
    let eexecBlockLength = properties.length2;
    let pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
    const pfbHeaderPresent = pfbHeader[0] === 0x80 && pfbHeader[1] === 0x01;

    if (pfbHeaderPresent) {
      file.skip(PFB_HEADER_SIZE);
      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }

    const headerBlock = getHeaderBlock(file, headerBlockLength);
    const headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    headerBlockParser.extractFontHeader(properties);

    if (pfbHeaderPresent) {
      pfbHeader = file.getBytes(PFB_HEADER_SIZE);
      eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }

    const eexecBlock = getEexecBlock(file, eexecBlockLength);
    const eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, _fonts_utils.SEAC_ANALYSIS_ENABLED);
    const data = eexecBlockParser.extractFontProgram(properties);

    for (const key in data.properties) {
      properties[key] = data.properties[key];
    }

    const charstrings = data.charstrings;
    const type2Charstrings = this.getType2Charstrings(charstrings);
    const subrs = this.getType2Subrs(data.subrs);
    this.charstrings = charstrings;
    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
    this.seacs = this.getSeacs(data.charstrings);
  }

  get numGlyphs() {
    return this.charstrings.length + 1;
  }

  getCharset() {
    const charset = [".notdef"];
    const charstrings = this.charstrings;

    for (let glyphId = 0; glyphId < charstrings.length; glyphId++) {
      charset.push(charstrings[glyphId].glyphName);
    }

    return charset;
  }

  getGlyphMapping(properties) {
    const charstrings = this.charstrings;

    if (properties.composite) {
      const charCodeToGlyphId = Object.create(null);

      for (let glyphId = 0, charstringsLen = charstrings.length; glyphId < charstringsLen; glyphId++) {
        const charCode = properties.cMap.charCodeOf(glyphId);
        charCodeToGlyphId[charCode] = glyphId + 1;
      }

      return charCodeToGlyphId;
    }

    const glyphNames = [".notdef"];
    let builtInEncoding, glyphId;

    for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
      glyphNames.push(charstrings[glyphId].glyphName);
    }

    const encoding = properties.builtInEncoding;

    if (encoding) {
      builtInEncoding = Object.create(null);

      for (const charCode in encoding) {
        glyphId = glyphNames.indexOf(encoding[charCode]);

        if (glyphId >= 0) {
          builtInEncoding[charCode] = glyphId;
        }
      }
    }

    return (0, _fonts_utils.type1FontGlyphMapping)(properties, builtInEncoding, glyphNames);
  }

  hasGlyphId(id) {
    if (id < 0 || id >= this.numGlyphs) {
      return false;
    }

    if (id === 0) {
      return true;
    }

    const glyph = this.charstrings[id - 1];
    return glyph.charstring.length > 0;
  }

  getSeacs(charstrings) {
    const seacMap = [];

    for (let i = 0, ii = charstrings.length; i < ii; i++) {
      const charstring = charstrings[i];

      if (charstring.seac) {
        seacMap[i + 1] = charstring.seac;
      }
    }

    return seacMap;
  }

  getType2Charstrings(type1Charstrings) {
    const type2Charstrings = [];

    for (let i = 0, ii = type1Charstrings.length; i < ii; i++) {
      type2Charstrings.push(type1Charstrings[i].charstring);
    }

    return type2Charstrings;
  }

  getType2Subrs(type1Subrs) {
    let bias = 0;
    const count = type1Subrs.length;

    if (count < 1133) {
      bias = 107;
    } else if (count < 33769) {
      bias = 1131;
    } else {
      bias = 32768;
    }

    const type2Subrs = [];
    let i;

    for (i = 0; i < bias; i++) {
      type2Subrs.push([0x0b]);
    }

    for (i = 0; i < count; i++) {
      type2Subrs.push(type1Subrs[i]);
    }

    return type2Subrs;
  }

  wrap(name, glyphs, charstrings, subrs, properties) {
    const cff = new _cff_parser.CFF();
    cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
    cff.names = [name];
    const topDict = new _cff_parser.CFFTopDict();
    topDict.setByName("version", 391);
    topDict.setByName("Notice", 392);
    topDict.setByName("FullName", 393);
    topDict.setByName("FamilyName", 394);
    topDict.setByName("Weight", 395);
    topDict.setByName("Encoding", null);
    topDict.setByName("FontMatrix", properties.fontMatrix);
    topDict.setByName("FontBBox", properties.bbox);
    topDict.setByName("charset", null);
    topDict.setByName("CharStrings", null);
    topDict.setByName("Private", null);
    cff.topDict = topDict;
    const strings = new _cff_parser.CFFStrings();
    strings.add("Version 0.11");
    strings.add("See original notice");
    strings.add(name);
    strings.add(name);
    strings.add("Medium");
    cff.strings = strings;
    cff.globalSubrIndex = new _cff_parser.CFFIndex();
    const count = glyphs.length;
    const charsetArray = [".notdef"];
    let i, ii;

    for (i = 0; i < count; i++) {
      const glyphName = charstrings[i].glyphName;

      const index = _cff_parser.CFFStandardStrings.indexOf(glyphName);

      if (index === -1) {
        strings.add(glyphName);
      }

      charsetArray.push(glyphName);
    }

    cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
    const charStringsIndex = new _cff_parser.CFFIndex();
    charStringsIndex.add([0x8b, 0x0e]);

    for (i = 0; i < count; i++) {
      charStringsIndex.add(glyphs[i]);
    }

    cff.charStrings = charStringsIndex;
    const privateDict = new _cff_parser.CFFPrivateDict();
    privateDict.setByName("Subrs", null);
    const fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];

    for (i = 0, ii = fields.length; i < ii; i++) {
      const field = fields[i];

      if (!(field in properties.privateData)) {
        continue;
      }

      const value = properties.privateData[field];

      if (Array.isArray(value)) {
        for (let j = value.length - 1; j > 0; j--) {
          value[j] -= value[j - 1];
        }
      }

      privateDict.setByName(field, value);
    }

    cff.topDict.privateDict = privateDict;
    const subrIndex = new _cff_parser.CFFIndex();

    for (i = 0, ii = subrs.length; i < ii; i++) {
      subrIndex.add(subrs[i]);
    }

    privateDict.subrsIndex = subrIndex;
    const compiler = new _cff_parser.CFFCompiler(cff);
    return compiler.compile();
  }

}

exports.Type1Font = Type1Font;

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Type1Parser = void 0;

var _encodings = __w_pdfjs_require__(37);

var _core_utils = __w_pdfjs_require__(9);

var _stream = __w_pdfjs_require__(10);

var _util = __w_pdfjs_require__(2);

const HINTING_ENABLED = false;

const Type1CharString = function Type1CharStringClosure() {
  const COMMAND_MAP = {
    hstem: [1],
    vstem: [3],
    vmoveto: [4],
    rlineto: [5],
    hlineto: [6],
    vlineto: [7],
    rrcurveto: [8],
    callsubr: [10],
    flex: [12, 35],
    drop: [12, 18],
    endchar: [14],
    rmoveto: [21],
    hmoveto: [22],
    vhcurveto: [30],
    hvcurveto: [31]
  };

  class Type1CharString {
    constructor() {
      this.width = 0;
      this.lsb = 0;
      this.flexing = false;
      this.output = [];
      this.stack = [];
    }

    convert(encoded, subrs, seacAnalysisEnabled) {
      const count = encoded.length;
      let error = false;
      let wx, sbx, subrNumber;

      for (let i = 0; i < count; i++) {
        let value = encoded[i];

        if (value < 32) {
          if (value === 12) {
            value = (value << 8) + encoded[++i];
          }

          switch (value) {
            case 1:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;

            case 3:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;

            case 4:
              if (this.flexing) {
                if (this.stack.length < 1) {
                  error = true;
                  break;
                }

                const dy = this.stack.pop();
                this.stack.push(0, dy);
                break;
              }

              error = this.executeCommand(1, COMMAND_MAP.vmoveto);
              break;

            case 5:
              error = this.executeCommand(2, COMMAND_MAP.rlineto);
              break;

            case 6:
              error = this.executeCommand(1, COMMAND_MAP.hlineto);
              break;

            case 7:
              error = this.executeCommand(1, COMMAND_MAP.vlineto);
              break;

            case 8:
              error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
              break;

            case 9:
              this.stack = [];
              break;

            case 10:
              if (this.stack.length < 1) {
                error = true;
                break;
              }

              subrNumber = this.stack.pop();

              if (!subrs[subrNumber]) {
                error = true;
                break;
              }

              error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
              break;

            case 11:
              return error;

            case 13:
              if (this.stack.length < 2) {
                error = true;
                break;
              }

              wx = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx);
              error = this.executeCommand(2, COMMAND_MAP.hmoveto);
              break;

            case 14:
              this.output.push(COMMAND_MAP.endchar[0]);
              break;

            case 21:
              if (this.flexing) {
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.rmoveto);
              break;

            case 22:
              if (this.flexing) {
                this.stack.push(0);
                break;
              }

              error = this.executeCommand(1, COMMAND_MAP.hmoveto);
              break;

            case 30:
              error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
              break;

            case 31:
              error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
              break;

            case (12 << 8) + 0:
              this.stack = [];
              break;

            case (12 << 8) + 1:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;

            case (12 << 8) + 2:
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }

              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;

            case (12 << 8) + 6:
              if (seacAnalysisEnabled) {
                const asb = this.stack[this.stack.length - 5];
                this.seac = this.stack.splice(-4, 4);
                this.seac[0] += this.lsb - asb;
                error = this.executeCommand(0, COMMAND_MAP.endchar);
              } else {
                error = this.executeCommand(4, COMMAND_MAP.endchar);
              }

              break;

            case (12 << 8) + 7:
              if (this.stack.length < 4) {
                error = true;
                break;
              }

              this.stack.pop();
              wx = this.stack.pop();
              const sby = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx, sby);
              error = this.executeCommand(3, COMMAND_MAP.rmoveto);
              break;

            case (12 << 8) + 12:
              if (this.stack.length < 2) {
                error = true;
                break;
              }

              const num2 = this.stack.pop();
              const num1 = this.stack.pop();
              this.stack.push(num1 / num2);
              break;

            case (12 << 8) + 16:
              if (this.stack.length < 2) {
                error = true;
                break;
              }

              subrNumber = this.stack.pop();
              const numArgs = this.stack.pop();

              if (subrNumber === 0 && numArgs === 3) {
                const flexArgs = this.stack.splice(this.stack.length - 17, 17);
                this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                error = this.executeCommand(13, COMMAND_MAP.flex, true);
                this.flexing = false;
                this.stack.push(flexArgs[15], flexArgs[16]);
              } else if (subrNumber === 1 && numArgs === 0) {
                this.flexing = true;
              }

              break;

            case (12 << 8) + 17:
              break;

            case (12 << 8) + 33:
              this.stack = [];
              break;

            default:
              (0, _util.warn)('Unknown type 1 charstring command of "' + value + '"');
              break;
          }

          if (error) {
            break;
          }

          continue;
        } else if (value <= 246) {
          value = value - 139;
        } else if (value <= 250) {
          value = (value - 247) * 256 + encoded[++i] + 108;
        } else if (value <= 254) {
          value = -((value - 251) * 256) - encoded[++i] - 108;
        } else {
          value = (encoded[++i] & 0xff) << 24 | (encoded[++i] & 0xff) << 16 | (encoded[++i] & 0xff) << 8 | (encoded[++i] & 0xff) << 0;
        }

        this.stack.push(value);
      }

      return error;
    }

    executeCommand(howManyArgs, command, keepStack) {
      const stackLength = this.stack.length;

      if (howManyArgs > stackLength) {
        return true;
      }

      const start = stackLength - howManyArgs;

      for (let i = start; i < stackLength; i++) {
        let value = this.stack[i];

        if (Number.isInteger(value)) {
          this.output.push(28, value >> 8 & 0xff, value & 0xff);
        } else {
          value = 65536 * value | 0;
          this.output.push(255, value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
        }
      }

      this.output.push.apply(this.output, command);

      if (keepStack) {
        this.stack.splice(start, howManyArgs);
      } else {
        this.stack.length = 0;
      }

      return false;
    }

  }

  return Type1CharString;
}();

const Type1Parser = function Type1ParserClosure() {
  const EEXEC_ENCRYPT_KEY = 55665;
  const CHAR_STRS_ENCRYPT_KEY = 4330;

  function isHexDigit(code) {
    return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
  }

  function decrypt(data, key, discardNumber) {
    if (discardNumber >= data.length) {
      return new Uint8Array(0);
    }

    const c1 = 52845,
          c2 = 22719;
    let r = key | 0,
        i,
        j;

    for (i = 0; i < discardNumber; i++) {
      r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
    }

    const count = data.length - discardNumber;
    const decrypted = new Uint8Array(count);

    for (i = discardNumber, j = 0; j < count; i++, j++) {
      const value = data[i];
      decrypted[j] = value ^ r >> 8;
      r = (value + r) * c1 + c2 & (1 << 16) - 1;
    }

    return decrypted;
  }

  function decryptAscii(data, key, discardNumber) {
    const c1 = 52845,
          c2 = 22719;
    let r = key | 0;
    const count = data.length,
          maybeLength = count >>> 1;
    const decrypted = new Uint8Array(maybeLength);
    let i, j;

    for (i = 0, j = 0; i < count; i++) {
      const digit1 = data[i];

      if (!isHexDigit(digit1)) {
        continue;
      }

      i++;
      let digit2;

      while (i < count && !isHexDigit(digit2 = data[i])) {
        i++;
      }

      if (i < count) {
        const value = parseInt(String.fromCharCode(digit1, digit2), 16);
        decrypted[j++] = value ^ r >> 8;
        r = (value + r) * c1 + c2 & (1 << 16) - 1;
      }
    }

    return decrypted.slice(discardNumber, j);
  }

  function isSpecial(c) {
    return c === 0x2f || c === 0x5b || c === 0x5d || c === 0x7b || c === 0x7d || c === 0x28 || c === 0x29;
  }

  class Type1Parser {
    constructor(stream, encrypted, seacAnalysisEnabled) {
      if (encrypted) {
        const data = stream.getBytes();
        const isBinary = !((isHexDigit(data[0]) || (0, _core_utils.isWhiteSpace)(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));
        stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
      }

      this.seacAnalysisEnabled = !!seacAnalysisEnabled;
      this.stream = stream;
      this.nextChar();
    }

    readNumberArray() {
      this.getToken();
      const array = [];

      while (true) {
        const token = this.getToken();

        if (token === null || token === "]" || token === "}") {
          break;
        }

        array.push(parseFloat(token || 0));
      }

      return array;
    }

    readNumber() {
      const token = this.getToken();
      return parseFloat(token || 0);
    }

    readInt() {
      const token = this.getToken();
      return parseInt(token || 0, 10) | 0;
    }

    readBoolean() {
      const token = this.getToken();
      return token === "true" ? 1 : 0;
    }

    nextChar() {
      return this.currentChar = this.stream.getByte();
    }

    getToken() {
      let comment = false;
      let ch = this.currentChar;

      while (true) {
        if (ch === -1) {
          return null;
        }

        if (comment) {
          if (ch === 0x0a || ch === 0x0d) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
          break;
        }

        ch = this.nextChar();
      }

      if (isSpecial(ch)) {
        this.nextChar();
        return String.fromCharCode(ch);
      }

      let token = "";

      do {
        token += String.fromCharCode(ch);
        ch = this.nextChar();
      } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));

      return token;
    }

    readCharStrings(bytes, lenIV) {
      if (lenIV === -1) {
        return bytes;
      }

      return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
    }

    extractFontProgram(properties) {
      const stream = this.stream;
      const subrs = [],
            charstrings = [];
      const privateData = Object.create(null);
      privateData.lenIV = 4;
      const program = {
        subrs: [],
        charstrings: [],
        properties: {
          privateData
        }
      };
      let token, length, data, lenIV, encoded;

      while ((token = this.getToken()) !== null) {
        if (token !== "/") {
          continue;
        }

        token = this.getToken();

        switch (token) {
          case "CharStrings":
            this.getToken();
            this.getToken();
            this.getToken();
            this.getToken();

            while (true) {
              token = this.getToken();

              if (token === null || token === "end") {
                break;
              }

              if (token !== "/") {
                continue;
              }

              const glyph = this.getToken();
              length = this.readInt();
              this.getToken();
              data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
              lenIV = program.properties.privateData.lenIV;
              encoded = this.readCharStrings(data, lenIV);
              this.nextChar();
              token = this.getToken();

              if (token === "noaccess") {
                this.getToken();
              }

              charstrings.push({
                glyph,
                encoded
              });
            }

            break;

          case "Subrs":
            this.readInt();
            this.getToken();

            while (this.getToken() === "dup") {
              const index = this.readInt();
              length = this.readInt();
              this.getToken();
              data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
              lenIV = program.properties.privateData.lenIV;
              encoded = this.readCharStrings(data, lenIV);
              this.nextChar();
              token = this.getToken();

              if (token === "noaccess") {
                this.getToken();
              }

              subrs[index] = encoded;
            }

            break;

          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            const blueArray = this.readNumberArray();

            if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
              program.properties.privateData[token] = blueArray;
            }

            break;

          case "StemSnapH":
          case "StemSnapV":
            program.properties.privateData[token] = this.readNumberArray();
            break;

          case "StdHW":
          case "StdVW":
            program.properties.privateData[token] = this.readNumberArray()[0];
            break;

          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
          case "ExpansionFactor":
            program.properties.privateData[token] = this.readNumber();
            break;

          case "ForceBold":
            program.properties.privateData[token] = this.readBoolean();
            break;
        }
      }

      for (let i = 0; i < charstrings.length; i++) {
        const glyph = charstrings[i].glyph;
        encoded = charstrings[i].encoded;
        const charString = new Type1CharString();
        const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
        let output = charString.output;

        if (error) {
          output = [14];
        }

        const charStringObject = {
          glyphName: glyph,
          charstring: output,
          width: charString.width,
          lsb: charString.lsb,
          seac: charString.seac
        };

        if (glyph === ".notdef") {
          program.charstrings.unshift(charStringObject);
        } else {
          program.charstrings.push(charStringObject);
        }

        if (properties.builtInEncoding) {
          const index = properties.builtInEncoding.indexOf(glyph);

          if (index > -1 && properties.widths[index] === undefined && index >= properties.firstChar && index <= properties.lastChar) {
            properties.widths[index] = charString.width;
          }
        }
      }

      return program;
    }

    extractFontHeader(properties) {
      let token;

      while ((token = this.getToken()) !== null) {
        if (token !== "/") {
          continue;
        }

        token = this.getToken();

        switch (token) {
          case "FontMatrix":
            const matrix = this.readNumberArray();
            properties.fontMatrix = matrix;
            break;

          case "Encoding":
            const encodingArg = this.getToken();
            let encoding;

            if (!/^\d+$/.test(encodingArg)) {
              encoding = (0, _encodings.getEncoding)(encodingArg);
            } else {
              encoding = [];
              const size = parseInt(encodingArg, 10) | 0;
              this.getToken();

              for (let j = 0; j < size; j++) {
                token = this.getToken();

                while (token !== "dup" && token !== "def") {
                  token = this.getToken();

                  if (token === null) {
                    return;
                  }
                }

                if (token === "def") {
                  break;
                }

                const index = this.readInt();
                this.getToken();
                const glyph = this.getToken();
                encoding[index] = glyph;
                this.getToken();
              }
            }

            properties.builtInEncoding = encoding;
            break;

          case "FontBBox":
            const fontBBox = this.readNumberArray();
            properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
            properties.descent = Math.min(fontBBox[1], fontBBox[3]);
            properties.ascentScaled = true;
            break;
        }
      }
    }

  }

  return Type1Parser;
}();

exports.Type1Parser = Type1Parser;

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getTilingPatternIR = getTilingPatternIR;
exports.Pattern = void 0;

var _util = __w_pdfjs_require__(2);

var _colorspace = __w_pdfjs_require__(14);

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

const ShadingType = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};

class Pattern {
  constructor() {
    (0, _util.unreachable)("Cannot initialize Pattern.");
  }

  static parseShading(shading, matrix, xref, res, handler, pdfFunctionFactory, localColorSpaceCache) {
    const dict = (0, _primitives.isStream)(shading) ? shading.dict : shading;
    const type = dict.get("ShadingType");

    try {
      switch (type) {
        case ShadingType.AXIAL:
        case ShadingType.RADIAL:
          return new RadialAxialShading(dict, matrix, xref, res, pdfFunctionFactory, localColorSpaceCache);

        case ShadingType.FREE_FORM_MESH:
        case ShadingType.LATTICE_FORM_MESH:
        case ShadingType.COONS_PATCH_MESH:
        case ShadingType.TENSOR_PATCH_MESH:
          return new MeshShading(shading, matrix, xref, res, pdfFunctionFactory, localColorSpaceCache);

        default:
          throw new _util.FormatError("Unsupported ShadingType: " + type);
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      handler.send("UnsupportedFeature", {
        featureId: _util.UNSUPPORTED_FEATURES.shadingPattern
      });
      (0, _util.warn)(ex);
      return new DummyShading();
    }
  }

}

exports.Pattern = Pattern;

class BaseShading {
  static get SMALL_NUMBER() {
    return (0, _util.shadow)(this, "SMALL_NUMBER", 1e-6);
  }

  constructor() {
    if (this.constructor === BaseShading) {
      (0, _util.unreachable)("Cannot initialize BaseShading.");
    }
  }

  getIR() {
    (0, _util.unreachable)("Abstract method `getIR` called.");
  }

}

class RadialAxialShading extends BaseShading {
  constructor(dict, matrix, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();
    this.matrix = matrix;
    this.coordsArr = dict.getArray("Coords");
    this.shadingType = dict.get("ShadingType");

    const cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("ColorSpace") || dict.getRaw("CS"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });

    const bbox = dict.getArray("BBox");

    if (Array.isArray(bbox) && bbox.length === 4) {
      this.bbox = _util.Util.normalizeRect(bbox);
    } else {
      this.bbox = null;
    }

    let t0 = 0.0,
        t1 = 1.0;

    if (dict.has("Domain")) {
      const domainArr = dict.getArray("Domain");
      t0 = domainArr[0];
      t1 = domainArr[1];
    }

    let extendStart = false,
        extendEnd = false;

    if (dict.has("Extend")) {
      const extendArr = dict.getArray("Extend");
      extendStart = extendArr[0];
      extendEnd = extendArr[1];
    }

    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
      const [x1, y1, r1, x2, y2, r2] = this.coordsArr;
      const distance = Math.hypot(x1 - x2, y1 - y2);

      if (r1 <= r2 + distance && r2 <= r1 + distance) {
        (0, _util.warn)("Unsupported radial gradient.");
      }
    }

    this.extendStart = extendStart;
    this.extendEnd = extendEnd;
    const fnObj = dict.getRaw("Function");
    const fn = pdfFunctionFactory.createFromArray(fnObj);
    const NUMBER_OF_SAMPLES = 10;
    const step = (t1 - t0) / NUMBER_OF_SAMPLES;
    const colorStops = this.colorStops = [];

    if (t0 >= t1 || step <= 0) {
      (0, _util.info)("Bad shading domain.");
      return;
    }

    const color = new Float32Array(cs.numComps),
          ratio = new Float32Array(1);
    let rgbColor;

    for (let i = 0; i <= NUMBER_OF_SAMPLES; i++) {
      ratio[0] = t0 + i * step;
      fn(ratio, 0, color, 0);
      rgbColor = cs.getRgb(color, 0);

      const cssColor = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);

      colorStops.push([i / NUMBER_OF_SAMPLES, cssColor]);
    }

    let background = "transparent";

    if (dict.has("Background")) {
      rgbColor = cs.getRgb(dict.get("Background"), 0);
      background = _util.Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
    }

    if (!extendStart) {
      colorStops.unshift([0, background]);
      colorStops[1][0] += BaseShading.SMALL_NUMBER;
    }

    if (!extendEnd) {
      colorStops[colorStops.length - 1][0] -= BaseShading.SMALL_NUMBER;
      colorStops.push([1, background]);
    }

    this.colorStops = colorStops;
  }

  getIR() {
    const coordsArr = this.coordsArr;
    const shadingType = this.shadingType;
    let type, p0, p1, r0, r1;

    if (shadingType === ShadingType.AXIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[2], coordsArr[3]];
      r0 = null;
      r1 = null;
      type = "axial";
    } else if (shadingType === ShadingType.RADIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[3], coordsArr[4]];
      r0 = coordsArr[2];
      r1 = coordsArr[5];
      type = "radial";
    } else {
      (0, _util.unreachable)(`getPattern type unknown: ${shadingType}`);
    }

    return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1, this.matrix];
  }

}

class MeshStreamReader {
  constructor(stream, context) {
    this.stream = stream;
    this.context = context;
    this.buffer = 0;
    this.bufferLength = 0;
    const numComps = context.numComps;
    this.tmpCompsBuf = new Float32Array(numComps);
    const csNumComps = context.colorSpace.numComps;
    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
  }

  get hasData() {
    if (this.stream.end) {
      return this.stream.pos < this.stream.end;
    }

    if (this.bufferLength > 0) {
      return true;
    }

    const nextByte = this.stream.getByte();

    if (nextByte < 0) {
      return false;
    }

    this.buffer = nextByte;
    this.bufferLength = 8;
    return true;
  }

  readBits(n) {
    let buffer = this.buffer;
    let bufferLength = this.bufferLength;

    if (n === 32) {
      if (bufferLength === 0) {
        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      }

      buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const nextByte = this.stream.getByte();
      this.buffer = nextByte & (1 << bufferLength) - 1;
      return (buffer << 8 - bufferLength | (nextByte & 0xff) >> bufferLength) >>> 0;
    }

    if (n === 8 && bufferLength === 0) {
      return this.stream.getByte();
    }

    while (bufferLength < n) {
      buffer = buffer << 8 | this.stream.getByte();
      bufferLength += 8;
    }

    bufferLength -= n;
    this.bufferLength = bufferLength;
    this.buffer = buffer & (1 << bufferLength) - 1;
    return buffer >> bufferLength;
  }

  align() {
    this.buffer = 0;
    this.bufferLength = 0;
  }

  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }

  readCoordinate() {
    const bitsPerCoordinate = this.context.bitsPerCoordinate;
    const xi = this.readBits(bitsPerCoordinate);
    const yi = this.readBits(bitsPerCoordinate);
    const decode = this.context.decode;
    const scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 2.3283064365386963e-10;
    return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
  }

  readComponents() {
    const numComps = this.context.numComps;
    const bitsPerComponent = this.context.bitsPerComponent;
    const scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 2.3283064365386963e-10;
    const decode = this.context.decode;
    const components = this.tmpCompsBuf;

    for (let i = 0, j = 4; i < numComps; i++, j += 2) {
      const ci = this.readBits(bitsPerComponent);
      components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
    }

    const color = this.tmpCsCompsBuf;

    if (this.context.colorFn) {
      this.context.colorFn(components, 0, color, 0);
    }

    return this.context.colorSpace.getRgb(color, 0);
  }

}

const getB = function getBClosure() {
  function buildB(count) {
    const lut = [];

    for (let i = 0; i <= count; i++) {
      const t = i / count,
            t_ = 1 - t;
      lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
    }

    return lut;
  }

  const cache = [];
  return function (count) {
    if (!cache[count]) {
      cache[count] = buildB(count);
    }

    return cache[count];
  };
}();

class MeshShading extends BaseShading {
  static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() {
    return (0, _util.shadow)(this, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
  }

  static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() {
    return (0, _util.shadow)(this, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
  }

  static get TRIANGLE_DENSITY() {
    return (0, _util.shadow)(this, "TRIANGLE_DENSITY", 20);
  }

  constructor(stream, matrix, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();

    if (!(0, _primitives.isStream)(stream)) {
      throw new _util.FormatError("Mesh data is not a stream");
    }

    const dict = stream.dict;
    this.matrix = matrix;
    this.shadingType = dict.get("ShadingType");
    const bbox = dict.getArray("BBox");

    if (Array.isArray(bbox) && bbox.length === 4) {
      this.bbox = _util.Util.normalizeRect(bbox);
    } else {
      this.bbox = null;
    }

    const cs = _colorspace.ColorSpace.parse({
      cs: dict.getRaw("ColorSpace") || dict.getRaw("CS"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });

    this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
    const fnObj = dict.getRaw("Function");
    const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    const decodeContext = {
      bitsPerCoordinate: dict.get("BitsPerCoordinate"),
      bitsPerComponent: dict.get("BitsPerComponent"),
      bitsPerFlag: dict.get("BitsPerFlag"),
      decode: dict.getArray("Decode"),
      colorFn: fn,
      colorSpace: cs,
      numComps: fn ? 1 : cs.numComps
    };
    const reader = new MeshStreamReader(stream, decodeContext);
    let patchMesh = false;

    switch (this.shadingType) {
      case ShadingType.FREE_FORM_MESH:
        this._decodeType4Shading(reader);

        break;

      case ShadingType.LATTICE_FORM_MESH:
        const verticesPerRow = dict.get("VerticesPerRow") | 0;

        if (verticesPerRow < 2) {
          throw new _util.FormatError("Invalid VerticesPerRow");
        }

        this._decodeType5Shading(reader, verticesPerRow);

        break;

      case ShadingType.COONS_PATCH_MESH:
        this._decodeType6Shading(reader);

        patchMesh = true;
        break;

      case ShadingType.TENSOR_PATCH_MESH:
        this._decodeType7Shading(reader);

        patchMesh = true;
        break;

      default:
        (0, _util.unreachable)("Unsupported mesh type.");
        break;
    }

    if (patchMesh) {
      this._updateBounds();

      for (let i = 0, ii = this.figures.length; i < ii; i++) {
        this._buildFigureFromPatch(i);
      }
    }

    this._updateBounds();

    this._packData();
  }

  _decodeType4Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const operators = [];
    const ps = [];
    let verticesLeft = 0;

    while (reader.hasData) {
      const f = reader.readFlag();
      const coord = reader.readCoordinate();
      const color = reader.readComponents();

      if (verticesLeft === 0) {
        if (!(0 <= f && f <= 2)) {
          throw new _util.FormatError("Unknown type4 flag");
        }

        switch (f) {
          case 0:
            verticesLeft = 3;
            break;

          case 1:
            ps.push(ps[ps.length - 2], ps[ps.length - 1]);
            verticesLeft = 1;
            break;

          case 2:
            ps.push(ps[ps.length - 3], ps[ps.length - 1]);
            verticesLeft = 1;
            break;
        }

        operators.push(f);
      }

      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
      verticesLeft--;
      reader.align();
    }

    this.figures.push({
      type: "triangles",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps)
    });
  }

  _decodeType5Shading(reader, verticesPerRow) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = [];

    while (reader.hasData) {
      const coord = reader.readCoordinate();
      const color = reader.readComponents();
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
    }

    this.figures.push({
      type: "lattice",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps),
      verticesPerRow
    });
  }

  _decodeType6Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);

    while (reader.hasData) {
      const f = reader.readFlag();

      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type6 flag");
      }

      const pi = coords.length;

      for (let i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }

      const ci = colors.length;

      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }

      let tmp1, tmp2, tmp3, tmp4;

      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;

        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }

      ps[5] = coords.length;
      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
      ps[6] = coords.length;
      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
      ps[9] = coords.length;
      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
      ps[10] = coords.length;
      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }

  _decodeType7Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);

    while (reader.hasData) {
      const f = reader.readFlag();

      if (!(0 <= f && f <= 3)) {
        throw new _util.FormatError("Unknown type7 flag");
      }

      const pi = coords.length;

      for (let i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }

      const ci = colors.length;

      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }

      let tmp1, tmp2, tmp3, tmp4;

      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[9] = pi + 13;
          ps[10] = pi + 14;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[5] = pi + 12;
          ps[6] = pi + 15;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;

        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;

        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }

      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        colors: new Int32Array(cs)
      });
    }
  }

  _buildFigureFromPatch(index) {
    const figure = this.figures[index];
    (0, _util.assert)(figure.type === "patch", "Unexpected patch mesh figure");
    const coords = this.coords,
          colors = this.colors;
    const pi = figure.coords;
    const ci = figure.colors;
    const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    let splitXBy = Math.ceil((figureMaxX - figureMinX) * MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    splitXBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
    let splitYBy = Math.ceil((figureMaxY - figureMinY) * MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    splitYBy = Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
    const verticesPerRow = splitXBy + 1;
    const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
    const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
    let k = 0;
    const cl = new Uint8Array(3),
          cr = new Uint8Array(3);
    const c0 = colors[ci[0]],
          c1 = colors[ci[1]],
          c2 = colors[ci[2]],
          c3 = colors[ci[3]];
    const bRow = getB(splitYBy),
          bCol = getB(splitXBy);

    for (let row = 0; row <= splitYBy; row++) {
      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;

      for (let col = 0; col <= splitXBy; col++, k++) {
        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
          continue;
        }

        let x = 0,
            y = 0;
        let q = 0;

        for (let i = 0; i <= 3; i++) {
          for (let j = 0; j <= 3; j++, q++) {
            const m = bRow[row][i] * bCol[col][j];
            x += coords[pi[q]][0] * m;
            y += coords[pi[q]][1] * m;
          }
        }

        figureCoords[k] = coords.length;
        coords.push([x, y]);
        figureColors[k] = colors.length;
        const newColor = new Uint8Array(3);
        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
        colors.push(newColor);
      }
    }

    figureCoords[0] = pi[0];
    figureColors[0] = ci[0];
    figureCoords[splitXBy] = pi[3];
    figureColors[splitXBy] = ci[1];
    figureCoords[verticesPerRow * splitYBy] = pi[12];
    figureColors[verticesPerRow * splitYBy] = ci[2];
    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
    this.figures[index] = {
      type: "lattice",
      coords: figureCoords,
      colors: figureColors,
      verticesPerRow
    };
  }

  _updateBounds() {
    let minX = this.coords[0][0],
        minY = this.coords[0][1],
        maxX = minX,
        maxY = minY;

    for (let i = 1, ii = this.coords.length; i < ii; i++) {
      const x = this.coords[i][0],
            y = this.coords[i][1];
      minX = minX > x ? x : minX;
      minY = minY > y ? y : minY;
      maxX = maxX < x ? x : maxX;
      maxY = maxY < y ? y : maxY;
    }

    this.bounds = [minX, minY, maxX, maxY];
  }

  _packData() {
    let i, ii, j, jj;
    const coords = this.coords;
    const coordsPacked = new Float32Array(coords.length * 2);

    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
      const xy = coords[i];
      coordsPacked[j++] = xy[0];
      coordsPacked[j++] = xy[1];
    }

    this.coords = coordsPacked;
    const colors = this.colors;
    const colorsPacked = new Uint8Array(colors.length * 3);

    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
      const c = colors[i];
      colorsPacked[j++] = c[0];
      colorsPacked[j++] = c[1];
      colorsPacked[j++] = c[2];
    }

    this.colors = colorsPacked;
    const figures = this.figures;

    for (i = 0, ii = figures.length; i < ii; i++) {
      const figure = figures[i],
            ps = figure.coords,
            cs = figure.colors;

      for (j = 0, jj = ps.length; j < jj; j++) {
        ps[j] *= 2;
        cs[j] *= 3;
      }
    }
  }

  getIR() {
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
  }

}

class DummyShading extends BaseShading {
  getIR() {
    return ["Dummy"];
  }

}

function getTilingPatternIR(operatorList, dict, color) {
  const matrix = dict.getArray("Matrix");

  const bbox = _util.Util.normalizeRect(dict.getArray("BBox"));

  const xstep = dict.get("XStep");
  const ystep = dict.get("YStep");
  const paintType = dict.get("PaintType");
  const tilingType = dict.get("TilingType");

  if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
    throw new _util.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
  }

  return ["TilingPattern", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
}

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isPDFFunction = isPDFFunction;
exports.PostScriptEvaluator = exports.PostScriptCompiler = exports.PDFFunctionFactory = void 0;

var _primitives = __w_pdfjs_require__(5);

var _util = __w_pdfjs_require__(2);

var _ps_parser = __w_pdfjs_require__(50);

var _image_utils = __w_pdfjs_require__(51);

class PDFFunctionFactory {
  constructor({
    xref,
    isEvalSupported = true
  }) {
    this.xref = xref;
    this.isEvalSupported = isEvalSupported !== false;
  }

  create(fn) {
    const cachedFunction = this.getCached(fn);

    if (cachedFunction) {
      return cachedFunction;
    }

    const parsedFunction = PDFFunction.parse({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fn: fn instanceof _primitives.Ref ? this.xref.fetch(fn) : fn
    });

    this._cache(fn, parsedFunction);

    return parsedFunction;
  }

  createFromArray(fnObj) {
    const cachedFunction = this.getCached(fnObj);

    if (cachedFunction) {
      return cachedFunction;
    }

    const parsedFunction = PDFFunction.parseArray({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fnObj: fnObj instanceof _primitives.Ref ? this.xref.fetch(fnObj) : fnObj
    });

    this._cache(fnObj, parsedFunction);

    return parsedFunction;
  }

  getCached(cacheKey) {
    let fnRef;

    if (cacheKey instanceof _primitives.Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof _primitives.Dict) {
      fnRef = cacheKey.objId;
    } else if ((0, _primitives.isStream)(cacheKey)) {
      fnRef = cacheKey.dict && cacheKey.dict.objId;
    }

    if (fnRef) {
      const localFunction = this._localFunctionCache.getByRef(fnRef);

      if (localFunction) {
        return localFunction;
      }
    }

    return null;
  }

  _cache(cacheKey, parsedFunction) {
    if (!parsedFunction) {
      throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    }

    let fnRef;

    if (cacheKey instanceof _primitives.Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof _primitives.Dict) {
      fnRef = cacheKey.objId;
    } else if ((0, _primitives.isStream)(cacheKey)) {
      fnRef = cacheKey.dict && cacheKey.dict.objId;
    }

    if (fnRef) {
      this._localFunctionCache.set(null, fnRef, parsedFunction);
    }
  }

  get _localFunctionCache() {
    return (0, _util.shadow)(this, "_localFunctionCache", new _image_utils.LocalFunctionCache());
  }

}

exports.PDFFunctionFactory = PDFFunctionFactory;

function toNumberArray(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }

  const length = arr.length;

  for (let i = 0; i < length; i++) {
    if (typeof arr[i] !== "number") {
      const result = new Array(length);

      for (let j = 0; j < length; j++) {
        result[j] = +arr[j];
      }

      return result;
    }
  }

  return arr;
}

const PDFFunction = function PDFFunctionClosure() {
  const CONSTRUCT_SAMPLED = 0;
  const CONSTRUCT_INTERPOLATED = 2;
  const CONSTRUCT_STICHED = 3;
  const CONSTRUCT_POSTSCRIPT = 4;
  return {
    getSampleArray(size, outputSize, bps, stream) {
      let i, ii;
      let length = 1;

      for (i = 0, ii = size.length; i < ii; i++) {
        length *= size[i];
      }

      length *= outputSize;
      const array = new Array(length);
      let codeSize = 0;
      let codeBuf = 0;
      const sampleMul = 1.0 / (2.0 ** bps - 1);
      const strBytes = stream.getBytes((length * bps + 7) / 8);
      let strIdx = 0;

      for (i = 0; i < length; i++) {
        while (codeSize < bps) {
          codeBuf <<= 8;
          codeBuf |= strBytes[strIdx++];
          codeSize += 8;
        }

        codeSize -= bps;
        array[i] = (codeBuf >> codeSize) * sampleMul;
        codeBuf &= (1 << codeSize) - 1;
      }

      return array;
    },

    getIR({
      xref,
      isEvalSupported,
      fn
    }) {
      let dict = fn.dict;

      if (!dict) {
        dict = fn;
      }

      const types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
      const typeNum = dict.get("FunctionType");
      const typeFn = types[typeNum];

      if (!typeFn) {
        throw new _util.FormatError("Unknown type of function");
      }

      return typeFn.call(this, {
        xref,
        isEvalSupported,
        fn,
        dict
      });
    },

    fromIR({
      xref,
      isEvalSupported,
      IR
    }) {
      const type = IR[0];

      switch (type) {
        case CONSTRUCT_SAMPLED:
          return this.constructSampledFromIR({
            xref,
            isEvalSupported,
            IR
          });

        case CONSTRUCT_INTERPOLATED:
          return this.constructInterpolatedFromIR({
            xref,
            isEvalSupported,
            IR
          });

        case CONSTRUCT_STICHED:
          return this.constructStichedFromIR({
            xref,
            isEvalSupported,
            IR
          });

        default:
          return this.constructPostScriptFromIR({
            xref,
            isEvalSupported,
            IR
          });
      }
    },

    parse({
      xref,
      isEvalSupported,
      fn
    }) {
      const IR = this.getIR({
        xref,
        isEvalSupported,
        fn
      });
      return this.fromIR({
        xref,
        isEvalSupported,
        IR
      });
    },

    parseArray({
      xref,
      isEvalSupported,
      fnObj
    }) {
      if (!Array.isArray(fnObj)) {
        return this.parse({
          xref,
          isEvalSupported,
          fn: fnObj
        });
      }

      const fnArray = [];

      for (let j = 0, jj = fnObj.length; j < jj; j++) {
        fnArray.push(this.parse({
          xref,
          isEvalSupported,
          fn: xref.fetchIfRef(fnObj[j])
        }));
      }

      return function (src, srcOffset, dest, destOffset) {
        for (let i = 0, ii = fnArray.length; i < ii; i++) {
          fnArray[i](src, srcOffset, dest, destOffset + i);
        }
      };
    },

    constructSampled({
      xref,
      isEvalSupported,
      fn,
      dict
    }) {
      function toMultiArray(arr) {
        const inputLength = arr.length;
        const out = [];
        let index = 0;

        for (let i = 0; i < inputLength; i += 2) {
          out[index] = [arr[i], arr[i + 1]];
          ++index;
        }

        return out;
      }

      let domain = toNumberArray(dict.getArray("Domain"));
      let range = toNumberArray(dict.getArray("Range"));

      if (!domain || !range) {
        throw new _util.FormatError("No domain or range");
      }

      const inputSize = domain.length / 2;
      const outputSize = range.length / 2;
      domain = toMultiArray(domain);
      range = toMultiArray(range);
      const size = toNumberArray(dict.getArray("Size"));
      const bps = dict.get("BitsPerSample");
      const order = dict.get("Order") || 1;

      if (order !== 1) {
        (0, _util.info)("No support for cubic spline interpolation: " + order);
      }

      let encode = toNumberArray(dict.getArray("Encode"));

      if (!encode) {
        encode = [];

        for (let i = 0; i < inputSize; ++i) {
          encode.push([0, size[i] - 1]);
        }
      } else {
        encode = toMultiArray(encode);
      }

      let decode = toNumberArray(dict.getArray("Decode"));

      if (!decode) {
        decode = range;
      } else {
        decode = toMultiArray(decode);
      }

      const samples = this.getSampleArray(size, outputSize, bps, fn);
      return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, 2 ** bps - 1, range];
    },

    constructSampledFromIR({
      xref,
      isEvalSupported,
      IR
    }) {
      function interpolate(x, xmin, xmax, ymin, ymax) {
        return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
      }

      return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
        const m = IR[1];
        const domain = IR[2];
        const encode = IR[3];
        const decode = IR[4];
        const samples = IR[5];
        const size = IR[6];
        const n = IR[7];
        const range = IR[9];
        const cubeVertices = 1 << m;
        const cubeN = new Float64Array(cubeVertices);
        const cubeVertex = new Uint32Array(cubeVertices);
        let i, j;

        for (j = 0; j < cubeVertices; j++) {
          cubeN[j] = 1;
        }

        let k = n,
            pos = 1;

        for (i = 0; i < m; ++i) {
          const domain_2i = domain[i][0];
          const domain_2i_1 = domain[i][1];
          const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
          let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
          const size_i = size[i];
          e = Math.min(Math.max(e, 0), size_i - 1);
          const e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
          const n0 = e0 + 1 - e;
          const n1 = e - e0;
          const offset0 = e0 * k;
          const offset1 = offset0 + k;

          for (j = 0; j < cubeVertices; j++) {
            if (j & pos) {
              cubeN[j] *= n1;
              cubeVertex[j] += offset1;
            } else {
              cubeN[j] *= n0;
              cubeVertex[j] += offset0;
            }
          }

          k *= size_i;
          pos <<= 1;
        }

        for (j = 0; j < n; ++j) {
          let rj = 0;

          for (i = 0; i < cubeVertices; i++) {
            rj += samples[cubeVertex[i] + j] * cubeN[i];
          }

          rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
          dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
        }
      };
    },

    constructInterpolated({
      xref,
      isEvalSupported,
      fn,
      dict
    }) {
      const c0 = toNumberArray(dict.getArray("C0")) || [0];
      const c1 = toNumberArray(dict.getArray("C1")) || [1];
      const n = dict.get("N");
      const length = c0.length;
      const diff = [];

      for (let i = 0; i < length; ++i) {
        diff.push(c1[i] - c0[i]);
      }

      return [CONSTRUCT_INTERPOLATED, c0, diff, n];
    },

    constructInterpolatedFromIR({
      xref,
      isEvalSupported,
      IR
    }) {
      const c0 = IR[1];
      const diff = IR[2];
      const n = IR[3];
      const length = diff.length;
      return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
        const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;

        for (let j = 0; j < length; ++j) {
          dest[destOffset + j] = c0[j] + x * diff[j];
        }
      };
    },

    constructStiched({
      xref,
      isEvalSupported,
      fn,
      dict
    }) {
      const domain = toNumberArray(dict.getArray("Domain"));

      if (!domain) {
        throw new _util.FormatError("No domain");
      }

      const inputSize = domain.length / 2;

      if (inputSize !== 1) {
        throw new _util.FormatError("Bad domain for stiched function");
      }

      const fnRefs = dict.get("Functions");
      const fns = [];

      for (let i = 0, ii = fnRefs.length; i < ii; ++i) {
        fns.push(this.parse({
          xref,
          isEvalSupported,
          fn: xref.fetchIfRef(fnRefs[i])
        }));
      }

      const bounds = toNumberArray(dict.getArray("Bounds"));
      const encode = toNumberArray(dict.getArray("Encode"));
      return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
    },

    constructStichedFromIR({
      xref,
      isEvalSupported,
      IR
    }) {
      const domain = IR[1];
      const bounds = IR[2];
      const encode = IR[3];
      const fns = IR[4];
      const tmpBuf = new Float32Array(1);
      return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
        const clip = function constructStichedFromIRClip(v, min, max) {
          if (v > max) {
            v = max;
          } else if (v < min) {
            v = min;
          }

          return v;
        };

        const v = clip(src[srcOffset], domain[0], domain[1]);
        const length = bounds.length;
        let i;

        for (i = 0; i < length; ++i) {
          if (v < bounds[i]) {
            break;
          }
        }

        let dmin = domain[0];

        if (i > 0) {
          dmin = bounds[i - 1];
        }

        let dmax = domain[1];

        if (i < bounds.length) {
          dmax = bounds[i];
        }

        const rmin = encode[2 * i];
        const rmax = encode[2 * i + 1];
        tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
        fns[i](tmpBuf, 0, dest, destOffset);
      };
    },

    constructPostScript({
      xref,
      isEvalSupported,
      fn,
      dict
    }) {
      const domain = toNumberArray(dict.getArray("Domain"));
      const range = toNumberArray(dict.getArray("Range"));

      if (!domain) {
        throw new _util.FormatError("No domain.");
      }

      if (!range) {
        throw new _util.FormatError("No range.");
      }

      const lexer = new _ps_parser.PostScriptLexer(fn);
      const parser = new _ps_parser.PostScriptParser(lexer);
      const code = parser.parse();
      return [CONSTRUCT_POSTSCRIPT, domain, range, code];
    },

    constructPostScriptFromIR({
      xref,
      isEvalSupported,
      IR
    }) {
      const domain = IR[1];
      const range = IR[2];
      const code = IR[3];

      if (isEvalSupported && _util.IsEvalSupportedCached.value) {
        const compiled = new PostScriptCompiler().compile(code, domain, range);

        if (compiled) {
          return new Function("src", "srcOffset", "dest", "destOffset", compiled);
        }
      }

      (0, _util.info)("Unable to compile PS function");
      const numOutputs = range.length >> 1;
      const numInputs = domain.length >> 1;
      const evaluator = new PostScriptEvaluator(code);
      const cache = Object.create(null);
      const MAX_CACHE_SIZE = 2048 * 4;
      let cache_available = MAX_CACHE_SIZE;
      const tmpBuf = new Float32Array(numInputs);
      return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
        let i, value;
        let key = "";
        const input = tmpBuf;

        for (i = 0; i < numInputs; i++) {
          value = src[srcOffset + i];
          input[i] = value;
          key += value + "_";
        }

        const cachedValue = cache[key];

        if (cachedValue !== undefined) {
          dest.set(cachedValue, destOffset);
          return;
        }

        const output = new Float32Array(numOutputs);
        const stack = evaluator.execute(input);
        const stackIndex = stack.length - numOutputs;

        for (i = 0; i < numOutputs; i++) {
          value = stack[stackIndex + i];
          let bound = range[i * 2];

          if (value < bound) {
            value = bound;
          } else {
            bound = range[i * 2 + 1];

            if (value > bound) {
              value = bound;
            }
          }

          output[i] = value;
        }

        if (cache_available > 0) {
          cache_available--;
          cache[key] = output;
        }

        dest.set(output, destOffset);
      };
    }

  };
}();

function isPDFFunction(v) {
  let fnDict;

  if (typeof v !== "object") {
    return false;
  } else if ((0, _primitives.isDict)(v)) {
    fnDict = v;
  } else if ((0, _primitives.isStream)(v)) {
    fnDict = v.dict;
  } else {
    return false;
  }

  return fnDict.has("FunctionType");
}

const PostScriptStack = function PostScriptStackClosure() {
  const MAX_STACK_SIZE = 100;

  class PostScriptStack {
    constructor(initialStack) {
      this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
    }

    push(value) {
      if (this.stack.length >= MAX_STACK_SIZE) {
        throw new Error("PostScript function stack overflow.");
      }

      this.stack.push(value);
    }

    pop() {
      if (this.stack.length <= 0) {
        throw new Error("PostScript function stack underflow.");
      }

      return this.stack.pop();
    }

    copy(n) {
      if (this.stack.length + n >= MAX_STACK_SIZE) {
        throw new Error("PostScript function stack overflow.");
      }

      const stack = this.stack;

      for (let i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
        stack.push(stack[i]);
      }
    }

    index(n) {
      this.push(this.stack[this.stack.length - n - 1]);
    }

    roll(n, p) {
      const stack = this.stack;
      const l = stack.length - n;
      const r = stack.length - 1;
      const c = l + (p - Math.floor(p / n) * n);

      for (let i = l, j = r; i < j; i++, j--) {
        const t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }

      for (let i = l, j = c - 1; i < j; i++, j--) {
        const t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }

      for (let i = c, j = r; i < j; i++, j--) {
        const t = stack[i];
        stack[i] = stack[j];
        stack[j] = t;
      }
    }

  }

  return PostScriptStack;
}();

class PostScriptEvaluator {
  constructor(operators) {
    this.operators = operators;
  }

  execute(initialStack) {
    const stack = new PostScriptStack(initialStack);
    let counter = 0;
    const operators = this.operators;
    const length = operators.length;
    let operator, a, b;

    while (counter < length) {
      operator = operators[counter++];

      if (typeof operator === "number") {
        stack.push(operator);
        continue;
      }

      switch (operator) {
        case "jz":
          b = stack.pop();
          a = stack.pop();

          if (!a) {
            counter = b;
          }

          break;

        case "j":
          a = stack.pop();
          counter = a;
          break;

        case "abs":
          a = stack.pop();
          stack.push(Math.abs(a));
          break;

        case "add":
          b = stack.pop();
          a = stack.pop();
          stack.push(a + b);
          break;

        case "and":
          b = stack.pop();
          a = stack.pop();

          if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
            stack.push(a && b);
          } else {
            stack.push(a & b);
          }

          break;

        case "atan":
          a = stack.pop();
          stack.push(Math.atan(a));
          break;

        case "bitshift":
          b = stack.pop();
          a = stack.pop();

          if (a > 0) {
            stack.push(a << b);
          } else {
            stack.push(a >> b);
          }

          break;

        case "ceiling":
          a = stack.pop();
          stack.push(Math.ceil(a));
          break;

        case "copy":
          a = stack.pop();
          stack.copy(a);
          break;

        case "cos":
          a = stack.pop();
          stack.push(Math.cos(a));
          break;

        case "cvi":
          a = stack.pop() | 0;
          stack.push(a);
          break;

        case "cvr":
          break;

        case "div":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b);
          break;

        case "dup":
          stack.copy(1);
          break;

        case "eq":
          b = stack.pop();
          a = stack.pop();
          stack.push(a === b);
          break;

        case "exch":
          stack.roll(2, 1);
          break;

        case "exp":
          b = stack.pop();
          a = stack.pop();
          stack.push(a ** b);
          break;

        case "false":
          stack.push(false);
          break;

        case "floor":
          a = stack.pop();
          stack.push(Math.floor(a));
          break;

        case "ge":
          b = stack.pop();
          a = stack.pop();
          stack.push(a >= b);
          break;

        case "gt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a > b);
          break;

        case "idiv":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b | 0);
          break;

        case "index":
          a = stack.pop();
          stack.index(a);
          break;

        case "le":
          b = stack.pop();
          a = stack.pop();
          stack.push(a <= b);
          break;

        case "ln":
          a = stack.pop();
          stack.push(Math.log(a));
          break;

        case "log":
          a = stack.pop();
          stack.push(Math.log(a) / Math.LN10);
          break;

        case "lt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a < b);
          break;

        case "mod":
          b = stack.pop();
          a = stack.pop();
          stack.push(a % b);
          break;

        case "mul":
          b = stack.pop();
          a = stack.pop();
          stack.push(a * b);
          break;

        case "ne":
          b = stack.pop();
          a = stack.pop();
          stack.push(a !== b);
          break;

        case "neg":
          a = stack.pop();
          stack.push(-a);
          break;

        case "not":
          a = stack.pop();

          if ((0, _util.isBool)(a)) {
            stack.push(!a);
          } else {
            stack.push(~a);
          }

          break;

        case "or":
          b = stack.pop();
          a = stack.pop();

          if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
            stack.push(a || b);
          } else {
            stack.push(a | b);
          }

          break;

        case "pop":
          stack.pop();
          break;

        case "roll":
          b = stack.pop();
          a = stack.pop();
          stack.roll(a, b);
          break;

        case "round":
          a = stack.pop();
          stack.push(Math.round(a));
          break;

        case "sin":
          a = stack.pop();
          stack.push(Math.sin(a));
          break;

        case "sqrt":
          a = stack.pop();
          stack.push(Math.sqrt(a));
          break;

        case "sub":
          b = stack.pop();
          a = stack.pop();
          stack.push(a - b);
          break;

        case "true":
          stack.push(true);
          break;

        case "truncate":
          a = stack.pop();
          a = a < 0 ? Math.ceil(a) : Math.floor(a);
          stack.push(a);
          break;

        case "xor":
          b = stack.pop();
          a = stack.pop();

          if ((0, _util.isBool)(a) && (0, _util.isBool)(b)) {
            stack.push(a !== b);
          } else {
            stack.push(a ^ b);
          }

          break;

        default:
          throw new _util.FormatError(`Unknown operator ${operator}`);
      }
    }

    return stack.stack;
  }

}

exports.PostScriptEvaluator = PostScriptEvaluator;

const PostScriptCompiler = function PostScriptCompilerClosure() {
  class AstNode {
    constructor(type) {
      this.type = type;
    }

    visit(visitor) {
      (0, _util.unreachable)("abstract method");
    }

  }

  class AstArgument extends AstNode {
    constructor(index, min, max) {
      super("args");
      this.index = index;
      this.min = min;
      this.max = max;
    }

    visit(visitor) {
      visitor.visitArgument(this);
    }

  }

  class AstLiteral extends AstNode {
    constructor(number) {
      super("literal");
      this.number = number;
      this.min = number;
      this.max = number;
    }

    visit(visitor) {
      visitor.visitLiteral(this);
    }

  }

  class AstBinaryOperation extends AstNode {
    constructor(op, arg1, arg2, min, max) {
      super("binary");
      this.op = op;
      this.arg1 = arg1;
      this.arg2 = arg2;
      this.min = min;
      this.max = max;
    }

    visit(visitor) {
      visitor.visitBinaryOperation(this);
    }

  }

  class AstMin extends AstNode {
    constructor(arg, max) {
      super("max");
      this.arg = arg;
      this.min = arg.min;
      this.max = max;
    }

    visit(visitor) {
      visitor.visitMin(this);
    }

  }

  class AstVariable extends AstNode {
    constructor(index, min, max) {
      super("var");
      this.index = index;
      this.min = min;
      this.max = max;
    }

    visit(visitor) {
      visitor.visitVariable(this);
    }

  }

  class AstVariableDefinition extends AstNode {
    constructor(variable, arg) {
      super("definition");
      this.variable = variable;
      this.arg = arg;
    }

    visit(visitor) {
      visitor.visitVariableDefinition(this);
    }

  }

  class ExpressionBuilderVisitor {
    constructor() {
      this.parts = [];
    }

    visitArgument(arg) {
      this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
    }

    visitVariable(variable) {
      this.parts.push("v", variable.index);
    }

    visitLiteral(literal) {
      this.parts.push(literal.number);
    }

    visitBinaryOperation(operation) {
      this.parts.push("(");
      operation.arg1.visit(this);
      this.parts.push(" ", operation.op, " ");
      operation.arg2.visit(this);
      this.parts.push(")");
    }

    visitVariableDefinition(definition) {
      this.parts.push("var ");
      definition.variable.visit(this);
      this.parts.push(" = ");
      definition.arg.visit(this);
      this.parts.push(";");
    }

    visitMin(max) {
      this.parts.push("Math.min(");
      max.arg.visit(this);
      this.parts.push(", ", max.max, ")");
    }

    toString() {
      return this.parts.join("");
    }

  }

  function buildAddOperation(num1, num2) {
    if (num2.type === "literal" && num2.number === 0) {
      return num1;
    }

    if (num1.type === "literal" && num1.number === 0) {
      return num2;
    }

    if (num2.type === "literal" && num1.type === "literal") {
      return new AstLiteral(num1.number + num2.number);
    }

    return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
  }

  function buildMulOperation(num1, num2) {
    if (num2.type === "literal") {
      if (num2.number === 0) {
        return new AstLiteral(0);
      } else if (num2.number === 1) {
        return num1;
      } else if (num1.type === "literal") {
        return new AstLiteral(num1.number * num2.number);
      }
    }

    if (num1.type === "literal") {
      if (num1.number === 0) {
        return new AstLiteral(0);
      } else if (num1.number === 1) {
        return num2;
      }
    }

    const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    return new AstBinaryOperation("*", num1, num2, min, max);
  }

  function buildSubOperation(num1, num2) {
    if (num2.type === "literal") {
      if (num2.number === 0) {
        return num1;
      } else if (num1.type === "literal") {
        return new AstLiteral(num1.number - num2.number);
      }
    }

    if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
      return num2.arg2;
    }

    return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
  }

  function buildMinOperation(num1, max) {
    if (num1.min >= max) {
      return new AstLiteral(max);
    } else if (num1.max <= max) {
      return num1;
    }

    return new AstMin(num1, max);
  }

  class PostScriptCompiler {
    compile(code, domain, range) {
      const stack = [];
      const instructions = [];
      const inputSize = domain.length >> 1,
            outputSize = range.length >> 1;
      let lastRegister = 0;
      let n, j;
      let num1, num2, ast1, ast2, tmpVar, item;

      for (let i = 0; i < inputSize; i++) {
        stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
      }

      for (let i = 0, ii = code.length; i < ii; i++) {
        item = code[i];

        if (typeof item === "number") {
          stack.push(new AstLiteral(item));
          continue;
        }

        switch (item) {
          case "add":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildAddOperation(num1, num2));
            break;

          case "cvr":
            if (stack.length < 1) {
              return null;
            }

            break;

          case "mul":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildMulOperation(num1, num2));
            break;

          case "sub":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildSubOperation(num1, num2));
            break;

          case "exch":
            if (stack.length < 2) {
              return null;
            }

            ast1 = stack.pop();
            ast2 = stack.pop();
            stack.push(ast1, ast2);
            break;

          case "pop":
            if (stack.length < 1) {
              return null;
            }

            stack.pop();
            break;

          case "index":
            if (stack.length < 1) {
              return null;
            }

            num1 = stack.pop();

            if (num1.type !== "literal") {
              return null;
            }

            n = num1.number;

            if (n < 0 || !Number.isInteger(n) || stack.length < n) {
              return null;
            }

            ast1 = stack[stack.length - n - 1];

            if (ast1.type === "literal" || ast1.type === "var") {
              stack.push(ast1);
              break;
            }

            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - n - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;

          case "dup":
            if (stack.length < 1) {
              return null;
            }

            if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
              num1 = stack.pop();
              stack.push(buildMinOperation(num1, code[i + 1]));
              i += 6;
              break;
            }

            ast1 = stack[stack.length - 1];

            if (ast1.type === "literal" || ast1.type === "var") {
              stack.push(ast1);
              break;
            }

            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;

          case "roll":
            if (stack.length < 2) {
              return null;
            }

            num2 = stack.pop();
            num1 = stack.pop();

            if (num2.type !== "literal" || num1.type !== "literal") {
              return null;
            }

            j = num2.number;
            n = num1.number;

            if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
              return null;
            }

            j = (j % n + n) % n;

            if (j === 0) {
              break;
            }

            Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
            break;

          default:
            return null;
        }
      }

      if (stack.length !== outputSize) {
        return null;
      }

      const result = [];

      for (const instruction of instructions) {
        const statementBuilder = new ExpressionBuilderVisitor();
        instruction.visit(statementBuilder);
        result.push(statementBuilder.toString());
      }

      for (let i = 0, ii = stack.length; i < ii; i++) {
        const expr = stack[i],
              statementBuilder = new ExpressionBuilderVisitor();
        expr.visit(statementBuilder);
        const min = range[i * 2],
              max = range[i * 2 + 1];
        const out = [statementBuilder.toString()];

        if (min > expr.min) {
          out.unshift("Math.max(", min, ", ");
          out.push(")");
        }

        if (max < expr.max) {
          out.unshift("Math.min(", max, ", ");
          out.push(")");
        }

        out.unshift("dest[destOffset + ", i, "] = ");
        out.push(";");
        result.push(out.join(""));
      }

      return result.join("\n");
    }

  }

  return PostScriptCompiler;
}();

exports.PostScriptCompiler = PostScriptCompiler;

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PostScriptParser = exports.PostScriptLexer = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

class PostScriptParser {
  constructor(lexer) {
    this.lexer = lexer;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }

  nextToken() {
    this.prev = this.token;
    this.token = this.lexer.getToken();
  }

  accept(type) {
    if (this.token.type === type) {
      this.nextToken();
      return true;
    }

    return false;
  }

  expect(type) {
    if (this.accept(type)) {
      return true;
    }

    throw new _util.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
  }

  parse() {
    this.nextToken();
    this.expect(PostScriptTokenTypes.LBRACE);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);
    return this.operators;
  }

  parseBlock() {
    while (true) {
      if (this.accept(PostScriptTokenTypes.NUMBER)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
        this.parseCondition();
      } else {
        return;
      }
    }
  }

  parseCondition() {
    const conditionLocation = this.operators.length;
    this.operators.push(null, null);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);

    if (this.accept(PostScriptTokenTypes.IF)) {
      this.operators[conditionLocation] = this.operators.length;
      this.operators[conditionLocation + 1] = "jz";
    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
      const jumpLocation = this.operators.length;
      this.operators.push(null, null);
      const endOfTrue = this.operators.length;
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);
      this.expect(PostScriptTokenTypes.IFELSE);
      this.operators[jumpLocation] = this.operators.length;
      this.operators[jumpLocation + 1] = "j";
      this.operators[conditionLocation] = endOfTrue;
      this.operators[conditionLocation + 1] = "jz";
    } else {
      throw new _util.FormatError("PS Function: error parsing conditional.");
    }
  }

}

exports.PostScriptParser = PostScriptParser;
const PostScriptTokenTypes = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};

const PostScriptToken = function PostScriptTokenClosure() {
  const opCache = Object.create(null);

  class PostScriptToken {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }

    static getOperator(op) {
      const opValue = opCache[op];

      if (opValue) {
        return opValue;
      }

      return opCache[op] = new PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
    }

    static get LBRACE() {
      return (0, _util.shadow)(this, "LBRACE", new PostScriptToken(PostScriptTokenTypes.LBRACE, "{"));
    }

    static get RBRACE() {
      return (0, _util.shadow)(this, "RBRACE", new PostScriptToken(PostScriptTokenTypes.RBRACE, "}"));
    }

    static get IF() {
      return (0, _util.shadow)(this, "IF", new PostScriptToken(PostScriptTokenTypes.IF, "IF"));
    }

    static get IFELSE() {
      return (0, _util.shadow)(this, "IFELSE", new PostScriptToken(PostScriptTokenTypes.IFELSE, "IFELSE"));
    }

  }

  return PostScriptToken;
}();

class PostScriptLexer {
  constructor(stream) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
  }

  nextChar() {
    return this.currentChar = this.stream.getByte();
  }

  getToken() {
    let comment = false;
    let ch = this.currentChar;

    while (true) {
      if (ch < 0) {
        return _primitives.EOF;
      }

      if (comment) {
        if (ch === 0x0a || ch === 0x0d) {
          comment = false;
        }
      } else if (ch === 0x25) {
        comment = true;
      } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
        break;
      }

      ch = this.nextChar();
    }

    switch (ch | 0) {
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x2b:
      case 0x2d:
      case 0x2e:
        return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());

      case 0x7b:
        this.nextChar();
        return PostScriptToken.LBRACE;

      case 0x7d:
        this.nextChar();
        return PostScriptToken.RBRACE;
    }

    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);

    while ((ch = this.nextChar()) >= 0 && (ch >= 0x41 && ch <= 0x5a || ch >= 0x61 && ch <= 0x7a)) {
      strBuf.push(String.fromCharCode(ch));
    }

    const str = strBuf.join("");

    switch (str.toLowerCase()) {
      case "if":
        return PostScriptToken.IF;

      case "ifelse":
        return PostScriptToken.IFELSE;

      default:
        return PostScriptToken.getOperator(str);
    }
  }

  getNumber() {
    let ch = this.currentChar;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);

    while ((ch = this.nextChar()) >= 0) {
      if (ch >= 0x30 && ch <= 0x39 || ch === 0x2d || ch === 0x2e) {
        strBuf.push(String.fromCharCode(ch));
      } else {
        break;
      }
    }

    const value = parseFloat(strBuf.join(""));

    if (isNaN(value)) {
      throw new _util.FormatError(`Invalid floating point number: ${value}`);
    }

    return value;
  }

}

exports.PostScriptLexer = PostScriptLexer;

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalTilingPatternCache = exports.LocalImageCache = exports.LocalGStateCache = exports.LocalFunctionCache = exports.LocalColorSpaceCache = exports.GlobalImageCache = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

class BaseLocalCache {
  constructor(options) {
    if (this.constructor === BaseLocalCache) {
      (0, _util.unreachable)("Cannot initialize BaseLocalCache.");
    }

    if (!options || !options.onlyRefs) {
      this._nameRefMap = new Map();
      this._imageMap = new Map();
    }

    this._imageCache = new _primitives.RefSetCache();
  }

  getByName(name) {
    const ref = this._nameRefMap.get(name);

    if (ref) {
      return this.getByRef(ref);
    }

    return this._imageMap.get(name) || null;
  }

  getByRef(ref) {
    return this._imageCache.get(ref) || null;
  }

  set(name, ref, data) {
    (0, _util.unreachable)("Abstract method `set` called.");
  }

}

class LocalImageCache extends BaseLocalCache {
  set(name, ref = null, data) {
    if (!name) {
      throw new Error('LocalImageCache.set - expected "name" argument.');
    }

    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }

      this._nameRefMap.set(name, ref);

      this._imageCache.put(ref, data);

      return;
    }

    if (this._imageMap.has(name)) {
      return;
    }

    this._imageMap.set(name, data);
  }

}

exports.LocalImageCache = LocalImageCache;

class LocalColorSpaceCache extends BaseLocalCache {
  set(name = null, ref = null, data) {
    if (!name && !ref) {
      throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    }

    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }

      if (name) {
        this._nameRefMap.set(name, ref);
      }

      this._imageCache.put(ref, data);

      return;
    }

    if (this._imageMap.has(name)) {
      return;
    }

    this._imageMap.set(name, data);
  }

}

exports.LocalColorSpaceCache = LocalColorSpaceCache;

class LocalFunctionCache extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }

  getByName(name) {
    (0, _util.unreachable)("Should not call `getByName` method.");
  }

  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    }

    if (this._imageCache.has(ref)) {
      return;
    }

    this._imageCache.put(ref, data);
  }

}

exports.LocalFunctionCache = LocalFunctionCache;

class LocalGStateCache extends BaseLocalCache {
  set(name, ref = null, data) {
    if (!name) {
      throw new Error('LocalGStateCache.set - expected "name" argument.');
    }

    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }

      this._nameRefMap.set(name, ref);

      this._imageCache.put(ref, data);

      return;
    }

    if (this._imageMap.has(name)) {
      return;
    }

    this._imageMap.set(name, data);
  }

}

exports.LocalGStateCache = LocalGStateCache;

class LocalTilingPatternCache extends BaseLocalCache {
  set(name, ref = null, data) {
    if (!name) {
      throw new Error('LocalTilingPatternCache.set - expected "name" argument.');
    }

    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }

      this._nameRefMap.set(name, ref);

      this._imageCache.put(ref, data);

      return;
    }

    if (this._imageMap.has(name)) {
      return;
    }

    this._imageMap.set(name, data);
  }

}

exports.LocalTilingPatternCache = LocalTilingPatternCache;

class GlobalImageCache {
  static get NUM_PAGES_THRESHOLD() {
    return (0, _util.shadow)(this, "NUM_PAGES_THRESHOLD", 2);
  }

  static get MIN_IMAGES_TO_CACHE() {
    return (0, _util.shadow)(this, "MIN_IMAGES_TO_CACHE", 10);
  }

  static get MAX_BYTE_SIZE() {
    return (0, _util.shadow)(this, "MAX_BYTE_SIZE", 40e6);
  }

  constructor() {
    this._refCache = new _primitives.RefSetCache();
    this._imageCache = new _primitives.RefSetCache();
  }

  get _byteSize() {
    let byteSize = 0;

    this._imageCache.forEach(imageData => {
      byteSize += imageData.byteSize;
    });

    return byteSize;
  }

  get _cacheLimitReached() {
    if (this._imageCache.size < GlobalImageCache.MIN_IMAGES_TO_CACHE) {
      return false;
    }

    if (this._byteSize < GlobalImageCache.MAX_BYTE_SIZE) {
      return false;
    }

    return true;
  }

  shouldCache(ref, pageIndex) {
    const pageIndexSet = this._refCache.get(ref);

    const numPages = pageIndexSet ? pageIndexSet.size + (pageIndexSet.has(pageIndex) ? 0 : 1) : 1;

    if (numPages < GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return false;
    }

    if (!this._imageCache.has(ref) && this._cacheLimitReached) {
      return false;
    }

    return true;
  }

  addPageIndex(ref, pageIndex) {
    let pageIndexSet = this._refCache.get(ref);

    if (!pageIndexSet) {
      pageIndexSet = new Set();

      this._refCache.put(ref, pageIndexSet);
    }

    pageIndexSet.add(pageIndex);
  }

  addByteSize(ref, byteSize) {
    const imageData = this._imageCache.get(ref);

    if (!imageData) {
      return;
    }

    if (imageData.byteSize) {
      return;
    }

    imageData.byteSize = byteSize;
  }

  getData(ref, pageIndex) {
    const pageIndexSet = this._refCache.get(ref);

    if (!pageIndexSet) {
      return null;
    }

    if (pageIndexSet.size < GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return null;
    }

    const imageData = this._imageCache.get(ref);

    if (!imageData) {
      return null;
    }

    pageIndexSet.add(pageIndex);
    return imageData;
  }

  setData(ref, data) {
    if (!this._refCache.has(ref)) {
      throw new Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
    }

    if (this._imageCache.has(ref)) {
      return;
    }

    if (this._cacheLimitReached) {
      (0, _util.warn)("GlobalImageCache.setData - cache limit reached.");
      return;
    }

    this._imageCache.put(ref, data);
  }

  clear(onlyData = false) {
    if (!onlyData) {
      this._refCache.clear();
    }

    this._imageCache.clear();
  }

}

exports.GlobalImageCache = GlobalImageCache;

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bidi = bidi;

var _util = __w_pdfjs_require__(2);

const baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
const arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];

function isOdd(i) {
  return (i & 1) !== 0;
}

function isEven(i) {
  return (i & 1) === 0;
}

function findUnequal(arr, start, value) {
  let j, jj;

  for (j = start, jj = arr.length; j < jj; ++j) {
    if (arr[j] !== value) {
      return j;
    }
  }

  return j;
}

function setValues(arr, start, end, value) {
  for (let j = start; j < end; ++j) {
    arr[j] = value;
  }
}

function reverseValues(arr, start, end) {
  for (let i = start, j = end - 1; i < j; ++i, --j) {
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}

function createBidiText(str, isLTR, vertical = false) {
  let dir = "ltr";

  if (vertical) {
    dir = "ttb";
  } else if (!isLTR) {
    dir = "rtl";
  }

  return {
    str,
    dir
  };
}

const chars = [];
const types = [];

function bidi(str, startLevel, vertical) {
  let isLTR = true;
  const strLength = str.length;

  if (strLength === 0 || vertical) {
    return createBidiText(str, isLTR, vertical);
  }

  chars.length = strLength;
  types.length = strLength;
  let numBidi = 0;
  let i, ii;

  for (i = 0; i < strLength; ++i) {
    chars[i] = str.charAt(i);
    const charCode = str.charCodeAt(i);
    let charType = "L";

    if (charCode <= 0x00ff) {
      charType = baseTypes[charCode];
    } else if (0x0590 <= charCode && charCode <= 0x05f4) {
      charType = "R";
    } else if (0x0600 <= charCode && charCode <= 0x06ff) {
      charType = arabicTypes[charCode & 0xff];

      if (!charType) {
        (0, _util.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
      }
    } else if (0x0700 <= charCode && charCode <= 0x08ac) {
      charType = "AL";
    }

    if (charType === "R" || charType === "AL" || charType === "AN") {
      numBidi++;
    }

    types[i] = charType;
  }

  if (numBidi === 0) {
    isLTR = true;
    return createBidiText(str, isLTR);
  }

  if (startLevel === -1) {
    if (numBidi / strLength < 0.3) {
      isLTR = true;
      startLevel = 0;
    } else {
      isLTR = false;
      startLevel = 1;
    }
  }

  const levels = [];

  for (i = 0; i < strLength; ++i) {
    levels[i] = startLevel;
  }

  const e = isOdd(startLevel) ? "R" : "L";
  const sor = e;
  const eor = sor;
  let lastType = sor;

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "NSM") {
      types[i] = lastType;
    } else {
      lastType = types[i];
    }
  }

  lastType = sor;
  let t;

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "EN") {
      types[i] = lastType === "AL" ? "AN" : "EN";
    } else if (t === "R" || t === "L" || t === "AL") {
      lastType = t;
    }
  }

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "AL") {
      types[i] = "R";
    }
  }

  for (i = 1; i < strLength - 1; ++i) {
    if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
      types[i] = "EN";
    }

    if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
      types[i] = types[i - 1];
    }
  }

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "EN") {
      for (let j = i - 1; j >= 0; --j) {
        if (types[j] !== "ET") {
          break;
        }

        types[j] = "EN";
      }

      for (let j = i + 1; j < strLength; ++j) {
        if (types[j] !== "ET") {
          break;
        }

        types[j] = "EN";
      }
    }
  }

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
      types[i] = "ON";
    }
  }

  lastType = sor;

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (t === "EN") {
      types[i] = lastType === "L" ? "L" : "EN";
    } else if (t === "R" || t === "L") {
      lastType = t;
    }
  }

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      const end = findUnequal(types, i + 1, "ON");
      let before = sor;

      if (i > 0) {
        before = types[i - 1];
      }

      let after = eor;

      if (end + 1 < strLength) {
        after = types[end + 1];
      }

      if (before !== "L") {
        before = "R";
      }

      if (after !== "L") {
        after = "R";
      }

      if (before === after) {
        setValues(types, i, end, before);
      }

      i = end - 1;
    }
  }

  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      types[i] = e;
    }
  }

  for (i = 0; i < strLength; ++i) {
    t = types[i];

    if (isEven(levels[i])) {
      if (t === "R") {
        levels[i] += 1;
      } else if (t === "AN" || t === "EN") {
        levels[i] += 2;
      }
    } else {
      if (t === "L" || t === "AN" || t === "EN") {
        levels[i] += 1;
      }
    }
  }

  let highestLevel = -1;
  let lowestOddLevel = 99;
  let level;

  for (i = 0, ii = levels.length; i < ii; ++i) {
    level = levels[i];

    if (highestLevel < level) {
      highestLevel = level;
    }

    if (lowestOddLevel > level && isOdd(level)) {
      lowestOddLevel = level;
    }
  }

  for (level = highestLevel; level >= lowestOddLevel; --level) {
    let start = -1;

    for (i = 0, ii = levels.length; i < ii; ++i) {
      if (levels[i] < level) {
        if (start >= 0) {
          reverseValues(chars, start, i);
          start = -1;
        }
      } else if (start < 0) {
        start = i;
      }
    }

    if (start >= 0) {
      reverseValues(chars, start, levels.length);
    }
  }

  for (i = 0, ii = chars.length; i < ii; ++i) {
    const ch = chars[i];

    if (ch === "<" || ch === ">") {
      chars[i] = "";
    }
  }

  return createBidiText(chars.join(""), isLTR);
}

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMetrics = void 0;

var _core_utils = __w_pdfjs_require__(9);

const getMetrics = (0, _core_utils.getLookupTableFactory)(function (t) {
  t.Courier = 600;
  t["Courier-Bold"] = 600;
  t["Courier-BoldOblique"] = 600;
  t["Courier-Oblique"] = 600;
  t.Helvetica = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 333;
    t.quotedbl = 474;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 722;
    t.quoteright = 278;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 611;
    t.at = 975;
    t.A = 722;
    t.B = 722;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 556;
    t.K = 722;
    t.L = 611;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 584;
    t.underscore = 556;
    t.quoteleft = 278;
    t.a = 556;
    t.b = 611;
    t.c = 556;
    t.d = 611;
    t.e = 556;
    t.f = 333;
    t.g = 611;
    t.h = 611;
    t.i = 278;
    t.j = 278;
    t.k = 556;
    t.l = 278;
    t.m = 889;
    t.n = 611;
    t.o = 611;
    t.p = 611;
    t.q = 611;
    t.r = 389;
    t.s = 556;
    t.t = 333;
    t.u = 611;
    t.v = 556;
    t.w = 778;
    t.x = 556;
    t.y = 556;
    t.z = 500;
    t.braceleft = 389;
    t.bar = 280;
    t.braceright = 389;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 238;
    t.quotedblleft = 500;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 611;
    t.fl = 611;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 556;
    t.bullet = 350;
    t.quotesinglbase = 278;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 611;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 611;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 722;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 556;
    t.scommaaccent = 556;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 611;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 556;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 556;
    t.scedilla = 556;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 611;
    t.acircumflex = 556;
    t.Amacron = 722;
    t.rcaron = 389;
    t.ccedilla = 556;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 743;
    t.Umacron = 722;
    t.uring = 611;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 584;
    t.uacute = 611;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 556;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 556;
    t.nacute = 611;
    t.umacron = 611;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 280;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 611;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 389;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 611;
    t.amacron = 556;
    t.sacute = 556;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 611;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 611;
    t.igrave = 278;
    t.ohungarumlaut = 611;
    t.Eogonek = 667;
    t.dcroat = 611;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 400;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 611;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 611;
    t.ntilde = 611;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 611;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 611;
    t.Ccaron = 722;
    t.ugrave = 611;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 611;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 556;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 611;
    t.tcommaaccent = 333;
    t.logicalnot = 584;
    t.odieresis = 611;
    t.udieresis = 611;
    t.notequal = 549;
    t.gcommaaccent = 611;
    t.eth = 611;
    t.zcaron = 500;
    t.ncommaaccent = 611;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.exclam = 278;
    t.quotedbl = 355;
    t.numbersign = 556;
    t.dollar = 556;
    t.percent = 889;
    t.ampersand = 667;
    t.quoteright = 222;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 389;
    t.plus = 584;
    t.comma = 278;
    t.hyphen = 333;
    t.period = 278;
    t.slash = 278;
    t.zero = 556;
    t.one = 556;
    t.two = 556;
    t.three = 556;
    t.four = 556;
    t.five = 556;
    t.six = 556;
    t.seven = 556;
    t.eight = 556;
    t.nine = 556;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 584;
    t.equal = 584;
    t.greater = 584;
    t.question = 556;
    t.at = 1015;
    t.A = 667;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 722;
    t.I = 278;
    t.J = 500;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 722;
    t.O = 778;
    t.P = 667;
    t.Q = 778;
    t.R = 722;
    t.S = 667;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 944;
    t.X = 667;
    t.Y = 667;
    t.Z = 611;
    t.bracketleft = 278;
    t.backslash = 278;
    t.bracketright = 278;
    t.asciicircum = 469;
    t.underscore = 556;
    t.quoteleft = 222;
    t.a = 556;
    t.b = 556;
    t.c = 500;
    t.d = 556;
    t.e = 556;
    t.f = 278;
    t.g = 556;
    t.h = 556;
    t.i = 222;
    t.j = 222;
    t.k = 500;
    t.l = 222;
    t.m = 833;
    t.n = 556;
    t.o = 556;
    t.p = 556;
    t.q = 556;
    t.r = 333;
    t.s = 500;
    t.t = 278;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 500;
    t.braceleft = 334;
    t.bar = 260;
    t.braceright = 334;
    t.asciitilde = 584;
    t.exclamdown = 333;
    t.cent = 556;
    t.sterling = 556;
    t.fraction = 167;
    t.yen = 556;
    t.florin = 556;
    t.section = 556;
    t.currency = 556;
    t.quotesingle = 191;
    t.quotedblleft = 333;
    t.guillemotleft = 556;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 556;
    t.dagger = 556;
    t.daggerdbl = 556;
    t.periodcentered = 278;
    t.paragraph = 537;
    t.bullet = 350;
    t.quotesinglbase = 222;
    t.quotedblbase = 333;
    t.quotedblright = 333;
    t.guillemotright = 556;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 611;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 370;
    t.Lslash = 556;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 365;
    t.ae = 889;
    t.dotlessi = 278;
    t.lslash = 222;
    t.oslash = 611;
    t.oe = 944;
    t.germandbls = 611;
    t.Idieresis = 278;
    t.eacute = 556;
    t.abreve = 556;
    t.uhungarumlaut = 556;
    t.ecaron = 556;
    t.Ydieresis = 667;
    t.divide = 584;
    t.Yacute = 667;
    t.Acircumflex = 667;
    t.aacute = 556;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 500;
    t.ecircumflex = 556;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 556;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 737;
    t.Emacron = 667;
    t.ccaron = 500;
    t.aring = 556;
    t.Ncommaaccent = 722;
    t.lacute = 222;
    t.agrave = 556;
    t.Tcommaaccent = 611;
    t.Cacute = 722;
    t.atilde = 556;
    t.Edotaccent = 667;
    t.scaron = 500;
    t.scedilla = 500;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 556;
    t.Amacron = 667;
    t.rcaron = 333;
    t.ccedilla = 500;
    t.Zdotaccent = 611;
    t.Thorn = 667;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 667;
    t.dcaron = 643;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 333;
    t.Ograve = 778;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 584;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 556;
    t.edieresis = 556;
    t.cacute = 500;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 278;
    t.plusminus = 584;
    t.brokenbar = 260;
    t.registered = 737;
    t.Gbreve = 778;
    t.Idotaccent = 278;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 333;
    t.omacron = 556;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 222;
    t.tcaron = 317;
    t.eogonek = 556;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 556;
    t.zacute = 500;
    t.iogonek = 222;
    t.Oacute = 778;
    t.oacute = 556;
    t.amacron = 556;
    t.sacute = 500;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 333;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 556;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 834;
    t.Scedilla = 667;
    t.lcaron = 299;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 1000;
    t.edotaccent = 556;
    t.Igrave = 278;
    t.Imacron = 278;
    t.Lcaron = 556;
    t.onehalf = 834;
    t.lessequal = 549;
    t.ocircumflex = 556;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 556;
    t.gbreve = 556;
    t.onequarter = 834;
    t.Scaron = 667;
    t.Scommaaccent = 667;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 556;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 556;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 556;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 778;
    t.zdotaccent = 500;
    t.Ecaron = 667;
    t.Iogonek = 278;
    t.kcommaaccent = 500;
    t.minus = 584;
    t.Icircumflex = 278;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 584;
    t.odieresis = 556;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 556;
    t.eth = 556;
    t.zcaron = 500;
    t.ncommaaccent = 556;
    t.onesuperior = 333;
    t.imacron = 278;
    t.Euro = 556;
  });
  t.Symbol = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.universal = 713;
    t.numbersign = 500;
    t.existential = 549;
    t.percent = 833;
    t.ampersand = 778;
    t.suchthat = 439;
    t.parenleft = 333;
    t.parenright = 333;
    t.asteriskmath = 500;
    t.plus = 549;
    t.comma = 250;
    t.minus = 549;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 549;
    t.equal = 549;
    t.greater = 549;
    t.question = 444;
    t.congruent = 549;
    t.Alpha = 722;
    t.Beta = 667;
    t.Chi = 722;
    t.Delta = 612;
    t.Epsilon = 611;
    t.Phi = 763;
    t.Gamma = 603;
    t.Eta = 722;
    t.Iota = 333;
    t.theta1 = 631;
    t.Kappa = 722;
    t.Lambda = 686;
    t.Mu = 889;
    t.Nu = 722;
    t.Omicron = 722;
    t.Pi = 768;
    t.Theta = 741;
    t.Rho = 556;
    t.Sigma = 592;
    t.Tau = 611;
    t.Upsilon = 690;
    t.sigma1 = 439;
    t.Omega = 768;
    t.Xi = 645;
    t.Psi = 795;
    t.Zeta = 611;
    t.bracketleft = 333;
    t.therefore = 863;
    t.bracketright = 333;
    t.perpendicular = 658;
    t.underscore = 500;
    t.radicalex = 500;
    t.alpha = 631;
    t.beta = 549;
    t.chi = 549;
    t.delta = 494;
    t.epsilon = 439;
    t.phi = 521;
    t.gamma = 411;
    t.eta = 603;
    t.iota = 329;
    t.phi1 = 603;
    t.kappa = 549;
    t.lambda = 549;
    t.mu = 576;
    t.nu = 521;
    t.omicron = 549;
    t.pi = 549;
    t.theta = 521;
    t.rho = 549;
    t.sigma = 603;
    t.tau = 439;
    t.upsilon = 576;
    t.omega1 = 713;
    t.omega = 686;
    t.xi = 493;
    t.psi = 686;
    t.zeta = 494;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.similar = 549;
    t.Euro = 750;
    t.Upsilon1 = 620;
    t.minute = 247;
    t.lessequal = 549;
    t.fraction = 167;
    t.infinity = 713;
    t.florin = 500;
    t.club = 753;
    t.diamond = 753;
    t.heart = 753;
    t.spade = 753;
    t.arrowboth = 1042;
    t.arrowleft = 987;
    t.arrowup = 603;
    t.arrowright = 987;
    t.arrowdown = 603;
    t.degree = 400;
    t.plusminus = 549;
    t.second = 411;
    t.greaterequal = 549;
    t.multiply = 549;
    t.proportional = 713;
    t.partialdiff = 494;
    t.bullet = 460;
    t.divide = 549;
    t.notequal = 549;
    t.equivalence = 549;
    t.approxequal = 549;
    t.ellipsis = 1000;
    t.arrowvertex = 603;
    t.arrowhorizex = 1000;
    t.carriagereturn = 658;
    t.aleph = 823;
    t.Ifraktur = 686;
    t.Rfraktur = 795;
    t.weierstrass = 987;
    t.circlemultiply = 768;
    t.circleplus = 768;
    t.emptyset = 823;
    t.intersection = 768;
    t.union = 768;
    t.propersuperset = 713;
    t.reflexsuperset = 713;
    t.notsubset = 713;
    t.propersubset = 713;
    t.reflexsubset = 713;
    t.element = 713;
    t.notelement = 713;
    t.angle = 768;
    t.gradient = 713;
    t.registerserif = 790;
    t.copyrightserif = 790;
    t.trademarkserif = 890;
    t.product = 823;
    t.radical = 549;
    t.dotmath = 250;
    t.logicalnot = 713;
    t.logicaland = 603;
    t.logicalor = 603;
    t.arrowdblboth = 1042;
    t.arrowdblleft = 987;
    t.arrowdblup = 603;
    t.arrowdblright = 987;
    t.arrowdbldown = 603;
    t.lozenge = 494;
    t.angleleft = 329;
    t.registersans = 790;
    t.copyrightsans = 790;
    t.trademarksans = 786;
    t.summation = 713;
    t.parenlefttp = 384;
    t.parenleftex = 384;
    t.parenleftbt = 384;
    t.bracketlefttp = 384;
    t.bracketleftex = 384;
    t.bracketleftbt = 384;
    t.bracelefttp = 494;
    t.braceleftmid = 494;
    t.braceleftbt = 494;
    t.braceex = 494;
    t.angleright = 329;
    t.integral = 274;
    t.integraltp = 686;
    t.integralex = 686;
    t.integralbt = 686;
    t.parenrighttp = 384;
    t.parenrightex = 384;
    t.parenrightbt = 384;
    t.bracketrighttp = 384;
    t.bracketrightex = 384;
    t.bracketrightbt = 384;
    t.bracerighttp = 494;
    t.bracerightmid = 494;
    t.bracerightbt = 494;
    t.apple = 790;
  });
  t["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 408;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 564;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 278;
    t.semicolon = 278;
    t.less = 564;
    t.equal = 564;
    t.greater = 564;
    t.question = 444;
    t.at = 921;
    t.A = 722;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 556;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 389;
    t.K = 722;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 556;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 722;
    t.W = 944;
    t.X = 722;
    t.Y = 722;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 469;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 444;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 333;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 480;
    t.bar = 200;
    t.braceright = 480;
    t.asciitilde = 541;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 180;
    t.quotedblleft = 444;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 453;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 444;
    t.quotedblright = 444;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 444;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 889;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 444;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 564;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 444;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 444;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 444;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 444;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 444;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 444;
    t.Amacron = 722;
    t.rcaron = 333;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 556;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 588;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 564;
    t.uacute = 500;
    t.Tcaron = 611;
    t.partialdiff = 476;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 444;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 722;
    t.Iacute = 333;
    t.plusminus = 564;
    t.brokenbar = 200;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 333;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 326;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 444;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 344;
    t.Kcommaaccent = 722;
    t.Lacute = 611;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 333;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 722;
    t.zdotaccent = 444;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 500;
    t.minus = 564;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 564;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 1000;
    t.ampersand = 833;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 930;
    t.A = 722;
    t.B = 667;
    t.C = 722;
    t.D = 722;
    t.E = 667;
    t.F = 611;
    t.G = 778;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 778;
    t.L = 667;
    t.M = 944;
    t.N = 722;
    t.O = 778;
    t.P = 611;
    t.Q = 778;
    t.R = 722;
    t.S = 556;
    t.T = 667;
    t.U = 722;
    t.V = 722;
    t.W = 1000;
    t.X = 722;
    t.Y = 722;
    t.Z = 667;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 581;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 556;
    t.c = 444;
    t.d = 556;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 333;
    t.k = 556;
    t.l = 278;
    t.m = 833;
    t.n = 556;
    t.o = 500;
    t.p = 556;
    t.q = 556;
    t.r = 444;
    t.s = 389;
    t.t = 333;
    t.u = 556;
    t.v = 500;
    t.w = 722;
    t.x = 500;
    t.y = 500;
    t.z = 444;
    t.braceleft = 394;
    t.bar = 220;
    t.braceright = 394;
    t.asciitilde = 520;
    t.exclamdown = 333;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 540;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 1000;
    t.ordfeminine = 300;
    t.Lslash = 667;
    t.Oslash = 778;
    t.OE = 1000;
    t.ordmasculine = 330;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 556;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 722;
    t.divide = 570;
    t.Yacute = 722;
    t.Acircumflex = 722;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 500;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 667;
    t.Cacute = 722;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 722;
    t.Gcommaaccent = 778;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 722;
    t.rcaron = 444;
    t.ccedilla = 444;
    t.Zdotaccent = 667;
    t.Thorn = 611;
    t.Omacron = 778;
    t.Racute = 722;
    t.Sacute = 556;
    t.dcaron = 672;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 778;
    t.Agrave = 722;
    t.Abreve = 722;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 667;
    t.partialdiff = 494;
    t.ydieresis = 500;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 778;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 444;
    t.omacron = 500;
    t.Zacute = 667;
    t.Zcaron = 667;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 722;
    t.lcommaaccent = 278;
    t.tcaron = 416;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 722;
    t.Adieresis = 722;
    t.egrave = 444;
    t.zacute = 444;
    t.iogonek = 278;
    t.Oacute = 778;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 778;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 556;
    t.twosuperior = 300;
    t.Odieresis = 778;
    t.mu = 556;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 556;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 394;
    t.Kcommaaccent = 778;
    t.Lacute = 667;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 667;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 778;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 722;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 444;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 722;
    t.Lcommaaccent = 667;
    t.Atilde = 722;
    t.Aogonek = 722;
    t.Aring = 722;
    t.Otilde = 778;
    t.zdotaccent = 444;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 556;
    t.minus = 570;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 333;
    t.logicalnot = 570;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 444;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 389;
    t.quotedbl = 555;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 570;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 570;
    t.equal = 570;
    t.greater = 570;
    t.question = 500;
    t.at = 832;
    t.A = 667;
    t.B = 667;
    t.C = 667;
    t.D = 722;
    t.E = 667;
    t.F = 667;
    t.G = 722;
    t.H = 778;
    t.I = 389;
    t.J = 500;
    t.K = 667;
    t.L = 611;
    t.M = 889;
    t.N = 722;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 667;
    t.S = 556;
    t.T = 611;
    t.U = 722;
    t.V = 667;
    t.W = 889;
    t.X = 667;
    t.Y = 611;
    t.Z = 611;
    t.bracketleft = 333;
    t.backslash = 278;
    t.bracketright = 333;
    t.asciicircum = 570;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 333;
    t.g = 500;
    t.h = 556;
    t.i = 278;
    t.j = 278;
    t.k = 500;
    t.l = 278;
    t.m = 778;
    t.n = 556;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 556;
    t.v = 444;
    t.w = 667;
    t.x = 500;
    t.y = 444;
    t.z = 389;
    t.braceleft = 348;
    t.bar = 220;
    t.braceright = 348;
    t.asciitilde = 570;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 278;
    t.quotedblleft = 500;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 556;
    t.fl = 556;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 500;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 500;
    t.quotedblright = 500;
    t.guillemotright = 500;
    t.ellipsis = 1000;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 1000;
    t.AE = 944;
    t.ordfeminine = 266;
    t.Lslash = 611;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 300;
    t.ae = 722;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 722;
    t.germandbls = 500;
    t.Idieresis = 389;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 556;
    t.ecaron = 444;
    t.Ydieresis = 611;
    t.divide = 570;
    t.Yacute = 611;
    t.Acircumflex = 667;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 556;
    t.Edieresis = 667;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 747;
    t.Emacron = 667;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 722;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 611;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 667;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 494;
    t.Rcaron = 667;
    t.Gcommaaccent = 722;
    t.ucircumflex = 556;
    t.acircumflex = 500;
    t.Amacron = 667;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 611;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 667;
    t.Sacute = 556;
    t.dcaron = 608;
    t.Umacron = 722;
    t.uring = 556;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 667;
    t.Abreve = 667;
    t.multiply = 570;
    t.uacute = 556;
    t.Tcaron = 611;
    t.partialdiff = 494;
    t.ydieresis = 444;
    t.Nacute = 722;
    t.icircumflex = 278;
    t.Ecircumflex = 667;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 556;
    t.umacron = 556;
    t.Ncaron = 722;
    t.Iacute = 389;
    t.plusminus = 570;
    t.brokenbar = 220;
    t.registered = 747;
    t.Gbreve = 722;
    t.Idotaccent = 389;
    t.summation = 600;
    t.Egrave = 667;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 611;
    t.Zcaron = 611;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 366;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 667;
    t.Adieresis = 667;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 576;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 667;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 556;
    t.lcaron = 382;
    t.Kcommaaccent = 667;
    t.Lacute = 611;
    t.trademark = 1000;
    t.edotaccent = 444;
    t.Igrave = 389;
    t.Imacron = 389;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 556;
    t.Uhungarumlaut = 722;
    t.Eacute = 667;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 556;
    t.Scommaaccent = 556;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 556;
    t.radical = 549;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 722;
    t.otilde = 500;
    t.Rcommaaccent = 667;
    t.Lcommaaccent = 611;
    t.Atilde = 667;
    t.Aogonek = 667;
    t.Aring = 667;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 667;
    t.Iogonek = 389;
    t.kcommaaccent = 500;
    t.minus = 606;
    t.Icircumflex = 389;
    t.ncaron = 556;
    t.tcommaaccent = 278;
    t.logicalnot = 606;
    t.odieresis = 500;
    t.udieresis = 556;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 556;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 250;
    t.exclam = 333;
    t.quotedbl = 420;
    t.numbersign = 500;
    t.dollar = 500;
    t.percent = 833;
    t.ampersand = 778;
    t.quoteright = 333;
    t.parenleft = 333;
    t.parenright = 333;
    t.asterisk = 500;
    t.plus = 675;
    t.comma = 250;
    t.hyphen = 333;
    t.period = 250;
    t.slash = 278;
    t.zero = 500;
    t.one = 500;
    t.two = 500;
    t.three = 500;
    t.four = 500;
    t.five = 500;
    t.six = 500;
    t.seven = 500;
    t.eight = 500;
    t.nine = 500;
    t.colon = 333;
    t.semicolon = 333;
    t.less = 675;
    t.equal = 675;
    t.greater = 675;
    t.question = 500;
    t.at = 920;
    t.A = 611;
    t.B = 611;
    t.C = 667;
    t.D = 722;
    t.E = 611;
    t.F = 611;
    t.G = 722;
    t.H = 722;
    t.I = 333;
    t.J = 444;
    t.K = 667;
    t.L = 556;
    t.M = 833;
    t.N = 667;
    t.O = 722;
    t.P = 611;
    t.Q = 722;
    t.R = 611;
    t.S = 500;
    t.T = 556;
    t.U = 722;
    t.V = 611;
    t.W = 833;
    t.X = 611;
    t.Y = 556;
    t.Z = 556;
    t.bracketleft = 389;
    t.backslash = 278;
    t.bracketright = 389;
    t.asciicircum = 422;
    t.underscore = 500;
    t.quoteleft = 333;
    t.a = 500;
    t.b = 500;
    t.c = 444;
    t.d = 500;
    t.e = 444;
    t.f = 278;
    t.g = 500;
    t.h = 500;
    t.i = 278;
    t.j = 278;
    t.k = 444;
    t.l = 278;
    t.m = 722;
    t.n = 500;
    t.o = 500;
    t.p = 500;
    t.q = 500;
    t.r = 389;
    t.s = 389;
    t.t = 278;
    t.u = 500;
    t.v = 444;
    t.w = 667;
    t.x = 444;
    t.y = 444;
    t.z = 389;
    t.braceleft = 400;
    t.bar = 275;
    t.braceright = 400;
    t.asciitilde = 541;
    t.exclamdown = 389;
    t.cent = 500;
    t.sterling = 500;
    t.fraction = 167;
    t.yen = 500;
    t.florin = 500;
    t.section = 500;
    t.currency = 500;
    t.quotesingle = 214;
    t.quotedblleft = 556;
    t.guillemotleft = 500;
    t.guilsinglleft = 333;
    t.guilsinglright = 333;
    t.fi = 500;
    t.fl = 500;
    t.endash = 500;
    t.dagger = 500;
    t.daggerdbl = 500;
    t.periodcentered = 250;
    t.paragraph = 523;
    t.bullet = 350;
    t.quotesinglbase = 333;
    t.quotedblbase = 556;
    t.quotedblright = 556;
    t.guillemotright = 500;
    t.ellipsis = 889;
    t.perthousand = 1000;
    t.questiondown = 500;
    t.grave = 333;
    t.acute = 333;
    t.circumflex = 333;
    t.tilde = 333;
    t.macron = 333;
    t.breve = 333;
    t.dotaccent = 333;
    t.dieresis = 333;
    t.ring = 333;
    t.cedilla = 333;
    t.hungarumlaut = 333;
    t.ogonek = 333;
    t.caron = 333;
    t.emdash = 889;
    t.AE = 889;
    t.ordfeminine = 276;
    t.Lslash = 556;
    t.Oslash = 722;
    t.OE = 944;
    t.ordmasculine = 310;
    t.ae = 667;
    t.dotlessi = 278;
    t.lslash = 278;
    t.oslash = 500;
    t.oe = 667;
    t.germandbls = 500;
    t.Idieresis = 333;
    t.eacute = 444;
    t.abreve = 500;
    t.uhungarumlaut = 500;
    t.ecaron = 444;
    t.Ydieresis = 556;
    t.divide = 675;
    t.Yacute = 556;
    t.Acircumflex = 611;
    t.aacute = 500;
    t.Ucircumflex = 722;
    t.yacute = 444;
    t.scommaaccent = 389;
    t.ecircumflex = 444;
    t.Uring = 722;
    t.Udieresis = 722;
    t.aogonek = 500;
    t.Uacute = 722;
    t.uogonek = 500;
    t.Edieresis = 611;
    t.Dcroat = 722;
    t.commaaccent = 250;
    t.copyright = 760;
    t.Emacron = 611;
    t.ccaron = 444;
    t.aring = 500;
    t.Ncommaaccent = 667;
    t.lacute = 278;
    t.agrave = 500;
    t.Tcommaaccent = 556;
    t.Cacute = 667;
    t.atilde = 500;
    t.Edotaccent = 611;
    t.scaron = 389;
    t.scedilla = 389;
    t.iacute = 278;
    t.lozenge = 471;
    t.Rcaron = 611;
    t.Gcommaaccent = 722;
    t.ucircumflex = 500;
    t.acircumflex = 500;
    t.Amacron = 611;
    t.rcaron = 389;
    t.ccedilla = 444;
    t.Zdotaccent = 556;
    t.Thorn = 611;
    t.Omacron = 722;
    t.Racute = 611;
    t.Sacute = 500;
    t.dcaron = 544;
    t.Umacron = 722;
    t.uring = 500;
    t.threesuperior = 300;
    t.Ograve = 722;
    t.Agrave = 611;
    t.Abreve = 611;
    t.multiply = 675;
    t.uacute = 500;
    t.Tcaron = 556;
    t.partialdiff = 476;
    t.ydieresis = 444;
    t.Nacute = 667;
    t.icircumflex = 278;
    t.Ecircumflex = 611;
    t.adieresis = 500;
    t.edieresis = 444;
    t.cacute = 444;
    t.nacute = 500;
    t.umacron = 500;
    t.Ncaron = 667;
    t.Iacute = 333;
    t.plusminus = 675;
    t.brokenbar = 275;
    t.registered = 760;
    t.Gbreve = 722;
    t.Idotaccent = 333;
    t.summation = 600;
    t.Egrave = 611;
    t.racute = 389;
    t.omacron = 500;
    t.Zacute = 556;
    t.Zcaron = 556;
    t.greaterequal = 549;
    t.Eth = 722;
    t.Ccedilla = 667;
    t.lcommaaccent = 278;
    t.tcaron = 300;
    t.eogonek = 444;
    t.Uogonek = 722;
    t.Aacute = 611;
    t.Adieresis = 611;
    t.egrave = 444;
    t.zacute = 389;
    t.iogonek = 278;
    t.Oacute = 722;
    t.oacute = 500;
    t.amacron = 500;
    t.sacute = 389;
    t.idieresis = 278;
    t.Ocircumflex = 722;
    t.Ugrave = 722;
    t.Delta = 612;
    t.thorn = 500;
    t.twosuperior = 300;
    t.Odieresis = 722;
    t.mu = 500;
    t.igrave = 278;
    t.ohungarumlaut = 500;
    t.Eogonek = 611;
    t.dcroat = 500;
    t.threequarters = 750;
    t.Scedilla = 500;
    t.lcaron = 300;
    t.Kcommaaccent = 667;
    t.Lacute = 556;
    t.trademark = 980;
    t.edotaccent = 444;
    t.Igrave = 333;
    t.Imacron = 333;
    t.Lcaron = 611;
    t.onehalf = 750;
    t.lessequal = 549;
    t.ocircumflex = 500;
    t.ntilde = 500;
    t.Uhungarumlaut = 722;
    t.Eacute = 611;
    t.emacron = 444;
    t.gbreve = 500;
    t.onequarter = 750;
    t.Scaron = 500;
    t.Scommaaccent = 500;
    t.Ohungarumlaut = 722;
    t.degree = 400;
    t.ograve = 500;
    t.Ccaron = 667;
    t.ugrave = 500;
    t.radical = 453;
    t.Dcaron = 722;
    t.rcommaaccent = 389;
    t.Ntilde = 667;
    t.otilde = 500;
    t.Rcommaaccent = 611;
    t.Lcommaaccent = 556;
    t.Atilde = 611;
    t.Aogonek = 611;
    t.Aring = 611;
    t.Otilde = 722;
    t.zdotaccent = 389;
    t.Ecaron = 611;
    t.Iogonek = 333;
    t.kcommaaccent = 444;
    t.minus = 675;
    t.Icircumflex = 333;
    t.ncaron = 500;
    t.tcommaaccent = 278;
    t.logicalnot = 675;
    t.odieresis = 500;
    t.udieresis = 500;
    t.notequal = 549;
    t.gcommaaccent = 500;
    t.eth = 500;
    t.zcaron = 389;
    t.ncommaaccent = 500;
    t.onesuperior = 300;
    t.imacron = 278;
    t.Euro = 500;
  });
  t.ZapfDingbats = (0, _core_utils.getLookupTableFactory)(function (t) {
    t.space = 278;
    t.a1 = 974;
    t.a2 = 961;
    t.a202 = 974;
    t.a3 = 980;
    t.a4 = 719;
    t.a5 = 789;
    t.a119 = 790;
    t.a118 = 791;
    t.a117 = 690;
    t.a11 = 960;
    t.a12 = 939;
    t.a13 = 549;
    t.a14 = 855;
    t.a15 = 911;
    t.a16 = 933;
    t.a105 = 911;
    t.a17 = 945;
    t.a18 = 974;
    t.a19 = 755;
    t.a20 = 846;
    t.a21 = 762;
    t.a22 = 761;
    t.a23 = 571;
    t.a24 = 677;
    t.a25 = 763;
    t.a26 = 760;
    t.a27 = 759;
    t.a28 = 754;
    t.a6 = 494;
    t.a7 = 552;
    t.a8 = 537;
    t.a9 = 577;
    t.a10 = 692;
    t.a29 = 786;
    t.a30 = 788;
    t.a31 = 788;
    t.a32 = 790;
    t.a33 = 793;
    t.a34 = 794;
    t.a35 = 816;
    t.a36 = 823;
    t.a37 = 789;
    t.a38 = 841;
    t.a39 = 823;
    t.a40 = 833;
    t.a41 = 816;
    t.a42 = 831;
    t.a43 = 923;
    t.a44 = 744;
    t.a45 = 723;
    t.a46 = 749;
    t.a47 = 790;
    t.a48 = 792;
    t.a49 = 695;
    t.a50 = 776;
    t.a51 = 768;
    t.a52 = 792;
    t.a53 = 759;
    t.a54 = 707;
    t.a55 = 708;
    t.a56 = 682;
    t.a57 = 701;
    t.a58 = 826;
    t.a59 = 815;
    t.a60 = 789;
    t.a61 = 789;
    t.a62 = 707;
    t.a63 = 687;
    t.a64 = 696;
    t.a65 = 689;
    t.a66 = 786;
    t.a67 = 787;
    t.a68 = 713;
    t.a69 = 791;
    t.a70 = 785;
    t.a71 = 791;
    t.a72 = 873;
    t.a73 = 761;
    t.a74 = 762;
    t.a203 = 762;
    t.a75 = 759;
    t.a204 = 759;
    t.a76 = 892;
    t.a77 = 892;
    t.a78 = 788;
    t.a79 = 784;
    t.a81 = 438;
    t.a82 = 138;
    t.a83 = 277;
    t.a84 = 415;
    t.a97 = 392;
    t.a98 = 392;
    t.a99 = 668;
    t.a100 = 668;
    t.a89 = 390;
    t.a90 = 390;
    t.a93 = 317;
    t.a94 = 317;
    t.a91 = 276;
    t.a92 = 276;
    t.a205 = 509;
    t.a85 = 509;
    t.a206 = 410;
    t.a86 = 410;
    t.a87 = 234;
    t.a88 = 234;
    t.a95 = 334;
    t.a96 = 334;
    t.a101 = 732;
    t.a102 = 544;
    t.a103 = 544;
    t.a104 = 910;
    t.a106 = 667;
    t.a107 = 760;
    t.a108 = 760;
    t.a112 = 776;
    t.a111 = 595;
    t.a110 = 694;
    t.a109 = 626;
    t.a120 = 788;
    t.a121 = 788;
    t.a122 = 788;
    t.a123 = 788;
    t.a124 = 788;
    t.a125 = 788;
    t.a126 = 788;
    t.a127 = 788;
    t.a128 = 788;
    t.a129 = 788;
    t.a130 = 788;
    t.a131 = 788;
    t.a132 = 788;
    t.a133 = 788;
    t.a134 = 788;
    t.a135 = 788;
    t.a136 = 788;
    t.a137 = 788;
    t.a138 = 788;
    t.a139 = 788;
    t.a140 = 788;
    t.a141 = 788;
    t.a142 = 788;
    t.a143 = 788;
    t.a144 = 788;
    t.a145 = 788;
    t.a146 = 788;
    t.a147 = 788;
    t.a148 = 788;
    t.a149 = 788;
    t.a150 = 788;
    t.a151 = 788;
    t.a152 = 788;
    t.a153 = 788;
    t.a154 = 788;
    t.a155 = 788;
    t.a156 = 788;
    t.a157 = 788;
    t.a158 = 788;
    t.a159 = 788;
    t.a160 = 894;
    t.a161 = 838;
    t.a163 = 1016;
    t.a164 = 458;
    t.a196 = 748;
    t.a165 = 924;
    t.a192 = 748;
    t.a166 = 918;
    t.a167 = 927;
    t.a168 = 928;
    t.a169 = 928;
    t.a170 = 834;
    t.a171 = 873;
    t.a172 = 828;
    t.a173 = 924;
    t.a162 = 924;
    t.a174 = 917;
    t.a175 = 930;
    t.a176 = 931;
    t.a177 = 463;
    t.a178 = 883;
    t.a179 = 836;
    t.a193 = 836;
    t.a180 = 867;
    t.a199 = 867;
    t.a181 = 696;
    t.a200 = 696;
    t.a182 = 874;
    t.a201 = 874;
    t.a183 = 760;
    t.a184 = 946;
    t.a197 = 771;
    t.a185 = 865;
    t.a194 = 771;
    t.a198 = 888;
    t.a186 = 967;
    t.a195 = 888;
    t.a187 = 831;
    t.a188 = 873;
    t.a189 = 927;
    t.a190 = 970;
    t.a191 = 918;
  });
});
exports.getMetrics = getMetrics;

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MurmurHash3_64 = void 0;

var _util = __w_pdfjs_require__(2);

const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;

class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }

  update(input) {
    let data, length;

    if ((0, _util.isString)(input)) {
      data = new Uint8Array(input.length * 2);
      length = 0;

      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);

        if (code <= 0xff) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 0xff;
        }
      }
    } else if ((0, _util.isArrayBuffer)(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
    }

    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0,
        k2 = 0;
    let h1 = this.h1,
        h2 = this.h2;
    const C1 = 0xcc9e2d51,
          C2 = 0x1b873593;
    const C1_LOW = C1 & MASK_LOW,
          C2_LOW = C2 & MASK_LOW;

    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 0xe6546b64;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 0xe6546b64;
      }
    }

    k1 = 0;

    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;

      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;

      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;

        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }

    }

    this.h1 = h1;
    this.h2 = h2;
  }

  hexdigest() {
    let h1 = this.h1,
        h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    const hex1 = (h1 >>> 0).toString(16),
          hex2 = (h2 >>> 0).toString(16);
    return hex1.padStart(8, "0") + hex2.padStart(8, "0");
  }

}

exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OperatorList = void 0;

var _util = __w_pdfjs_require__(2);

function addState(parentState, pattern, checkFn, iterateFn, processFn) {
  let state = parentState;

  for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
    const item = pattern[i];
    state = state[item] || (state[item] = []);
  }

  state[pattern[pattern.length - 1]] = {
    checkFn,
    iterateFn,
    processFn
  };
}

function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
  const iFirstPIMXO = iFirstSave + 2;
  let i;

  for (i = 0; i < count; i++) {
    const arg = argsArray[iFirstPIMXO + 4 * i];
    const imageMask = arg.length === 1 && arg[0];

    if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
      fnArray[iFirstPIMXO + 4 * i] = _util.OPS.paintSolidColorImageMask;
      continue;
    }

    break;
  }

  return count - i;
}

const InitialState = [];
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintInlineImageXObject, _util.OPS.restore], null, function iterateInlineImageGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;

  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;

    case 1:
      return fnArray[i] === _util.OPS.transform;

    case 2:
      return fnArray[i] === _util.OPS.paintInlineImageXObject;

    case 3:
      return fnArray[i] === _util.OPS.restore;
  }

  throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
}, function foundInlineImageGroup(context, i) {
  const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
  const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
  const MAX_WIDTH = 1000;
  const IMAGE_PADDING = 1;
  const fnArray = context.fnArray,
        argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIIXO = curr - 1;
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);

  if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }

  let maxX = 0;
  const map = [];
  let maxLineHeight = 0;
  let currentX = IMAGE_PADDING,
      currentY = IMAGE_PADDING;

  for (let q = 0; q < count; q++) {
    const transform = argsArray[iFirstTransform + (q << 2)];
    const img = argsArray[iFirstPIIXO + (q << 2)][0];

    if (currentX + img.width > MAX_WIDTH) {
      maxX = Math.max(maxX, currentX);
      currentY += maxLineHeight + 2 * IMAGE_PADDING;
      currentX = 0;
      maxLineHeight = 0;
    }

    map.push({
      transform,
      x: currentX,
      y: currentY,
      w: img.width,
      h: img.height
    });
    currentX += img.width + 2 * IMAGE_PADDING;
    maxLineHeight = Math.max(maxLineHeight, img.height);
  }

  const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
  const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
  const imgData = new Uint8ClampedArray(imgWidth * imgHeight * 4);
  const imgRowSize = imgWidth << 2;

  for (let q = 0; q < count; q++) {
    const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
    const rowSize = map[q].w << 2;
    let dataOffset = 0;
    let offset = map[q].x + map[q].y * imgWidth << 2;
    imgData.set(data.subarray(0, rowSize), offset - imgRowSize);

    for (let k = 0, kk = map[q].h; k < kk; k++) {
      imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
      dataOffset += rowSize;
      offset += imgRowSize;
    }

    imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);

    while (offset >= 0) {
      data[offset - 4] = data[offset];
      data[offset - 3] = data[offset + 1];
      data[offset - 2] = data[offset + 2];
      data[offset - 1] = data[offset + 3];
      data[offset + rowSize] = data[offset + rowSize - 4];
      data[offset + rowSize + 1] = data[offset + rowSize - 3];
      data[offset + rowSize + 2] = data[offset + rowSize - 2];
      data[offset + rowSize + 3] = data[offset + rowSize - 1];
      offset -= imgRowSize;
    }
  }

  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintInlineImageXObjectGroup);
  argsArray.splice(iFirstSave, count * 4, [{
    width: imgWidth,
    height: imgHeight,
    kind: _util.ImageKind.RGBA_32BPP,
    data: imgData
  }, map]);
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageMaskXObject, _util.OPS.restore], null, function iterateImageMaskGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;

  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;

    case 1:
      return fnArray[i] === _util.OPS.transform;

    case 2:
      return fnArray[i] === _util.OPS.paintImageMaskXObject;

    case 3:
      return fnArray[i] === _util.OPS.restore;
  }

  throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
}, function foundImageMaskGroup(context, i) {
  const MIN_IMAGES_IN_MASKS_BLOCK = 10;
  const MAX_IMAGES_IN_MASKS_BLOCK = 100;
  const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
  const fnArray = context.fnArray,
        argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIMXO = curr - 1;
  let count = Math.floor((i - iFirstSave) / 4);
  count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);

  if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }

  let isSameImage = false;
  let iTransform, transformArgs;
  const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0],
        firstTransformArg1 = argsArray[iFirstTransform][1],
        firstTransformArg2 = argsArray[iFirstTransform][2],
        firstTransformArg3 = argsArray[iFirstTransform][3];

  if (firstTransformArg1 === firstTransformArg2) {
    isSameImage = true;
    iTransform = iFirstTransform + 4;
    let iPIMXO = iFirstPIMXO + 4;

    for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
      transformArgs = argsArray[iTransform];

      if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {
        if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
          isSameImage = false;
        } else {
          count = q;
        }

        break;
      }
    }
  }

  if (isSameImage) {
    count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
    const positions = new Float32Array(count * 2);
    iTransform = iFirstTransform;

    for (let q = 0; q < count; q++, iTransform += 4) {
      transformArgs = argsArray[iTransform];
      positions[q << 1] = transformArgs[4];
      positions[(q << 1) + 1] = transformArgs[5];
    }

    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectRepeat);
    argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);
  } else {
    count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
    const images = [];

    for (let q = 0; q < count; q++) {
      transformArgs = argsArray[iFirstTransform + (q << 2)];
      const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
      images.push({
        data: maskParams.data,
        width: maskParams.width,
        height: maskParams.height,
        transform: transformArgs
      });
    }

    fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageMaskXObjectGroup);
    argsArray.splice(iFirstSave, count * 4, [images]);
  }

  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.save, _util.OPS.transform, _util.OPS.paintImageXObject, _util.OPS.restore], function (context) {
  const argsArray = context.argsArray;
  const iFirstTransform = context.iCurr - 2;
  return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
}, function iterateImageGroup(context, i) {
  const fnArray = context.fnArray,
        argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;

  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.save;

    case 1:
      if (fnArray[i] !== _util.OPS.transform) {
        return false;
      }

      const iFirstTransform = context.iCurr - 2;
      const firstTransformArg0 = argsArray[iFirstTransform][0];
      const firstTransformArg3 = argsArray[iFirstTransform][3];

      if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
        return false;
      }

      return true;

    case 2:
      if (fnArray[i] !== _util.OPS.paintImageXObject) {
        return false;
      }

      const iFirstPIXO = context.iCurr - 1;
      const firstPIXOArg0 = argsArray[iFirstPIXO][0];

      if (argsArray[i][0] !== firstPIXOArg0) {
        return false;
      }

      return true;

    case 3:
      return fnArray[i] === _util.OPS.restore;
  }

  throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
}, function (context, i) {
  const MIN_IMAGES_IN_BLOCK = 3;
  const MAX_IMAGES_IN_BLOCK = 1000;
  const fnArray = context.fnArray,
        argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIXO = curr - 1;
  const firstPIXOArg0 = argsArray[iFirstPIXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0];
  const firstTransformArg3 = argsArray[iFirstTransform][3];
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);

  if (count < MIN_IMAGES_IN_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }

  const positions = new Float32Array(count * 2);
  let iTransform = iFirstTransform;

  for (let q = 0; q < count; q++, iTransform += 4) {
    const transformArgs = argsArray[iTransform];
    positions[q << 1] = transformArgs[4];
    positions[(q << 1) + 1] = transformArgs[5];
  }

  const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
  fnArray.splice(iFirstSave, count * 4, _util.OPS.paintImageXObjectRepeat);
  argsArray.splice(iFirstSave, count * 4, args);
  return iFirstSave + 1;
});
addState(InitialState, [_util.OPS.beginText, _util.OPS.setFont, _util.OPS.setTextMatrix, _util.OPS.showText, _util.OPS.endText], null, function iterateShowTextGroup(context, i) {
  const fnArray = context.fnArray,
        argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 4;
  const pos = (i - iFirstSave) % 5;

  switch (pos) {
    case 0:
      return fnArray[i] === _util.OPS.beginText;

    case 1:
      return fnArray[i] === _util.OPS.setFont;

    case 2:
      return fnArray[i] === _util.OPS.setTextMatrix;

    case 3:
      if (fnArray[i] !== _util.OPS.showText) {
        return false;
      }

      const iFirstSetFont = context.iCurr - 3;
      const firstSetFontArg0 = argsArray[iFirstSetFont][0];
      const firstSetFontArg1 = argsArray[iFirstSetFont][1];

      if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
        return false;
      }

      return true;

    case 4:
      return fnArray[i] === _util.OPS.endText;
  }

  throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
}, function (context, i) {
  const MIN_CHARS_IN_BLOCK = 3;
  const MAX_CHARS_IN_BLOCK = 1000;
  const fnArray = context.fnArray,
        argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstBeginText = curr - 4;
  const iFirstSetFont = curr - 3;
  const iFirstSetTextMatrix = curr - 2;
  const iFirstShowText = curr - 1;
  const iFirstEndText = curr;
  const firstSetFontArg0 = argsArray[iFirstSetFont][0];
  const firstSetFontArg1 = argsArray[iFirstSetFont][1];
  let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);

  if (count < MIN_CHARS_IN_BLOCK) {
    return i - (i - iFirstBeginText) % 5;
  }

  let iFirst = iFirstBeginText;

  if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
    count++;
    iFirst -= 5;
  }

  let iEndText = iFirst + 4;

  for (let q = 1; q < count; q++) {
    fnArray.splice(iEndText, 3);
    argsArray.splice(iEndText, 3);
    iEndText += 2;
  }

  return iEndText + 1;
});

class NullOptimizer {
  constructor(queue) {
    this.queue = queue;
  }

  _optimize() {}

  push(fn, args) {
    this.queue.fnArray.push(fn);
    this.queue.argsArray.push(args);

    this._optimize();
  }

  flush() {}

  reset() {}

}

class QueueOptimizer extends NullOptimizer {
  constructor(queue) {
    super(queue);
    this.state = null;
    this.context = {
      iCurr: 0,
      fnArray: queue.fnArray,
      argsArray: queue.argsArray
    };
    this.match = null;
    this.lastProcessed = 0;
  }

  _optimize() {
    const fnArray = this.queue.fnArray;
    let i = this.lastProcessed,
        ii = fnArray.length;
    let state = this.state;
    let match = this.match;

    if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
      this.lastProcessed = ii;
      return;
    }

    const context = this.context;

    while (i < ii) {
      if (match) {
        const iterate = (0, match.iterateFn)(context, i);

        if (iterate) {
          i++;
          continue;
        }

        i = (0, match.processFn)(context, i + 1);
        ii = fnArray.length;
        match = null;
        state = null;

        if (i >= ii) {
          break;
        }
      }

      state = (state || InitialState)[fnArray[i]];

      if (!state || Array.isArray(state)) {
        i++;
        continue;
      }

      context.iCurr = i;
      i++;

      if (state.checkFn && !(0, state.checkFn)(context)) {
        state = null;
        continue;
      }

      match = state;
      state = null;
    }

    this.state = state;
    this.match = match;
    this.lastProcessed = i;
  }

  flush() {
    while (this.match) {
      const length = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, length);
      this.match = null;
      this.state = null;

      this._optimize();
    }
  }

  reset() {
    this.state = null;
    this.match = null;
    this.lastProcessed = 0;
  }

}

class OperatorList {
  static get CHUNK_SIZE() {
    return (0, _util.shadow)(this, "CHUNK_SIZE", 1000);
  }

  static get CHUNK_SIZE_ABOUT() {
    return (0, _util.shadow)(this, "CHUNK_SIZE_ABOUT", OperatorList.CHUNK_SIZE - 5);
  }

  constructor(intent, streamSink) {
    this._streamSink = streamSink;
    this.fnArray = [];
    this.argsArray = [];

    if (streamSink && intent !== "oplist") {
      this.optimizer = new QueueOptimizer(this);
    } else {
      this.optimizer = new NullOptimizer(this);
    }

    this.dependencies = new Set();
    this._totalLength = 0;
    this.weight = 0;
    this._resolved = streamSink ? null : Promise.resolve();
  }

  get length() {
    return this.argsArray.length;
  }

  get ready() {
    return this._resolved || this._streamSink.ready;
  }

  get totalLength() {
    return this._totalLength + this.length;
  }

  addOp(fn, args) {
    this.optimizer.push(fn, args);
    this.weight++;

    if (this._streamSink) {
      if (this.weight >= OperatorList.CHUNK_SIZE) {
        this.flush();
      } else if (this.weight >= OperatorList.CHUNK_SIZE_ABOUT && (fn === _util.OPS.restore || fn === _util.OPS.endText)) {
        this.flush();
      }
    }
  }

  addDependency(dependency) {
    if (this.dependencies.has(dependency)) {
      return;
    }

    this.dependencies.add(dependency);
    this.addOp(_util.OPS.dependency, [dependency]);
  }

  addDependencies(dependencies) {
    for (const dependency of dependencies) {
      this.addDependency(dependency);
    }
  }

  addOpList(opList) {
    if (!(opList instanceof OperatorList)) {
      (0, _util.warn)('addOpList - ignoring invalid "opList" parameter.');
      return;
    }

    for (const dependency of opList.dependencies) {
      this.dependencies.add(dependency);
    }

    for (let i = 0, ii = opList.length; i < ii; i++) {
      this.addOp(opList.fnArray[i], opList.argsArray[i]);
    }
  }

  getIR() {
    return {
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      length: this.length
    };
  }

  get _transfers() {
    const transfers = [];
    const {
      fnArray,
      argsArray,
      length
    } = this;

    for (let i = 0; i < length; i++) {
      switch (fnArray[i]) {
        case _util.OPS.paintInlineImageXObject:
        case _util.OPS.paintInlineImageXObjectGroup:
        case _util.OPS.paintImageMaskXObject:
          const arg = argsArray[i][0];
          ;

          if (!arg.cached) {
            transfers.push(arg.data.buffer);
          }

          break;
      }
    }

    return transfers;
  }

  flush(lastChunk = false) {
    this.optimizer.flush();
    const length = this.length;
    this._totalLength += length;

    this._streamSink.enqueue({
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      lastChunk,
      length
    }, 1, this._transfers);

    this.dependencies.clear();
    this.fnArray.length = 0;
    this.argsArray.length = 0;
    this.weight = 0;
    this.optimizer.reset();
  }

}

exports.OperatorList = OperatorList;

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFImage = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _colorspace = __w_pdfjs_require__(14);

var _decode_stream = __w_pdfjs_require__(19);

var _jpeg_stream = __w_pdfjs_require__(27);

var _jpx = __w_pdfjs_require__(30);

function decodeAndClamp(value, addend, coefficient, max) {
  value = addend + value * coefficient;

  if (value < 0) {
    value = 0;
  } else if (value > max) {
    value = max;
  }

  return value;
}

function resizeImageMask(src, bpc, w1, h1, w2, h2) {
  const length = w2 * h2;
  let dest;

  if (bpc <= 8) {
    dest = new Uint8Array(length);
  } else if (bpc <= 16) {
    dest = new Uint16Array(length);
  } else {
    dest = new Uint32Array(length);
  }

  const xRatio = w1 / w2;
  const yRatio = h1 / h2;
  let i,
      j,
      py,
      newIndex = 0,
      oldIndex;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1;

  for (i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio);
  }

  for (i = 0; i < h2; i++) {
    py = Math.floor(i * yRatio) * w1Scanline;

    for (j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex];
    }
  }

  return dest;
}

class PDFImage {
  constructor({
    xref,
    res,
    image,
    isInline = false,
    smask = null,
    mask = null,
    isMask = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    this.image = image;
    const dict = image.dict;
    const filter = dict.get("Filter");

    if ((0, _primitives.isName)(filter)) {
      switch (filter.name) {
        case "JPXDecode":
          const jpxImage = new _jpx.JpxImage();
          jpxImage.parseImageProperties(image.stream);
          image.stream.reset();
          image.width = jpxImage.width;
          image.height = jpxImage.height;
          image.bitsPerComponent = jpxImage.bitsPerComponent;
          image.numComps = jpxImage.componentsCount;
          break;

        case "JBIG2Decode":
          image.bitsPerComponent = 1;
          image.numComps = 1;
          break;
      }
    }

    let width = dict.get("Width", "W");
    let height = dict.get("Height", "H");

    if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
      (0, _util.warn)("PDFImage - using the Width/Height of the image data, " + "rather than the image dictionary.");
      width = image.width;
      height = image.height;
    }

    if (width < 1 || height < 1) {
      throw new _util.FormatError(`Invalid image width: ${width} or height: ${height}`);
    }

    this.width = width;
    this.height = height;
    this.interpolate = dict.get("Interpolate", "I") || false;
    this.imageMask = dict.get("ImageMask", "IM") || false;
    this.matte = dict.get("Matte") || false;
    let bitsPerComponent = image.bitsPerComponent;

    if (!bitsPerComponent) {
      bitsPerComponent = dict.get("BitsPerComponent", "BPC");

      if (!bitsPerComponent) {
        if (this.imageMask) {
          bitsPerComponent = 1;
        } else {
          throw new _util.FormatError(`Bits per component missing in image: ${this.imageMask}`);
        }
      }
    }

    this.bpc = bitsPerComponent;

    if (!this.imageMask) {
      let colorSpace = dict.getRaw("ColorSpace") || dict.getRaw("CS");

      if (!colorSpace) {
        (0, _util.info)("JPX images (which do not require color spaces)");

        switch (image.numComps) {
          case 1:
            colorSpace = _primitives.Name.get("DeviceGray");
            break;

          case 3:
            colorSpace = _primitives.Name.get("DeviceRGB");
            break;

          case 4:
            colorSpace = _primitives.Name.get("DeviceCMYK");
            break;

          default:
            throw new Error(`JPX images with ${image.numComps} ` + "color components not supported.");
        }
      }

      this.colorSpace = _colorspace.ColorSpace.parse({
        cs: colorSpace,
        xref,
        resources: isInline ? res : null,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      this.numComps = this.colorSpace.numComps;
    }

    this.decode = dict.getArray("Decode", "D");
    this.needsDecode = false;

    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      const max = (1 << bitsPerComponent) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      const isIndexed = this.colorSpace && this.colorSpace.name === "Indexed";

      for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
        const dmin = this.decode[i];
        const dmax = this.decode[i + 1];
        this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
        this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
      }
    }

    if (smask) {
      this.smask = new PDFImage({
        xref,
        res,
        image: smask,
        isInline,
        pdfFunctionFactory,
        localColorSpaceCache
      });
    } else if (mask) {
      if ((0, _primitives.isStream)(mask)) {
        const maskDict = mask.dict,
              imageMask = maskDict.get("ImageMask", "IM");

        if (!imageMask) {
          (0, _util.warn)("Ignoring /Mask in image without /ImageMask.");
        } else {
          this.mask = new PDFImage({
            xref,
            res,
            image: mask,
            isInline,
            isMask: true,
            pdfFunctionFactory,
            localColorSpaceCache
          });
        }
      } else {
        this.mask = mask;
      }
    }
  }

  static async buildImage({
    xref,
    res,
    image,
    isInline = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const imageData = image;
    let smaskData = null;
    let maskData = null;
    const smask = image.dict.get("SMask");
    const mask = image.dict.get("Mask");

    if (smask) {
      smaskData = smask;
    } else if (mask) {
      if ((0, _primitives.isStream)(mask) || Array.isArray(mask)) {
        maskData = mask;
      } else {
        (0, _util.warn)("Unsupported mask format.");
      }
    }

    return new PDFImage({
      xref,
      res,
      image: imageData,
      isInline,
      smask: smaskData,
      mask: maskData,
      pdfFunctionFactory,
      localColorSpaceCache
    });
  }

  static createMask({
    imgArray,
    width,
    height,
    imageIsFromDecodeStream,
    inverseDecode
  }) {
    const computedLength = (width + 7 >> 3) * height;
    const actualLength = imgArray.byteLength;
    const haveFullData = computedLength === actualLength;
    let data, i;

    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
      data = imgArray;
    } else if (!inverseDecode) {
      data = new Uint8ClampedArray(actualLength);
      data.set(imgArray);
    } else {
      data = new Uint8ClampedArray(computedLength);
      data.set(imgArray);

      for (i = actualLength; i < computedLength; i++) {
        data[i] = 0xff;
      }
    }

    if (inverseDecode) {
      for (i = 0; i < actualLength; i++) {
        data[i] ^= 0xff;
      }
    }

    return {
      data,
      width,
      height
    };
  }

  get drawWidth() {
    return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
  }

  get drawHeight() {
    return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
  }

  decodeBuffer(buffer) {
    const bpc = this.bpc;
    const numComps = this.numComps;
    const decodeAddends = this.decodeAddends;
    const decodeCoefficients = this.decodeCoefficients;
    const max = (1 << bpc) - 1;
    let i, ii;

    if (bpc === 1) {
      for (i = 0, ii = buffer.length; i < ii; i++) {
        buffer[i] = +!buffer[i];
      }

      return;
    }

    let index = 0;

    for (i = 0, ii = this.width * this.height; i < ii; i++) {
      for (let j = 0; j < numComps; j++) {
        buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
        index++;
      }
    }
  }

  getComponents(buffer) {
    const bpc = this.bpc;

    if (bpc === 8) {
      return buffer;
    }

    const width = this.width;
    const height = this.height;
    const numComps = this.numComps;
    const length = width * height * numComps;
    let bufferPos = 0;
    let output;

    if (bpc <= 8) {
      output = new Uint8Array(length);
    } else if (bpc <= 16) {
      output = new Uint16Array(length);
    } else {
      output = new Uint32Array(length);
    }

    const rowComps = width * numComps;
    const max = (1 << bpc) - 1;
    let i = 0,
        ii,
        buf;

    if (bpc === 1) {
      let mask, loop1End, loop2End;

      for (let j = 0; j < height; j++) {
        loop1End = i + (rowComps & ~7);
        loop2End = i + rowComps;

        while (i < loop1End) {
          buf = buffer[bufferPos++];
          output[i] = buf >> 7 & 1;
          output[i + 1] = buf >> 6 & 1;
          output[i + 2] = buf >> 5 & 1;
          output[i + 3] = buf >> 4 & 1;
          output[i + 4] = buf >> 3 & 1;
          output[i + 5] = buf >> 2 & 1;
          output[i + 6] = buf >> 1 & 1;
          output[i + 7] = buf & 1;
          i += 8;
        }

        if (i < loop2End) {
          buf = buffer[bufferPos++];
          mask = 128;

          while (i < loop2End) {
            output[i++] = +!!(buf & mask);
            mask >>= 1;
          }
        }
      }
    } else {
      let bits = 0;
      buf = 0;

      for (i = 0, ii = length; i < ii; ++i) {
        if (i % rowComps === 0) {
          buf = 0;
          bits = 0;
        }

        while (bits < bpc) {
          buf = buf << 8 | buffer[bufferPos++];
          bits += 8;
        }

        const remainingBits = bits - bpc;
        let value = buf >> remainingBits;

        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }

        output[i] = value;
        buf = buf & (1 << remainingBits) - 1;
        bits = remainingBits;
      }
    }

    return output;
  }

  fillOpacity(rgbaBuf, width, height, actualHeight, image) {
    const smask = this.smask;
    const mask = this.mask;
    let alphaBuf, sw, sh, i, ii, j;

    if (smask) {
      sw = smask.width;
      sh = smask.height;
      alphaBuf = new Uint8ClampedArray(sw * sh);
      smask.fillGrayBuffer(alphaBuf);

      if (sw !== width || sh !== height) {
        alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
      }
    } else if (mask) {
      if (mask instanceof PDFImage) {
        sw = mask.width;
        sh = mask.height;
        alphaBuf = new Uint8ClampedArray(sw * sh);
        mask.numComps = 1;
        mask.fillGrayBuffer(alphaBuf);

        for (i = 0, ii = sw * sh; i < ii; ++i) {
          alphaBuf[i] = 255 - alphaBuf[i];
        }

        if (sw !== width || sh !== height) {
          alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
        }
      } else if (Array.isArray(mask)) {
        alphaBuf = new Uint8ClampedArray(width * height);
        const numComps = this.numComps;

        for (i = 0, ii = width * height; i < ii; ++i) {
          let opacity = 0;
          const imageOffset = i * numComps;

          for (j = 0; j < numComps; ++j) {
            const color = image[imageOffset + j];
            const maskOffset = j * 2;

            if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
              opacity = 255;
              break;
            }
          }

          alphaBuf[i] = opacity;
        }
      } else {
        throw new _util.FormatError("Unknown mask format.");
      }
    }

    if (alphaBuf) {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = alphaBuf[i];
      }
    } else {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = 255;
      }
    }
  }

  undoPreblend(buffer, width, height) {
    const matte = this.smask && this.smask.matte;

    if (!matte) {
      return;
    }

    const matteRgb = this.colorSpace.getRgb(matte, 0);
    const matteR = matteRgb[0];
    const matteG = matteRgb[1];
    const matteB = matteRgb[2];
    const length = width * height * 4;

    for (let i = 0; i < length; i += 4) {
      const alpha = buffer[i + 3];

      if (alpha === 0) {
        buffer[i] = 255;
        buffer[i + 1] = 255;
        buffer[i + 2] = 255;
        continue;
      }

      const k = 255 / alpha;
      buffer[i] = (buffer[i] - matteR) * k + matteR;
      buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
      buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
    }
  }

  createImageData(forceRGBA = false) {
    const drawWidth = this.drawWidth;
    const drawHeight = this.drawHeight;
    const imgData = {
      width: drawWidth,
      height: drawHeight,
      kind: 0,
      data: null
    };
    const numComps = this.numComps;
    const originalWidth = this.width;
    const originalHeight = this.height;
    const bpc = this.bpc;
    const rowBytes = originalWidth * numComps * bpc + 7 >> 3;
    let imgArray;

    if (!forceRGBA) {
      let kind;

      if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
        kind = _util.ImageKind.GRAYSCALE_1BPP;
      } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
        kind = _util.ImageKind.RGB_24BPP;
      }

      if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
        imgData.kind = kind;
        imgArray = this.getImageBytes(originalHeight * rowBytes);

        if (this.image instanceof _decode_stream.DecodeStream) {
          imgData.data = imgArray;
        } else {
          const newArray = new Uint8ClampedArray(imgArray.length);
          newArray.set(imgArray);
          imgData.data = newArray;
        }

        if (this.needsDecode) {
          (0, _util.assert)(kind === _util.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
          const buffer = imgData.data;

          for (let i = 0, ii = buffer.length; i < ii; i++) {
            buffer[i] ^= 0xff;
          }
        }

        return imgData;
      }

      if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask) {
        let imageLength = originalHeight * rowBytes;

        switch (this.colorSpace.name) {
          case "DeviceGray":
            imageLength *= 3;

          case "DeviceRGB":
          case "DeviceCMYK":
            imgData.kind = _util.ImageKind.RGB_24BPP;
            imgData.data = this.getImageBytes(imageLength, drawWidth, drawHeight, true);
            return imgData;
        }
      }
    }

    imgArray = this.getImageBytes(originalHeight * rowBytes);
    const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
    const comps = this.getComponents(imgArray);
    let alpha01, maybeUndoPreblend;

    if (!forceRGBA && !this.smask && !this.mask) {
      imgData.kind = _util.ImageKind.RGB_24BPP;
      imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
      alpha01 = 0;
      maybeUndoPreblend = false;
    } else {
      imgData.kind = _util.ImageKind.RGBA_32BPP;
      imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
      alpha01 = 1;
      maybeUndoPreblend = true;
      this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
    }

    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }

    this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);

    if (maybeUndoPreblend) {
      this.undoPreblend(imgData.data, drawWidth, actualHeight);
    }

    return imgData;
  }

  fillGrayBuffer(buffer) {
    const numComps = this.numComps;

    if (numComps !== 1) {
      throw new _util.FormatError(`Reading gray scale from a color image: ${numComps}`);
    }

    const width = this.width;
    const height = this.height;
    const bpc = this.bpc;
    const rowBytes = width * numComps * bpc + 7 >> 3;
    const imgArray = this.getImageBytes(height * rowBytes);
    const comps = this.getComponents(imgArray);
    let i, length;

    if (bpc === 1) {
      length = width * height;

      if (this.needsDecode) {
        for (i = 0; i < length; ++i) {
          buffer[i] = comps[i] - 1 & 255;
        }
      } else {
        for (i = 0; i < length; ++i) {
          buffer[i] = -comps[i] & 255;
        }
      }

      return;
    }

    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }

    length = width * height;
    const scale = 255 / ((1 << bpc) - 1);

    for (i = 0; i < length; ++i) {
      buffer[i] = scale * comps[i];
    }
  }

  getImageBytes(length, drawWidth, drawHeight, forceRGB = false) {
    this.image.reset();
    this.image.drawWidth = drawWidth || this.width;
    this.image.drawHeight = drawHeight || this.height;
    this.image.forceRGB = !!forceRGB;
    return this.image.getBytes(length, true);
  }

}

exports.PDFImage = PDFImage;

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Catalog = void 0;

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

var _util = __w_pdfjs_require__(2);

var _name_number_tree = __w_pdfjs_require__(58);

var _colorspace = __w_pdfjs_require__(14);

var _file_spec = __w_pdfjs_require__(59);

var _image_utils = __w_pdfjs_require__(51);

var _metadata_parser = __w_pdfjs_require__(60);

var _struct_tree = __w_pdfjs_require__(62);

function fetchDestination(dest) {
  if (dest instanceof _primitives.Dict) {
    dest = dest.get("D");
  }

  return Array.isArray(dest) ? dest : null;
}

class Catalog {
  constructor(pdfManager, xref) {
    this.pdfManager = pdfManager;
    this.xref = xref;
    this._catDict = xref.getCatalogObj();

    if (!(0, _primitives.isDict)(this._catDict)) {
      throw new _util.FormatError("Catalog object is not a dictionary.");
    }

    this.fontCache = new _primitives.RefSetCache();
    this.builtInCMapCache = new Map();
    this.globalImageCache = new _image_utils.GlobalImageCache();
    this.pageKidsCountCache = new _primitives.RefSetCache();
    this.pageIndexCache = new _primitives.RefSetCache();
    this.nonBlendModesSet = new _primitives.RefSet();
  }

  get version() {
    const version = this._catDict.get("Version");

    if (!(0, _primitives.isName)(version)) {
      return (0, _util.shadow)(this, "version", null);
    }

    return (0, _util.shadow)(this, "version", version.name);
  }

  get collection() {
    let collection = null;

    try {
      const obj = this._catDict.get("Collection");

      if ((0, _primitives.isDict)(obj) && obj.size > 0) {
        collection = obj;
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.info)("Cannot fetch Collection entry; assuming no collection is present.");
    }

    return (0, _util.shadow)(this, "collection", collection);
  }

  get acroForm() {
    let acroForm = null;

    try {
      const obj = this._catDict.get("AcroForm");

      if ((0, _primitives.isDict)(obj) && obj.size > 0) {
        acroForm = obj;
      }
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
    }

    return (0, _util.shadow)(this, "acroForm", acroForm);
  }

  get metadata() {
    const streamRef = this._catDict.getRaw("Metadata");

    if (!(0, _primitives.isRef)(streamRef)) {
      return (0, _util.shadow)(this, "metadata", null);
    }

    const suppressEncryption = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata);
    const stream = this.xref.fetch(streamRef, suppressEncryption);
    let metadata = null;

    if ((0, _primitives.isStream)(stream) && (0, _primitives.isDict)(stream.dict)) {
      const type = stream.dict.get("Type");
      const subtype = stream.dict.get("Subtype");

      if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
        try {
          const data = (0, _util.stringToUTF8String)(stream.getString());

          if (data) {
            metadata = new _metadata_parser.MetadataParser(data).serializable;
          }
        } catch (e) {
          if (e instanceof _core_utils.MissingDataException) {
            throw e;
          }

          (0, _util.info)("Skipping invalid metadata.");
        }
      }
    }

    return (0, _util.shadow)(this, "metadata", metadata);
  }

  get markInfo() {
    let markInfo = null;

    try {
      markInfo = this._readMarkInfo();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)("Unable to read mark info.");
    }

    return (0, _util.shadow)(this, "markInfo", markInfo);
  }

  _readMarkInfo() {
    const obj = this._catDict.get("MarkInfo");

    if (!(0, _primitives.isDict)(obj)) {
      return null;
    }

    const markInfo = Object.assign(Object.create(null), {
      Marked: false,
      UserProperties: false,
      Suspects: false
    });

    for (const key in markInfo) {
      if (!obj.has(key)) {
        continue;
      }

      const value = obj.get(key);

      if (!(0, _util.isBool)(value)) {
        continue;
      }

      markInfo[key] = value;
    }

    return markInfo;
  }

  get structTreeRoot() {
    let structTree = null;

    try {
      structTree = this._readStructTreeRoot();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)("Unable read to structTreeRoot info.");
    }

    return (0, _util.shadow)(this, "structTreeRoot", structTree);
  }

  _readStructTreeRoot() {
    const obj = this._catDict.get("StructTreeRoot");

    if (!(0, _primitives.isDict)(obj)) {
      return null;
    }

    const root = new _struct_tree.StructTreeRoot(obj);
    root.init();
    return root;
  }

  get toplevelPagesDict() {
    const pagesObj = this._catDict.get("Pages");

    if (!(0, _primitives.isDict)(pagesObj)) {
      throw new _util.FormatError("Invalid top-level pages dictionary.");
    }

    return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
  }

  get documentOutline() {
    let obj = null;

    try {
      obj = this._readDocumentOutline();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)("Unable to read document outline.");
    }

    return (0, _util.shadow)(this, "documentOutline", obj);
  }

  _readDocumentOutline() {
    let obj = this._catDict.get("Outlines");

    if (!(0, _primitives.isDict)(obj)) {
      return null;
    }

    obj = obj.getRaw("First");

    if (!(0, _primitives.isRef)(obj)) {
      return null;
    }

    const root = {
      items: []
    };
    const queue = [{
      obj,
      parent: root
    }];
    const processed = new _primitives.RefSet();
    processed.put(obj);
    const xref = this.xref,
          blackColor = new Uint8ClampedArray(3);

    while (queue.length > 0) {
      const i = queue.shift();
      const outlineDict = xref.fetchIfRef(i.obj);

      if (outlineDict === null) {
        continue;
      }

      if (!outlineDict.has("Title")) {
        throw new _util.FormatError("Invalid outline item encountered.");
      }

      const data = {
        url: null,
        dest: null
      };
      Catalog.parseDestDictionary({
        destDict: outlineDict,
        resultObj: data,
        docBaseUrl: this.pdfManager.docBaseUrl
      });
      const title = outlineDict.get("Title");
      const flags = outlineDict.get("F") || 0;
      const color = outlineDict.getArray("C");
      const count = outlineDict.get("Count");
      let rgbColor = blackColor;

      if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
        rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
      }

      const outlineItem = {
        dest: data.dest,
        url: data.url,
        unsafeUrl: data.unsafeUrl,
        newWindow: data.newWindow,
        title: (0, _util.stringToPDFString)(title),
        color: rgbColor,
        count: Number.isInteger(count) ? count : undefined,
        bold: !!(flags & 2),
        italic: !!(flags & 1),
        items: []
      };
      i.parent.items.push(outlineItem);
      obj = outlineDict.getRaw("First");

      if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
        queue.push({
          obj,
          parent: outlineItem
        });
        processed.put(obj);
      }

      obj = outlineDict.getRaw("Next");

      if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
        queue.push({
          obj,
          parent: i.parent
        });
        processed.put(obj);
      }
    }

    return root.items.length > 0 ? root.items : null;
  }

  get permissions() {
    let permissions = null;

    try {
      permissions = this._readPermissions();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)("Unable to read permissions.");
    }

    return (0, _util.shadow)(this, "permissions", permissions);
  }

  _readPermissions() {
    const encrypt = this.xref.trailer.get("Encrypt");

    if (!(0, _primitives.isDict)(encrypt)) {
      return null;
    }

    let flags = encrypt.get("P");

    if (!(0, _util.isNum)(flags)) {
      return null;
    }

    flags += 2 ** 32;
    const permissions = [];

    for (const key in _util.PermissionFlag) {
      const value = _util.PermissionFlag[key];

      if (flags & value) {
        permissions.push(value);
      }
    }

    return permissions;
  }

  get optionalContentConfig() {
    let config = null;

    try {
      const properties = this._catDict.get("OCProperties");

      if (!properties) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }

      const defaultConfig = properties.get("D");

      if (!defaultConfig) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }

      const groupsData = properties.get("OCGs");

      if (!Array.isArray(groupsData)) {
        return (0, _util.shadow)(this, "optionalContentConfig", null);
      }

      const groups = [];
      const groupRefs = [];

      for (const groupRef of groupsData) {
        if (!(0, _primitives.isRef)(groupRef)) {
          continue;
        }

        groupRefs.push(groupRef);
        const group = this.xref.fetchIfRef(groupRef);
        groups.push({
          id: groupRef.toString(),
          name: (0, _util.isString)(group.get("Name")) ? (0, _util.stringToPDFString)(group.get("Name")) : null,
          intent: (0, _util.isString)(group.get("Intent")) ? (0, _util.stringToPDFString)(group.get("Intent")) : null
        });
      }

      config = this._readOptionalContentConfig(defaultConfig, groupRefs);
      config.groups = groups;
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)(`Unable to read optional content config: ${ex}`);
    }

    return (0, _util.shadow)(this, "optionalContentConfig", config);
  }

  _readOptionalContentConfig(config, contentGroupRefs) {
    function parseOnOff(refs) {
      const onParsed = [];

      if (Array.isArray(refs)) {
        for (const value of refs) {
          if (!(0, _primitives.isRef)(value)) {
            continue;
          }

          if (contentGroupRefs.includes(value)) {
            onParsed.push(value.toString());
          }
        }
      }

      return onParsed;
    }

    function parseOrder(refs, nestedLevels = 0) {
      if (!Array.isArray(refs)) {
        return null;
      }

      const order = [];

      for (const value of refs) {
        if ((0, _primitives.isRef)(value) && contentGroupRefs.includes(value)) {
          parsedOrderRefs.put(value);
          order.push(value.toString());
          continue;
        }

        const nestedOrder = parseNestedOrder(value, nestedLevels);

        if (nestedOrder) {
          order.push(nestedOrder);
        }
      }

      if (nestedLevels > 0) {
        return order;
      }

      const hiddenGroups = [];

      for (const groupRef of contentGroupRefs) {
        if (parsedOrderRefs.has(groupRef)) {
          continue;
        }

        hiddenGroups.push(groupRef.toString());
      }

      if (hiddenGroups.length) {
        order.push({
          name: null,
          order: hiddenGroups
        });
      }

      return order;
    }

    function parseNestedOrder(ref, nestedLevels) {
      if (++nestedLevels > MAX_NESTED_LEVELS) {
        (0, _util.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS.");
        return null;
      }

      const value = xref.fetchIfRef(ref);

      if (!Array.isArray(value)) {
        return null;
      }

      const nestedName = xref.fetchIfRef(value[0]);

      if (typeof nestedName !== "string") {
        return null;
      }

      const nestedOrder = parseOrder(value.slice(1), nestedLevels);

      if (!nestedOrder || !nestedOrder.length) {
        return null;
      }

      return {
        name: (0, _util.stringToPDFString)(nestedName),
        order: nestedOrder
      };
    }

    const xref = this.xref,
          parsedOrderRefs = new _primitives.RefSet(),
          MAX_NESTED_LEVELS = 10;
    return {
      name: (0, _util.isString)(config.get("Name")) ? (0, _util.stringToPDFString)(config.get("Name")) : null,
      creator: (0, _util.isString)(config.get("Creator")) ? (0, _util.stringToPDFString)(config.get("Creator")) : null,
      baseState: (0, _primitives.isName)(config.get("BaseState")) ? config.get("BaseState").name : null,
      on: parseOnOff(config.get("ON")),
      off: parseOnOff(config.get("OFF")),
      order: parseOrder(config.get("Order")),
      groups: null
    };
  }

  get numPages() {
    const obj = this.toplevelPagesDict.get("Count");

    if (!Number.isInteger(obj)) {
      throw new _util.FormatError("Page count in top-level pages dictionary is not an integer.");
    }

    return (0, _util.shadow)(this, "numPages", obj);
  }

  get destinations() {
    const obj = this._readDests(),
          dests = Object.create(null);

    if (obj instanceof _name_number_tree.NameTree) {
      for (const [key, value] of obj.getAll()) {
        const dest = fetchDestination(value);

        if (dest) {
          dests[key] = dest;
        }
      }
    } else if (obj instanceof _primitives.Dict) {
      obj.forEach(function (key, value) {
        const dest = fetchDestination(value);

        if (dest) {
          dests[key] = dest;
        }
      });
    }

    return (0, _util.shadow)(this, "destinations", dests);
  }

  getDestination(id) {
    const obj = this._readDests();

    if (obj instanceof _name_number_tree.NameTree) {
      const dest = fetchDestination(obj.get(id));

      if (dest) {
        return dest;
      }

      const allDest = this.destinations[id];

      if (allDest) {
        (0, _util.warn)(`Found "${id}" at an incorrect position in the NameTree.`);
        return allDest;
      }
    } else if (obj instanceof _primitives.Dict) {
      const dest = fetchDestination(obj.get(id));

      if (dest) {
        return dest;
      }
    }

    return null;
  }

  _readDests() {
    const obj = this._catDict.get("Names");

    if (obj && obj.has("Dests")) {
      return new _name_number_tree.NameTree(obj.getRaw("Dests"), this.xref);
    } else if (this._catDict.has("Dests")) {
      return this._catDict.get("Dests");
    }

    return undefined;
  }

  get pageLabels() {
    let obj = null;

    try {
      obj = this._readPageLabels();
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)("Unable to read page labels.");
    }

    return (0, _util.shadow)(this, "pageLabels", obj);
  }

  _readPageLabels() {
    const obj = this._catDict.getRaw("PageLabels");

    if (!obj) {
      return null;
    }

    const pageLabels = new Array(this.numPages);
    let style = null,
        prefix = "";
    const numberTree = new _name_number_tree.NumberTree(obj, this.xref);
    const nums = numberTree.getAll();
    let currentLabel = "",
        currentIndex = 1;

    for (let i = 0, ii = this.numPages; i < ii; i++) {
      const labelDict = nums.get(i);

      if (labelDict !== undefined) {
        if (!(0, _primitives.isDict)(labelDict)) {
          throw new _util.FormatError("PageLabel is not a dictionary.");
        }

        if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
          throw new _util.FormatError("Invalid type in PageLabel dictionary.");
        }

        if (labelDict.has("S")) {
          const s = labelDict.get("S");

          if (!(0, _primitives.isName)(s)) {
            throw new _util.FormatError("Invalid style in PageLabel dictionary.");
          }

          style = s.name;
        } else {
          style = null;
        }

        if (labelDict.has("P")) {
          const p = labelDict.get("P");

          if (!(0, _util.isString)(p)) {
            throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
          }

          prefix = (0, _util.stringToPDFString)(p);
        } else {
          prefix = "";
        }

        if (labelDict.has("St")) {
          const st = labelDict.get("St");

          if (!(Number.isInteger(st) && st >= 1)) {
            throw new _util.FormatError("Invalid start in PageLabel dictionary.");
          }

          currentIndex = st;
        } else {
          currentIndex = 1;
        }
      }

      switch (style) {
        case "D":
          currentLabel = currentIndex;
          break;

        case "R":
        case "r":
          currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
          break;

        case "A":
        case "a":
          const LIMIT = 26;
          const A_UPPER_CASE = 0x41,
                A_LOWER_CASE = 0x61;
          const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
          const letterIndex = currentIndex - 1;
          const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
          const charBuf = [];

          for (let j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
            charBuf.push(character);
          }

          currentLabel = charBuf.join("");
          break;

        default:
          if (style) {
            throw new _util.FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
          }

          currentLabel = "";
      }

      pageLabels[i] = prefix + currentLabel;
      currentIndex++;
    }

    return pageLabels;
  }

  get pageLayout() {
    const obj = this._catDict.get("PageLayout");

    let pageLayout = "";

    if ((0, _primitives.isName)(obj)) {
      switch (obj.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          pageLayout = obj.name;
      }
    }

    return (0, _util.shadow)(this, "pageLayout", pageLayout);
  }

  get pageMode() {
    const obj = this._catDict.get("PageMode");

    let pageMode = "UseNone";

    if ((0, _primitives.isName)(obj)) {
      switch (obj.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          pageMode = obj.name;
      }
    }

    return (0, _util.shadow)(this, "pageMode", pageMode);
  }

  get viewerPreferences() {
    const ViewerPreferencesValidators = {
      HideToolbar: _util.isBool,
      HideMenubar: _util.isBool,
      HideWindowUI: _util.isBool,
      FitWindow: _util.isBool,
      CenterWindow: _util.isBool,
      DisplayDocTitle: _util.isBool,
      NonFullScreenPageMode: _primitives.isName,
      Direction: _primitives.isName,
      ViewArea: _primitives.isName,
      ViewClip: _primitives.isName,
      PrintArea: _primitives.isName,
      PrintClip: _primitives.isName,
      PrintScaling: _primitives.isName,
      Duplex: _primitives.isName,
      PickTrayByPDFSize: _util.isBool,
      PrintPageRange: Array.isArray,
      NumCopies: Number.isInteger
    };

    const obj = this._catDict.get("ViewerPreferences");

    let prefs = null;

    if ((0, _primitives.isDict)(obj)) {
      for (const key in ViewerPreferencesValidators) {
        if (!obj.has(key)) {
          continue;
        }

        const value = obj.get(key);

        if (!ViewerPreferencesValidators[key](value)) {
          (0, _util.info)(`Bad value in ViewerPreferences for "${key}".`);
          continue;
        }

        let prefValue;

        switch (key) {
          case "NonFullScreenPageMode":
            switch (value.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                prefValue = value.name;
                break;

              default:
                prefValue = "UseNone";
            }

            break;

          case "Direction":
            switch (value.name) {
              case "L2R":
              case "R2L":
                prefValue = value.name;
                break;

              default:
                prefValue = "L2R";
            }

            break;

          case "ViewArea":
          case "ViewClip":
          case "PrintArea":
          case "PrintClip":
            switch (value.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                prefValue = value.name;
                break;

              default:
                prefValue = "CropBox";
            }

            break;

          case "PrintScaling":
            switch (value.name) {
              case "None":
              case "AppDefault":
                prefValue = value.name;
                break;

              default:
                prefValue = "AppDefault";
            }

            break;

          case "Duplex":
            switch (value.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                prefValue = value.name;
                break;

              default:
                prefValue = "None";
            }

            break;

          case "PrintPageRange":
            const length = value.length;

            if (length % 2 !== 0) {
              break;
            }

            const isValid = value.every((page, i, arr) => {
              return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages;
            });

            if (isValid) {
              prefValue = value;
            }

            break;

          case "NumCopies":
            if (value > 0) {
              prefValue = value;
            }

            break;

          default:
            if (typeof value !== "boolean") {
              throw new _util.FormatError(`viewerPreferences - expected a boolean value for: ${key}`);
            }

            prefValue = value;
        }

        if (prefValue !== undefined) {
          if (!prefs) {
            prefs = Object.create(null);
          }

          prefs[key] = prefValue;
        } else {
          (0, _util.info)(`Bad value in ViewerPreferences for "${key}".`);
        }
      }
    }

    return (0, _util.shadow)(this, "viewerPreferences", prefs);
  }

  get openAction() {
    const obj = this._catDict.get("OpenAction");

    const openAction = Object.create(null);

    if ((0, _primitives.isDict)(obj)) {
      const destDict = new _primitives.Dict(this.xref);
      destDict.set("A", obj);
      const resultObj = {
        url: null,
        dest: null,
        action: null
      };
      Catalog.parseDestDictionary({
        destDict,
        resultObj
      });

      if (Array.isArray(resultObj.dest)) {
        openAction.dest = resultObj.dest;
      } else if (resultObj.action) {
        openAction.action = resultObj.action;
      }
    } else if (Array.isArray(obj)) {
      openAction.dest = obj;
    }

    return (0, _util.shadow)(this, "openAction", (0, _util.objectSize)(openAction) > 0 ? openAction : null);
  }

  get attachments() {
    const obj = this._catDict.get("Names");

    let attachments = null;

    if (obj instanceof _primitives.Dict && obj.has("EmbeddedFiles")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("EmbeddedFiles"), this.xref);

      for (const [key, value] of nameTree.getAll()) {
        const fs = new _file_spec.FileSpec(value, this.xref);

        if (!attachments) {
          attachments = Object.create(null);
        }

        attachments[(0, _util.stringToPDFString)(key)] = fs.serializable;
      }
    }

    return (0, _util.shadow)(this, "attachments", attachments);
  }

  _collectJavaScript() {
    const obj = this._catDict.get("Names");

    let javaScript = null;

    function appendIfJavaScriptDict(name, jsDict) {
      if (!(jsDict instanceof _primitives.Dict)) {
        return;
      }

      if (!(0, _primitives.isName)(jsDict.get("S"), "JavaScript")) {
        return;
      }

      let js = jsDict.get("JS");

      if ((0, _primitives.isStream)(js)) {
        js = js.getString();
      } else if (typeof js !== "string") {
        return;
      }

      if (javaScript === null) {
        javaScript = new Map();
      }

      javaScript.set(name, (0, _util.stringToPDFString)(js));
    }

    if (obj instanceof _primitives.Dict && obj.has("JavaScript")) {
      const nameTree = new _name_number_tree.NameTree(obj.getRaw("JavaScript"), this.xref);

      for (const [key, value] of nameTree.getAll()) {
        appendIfJavaScriptDict(key, value);
      }
    }

    const openAction = this._catDict.get("OpenAction");

    if (openAction) {
      appendIfJavaScriptDict("OpenAction", openAction);
    }

    return javaScript;
  }

  get javaScript() {
    const javaScript = this._collectJavaScript();

    return (0, _util.shadow)(this, "javaScript", javaScript ? [...javaScript.values()] : null);
  }

  get jsActions() {
    const javaScript = this._collectJavaScript();

    let actions = (0, _core_utils.collectActions)(this.xref, this._catDict, _util.DocumentActionEventType);

    if (javaScript) {
      if (!actions) {
        actions = Object.create(null);
      }

      for (const [key, val] of javaScript) {
        if (key in actions) {
          actions[key].push(val);
        } else {
          actions[key] = [val];
        }
      }
    }

    return (0, _util.shadow)(this, "jsActions", actions);
  }

  fontFallback(id, handler) {
    const promises = [];
    this.fontCache.forEach(function (promise) {
      promises.push(promise);
    });
    return Promise.all(promises).then(translatedFonts => {
      for (const translatedFont of translatedFonts) {
        if (translatedFont.loadedName === id) {
          translatedFont.fallback(handler);
          return;
        }
      }
    });
  }

  cleanup(manuallyTriggered = false) {
    (0, _primitives.clearPrimitiveCaches)();
    this.globalImageCache.clear(manuallyTriggered);
    this.pageKidsCountCache.clear();
    this.pageIndexCache.clear();
    this.nonBlendModesSet.clear();
    const promises = [];
    this.fontCache.forEach(function (promise) {
      promises.push(promise);
    });
    return Promise.all(promises).then(translatedFonts => {
      for (const {
        dict
      } of translatedFonts) {
        delete dict.cacheKey;
      }

      this.fontCache.clear();
      this.builtInCMapCache.clear();
    });
  }

  getPageDict(pageIndex) {
    const capability = (0, _util.createPromiseCapability)();
    const nodesToVisit = [this._catDict.getRaw("Pages")];
    const visitedNodes = new _primitives.RefSet();
    const xref = this.xref,
          pageKidsCountCache = this.pageKidsCountCache;
    let count,
        currentPageIndex = 0;

    function next() {
      while (nodesToVisit.length) {
        const currentNode = nodesToVisit.pop();

        if ((0, _primitives.isRef)(currentNode)) {
          count = pageKidsCountCache.get(currentNode);

          if (count > 0 && currentPageIndex + count < pageIndex) {
            currentPageIndex += count;
            continue;
          }

          if (visitedNodes.has(currentNode)) {
            capability.reject(new _util.FormatError("Pages tree contains circular reference."));
            return;
          }

          visitedNodes.put(currentNode);
          xref.fetchAsync(currentNode).then(function (obj) {
            if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Kids")) {
              if (pageIndex === currentPageIndex) {
                if (currentNode && !pageKidsCountCache.has(currentNode)) {
                  pageKidsCountCache.put(currentNode, 1);
                }

                capability.resolve([obj, currentNode]);
              } else {
                currentPageIndex++;
                next();
              }

              return;
            }

            nodesToVisit.push(obj);
            next();
          }, capability.reject);
          return;
        }

        if (!(0, _primitives.isDict)(currentNode)) {
          capability.reject(new _util.FormatError("Page dictionary kid reference points to wrong type of object."));
          return;
        }

        count = currentNode.get("Count");

        if (Number.isInteger(count) && count >= 0) {
          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {
            pageKidsCountCache.put(objId, count);
          }

          if (currentPageIndex + count <= pageIndex) {
            currentPageIndex += count;
            continue;
          }
        }

        const kids = currentNode.get("Kids");

        if (!Array.isArray(kids)) {
          if ((0, _primitives.isName)(currentNode.get("Type"), "Page") || !currentNode.has("Type") && currentNode.has("Contents")) {
            if (currentPageIndex === pageIndex) {
              capability.resolve([currentNode, null]);
              return;
            }

            currentPageIndex++;
            continue;
          }

          capability.reject(new _util.FormatError("Page dictionary kids object is not an array."));
          return;
        }

        for (let last = kids.length - 1; last >= 0; last--) {
          nodesToVisit.push(kids[last]);
        }
      }

      capability.reject(new Error(`Page index ${pageIndex} not found.`));
    }

    next();
    return capability.promise;
  }

  getPageIndex(pageRef) {
    const cachedPageIndex = this.pageIndexCache.get(pageRef);

    if (cachedPageIndex !== undefined) {
      return Promise.resolve(cachedPageIndex);
    }

    const xref = this.xref;

    function pagesBeforeRef(kidRef) {
      let total = 0,
          parentRef;
      return xref.fetchAsync(kidRef).then(function (node) {
        if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !((0, _primitives.isDict)(node) && !node.has("Type") && node.has("Contents"))) {
          throw new _util.FormatError("The reference does not point to a /Page dictionary.");
        }

        if (!node) {
          return null;
        }

        if (!(0, _primitives.isDict)(node)) {
          throw new _util.FormatError("Node must be a dictionary.");
        }

        parentRef = node.getRaw("Parent");
        return node.getAsync("Parent");
      }).then(function (parent) {
        if (!parent) {
          return null;
        }

        if (!(0, _primitives.isDict)(parent)) {
          throw new _util.FormatError("Parent must be a dictionary.");
        }

        return parent.getAsync("Kids");
      }).then(function (kids) {
        if (!kids) {
          return null;
        }

        const kidPromises = [];
        let found = false;

        for (let i = 0, ii = kids.length; i < ii; i++) {
          const kid = kids[i];

          if (!(0, _primitives.isRef)(kid)) {
            throw new _util.FormatError("Kid must be a reference.");
          }

          if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
            found = true;
            break;
          }

          kidPromises.push(xref.fetchAsync(kid).then(function (obj) {
            if (!(0, _primitives.isDict)(obj)) {
              throw new _util.FormatError("Kid node must be a dictionary.");
            }

            if (obj.has("Count")) {
              total += obj.get("Count");
            } else {
              total++;
            }
          }));
        }

        if (!found) {
          throw new _util.FormatError("Kid reference not found in parent's kids.");
        }

        return Promise.all(kidPromises).then(function () {
          return [total, parentRef];
        });
      });
    }

    let total = 0;

    const next = ref => pagesBeforeRef(ref).then(args => {
      if (!args) {
        this.pageIndexCache.put(pageRef, total);
        return total;
      }

      const [count, parentRef] = args;
      total += count;
      return next(parentRef);
    });

    return next(pageRef);
  }

  static parseDestDictionary(params) {
    function addDefaultProtocolToUrl(url) {
      return url.startsWith("www.") ? `http://${url}` : url;
    }

    function tryConvertUrlEncoding(url) {
      try {
        return (0, _util.stringToUTF8String)(url);
      } catch (e) {
        return url;
      }
    }

    const destDict = params.destDict;

    if (!(0, _primitives.isDict)(destDict)) {
      (0, _util.warn)("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }

    const resultObj = params.resultObj;

    if (typeof resultObj !== "object") {
      (0, _util.warn)("parseDestDictionary: `resultObj` must be an object.");
      return;
    }

    const docBaseUrl = params.docBaseUrl || null;
    let action = destDict.get("A"),
        url,
        dest;

    if (!(0, _primitives.isDict)(action)) {
      if (destDict.has("Dest")) {
        action = destDict.get("Dest");
      } else {
        action = destDict.get("AA");

        if ((0, _primitives.isDict)(action)) {
          if (action.has("D")) {
            action = action.get("D");
          } else if (action.has("U")) {
            action = action.get("U");
          }
        }
      }
    }

    if ((0, _primitives.isDict)(action)) {
      const actionType = action.get("S");

      if (!(0, _primitives.isName)(actionType)) {
        (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }

      const actionName = actionType.name;

      switch (actionName) {
        case "URI":
          url = action.get("URI");

          if ((0, _primitives.isName)(url)) {
            url = "/" + url.name;
          } else if ((0, _util.isString)(url)) {
            url = addDefaultProtocolToUrl(url);
          }

          break;

        case "GoTo":
          dest = action.get("D");
          break;

        case "Launch":
        case "GoToR":
          const urlDict = action.get("F");

          if ((0, _primitives.isDict)(urlDict)) {
            url = urlDict.get("F") || null;
          } else if ((0, _util.isString)(urlDict)) {
            url = urlDict;
          }

          let remoteDest = action.get("D");

          if (remoteDest) {
            if ((0, _primitives.isName)(remoteDest)) {
              remoteDest = remoteDest.name;
            }

            if ((0, _util.isString)(url)) {
              const baseUrl = url.split("#")[0];

              if ((0, _util.isString)(remoteDest)) {
                url = baseUrl + "#" + remoteDest;
              } else if (Array.isArray(remoteDest)) {
                url = baseUrl + "#" + JSON.stringify(remoteDest);
              }
            }
          }

          const newWindow = action.get("NewWindow");

          if ((0, _util.isBool)(newWindow)) {
            resultObj.newWindow = newWindow;
          }

          break;

        case "Named":
          const namedAction = action.get("N");

          if ((0, _primitives.isName)(namedAction)) {
            resultObj.action = namedAction.name;
          }

          break;

        case "JavaScript":
          const jsAction = action.get("JS");
          let js;

          if ((0, _primitives.isStream)(jsAction)) {
            js = jsAction.getString();
          } else if ((0, _util.isString)(jsAction)) {
            js = jsAction;
          }

          if (js) {
            const URL_OPEN_METHODS = ["app.launchURL", "window.open"];
            const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i");
            const jsUrl = regex.exec((0, _util.stringToPDFString)(js));

            if (jsUrl && jsUrl[2]) {
              url = jsUrl[2];

              if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                resultObj.newWindow = true;
              }

              break;
            }
          }

        default:
          if (actionName === "JavaScript" || actionName === "ResetForm" || actionName === "SubmitForm") {
            break;
          }

          (0, _util.warn)(`parseDestDictionary - unsupported action: "${actionName}".`);
          break;
      }
    } else if (destDict.has("Dest")) {
      dest = destDict.get("Dest");
    }

    if ((0, _util.isString)(url)) {
      url = tryConvertUrlEncoding(url);
      const absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl);

      if (absoluteUrl) {
        resultObj.url = absoluteUrl.href;
      }

      resultObj.unsafeUrl = url;
    }

    if (dest) {
      if ((0, _primitives.isName)(dest)) {
        dest = dest.name;
      }

      if ((0, _util.isString)(dest) || Array.isArray(dest)) {
        resultObj.dest = dest;
      }
    }
  }

}

exports.Catalog = Catalog;

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NumberTree = exports.NameTree = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

class NameOrNumberTree {
  constructor(root, xref, type) {
    if (this.constructor === NameOrNumberTree) {
      (0, _util.unreachable)("Cannot initialize NameOrNumberTree.");
    }

    this.root = root;
    this.xref = xref;
    this._type = type;
  }

  getAll() {
    const map = new Map();

    if (!this.root) {
      return map;
    }

    const xref = this.xref;
    const processed = new _primitives.RefSet();
    processed.put(this.root);
    const queue = [this.root];

    while (queue.length > 0) {
      const obj = xref.fetchIfRef(queue.shift());

      if (!(0, _primitives.isDict)(obj)) {
        continue;
      }

      if (obj.has("Kids")) {
        const kids = obj.get("Kids");

        for (let i = 0, ii = kids.length; i < ii; i++) {
          const kid = kids[i];

          if (processed.has(kid)) {
            throw new _util.FormatError(`Duplicate entry in "${this._type}" tree.`);
          }

          queue.push(kid);
          processed.put(kid);
        }

        continue;
      }

      const entries = obj.get(this._type);

      if (!Array.isArray(entries)) {
        continue;
      }

      for (let i = 0, ii = entries.length; i < ii; i += 2) {
        map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1]));
      }
    }

    return map;
  }

  get(key) {
    if (!this.root) {
      return null;
    }

    const xref = this.xref;
    let kidsOrEntries = xref.fetchIfRef(this.root);
    let loopCount = 0;
    const MAX_LEVELS = 10;

    while (kidsOrEntries.has("Kids")) {
      if (++loopCount > MAX_LEVELS) {
        (0, _util.warn)(`Search depth limit reached for "${this._type}" tree.`);
        return null;
      }

      const kids = kidsOrEntries.get("Kids");

      if (!Array.isArray(kids)) {
        return null;
      }

      let l = 0,
          r = kids.length - 1;

      while (l <= r) {
        const m = l + r >> 1;
        const kid = xref.fetchIfRef(kids[m]);
        const limits = kid.get("Limits");

        if (key < xref.fetchIfRef(limits[0])) {
          r = m - 1;
        } else if (key > xref.fetchIfRef(limits[1])) {
          l = m + 1;
        } else {
          kidsOrEntries = xref.fetchIfRef(kids[m]);
          break;
        }
      }

      if (l > r) {
        return null;
      }
    }

    const entries = kidsOrEntries.get(this._type);

    if (Array.isArray(entries)) {
      let l = 0,
          r = entries.length - 2;

      while (l <= r) {
        const tmp = l + r >> 1,
              m = tmp + (tmp & 1);
        const currentKey = xref.fetchIfRef(entries[m]);

        if (key < currentKey) {
          r = m - 2;
        } else if (key > currentKey) {
          l = m + 2;
        } else {
          return xref.fetchIfRef(entries[m + 1]);
        }
      }
    }

    return null;
  }

}

class NameTree extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Names");
  }

}

exports.NameTree = NameTree;

class NumberTree extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Nums");
  }

}

exports.NumberTree = NumberTree;

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FileSpec = void 0;

var _primitives = __w_pdfjs_require__(5);

var _util = __w_pdfjs_require__(2);

function pickPlatformItem(dict) {
  if (dict.has("UF")) {
    return dict.get("UF");
  } else if (dict.has("F")) {
    return dict.get("F");
  } else if (dict.has("Unix")) {
    return dict.get("Unix");
  } else if (dict.has("Mac")) {
    return dict.get("Mac");
  } else if (dict.has("DOS")) {
    return dict.get("DOS");
  }

  return null;
}

class FileSpec {
  constructor(root, xref) {
    if (!root || !(0, _primitives.isDict)(root)) {
      return;
    }

    this.xref = xref;
    this.root = root;

    if (root.has("FS")) {
      this.fs = root.get("FS");
    }

    this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";

    if (root.has("RF")) {
      (0, _util.warn)("Related file specifications are not supported");
    }

    this.contentAvailable = true;

    if (!root.has("EF")) {
      this.contentAvailable = false;
      (0, _util.warn)("Non-embedded file specifications are not supported");
    }
  }

  get filename() {
    if (!this._filename && this.root) {
      const filename = pickPlatformItem(this.root) || "unnamed";
      this._filename = (0, _util.stringToPDFString)(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
    }

    return this._filename;
  }

  get content() {
    if (!this.contentAvailable) {
      return null;
    }

    if (!this.contentRef && this.root) {
      this.contentRef = pickPlatformItem(this.root.get("EF"));
    }

    let content = null;

    if (this.contentRef) {
      const fileObj = this.xref.fetchIfRef(this.contentRef);

      if (fileObj && (0, _primitives.isStream)(fileObj)) {
        content = fileObj.getBytes();
      } else {
        (0, _util.warn)("Embedded file specification points to non-existing/invalid content");
      }
    } else {
      (0, _util.warn)("Embedded file specification does not have a content");
    }

    return content;
  }

  get serializable() {
    return {
      filename: this.filename,
      content: this.content
    };
  }

}

exports.FileSpec = FileSpec;

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MetadataParser = void 0;

var _xml_parser = __w_pdfjs_require__(61);

class MetadataParser {
  constructor(data) {
    data = this._repair(data);
    const parser = new _xml_parser.SimpleXMLParser({
      lowerCaseName: true
    });
    const xmlDocument = parser.parseFromString(data);
    this._metadataMap = new Map();
    this._data = data;

    if (xmlDocument) {
      this._parse(xmlDocument);
    }
  }

  _repair(data) {
    return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function (all, codes) {
      const bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
      }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {
        switch (name) {
          case "amp":
            return "&";

          case "apos":
            return "'";

          case "gt":
            return ">";

          case "lt":
            return "<";

          case "quot":
            return '"';
        }

        throw new Error(`_repair: ${name} isn't defined.`);
      });
      const charBuf = [];

      for (let i = 0, ii = bytes.length; i < ii; i += 2) {
        const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);

        if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
          charBuf.push(String.fromCharCode(code));
        } else {
          charBuf.push("&#x" + (0x10000 + code).toString(16).substring(1) + ";");
        }
      }

      return ">" + charBuf.join("");
    });
  }

  _getSequence(entry) {
    const name = entry.nodeName;

    if (name !== "rdf:bag" && name !== "rdf:seq" && name !== "rdf:alt") {
      return null;
    }

    return entry.childNodes.filter(node => node.nodeName === "rdf:li");
  }

  _parseArray(entry) {
    if (!entry.hasChildNodes()) {
      return;
    }

    const [seqNode] = entry.childNodes;
    const sequence = this._getSequence(seqNode) || [];

    this._metadataMap.set(entry.nodeName, sequence.map(node => node.textContent.trim()));
  }

  _parse(xmlDocument) {
    let rdf = xmlDocument.documentElement;

    if (rdf.nodeName !== "rdf:rdf") {
      rdf = rdf.firstChild;

      while (rdf && rdf.nodeName !== "rdf:rdf") {
        rdf = rdf.nextSibling;
      }
    }

    if (!rdf || rdf.nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
      return;
    }

    for (const desc of rdf.childNodes) {
      if (desc.nodeName !== "rdf:description") {
        continue;
      }

      for (const entry of desc.childNodes) {
        const name = entry.nodeName;

        switch (name) {
          case "#text":
            continue;

          case "dc:creator":
          case "dc:subject":
            this._parseArray(entry);

            continue;
        }

        this._metadataMap.set(name, entry.textContent.trim());
      }
    }
  }

  get serializable() {
    return {
      parsedData: this._metadataMap,
      rawData: this._data
    };
  }

}

exports.MetadataParser = MetadataParser;

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XMLParserErrorCode = exports.XMLParserBase = exports.SimpleXMLParser = exports.SimpleDOMNode = void 0;

var _core_utils = __w_pdfjs_require__(9);

const XMLParserErrorCode = {
  NoError: 0,
  EndOfDocument: -1,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  OutOfMemory: -7,
  UnterminatedAttributeValue: -8,
  UnterminatedElement: -9,
  ElementNeverBegun: -10
};
exports.XMLParserErrorCode = XMLParserErrorCode;

function isWhitespace(s, index) {
  const ch = s[index];
  return ch === " " || ch === "\n" || ch === "\r" || ch === "\t";
}

function isWhitespaceString(s) {
  for (let i = 0, ii = s.length; i < ii; i++) {
    if (!isWhitespace(s, i)) {
      return false;
    }
  }

  return true;
}

class XMLParserBase {
  _resolveEntities(s) {
    return s.replace(/&([^;]+);/g, (all, entity) => {
      if (entity.substring(0, 2) === "#x") {
        return String.fromCodePoint(parseInt(entity.substring(2), 16));
      } else if (entity.substring(0, 1) === "#") {
        return String.fromCodePoint(parseInt(entity.substring(1), 10));
      }

      switch (entity) {
        case "lt":
          return "<";

        case "gt":
          return ">";

        case "amp":
          return "&";

        case "quot":
          return '"';

        case "apos":
          return "'";
      }

      return this.onResolveEntity(entity);
    });
  }

  _parseContent(s, start) {
    const attributes = [];
    let pos = start;

    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }

    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
      ++pos;
    }

    const name = s.substring(start, pos);
    skipWs();

    while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
      skipWs();
      let attrName = "",
          attrValue = "";

      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
        attrName += s[pos];
        ++pos;
      }

      skipWs();

      if (s[pos] !== "=") {
        return null;
      }

      ++pos;
      skipWs();
      const attrEndChar = s[pos];

      if (attrEndChar !== '"' && attrEndChar !== "'") {
        return null;
      }

      const attrEndIndex = s.indexOf(attrEndChar, ++pos);

      if (attrEndIndex < 0) {
        return null;
      }

      attrValue = s.substring(pos, attrEndIndex);
      attributes.push({
        name: attrName,
        value: this._resolveEntities(attrValue)
      });
      pos = attrEndIndex + 1;
      skipWs();
    }

    return {
      name,
      attributes,
      parsed: pos - start
    };
  }

  _parseProcessingInstruction(s, start) {
    let pos = start;

    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }

    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "?" && s[pos] !== "/") {
      ++pos;
    }

    const name = s.substring(start, pos);
    skipWs();
    const attrStart = pos;

    while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
      ++pos;
    }

    const value = s.substring(attrStart, pos);
    return {
      name,
      value,
      parsed: pos - start
    };
  }

  parseXml(s) {
    let i = 0;

    while (i < s.length) {
      const ch = s[i];
      let j = i;

      if (ch === "<") {
        ++j;
        const ch2 = s[j];
        let q;

        switch (ch2) {
          case "/":
            ++j;
            q = s.indexOf(">", j);

            if (q < 0) {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }

            this.onEndElement(s.substring(j, q));
            j = q + 1;
            break;

          case "?":
            ++j;

            const pi = this._parseProcessingInstruction(s, j);

            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
              return;
            }

            this.onPi(pi.name, pi.value);
            j += pi.parsed + 2;
            break;

          case "!":
            if (s.substring(j + 1, j + 3) === "--") {
              q = s.indexOf("-->", j + 3);

              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedComment);
                return;
              }

              this.onComment(s.substring(j + 3, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
              q = s.indexOf("]]>", j + 8);

              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedCdat);
                return;
              }

              this.onCdata(s.substring(j + 8, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
              const q2 = s.indexOf("[", j + 8);
              let complexDoctype = false;
              q = s.indexOf(">", j + 8);

              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                return;
              }

              if (q2 > 0 && q > q2) {
                q = s.indexOf("]>", j + 8);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                  return;
                }

                complexDoctype = true;
              }

              const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
              this.onDoctype(doctypeContent);
              j = q + (complexDoctype ? 2 : 1);
            } else {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }

            break;

          default:
            const content = this._parseContent(s, j);

            if (content === null) {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }

            let isClosed = false;

            if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
              isClosed = true;
            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }

            this.onBeginElement(content.name, content.attributes, isClosed);
            j += content.parsed + (isClosed ? 2 : 1);
            break;
        }
      } else {
        while (j < s.length && s[j] !== "<") {
          j++;
        }

        const text = s.substring(i, j);
        this.onText(this._resolveEntities(text));
      }

      i = j;
    }
  }

  onResolveEntity(name) {
    return `&${name};`;
  }

  onPi(name, value) {}

  onComment(text) {}

  onCdata(text) {}

  onDoctype(doctypeContent) {}

  onText(text) {}

  onBeginElement(name, attributes, isEmpty) {}

  onEndElement(name) {}

  onError(code) {}

}

exports.XMLParserBase = XMLParserBase;

class SimpleDOMNode {
  constructor(nodeName, nodeValue) {
    this.nodeName = nodeName;
    this.nodeValue = nodeValue;
    Object.defineProperty(this, "parentNode", {
      value: null,
      writable: true
    });
  }

  get firstChild() {
    return this.childNodes && this.childNodes[0];
  }

  get nextSibling() {
    const childNodes = this.parentNode.childNodes;

    if (!childNodes) {
      return undefined;
    }

    const index = childNodes.indexOf(this);

    if (index === -1) {
      return undefined;
    }

    return childNodes[index + 1];
  }

  get textContent() {
    if (!this.childNodes) {
      return this.nodeValue || "";
    }

    return this.childNodes.map(function (child) {
      return child.textContent;
    }).join("");
  }

  hasChildNodes() {
    return this.childNodes && this.childNodes.length > 0;
  }

  searchNode(paths, pos) {
    if (pos >= paths.length) {
      return this;
    }

    const component = paths[pos];
    const stack = [];
    let node = this;

    while (true) {
      if (component.name === node.nodeName) {
        if (component.pos === 0) {
          const res = node.searchNode(paths, pos + 1);

          if (res !== null) {
            return res;
          }
        } else if (stack.length === 0) {
          return null;
        } else {
          const [parent] = stack.pop();
          let siblingPos = 0;

          for (const child of parent.childNodes) {
            if (component.name === child.nodeName) {
              if (siblingPos === component.pos) {
                return child.searchNode(paths, pos + 1);
              }

              siblingPos++;
            }
          }

          return node.searchNode(paths, pos + 1);
        }
      }

      if (node.childNodes && node.childNodes.length !== 0) {
        stack.push([node, 0]);
        node = node.childNodes[0];
      } else if (stack.length === 0) {
        return null;
      } else {
        while (stack.length !== 0) {
          const [parent, currentPos] = stack.pop();
          const newPos = currentPos + 1;

          if (newPos < parent.childNodes.length) {
            stack.push([parent, newPos]);
            node = parent.childNodes[newPos];
            break;
          }
        }

        if (stack.length === 0) {
          return null;
        }
      }
    }
  }

  dump(buffer) {
    if (this.nodeName === "#text") {
      buffer.push((0, _core_utils.encodeToXmlString)(this.nodeValue));
      return;
    }

    buffer.push(`<${this.nodeName}`);

    if (this.attributes) {
      for (const attribute of this.attributes) {
        buffer.push(` ${attribute.name}="${(0, _core_utils.encodeToXmlString)(attribute.value)}"`);
      }
    }

    if (this.hasChildNodes()) {
      buffer.push(">");

      for (const child of this.childNodes) {
        child.dump(buffer);
      }

      buffer.push(`</${this.nodeName}>`);
    } else if (this.nodeValue) {
      buffer.push(`>${(0, _core_utils.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);
    } else {
      buffer.push("/>");
    }
  }

}

exports.SimpleDOMNode = SimpleDOMNode;

class SimpleXMLParser extends XMLParserBase {
  constructor({
    hasAttributes = false,
    lowerCaseName = false
  }) {
    super();
    this._currentFragment = null;
    this._stack = null;
    this._errorCode = XMLParserErrorCode.NoError;
    this._hasAttributes = hasAttributes;
    this._lowerCaseName = lowerCaseName;
  }

  parseFromString(data) {
    this._currentFragment = [];
    this._stack = [];
    this._errorCode = XMLParserErrorCode.NoError;
    this.parseXml(data);

    if (this._errorCode !== XMLParserErrorCode.NoError) {
      return undefined;
    }

    const [documentElement] = this._currentFragment;

    if (!documentElement) {
      return undefined;
    }

    return {
      documentElement
    };
  }

  onText(text) {
    if (isWhitespaceString(text)) {
      return;
    }

    const node = new SimpleDOMNode("#text", text);

    this._currentFragment.push(node);
  }

  onCdata(text) {
    const node = new SimpleDOMNode("#text", text);

    this._currentFragment.push(node);
  }

  onBeginElement(name, attributes, isEmpty) {
    if (this._lowerCaseName) {
      name = name.toLowerCase();
    }

    const node = new SimpleDOMNode(name);
    node.childNodes = [];

    if (this._hasAttributes) {
      node.attributes = attributes;
    }

    this._currentFragment.push(node);

    if (isEmpty) {
      return;
    }

    this._stack.push(this._currentFragment);

    this._currentFragment = node.childNodes;
  }

  onEndElement(name) {
    this._currentFragment = this._stack.pop() || [];
    const lastElement = this._currentFragment[this._currentFragment.length - 1];

    if (!lastElement) {
      return;
    }

    for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
      lastElement.childNodes[i].parentNode = lastElement;
    }
  }

  onError(code) {
    this._errorCode = code;
  }

}

exports.SimpleXMLParser = SimpleXMLParser;

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StructTreeRoot = exports.StructTreePage = void 0;

var _primitives = __w_pdfjs_require__(5);

var _util = __w_pdfjs_require__(2);

var _name_number_tree = __w_pdfjs_require__(58);

const MAX_DEPTH = 40;
const StructElementType = {
  PAGE_CONTENT: "PAGE_CONTENT",
  STREAM_CONTENT: "STREAM_CONTENT",
  OBJECT: "OBJECT",
  ELEMENT: "ELEMENT"
};

class StructTreeRoot {
  constructor(rootDict) {
    this.dict = rootDict;
    this.roleMap = new Map();
  }

  init() {
    this.readRoleMap();
  }

  readRoleMap() {
    const roleMapDict = this.dict.get("RoleMap");

    if (!(0, _primitives.isDict)(roleMapDict)) {
      return;
    }

    roleMapDict.forEach((key, value) => {
      if (!(0, _primitives.isName)(value)) {
        return;
      }

      this.roleMap.set(key, value.name);
    });
  }

}

exports.StructTreeRoot = StructTreeRoot;

class StructElementNode {
  constructor(tree, dict) {
    this.tree = tree;
    this.dict = dict;
    this.kids = [];
    this.parseKids();
  }

  get role() {
    const nameObj = this.dict.get("S");
    const name = (0, _primitives.isName)(nameObj) ? nameObj.name : "";
    const {
      root
    } = this.tree;

    if (root.roleMap.has(name)) {
      return root.roleMap.get(name);
    }

    return name;
  }

  parseKids() {
    let pageObjId = null;
    const objRef = this.dict.getRaw("Pg");

    if ((0, _primitives.isRef)(objRef)) {
      pageObjId = objRef.toString();
    }

    const kids = this.dict.get("K");

    if (Array.isArray(kids)) {
      for (const kid of kids) {
        const element = this.parseKid(pageObjId, kid);

        if (element) {
          this.kids.push(element);
        }
      }
    } else {
      const element = this.parseKid(pageObjId, kids);

      if (element) {
        this.kids.push(element);
      }
    }
  }

  parseKid(pageObjId, kid) {
    if (Number.isInteger(kid)) {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }

      return new StructElement({
        type: StructElementType.PAGE_CONTENT,
        mcid: kid,
        pageObjId
      });
    }

    let kidDict = null;

    if ((0, _primitives.isRef)(kid)) {
      kidDict = this.dict.xref.fetch(kid);
    } else if ((0, _primitives.isDict)(kid)) {
      kidDict = kid;
    }

    if (!kidDict) {
      return null;
    }

    const pageRef = kidDict.getRaw("Pg");

    if ((0, _primitives.isRef)(pageRef)) {
      pageObjId = pageRef.toString();
    }

    const type = (0, _primitives.isName)(kidDict.get("Type")) ? kidDict.get("Type").name : null;

    if (type === "MCR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }

      return new StructElement({
        type: StructElementType.STREAM_CONTENT,
        refObjId: (0, _primitives.isRef)(kidDict.getRaw("Stm")) ? kidDict.getRaw("Stm").toString() : null,
        pageObjId,
        mcid: kidDict.get("MCID")
      });
    }

    if (type === "OBJR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }

      return new StructElement({
        type: StructElementType.OBJECT,
        refObjId: (0, _primitives.isRef)(kidDict.getRaw("Obj")) ? kidDict.getRaw("Obj").toString() : null,
        pageObjId
      });
    }

    return new StructElement({
      type: StructElementType.ELEMENT,
      dict: kidDict
    });
  }

}

class StructElement {
  constructor({
    type,
    dict = null,
    mcid = null,
    pageObjId = null,
    refObjId = null
  }) {
    this.type = type;
    this.dict = dict;
    this.mcid = mcid;
    this.pageObjId = pageObjId;
    this.refObjId = refObjId;
    this.parentNode = null;
  }

}

class StructTreePage {
  constructor(structTreeRoot, pageDict) {
    this.root = structTreeRoot;
    this.rootDict = structTreeRoot ? structTreeRoot.dict : null;
    this.pageDict = pageDict;
    this.nodes = [];
  }

  parse() {
    if (!this.root || !this.rootDict) {
      return;
    }

    const parentTree = this.rootDict.get("ParentTree");

    if (!parentTree) {
      return;
    }

    const id = this.pageDict.get("StructParents");

    if (!Number.isInteger(id)) {
      return;
    }

    const numberTree = new _name_number_tree.NumberTree(parentTree, this.rootDict.xref);
    const parentArray = numberTree.get(id);

    if (!Array.isArray(parentArray)) {
      return;
    }

    const map = new Map();

    for (const ref of parentArray) {
      if ((0, _primitives.isRef)(ref)) {
        this.addNode(this.rootDict.xref.fetch(ref), map);
      }
    }
  }

  addNode(dict, map, level = 0) {
    if (level > MAX_DEPTH) {
      (0, _util.warn)("StructTree MAX_DEPTH reached.");
      return null;
    }

    if (map.has(dict)) {
      return map.get(dict);
    }

    const element = new StructElementNode(this, dict);
    map.set(dict, element);
    const parent = dict.get("P");

    if (!parent || (0, _primitives.isName)(parent.get("Type"), "StructTreeRoot")) {
      if (!this.addTopLevelNode(dict, element)) {
        map.delete(dict);
      }

      return element;
    }

    const parentNode = this.addNode(parent, map, level + 1);

    if (!parentNode) {
      return element;
    }

    let save = false;

    for (const kid of parentNode.kids) {
      if (kid.type === StructElementType.ELEMENT && kid.dict === dict) {
        kid.parentNode = element;
        save = true;
      }
    }

    if (!save) {
      map.delete(dict);
    }

    return element;
  }

  addTopLevelNode(dict, element) {
    const obj = this.rootDict.get("K");

    if (!obj) {
      return false;
    }

    if ((0, _primitives.isDict)(obj)) {
      if (obj.objId !== dict.objId) {
        return false;
      }

      this.nodes[0] = element;
      return true;
    }

    if (!Array.isArray(obj)) {
      return true;
    }

    let save = false;

    for (let i = 0; i < obj.length; i++) {
      const kidRef = obj[i];

      if (kidRef && kidRef.toString() === dict.objId) {
        this.nodes[i] = element;
        save = true;
      }
    }

    return save;
  }

  get serializable() {
    function nodeToSerializable(node, parent, level = 0) {
      if (level > MAX_DEPTH) {
        (0, _util.warn)("StructTree too deep to be fully serialized.");
        return;
      }

      const obj = Object.create(null);
      obj.role = node.role;
      obj.children = [];
      parent.children.push(obj);
      const alt = node.dict.get("Alt");

      if ((0, _util.isString)(alt)) {
        obj.alt = (0, _util.stringToPDFString)(alt);
      }

      for (const kid of node.kids) {
        const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null;

        if (kidElement) {
          nodeToSerializable(kidElement, obj, level + 1);
          continue;
        } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) {
          obj.children.push({
            type: "content",
            id: `page${kid.pageObjId}_mcid${kid.mcid}`
          });
        } else if (kid.type === StructElementType.OBJECT) {
          obj.children.push({
            type: "object",
            id: kid.refObjId
          });
        }
      }
    }

    const root = Object.create(null);
    root.children = [];
    root.role = "Root";

    for (const child of this.nodes) {
      if (!child) {
        continue;
      }

      nodeToSerializable(child, root);
    }

    return root;
  }

}

exports.StructTreePage = StructTreePage;

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ObjectLoader = void 0;

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

var _util = __w_pdfjs_require__(2);

function mayHaveChildren(value) {
  return value instanceof _primitives.Ref || value instanceof _primitives.Dict || Array.isArray(value) || (0, _primitives.isStream)(value);
}

function addChildren(node, nodesToVisit) {
  if (node instanceof _primitives.Dict) {
    node = node.getRawValues();
  } else if ((0, _primitives.isStream)(node)) {
    node = node.dict.getRawValues();
  } else if (!Array.isArray(node)) {
    return;
  }

  for (const rawValue of node) {
    if (mayHaveChildren(rawValue)) {
      nodesToVisit.push(rawValue);
    }
  }
}

class ObjectLoader {
  constructor(dict, keys, xref) {
    this.dict = dict;
    this.keys = keys;
    this.xref = xref;
    this.refSet = null;
  }

  async load() {
    if (this.xref.stream.isDataLoaded) {
      return undefined;
    }

    const {
      keys,
      dict
    } = this;
    this.refSet = new _primitives.RefSet();
    const nodesToVisit = [];

    for (let i = 0, ii = keys.length; i < ii; i++) {
      const rawValue = dict.getRaw(keys[i]);

      if (rawValue !== undefined) {
        nodesToVisit.push(rawValue);
      }
    }

    return this._walk(nodesToVisit);
  }

  async _walk(nodesToVisit) {
    const nodesToRevisit = [];
    const pendingRequests = [];

    while (nodesToVisit.length) {
      let currentNode = nodesToVisit.pop();

      if (currentNode instanceof _primitives.Ref) {
        if (this.refSet.has(currentNode)) {
          continue;
        }

        try {
          this.refSet.put(currentNode);
          currentNode = this.xref.fetch(currentNode);
        } catch (ex) {
          if (!(ex instanceof _core_utils.MissingDataException)) {
            (0, _util.warn)(`ObjectLoader._walk - requesting all data: "${ex}".`);
            this.refSet = null;
            const {
              manager
            } = this.xref.stream;
            return manager.requestAllChunks();
          }

          nodesToRevisit.push(currentNode);
          pendingRequests.push({
            begin: ex.begin,
            end: ex.end
          });
        }
      }

      if ((0, _primitives.isStream)(currentNode)) {
        const baseStreams = currentNode.getBaseStreams();

        if (baseStreams) {
          let foundMissingData = false;

          for (const stream of baseStreams) {
            if (stream.isDataLoaded) {
              continue;
            }

            foundMissingData = true;
            pendingRequests.push({
              begin: stream.start,
              end: stream.end
            });
          }

          if (foundMissingData) {
            nodesToRevisit.push(currentNode);
          }
        }
      }

      addChildren(currentNode, nodesToVisit);
    }

    if (pendingRequests.length) {
      await this.xref.stream.manager.requestRanges(pendingRequests);

      for (const node of nodesToRevisit) {
        if (node instanceof _primitives.Ref) {
          this.refSet.remove(node);
        }
      }

      return this._walk(nodesToRevisit);
    }

    this.refSet = null;
    return undefined;
  }

}

exports.ObjectLoader = ObjectLoader;

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.incrementalUpdate = incrementalUpdate;
exports.writeDict = writeDict;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _core_utils = __w_pdfjs_require__(9);

var _xml_parser = __w_pdfjs_require__(61);

var _crypto = __w_pdfjs_require__(65);

function writeDict(dict, buffer, transform) {
  buffer.push("<<");

  for (const key of dict.getKeys()) {
    buffer.push(` /${(0, _core_utils.escapePDFName)(key)} `);
    writeValue(dict.getRaw(key), buffer, transform);
  }

  buffer.push(">>");
}

function writeStream(stream, buffer, transform) {
  writeDict(stream.dict, buffer, transform);
  buffer.push(" stream\n");
  let string = stream.getString();

  if (transform !== null) {
    string = transform.encryptString(string);
  }

  buffer.push(string);
  buffer.push("\nendstream\n");
}

function writeArray(array, buffer, transform) {
  buffer.push("[");
  let first = true;

  for (const val of array) {
    if (!first) {
      buffer.push(" ");
    } else {
      first = false;
    }

    writeValue(val, buffer, transform);
  }

  buffer.push("]");
}

function numberToString(value) {
  if (Number.isInteger(value)) {
    return value.toString();
  }

  const roundedValue = Math.round(value * 100);

  if (roundedValue % 100 === 0) {
    return (roundedValue / 100).toString();
  }

  if (roundedValue % 10 === 0) {
    return value.toFixed(1);
  }

  return value.toFixed(2);
}

function writeValue(value, buffer, transform) {
  if ((0, _primitives.isName)(value)) {
    buffer.push(`/${(0, _core_utils.escapePDFName)(value.name)}`);
  } else if ((0, _primitives.isRef)(value)) {
    buffer.push(`${value.num} ${value.gen} R`);
  } else if (Array.isArray(value)) {
    writeArray(value, buffer, transform);
  } else if (typeof value === "string") {
    if (transform !== null) {
      value = transform.encryptString(value);
    }

    buffer.push(`(${(0, _util.escapeString)(value)})`);
  } else if (typeof value === "number") {
    buffer.push(numberToString(value));
  } else if ((0, _primitives.isDict)(value)) {
    writeDict(value, buffer, transform);
  } else if ((0, _primitives.isStream)(value)) {
    writeStream(value, buffer, transform);
  }
}

function writeInt(number, size, offset, buffer) {
  for (let i = size + offset - 1; i > offset - 1; i--) {
    buffer[i] = number & 0xff;
    number >>= 8;
  }

  return offset + size;
}

function writeString(string, offset, buffer) {
  for (let i = 0, len = string.length; i < len; i++) {
    buffer[offset + i] = string.charCodeAt(i) & 0xff;
  }
}

function computeMD5(filesize, xrefInfo) {
  const time = Math.floor(Date.now() / 1000);
  const filename = xrefInfo.filename || "";
  const md5Buffer = [time.toString(), filename, filesize.toString()];
  let md5BufferLen = md5Buffer.reduce((a, str) => a + str.length, 0);

  for (const value of Object.values(xrefInfo.info)) {
    md5Buffer.push(value);
    md5BufferLen += value.length;
  }

  const array = new Uint8Array(md5BufferLen);
  let offset = 0;

  for (const str of md5Buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }

  return (0, _util.bytesToString)((0, _crypto.calculateMD5)(array));
}

function updateXFA(datasetsRef, newRefs, xref) {
  if (datasetsRef === null || xref === null) {
    return;
  }

  const datasets = xref.fetchIfRef(datasetsRef);
  const str = datasets.getString();
  const xml = new _xml_parser.SimpleXMLParser({
    hasAttributes: true
  }).parseFromString(str);

  for (const {
    xfa
  } of newRefs) {
    if (!xfa) {
      continue;
    }

    const {
      path,
      value
    } = xfa;

    if (!path) {
      continue;
    }

    const node = xml.documentElement.searchNode((0, _core_utils.parseXFAPath)(path), 0);

    if (node) {
      node.childNodes = [new _xml_parser.SimpleDOMNode("#text", value)];
    } else {
      (0, _util.warn)(`Node not found for path: ${path}`);
    }
  }

  const buffer = [];
  xml.documentElement.dump(buffer);
  let updatedXml = buffer.join("");
  const encrypt = xref.encrypt;

  if (encrypt) {
    const transform = encrypt.createCipherTransform(datasetsRef.num, datasetsRef.gen);
    updatedXml = transform.encryptString(updatedXml);
  }

  const data = `${datasetsRef.num} ${datasetsRef.gen} obj\n` + `<< /Type /EmbeddedFile /Length ${updatedXml.length}>>\nstream\n` + updatedXml + "\nendstream\nendobj\n";
  newRefs.push({
    ref: datasetsRef,
    data
  });
}

function incrementalUpdate({
  originalData,
  xrefInfo,
  newRefs,
  xref = null,
  datasetsRef = null
}) {
  updateXFA(datasetsRef, newRefs, xref);
  const newXref = new _primitives.Dict(null);
  const refForXrefTable = xrefInfo.newRef;
  let buffer, baseOffset;
  const lastByte = originalData[originalData.length - 1];

  if (lastByte === 0x0a || lastByte === 0x0d) {
    buffer = [];
    baseOffset = originalData.length;
  } else {
    buffer = ["\n"];
    baseOffset = originalData.length + 1;
  }

  newXref.set("Size", refForXrefTable.num + 1);
  newXref.set("Prev", xrefInfo.startXRef);
  newXref.set("Type", _primitives.Name.get("XRef"));

  if (xrefInfo.rootRef !== null) {
    newXref.set("Root", xrefInfo.rootRef);
  }

  if (xrefInfo.infoRef !== null) {
    newXref.set("Info", xrefInfo.infoRef);
  }

  if (xrefInfo.encryptRef !== null) {
    newXref.set("Encrypt", xrefInfo.encryptRef);
  }

  newRefs.push({
    ref: refForXrefTable,
    data: ""
  });
  newRefs = newRefs.sort((a, b) => {
    return a.ref.num - b.ref.num;
  });
  const xrefTableData = [[0, 1, 0xffff]];
  const indexes = [0, 1];
  let maxOffset = 0;

  for (const {
    ref,
    data
  } of newRefs) {
    maxOffset = Math.max(maxOffset, baseOffset);
    xrefTableData.push([1, baseOffset, Math.min(ref.gen, 0xffff)]);
    baseOffset += data.length;
    indexes.push(ref.num);
    indexes.push(1);
    buffer.push(data);
  }

  newXref.set("Index", indexes);

  if (Array.isArray(xrefInfo.fileIds) && xrefInfo.fileIds.length > 0) {
    const md5 = computeMD5(baseOffset, xrefInfo);
    newXref.set("ID", [xrefInfo.fileIds[0], md5]);
  }

  const offsetSize = Math.ceil(Math.log2(maxOffset) / 8);
  const sizes = [1, offsetSize, 2];
  const structSize = sizes[0] + sizes[1] + sizes[2];
  const tableLength = structSize * xrefTableData.length;
  newXref.set("W", sizes);
  newXref.set("Length", tableLength);
  buffer.push(`${refForXrefTable.num} ${refForXrefTable.gen} obj\n`);
  writeDict(newXref, buffer, null);
  buffer.push(" stream\n");
  const bufferLen = buffer.reduce((a, str) => a + str.length, 0);
  const footer = `\nendstream\nendobj\nstartxref\n${baseOffset}\n%%EOF\n`;
  const array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length);
  array.set(originalData);
  let offset = originalData.length;

  for (const str of buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }

  for (const [type, objOffset, gen] of xrefTableData) {
    offset = writeInt(type, sizes[0], offset, array);
    offset = writeInt(objOffset, sizes[1], offset, array);
    offset = writeInt(gen, sizes[2], offset, array);
  }

  writeString(footer, offset, array);
  return array;
}

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.calculateSHA384 = calculateSHA384;
exports.PDF20 = exports.PDF17 = exports.CipherTransformFactory = exports.calculateSHA512 = exports.calculateSHA256 = exports.calculateMD5 = exports.ARCFourCipher = exports.AES256Cipher = exports.AES128Cipher = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _decrypt_stream = __w_pdfjs_require__(66);

class ARCFourCipher {
  constructor(key) {
    this.a = 0;
    this.b = 0;
    const s = new Uint8Array(256);
    const keyLength = key.length;

    for (let i = 0; i < 256; ++i) {
      s[i] = i;
    }

    for (let i = 0, j = 0; i < 256; ++i) {
      const tmp = s[i];
      j = j + tmp + key[i % keyLength] & 0xff;
      s[i] = s[j];
      s[j] = tmp;
    }

    this.s = s;
  }

  encryptBlock(data) {
    let a = this.a,
        b = this.b;
    const s = this.s;
    const n = data.length;
    const output = new Uint8Array(n);

    for (let i = 0; i < n; ++i) {
      a = a + 1 & 0xff;
      const tmp = s[a];
      b = b + tmp & 0xff;
      const tmp2 = s[b];
      s[a] = tmp2;
      s[b] = tmp;
      output[i] = data[i] ^ s[tmp + tmp2 & 0xff];
    }

    this.a = a;
    this.b = b;
    return output;
  }

  decryptBlock(data) {
    return this.encryptBlock(data);
  }

  encrypt(data) {
    return this.encryptBlock(data);
  }

}

exports.ARCFourCipher = ARCFourCipher;

const calculateMD5 = function calculateMD5Closure() {
  const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);

  function hash(data, offset, length) {
    let h0 = 1732584193,
        h1 = -271733879,
        h2 = -1732584194,
        h3 = 271733878;
    const paddedLength = length + 72 & ~63;
    const padded = new Uint8Array(paddedLength);
    let i, j;

    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }

    padded[i++] = 0x80;
    const n = paddedLength - 8;

    while (i < n) {
      padded[i++] = 0;
    }

    padded[i++] = length << 3 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    const w = new Int32Array(16);

    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j, i += 4) {
        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
      }

      let a = h0,
          b = h1,
          c = h2,
          d = h3,
          f,
          g;

      for (j = 0; j < 64; ++j) {
        if (j < 16) {
          f = b & c | ~b & d;
          g = j;
        } else if (j < 32) {
          f = d & b | ~d & c;
          g = 5 * j + 1 & 15;
        } else if (j < 48) {
          f = b ^ c ^ d;
          g = 3 * j + 5 & 15;
        } else {
          f = c ^ (b | ~d);
          g = 7 * j & 15;
        }

        const tmp = d,
              rotateArg = a + f + k[j] + w[g] | 0,
              rotate = r[j];
        d = c;
        c = b;
        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
        a = tmp;
      }

      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
    }

    return new Uint8Array([h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >>> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >>> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >>> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >>> 24 & 0xFF]);
  }

  return hash;
}();

exports.calculateMD5 = calculateMD5;

class Word64 {
  constructor(highInteger, lowInteger) {
    this.high = highInteger | 0;
    this.low = lowInteger | 0;
  }

  and(word) {
    this.high &= word.high;
    this.low &= word.low;
  }

  xor(word) {
    this.high ^= word.high;
    this.low ^= word.low;
  }

  or(word) {
    this.high |= word.high;
    this.low |= word.low;
  }

  shiftRight(places) {
    if (places >= 32) {
      this.low = this.high >>> places - 32 | 0;
      this.high = 0;
    } else {
      this.low = this.low >>> places | this.high << 32 - places;
      this.high = this.high >>> places | 0;
    }
  }

  shiftLeft(places) {
    if (places >= 32) {
      this.high = this.low << places - 32;
      this.low = 0;
    } else {
      this.high = this.high << places | this.low >>> 32 - places;
      this.low = this.low << places;
    }
  }

  rotateRight(places) {
    let low, high;

    if (places & 32) {
      high = this.low;
      low = this.high;
    } else {
      low = this.low;
      high = this.high;
    }

    places &= 31;
    this.low = low >>> places | high << 32 - places;
    this.high = high >>> places | low << 32 - places;
  }

  not() {
    this.high = ~this.high;
    this.low = ~this.low;
  }

  add(word) {
    const lowAdd = (this.low >>> 0) + (word.low >>> 0);
    let highAdd = (this.high >>> 0) + (word.high >>> 0);

    if (lowAdd > 0xffffffff) {
      highAdd += 1;
    }

    this.low = lowAdd | 0;
    this.high = highAdd | 0;
  }

  copyTo(bytes, offset) {
    bytes[offset] = this.high >>> 24 & 0xff;
    bytes[offset + 1] = this.high >> 16 & 0xff;
    bytes[offset + 2] = this.high >> 8 & 0xff;
    bytes[offset + 3] = this.high & 0xff;
    bytes[offset + 4] = this.low >>> 24 & 0xff;
    bytes[offset + 5] = this.low >> 16 & 0xff;
    bytes[offset + 6] = this.low >> 8 & 0xff;
    bytes[offset + 7] = this.low & 0xff;
  }

  assign(word) {
    this.high = word.high;
    this.low = word.low;
  }

}

const calculateSHA256 = function calculateSHA256Closure() {
  function rotr(x, n) {
    return x >>> n | x << 32 - n;
  }

  function ch(x, y, z) {
    return x & y ^ ~x & z;
  }

  function maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }

  function sigma(x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  }

  function sigmaPrime(x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  }

  function littleSigma(x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
  }

  function littleSigmaPrime(x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
  }

  const k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

  function hash(data, offset, length) {
    let h0 = 0x6a09e667,
        h1 = 0xbb67ae85,
        h2 = 0x3c6ef372,
        h3 = 0xa54ff53a,
        h4 = 0x510e527f,
        h5 = 0x9b05688c,
        h6 = 0x1f83d9ab,
        h7 = 0x5be0cd19;
    const paddedLength = Math.ceil((length + 9) / 64) * 64;
    const padded = new Uint8Array(paddedLength);
    let i, j;

    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }

    padded[i++] = 0x80;
    const n = paddedLength - 8;

    while (i < n) {
      padded[i++] = 0;
    }

    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    const w = new Uint32Array(64);

    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        i += 4;
      }

      for (j = 16; j < 64; ++j) {
        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
      }

      let a = h0,
          b = h1,
          c = h2,
          d = h3,
          e = h4,
          f = h5,
          g = h6,
          h = h7,
          t1,
          t2;

      for (j = 0; j < 64; ++j) {
        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
        t2 = sigma(a) + maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }

      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
      h4 = h4 + e | 0;
      h5 = h5 + f | 0;
      h6 = h6 + g | 0;
      h7 = h7 + h | 0;
    }

    return new Uint8Array([h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF, h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF]);
  }

  return hash;
}();

exports.calculateSHA256 = calculateSHA256;

const calculateSHA512 = function calculateSHA512Closure() {
  function ch(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.not();
    tmp.and(z);
    result.xor(tmp);
  }

  function maj(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.and(z);
    result.xor(tmp);
    tmp.assign(y);
    tmp.and(z);
    result.xor(tmp);
  }

  function sigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(28);
    tmp.assign(x);
    tmp.rotateRight(34);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(39);
    result.xor(tmp);
  }

  function sigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(14);
    tmp.assign(x);
    tmp.rotateRight(18);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(41);
    result.xor(tmp);
  }

  function littleSigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(1);
    tmp.assign(x);
    tmp.rotateRight(8);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(7);
    result.xor(tmp);
  }

  function littleSigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(19);
    tmp.assign(x);
    tmp.rotateRight(61);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(6);
    result.xor(tmp);
  }

  const k = [new Word64(0x428a2f98, 0xd728ae22), new Word64(0x71374491, 0x23ef65cd), new Word64(0xb5c0fbcf, 0xec4d3b2f), new Word64(0xe9b5dba5, 0x8189dbbc), new Word64(0x3956c25b, 0xf348b538), new Word64(0x59f111f1, 0xb605d019), new Word64(0x923f82a4, 0xaf194f9b), new Word64(0xab1c5ed5, 0xda6d8118), new Word64(0xd807aa98, 0xa3030242), new Word64(0x12835b01, 0x45706fbe), new Word64(0x243185be, 0x4ee4b28c), new Word64(0x550c7dc3, 0xd5ffb4e2), new Word64(0x72be5d74, 0xf27b896f), new Word64(0x80deb1fe, 0x3b1696b1), new Word64(0x9bdc06a7, 0x25c71235), new Word64(0xc19bf174, 0xcf692694), new Word64(0xe49b69c1, 0x9ef14ad2), new Word64(0xefbe4786, 0x384f25e3), new Word64(0x0fc19dc6, 0x8b8cd5b5), new Word64(0x240ca1cc, 0x77ac9c65), new Word64(0x2de92c6f, 0x592b0275), new Word64(0x4a7484aa, 0x6ea6e483), new Word64(0x5cb0a9dc, 0xbd41fbd4), new Word64(0x76f988da, 0x831153b5), new Word64(0x983e5152, 0xee66dfab), new Word64(0xa831c66d, 0x2db43210), new Word64(0xb00327c8, 0x98fb213f), new Word64(0xbf597fc7, 0xbeef0ee4), new Word64(0xc6e00bf3, 0x3da88fc2), new Word64(0xd5a79147, 0x930aa725), new Word64(0x06ca6351, 0xe003826f), new Word64(0x14292967, 0x0a0e6e70), new Word64(0x27b70a85, 0x46d22ffc), new Word64(0x2e1b2138, 0x5c26c926), new Word64(0x4d2c6dfc, 0x5ac42aed), new Word64(0x53380d13, 0x9d95b3df), new Word64(0x650a7354, 0x8baf63de), new Word64(0x766a0abb, 0x3c77b2a8), new Word64(0x81c2c92e, 0x47edaee6), new Word64(0x92722c85, 0x1482353b), new Word64(0xa2bfe8a1, 0x4cf10364), new Word64(0xa81a664b, 0xbc423001), new Word64(0xc24b8b70, 0xd0f89791), new Word64(0xc76c51a3, 0x0654be30), new Word64(0xd192e819, 0xd6ef5218), new Word64(0xd6990624, 0x5565a910), new Word64(0xf40e3585, 0x5771202a), new Word64(0x106aa070, 0x32bbd1b8), new Word64(0x19a4c116, 0xb8d2d0c8), new Word64(0x1e376c08, 0x5141ab53), new Word64(0x2748774c, 0xdf8eeb99), new Word64(0x34b0bcb5, 0xe19b48a8), new Word64(0x391c0cb3, 0xc5c95a63), new Word64(0x4ed8aa4a, 0xe3418acb), new Word64(0x5b9cca4f, 0x7763e373), new Word64(0x682e6ff3, 0xd6b2b8a3), new Word64(0x748f82ee, 0x5defb2fc), new Word64(0x78a5636f, 0x43172f60), new Word64(0x84c87814, 0xa1f0ab72), new Word64(0x8cc70208, 0x1a6439ec), new Word64(0x90befffa, 0x23631e28), new Word64(0xa4506ceb, 0xde82bde9), new Word64(0xbef9a3f7, 0xb2c67915), new Word64(0xc67178f2, 0xe372532b), new Word64(0xca273ece, 0xea26619c), new Word64(0xd186b8c7, 0x21c0c207), new Word64(0xeada7dd6, 0xcde0eb1e), new Word64(0xf57d4f7f, 0xee6ed178), new Word64(0x06f067aa, 0x72176fba), new Word64(0x0a637dc5, 0xa2c898a6), new Word64(0x113f9804, 0xbef90dae), new Word64(0x1b710b35, 0x131c471b), new Word64(0x28db77f5, 0x23047d84), new Word64(0x32caab7b, 0x40c72493), new Word64(0x3c9ebe0a, 0x15c9bebc), new Word64(0x431d67c4, 0x9c100d4c), new Word64(0x4cc5d4be, 0xcb3e42b6), new Word64(0x597f299c, 0xfc657e2a), new Word64(0x5fcb6fab, 0x3ad6faec), new Word64(0x6c44198c, 0x4a475817)];

  function hash(data, offset, length, mode384 = false) {
    let h0, h1, h2, h3, h4, h5, h6, h7;

    if (!mode384) {
      h0 = new Word64(0x6a09e667, 0xf3bcc908);
      h1 = new Word64(0xbb67ae85, 0x84caa73b);
      h2 = new Word64(0x3c6ef372, 0xfe94f82b);
      h3 = new Word64(0xa54ff53a, 0x5f1d36f1);
      h4 = new Word64(0x510e527f, 0xade682d1);
      h5 = new Word64(0x9b05688c, 0x2b3e6c1f);
      h6 = new Word64(0x1f83d9ab, 0xfb41bd6b);
      h7 = new Word64(0x5be0cd19, 0x137e2179);
    } else {
      h0 = new Word64(0xcbbb9d5d, 0xc1059ed8);
      h1 = new Word64(0x629a292a, 0x367cd507);
      h2 = new Word64(0x9159015a, 0x3070dd17);
      h3 = new Word64(0x152fecd8, 0xf70e5939);
      h4 = new Word64(0x67332667, 0xffc00b31);
      h5 = new Word64(0x8eb44a87, 0x68581511);
      h6 = new Word64(0xdb0c2e0d, 0x64f98fa7);
      h7 = new Word64(0x47b5481d, 0xbefa4fa4);
    }

    const paddedLength = Math.ceil((length + 17) / 128) * 128;
    const padded = new Uint8Array(paddedLength);
    let i, j;

    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }

    padded[i++] = 0x80;
    const n = paddedLength - 16;

    while (i < n) {
      padded[i++] = 0;
    }

    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 0xff;
    padded[i++] = length >> 21 & 0xff;
    padded[i++] = length >> 13 & 0xff;
    padded[i++] = length >> 5 & 0xff;
    padded[i++] = length << 3 & 0xff;
    const w = new Array(80);

    for (i = 0; i < 80; i++) {
      w[i] = new Word64(0, 0);
    }

    let a = new Word64(0, 0),
        b = new Word64(0, 0),
        c = new Word64(0, 0);
    let d = new Word64(0, 0),
        e = new Word64(0, 0),
        f = new Word64(0, 0);
    let g = new Word64(0, 0),
        h = new Word64(0, 0);
    const t1 = new Word64(0, 0),
          t2 = new Word64(0, 0);
    const tmp1 = new Word64(0, 0),
          tmp2 = new Word64(0, 0);
    let tmp3;

    for (i = 0; i < paddedLength;) {
      for (j = 0; j < 16; ++j) {
        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
        i += 8;
      }

      for (j = 16; j < 80; ++j) {
        tmp3 = w[j];
        littleSigmaPrime(tmp3, w[j - 2], tmp2);
        tmp3.add(w[j - 7]);
        littleSigma(tmp1, w[j - 15], tmp2);
        tmp3.add(tmp1);
        tmp3.add(w[j - 16]);
      }

      a.assign(h0);
      b.assign(h1);
      c.assign(h2);
      d.assign(h3);
      e.assign(h4);
      f.assign(h5);
      g.assign(h6);
      h.assign(h7);

      for (j = 0; j < 80; ++j) {
        t1.assign(h);
        sigmaPrime(tmp1, e, tmp2);
        t1.add(tmp1);
        ch(tmp1, e, f, g, tmp2);
        t1.add(tmp1);
        t1.add(k[j]);
        t1.add(w[j]);
        sigma(t2, a, tmp2);
        maj(tmp1, a, b, c, tmp2);
        t2.add(tmp1);
        tmp3 = h;
        h = g;
        g = f;
        f = e;
        d.add(t1);
        e = d;
        d = c;
        c = b;
        b = a;
        tmp3.assign(t1);
        tmp3.add(t2);
        a = tmp3;
      }

      h0.add(a);
      h1.add(b);
      h2.add(c);
      h3.add(d);
      h4.add(e);
      h5.add(f);
      h6.add(g);
      h7.add(h);
    }

    let result;

    if (!mode384) {
      result = new Uint8Array(64);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
      h6.copyTo(result, 48);
      h7.copyTo(result, 56);
    } else {
      result = new Uint8Array(48);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
    }

    return result;
  }

  return hash;
}();

exports.calculateSHA512 = calculateSHA512;

function calculateSHA384(data, offset, length) {
  return calculateSHA512(data, offset, length, true);
}

class NullCipher {
  decryptBlock(data) {
    return data;
  }

  encrypt(data) {
    return data;
  }

}

class AESBaseCipher {
  constructor() {
    if (this.constructor === AESBaseCipher) {
      (0, _util.unreachable)("Cannot initialize AESBaseCipher.");
    }

    this._s = new Uint8Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]);
    this._inv_s = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
    this._mix = new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3]);
    this._mixCol = new Uint8Array(256);

    for (let i = 0; i < 256; i++) {
      if (i < 128) {
        this._mixCol[i] = i << 1;
      } else {
        this._mixCol[i] = i << 1 ^ 0x1b;
      }
    }

    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }

  _expandKey(cipherKey) {
    (0, _util.unreachable)("Cannot call `_expandKey` on the base class");
  }

  _decrypt(input, key) {
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);

    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }

    for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
      t = state[13];
      state[13] = state[9];
      state[9] = state[5];
      state[5] = state[1];
      state[1] = t;
      t = state[14];
      u = state[10];
      state[14] = state[6];
      state[10] = state[2];
      state[6] = t;
      state[2] = u;
      t = state[15];
      u = state[11];
      v = state[7];
      state[15] = state[3];
      state[11] = t;
      state[7] = u;
      state[3] = v;

      for (let j = 0; j < 16; ++j) {
        state[j] = this._inv_s[state[j]];
      }

      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }

      for (let j = 0; j < 16; j += 4) {
        const s0 = this._mix[state[j]];
        const s1 = this._mix[state[j + 1]];
        const s2 = this._mix[state[j + 2]];
        const s3 = this._mix[state[j + 3]];
        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
        state[j] = t >>> 24 & 0xff;
        state[j + 1] = t >> 16 & 0xff;
        state[j + 2] = t >> 8 & 0xff;
        state[j + 3] = t & 0xff;
      }
    }

    t = state[13];
    state[13] = state[9];
    state[9] = state[5];
    state[5] = state[1];
    state[1] = t;
    t = state[14];
    u = state[10];
    state[14] = state[6];
    state[10] = state[2];
    state[6] = t;
    state[2] = u;
    t = state[15];
    u = state[11];
    v = state[7];
    state[15] = state[3];
    state[11] = t;
    state[7] = u;
    state[3] = v;

    for (let j = 0; j < 16; ++j) {
      state[j] = this._inv_s[state[j]];
      state[j] ^= key[j];
    }

    return state;
  }

  _encrypt(input, key) {
    const s = this._s;
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);

    for (let j = 0; j < 16; ++j) {
      state[j] ^= key[j];
    }

    for (let i = 1; i < this._cyclesOfRepetition; i++) {
      for (let j = 0; j < 16; ++j) {
        state[j] = s[state[j]];
      }

      v = state[1];
      state[1] = state[5];
      state[5] = state[9];
      state[9] = state[13];
      state[13] = v;
      v = state[2];
      u = state[6];
      state[2] = state[10];
      state[6] = state[14];
      state[10] = v;
      state[14] = u;
      v = state[3];
      u = state[7];
      t = state[11];
      state[3] = state[15];
      state[7] = v;
      state[11] = u;
      state[15] = t;

      for (let j = 0; j < 16; j += 4) {
        const s0 = state[j + 0];
        const s1 = state[j + 1];
        const s2 = state[j + 2];
        const s3 = state[j + 3];
        t = s0 ^ s1 ^ s2 ^ s3;
        state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
        state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
        state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
        state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
      }

      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
    }

    for (let j = 0; j < 16; ++j) {
      state[j] = s[state[j]];
    }

    v = state[1];
    state[1] = state[5];
    state[5] = state[9];
    state[9] = state[13];
    state[13] = v;
    v = state[2];
    u = state[6];
    state[2] = state[10];
    state[6] = state[14];
    state[10] = v;
    state[14] = u;
    v = state[3];
    u = state[7];
    t = state[11];
    state[3] = state[15];
    state[7] = v;
    state[11] = u;
    state[15] = t;

    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }

    return state;
  }

  _decryptBlock2(data, finalize) {
    const sourceLength = data.length;
    let buffer = this.buffer,
        bufferLength = this.bufferPosition;
    const result = [];
    let iv = this.iv;

    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;

      if (bufferLength < 16) {
        continue;
      }

      const plain = this._decrypt(buffer, this._key);

      for (let j = 0; j < 16; ++j) {
        plain[j] ^= iv[j];
      }

      iv = buffer;
      result.push(plain);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }

    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;

    if (result.length === 0) {
      return new Uint8Array(0);
    }

    let outputLength = 16 * result.length;

    if (finalize) {
      const lastBlock = result[result.length - 1];
      let psLen = lastBlock[15];

      if (psLen <= 16) {
        for (let i = 15, ii = 16 - psLen; i >= ii; --i) {
          if (lastBlock[i] !== psLen) {
            psLen = 0;
            break;
          }
        }

        outputLength -= psLen;
        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
      }
    }

    const output = new Uint8Array(outputLength);

    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }

    return output;
  }

  decryptBlock(data, finalize, iv = null) {
    const sourceLength = data.length;
    const buffer = this.buffer;
    let bufferLength = this.bufferPosition;

    if (iv) {
      this.iv = iv;
    } else {
      for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
        buffer[bufferLength] = data[i];
      }

      if (bufferLength < 16) {
        this.bufferLength = bufferLength;
        return new Uint8Array(0);
      }

      this.iv = buffer;
      data = data.subarray(16);
    }

    this.buffer = new Uint8Array(16);
    this.bufferLength = 0;
    this.decryptBlock = this._decryptBlock2;
    return this.decryptBlock(data, finalize);
  }

  encrypt(data, iv) {
    const sourceLength = data.length;
    let buffer = this.buffer,
        bufferLength = this.bufferPosition;
    const result = [];

    if (!iv) {
      iv = new Uint8Array(16);
    }

    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;

      if (bufferLength < 16) {
        continue;
      }

      for (let j = 0; j < 16; ++j) {
        buffer[j] ^= iv[j];
      }

      const cipher = this._encrypt(buffer, this._key);

      iv = cipher;
      result.push(cipher);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }

    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;

    if (result.length === 0) {
      return new Uint8Array(0);
    }

    const outputLength = 16 * result.length;
    const output = new Uint8Array(outputLength);

    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }

    return output;
  }

}

class AES128Cipher extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 10;
    this._keySize = 160;
    this._rcon = new Uint8Array([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]);
    this._key = this._expandKey(key);
  }

  _expandKey(cipherKey) {
    const b = 176;
    const s = this._s;
    const rcon = this._rcon;
    const result = new Uint8Array(b);
    result.set(cipherKey);

    for (let j = 16, i = 1; j < b; ++i) {
      let t1 = result[j - 3];
      let t2 = result[j - 2];
      let t3 = result[j - 1];
      let t4 = result[j - 4];
      t1 = s[t1];
      t2 = s[t2];
      t3 = s[t3];
      t4 = s[t4];
      t1 = t1 ^ rcon[i];

      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 16];
        j++;
        result[j] = t2 ^= result[j - 16];
        j++;
        result[j] = t3 ^= result[j - 16];
        j++;
        result[j] = t4 ^= result[j - 16];
        j++;
      }
    }

    return result;
  }

}

exports.AES128Cipher = AES128Cipher;

class AES256Cipher extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 14;
    this._keySize = 224;
    this._key = this._expandKey(key);
  }

  _expandKey(cipherKey) {
    const b = 240;
    const s = this._s;
    const result = new Uint8Array(b);
    result.set(cipherKey);
    let r = 1;
    let t1, t2, t3, t4;

    for (let j = 32, i = 1; j < b; ++i) {
      if (j % 32 === 16) {
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
      } else if (j % 32 === 0) {
        t1 = result[j - 3];
        t2 = result[j - 2];
        t3 = result[j - 1];
        t4 = result[j - 4];
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
        t1 = t1 ^ r;

        if ((r <<= 1) >= 256) {
          r = (r ^ 0x1b) & 0xff;
        }
      }

      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 32];
        j++;
        result[j] = t2 ^= result[j - 32];
        j++;
        result[j] = t3 ^= result[j - 32];
        j++;
        result[j] = t4 ^= result[j - 32];
        j++;
      }
    }

    return result;
  }

}

exports.AES256Cipher = AES256Cipher;

class PDF17 {
  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerValidationSalt, password.length);
    hashData.set(userBytes, password.length + ownerValidationSalt.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return (0, _util.isArrayEqual)(result, ownerPassword);
  }

  checkUserPassword(password, userValidationSalt, userPassword) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userValidationSalt, password.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return (0, _util.isArrayEqual)(result, userPassword);
  }

  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerKeySalt, password.length);
    hashData.set(userBytes, password.length + ownerKeySalt.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
  }

  getUserKey(password, userKeySalt, userEncryption) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userKeySalt, password.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
  }

}

exports.PDF17 = PDF17;

const PDF20 = function PDF20Closure() {
  function calculatePDF20Hash(password, input, userBytes) {
    let k = calculateSHA256(input, 0, input.length).subarray(0, 32);
    let e = [0];
    let i = 0;

    while (i < 64 || e[e.length - 1] > i - 32) {
      const combinedLength = password.length + k.length + userBytes.length,
            combinedArray = new Uint8Array(combinedLength);
      let writeOffset = 0;
      combinedArray.set(password, writeOffset);
      writeOffset += password.length;
      combinedArray.set(k, writeOffset);
      writeOffset += k.length;
      combinedArray.set(userBytes, writeOffset);
      const k1 = new Uint8Array(combinedLength * 64);

      for (let j = 0, pos = 0; j < 64; j++, pos += combinedLength) {
        k1.set(combinedArray, pos);
      }

      const cipher = new AES128Cipher(k.subarray(0, 16));
      e = cipher.encrypt(k1, k.subarray(16, 32));
      let remainder = 0;

      for (let z = 0; z < 16; z++) {
        remainder *= 256 % 3;
        remainder %= 3;
        remainder += (e[z] >>> 0) % 3;
        remainder %= 3;
      }

      if (remainder === 0) {
        k = calculateSHA256(e, 0, e.length);
      } else if (remainder === 1) {
        k = calculateSHA384(e, 0, e.length);
      } else if (remainder === 2) {
        k = calculateSHA512(e, 0, e.length);
      }

      i++;
    }

    return k.subarray(0, 32);
  }

  class PDF20 {
    hash(password, concatBytes, userBytes) {
      return calculatePDF20Hash(password, concatBytes, userBytes);
    }

    checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
      const hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerValidationSalt, password.length);
      hashData.set(userBytes, password.length + ownerValidationSalt.length);
      const result = calculatePDF20Hash(password, hashData, userBytes);
      return (0, _util.isArrayEqual)(result, ownerPassword);
    }

    checkUserPassword(password, userValidationSalt, userPassword) {
      const hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userValidationSalt, password.length);
      const result = calculatePDF20Hash(password, hashData, []);
      return (0, _util.isArrayEqual)(result, userPassword);
    }

    getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
      const hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerKeySalt, password.length);
      hashData.set(userBytes, password.length + ownerKeySalt.length);
      const key = calculatePDF20Hash(password, hashData, userBytes);
      const cipher = new AES256Cipher(key);
      return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
    }

    getUserKey(password, userKeySalt, userEncryption) {
      const hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userKeySalt, password.length);
      const key = calculatePDF20Hash(password, hashData, []);
      const cipher = new AES256Cipher(key);
      return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
    }

  }

  return PDF20;
}();

exports.PDF20 = PDF20;

class CipherTransform {
  constructor(stringCipherConstructor, streamCipherConstructor) {
    this.StringCipherConstructor = stringCipherConstructor;
    this.StreamCipherConstructor = streamCipherConstructor;
  }

  createStream(stream, length) {
    const cipher = new this.StreamCipherConstructor();
    return new _decrypt_stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
      return cipher.decryptBlock(data, finalize);
    });
  }

  decryptString(s) {
    const cipher = new this.StringCipherConstructor();
    let data = (0, _util.stringToBytes)(s);
    data = cipher.decryptBlock(data, true);
    return (0, _util.bytesToString)(data);
  }

  encryptString(s) {
    const cipher = new this.StringCipherConstructor();

    if (cipher instanceof AESBaseCipher) {
      const strLen = s.length;
      const pad = 16 - strLen % 16;

      if (pad !== 16) {
        s = s.padEnd(16 * Math.ceil(strLen / 16), String.fromCharCode(pad));
      }

      const iv = new Uint8Array(16);

      if (typeof crypto !== "undefined") {
        crypto.getRandomValues(iv);
      } else {
        for (let i = 0; i < 16; i++) {
          iv[i] = Math.floor(256 * Math.random());
        }
      }

      let data = (0, _util.stringToBytes)(s);
      data = cipher.encrypt(data, iv);
      const buf = new Uint8Array(16 + data.length);
      buf.set(iv);
      buf.set(data, 16);
      return (0, _util.bytesToString)(buf);
    }

    let data = (0, _util.stringToBytes)(s);
    data = cipher.encrypt(data);
    return (0, _util.bytesToString)(data);
  }

}

const CipherTransformFactory = function CipherTransformFactoryClosure() {
  const defaultPasswordBytes = new Uint8Array([0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a]);

  function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
    if (password) {
      const passwordLength = Math.min(127, password.length);
      password = password.subarray(0, passwordLength);
    } else {
      password = [];
    }

    let pdfAlgorithm;

    if (revision === 6) {
      pdfAlgorithm = new PDF20();
    } else {
      pdfAlgorithm = new PDF17();
    }

    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
    }

    return null;
  }

  function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
    const hashDataSize = 40 + ownerPassword.length + fileId.length;
    const hashData = new Uint8Array(hashDataSize);
    let i = 0,
        j,
        n;

    if (password) {
      n = Math.min(32, password.length);

      for (; i < n; ++i) {
        hashData[i] = password[i];
      }
    }

    j = 0;

    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }

    for (j = 0, n = ownerPassword.length; j < n; ++j) {
      hashData[i++] = ownerPassword[j];
    }

    hashData[i++] = flags & 0xff;
    hashData[i++] = flags >> 8 & 0xff;
    hashData[i++] = flags >> 16 & 0xff;
    hashData[i++] = flags >>> 24 & 0xff;

    for (j = 0, n = fileId.length; j < n; ++j) {
      hashData[i++] = fileId[j];
    }

    if (revision >= 4 && !encryptMetadata) {
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
      hashData[i++] = 0xff;
    }

    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;

    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, keyLengthInBytes);
      }
    }

    const encryptionKey = hash.subarray(0, keyLengthInBytes);
    let cipher, checkData;

    if (revision >= 3) {
      for (i = 0; i < 32; ++i) {
        hashData[i] = defaultPasswordBytes[i];
      }

      for (j = 0, n = fileId.length; j < n; ++j) {
        hashData[i++] = fileId[j];
      }

      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
      n = encryptionKey.length;
      const derivedKey = new Uint8Array(n);

      for (j = 1; j <= 19; ++j) {
        for (let k = 0; k < n; ++k) {
          derivedKey[k] = encryptionKey[k] ^ j;
        }

        cipher = new ARCFourCipher(derivedKey);
        checkData = cipher.encryptBlock(checkData);
      }

      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    } else {
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(defaultPasswordBytes);

      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    }

    return encryptionKey;
  }

  function decodeUserPassword(password, ownerPassword, revision, keyLength) {
    const hashData = new Uint8Array(32);
    let i = 0;
    const n = Math.min(32, password.length);

    for (; i < n; ++i) {
      hashData[i] = password[i];
    }

    let j = 0;

    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }

    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;

    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, hash.length);
      }
    }

    let cipher, userPassword;

    if (revision >= 3) {
      userPassword = ownerPassword;
      const derivedKey = new Uint8Array(keyLengthInBytes);

      for (j = 19; j >= 0; j--) {
        for (let k = 0; k < keyLengthInBytes; ++k) {
          derivedKey[k] = hash[k] ^ j;
        }

        cipher = new ARCFourCipher(derivedKey);
        userPassword = cipher.encryptBlock(userPassword);
      }
    } else {
      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
      userPassword = cipher.encryptBlock(ownerPassword);
    }

    return userPassword;
  }

  const identityName = _primitives.Name.get("Identity");

  function buildObjectKey(num, gen, encryptionKey, isAes = false) {
    const key = new Uint8Array(encryptionKey.length + 9);
    const n = encryptionKey.length;
    let i;

    for (i = 0; i < n; ++i) {
      key[i] = encryptionKey[i];
    }

    key[i++] = num & 0xff;
    key[i++] = num >> 8 & 0xff;
    key[i++] = num >> 16 & 0xff;
    key[i++] = gen & 0xff;
    key[i++] = gen >> 8 & 0xff;

    if (isAes) {
      key[i++] = 0x73;
      key[i++] = 0x41;
      key[i++] = 0x6c;
      key[i++] = 0x54;
    }

    const hash = calculateMD5(key, 0, i);
    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
  }

  function buildCipherConstructor(cf, name, num, gen, key) {
    if (!(0, _primitives.isName)(name)) {
      throw new _util.FormatError("Invalid crypt filter name.");
    }

    const cryptFilter = cf.get(name.name);
    let cfm;

    if (cryptFilter !== null && cryptFilter !== undefined) {
      cfm = cryptFilter.get("CFM");
    }

    if (!cfm || cfm.name === "None") {
      return function cipherTransformFactoryBuildCipherConstructorNone() {
        return new NullCipher();
      };
    }

    if (cfm.name === "V2") {
      return function cipherTransformFactoryBuildCipherConstructorV2() {
        return new ARCFourCipher(buildObjectKey(num, gen, key, false));
      };
    }

    if (cfm.name === "AESV2") {
      return function cipherTransformFactoryBuildCipherConstructorAESV2() {
        return new AES128Cipher(buildObjectKey(num, gen, key, true));
      };
    }

    if (cfm.name === "AESV3") {
      return function cipherTransformFactoryBuildCipherConstructorAESV3() {
        return new AES256Cipher(key);
      };
    }

    throw new _util.FormatError("Unknown crypto method");
  }

  class CipherTransformFactory {
    constructor(dict, fileId, password) {
      const filter = dict.get("Filter");

      if (!(0, _primitives.isName)(filter, "Standard")) {
        throw new _util.FormatError("unknown encryption method");
      }

      this.dict = dict;
      const algorithm = dict.get("V");

      if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
        throw new _util.FormatError("unsupported encryption algorithm");
      }

      this.algorithm = algorithm;
      let keyLength = dict.get("Length");

      if (!keyLength) {
        if (algorithm <= 3) {
          keyLength = 40;
        } else {
          const cfDict = dict.get("CF");
          const streamCryptoName = dict.get("StmF");

          if ((0, _primitives.isDict)(cfDict) && (0, _primitives.isName)(streamCryptoName)) {
            cfDict.suppressEncryption = true;
            const handlerDict = cfDict.get(streamCryptoName.name);
            keyLength = handlerDict && handlerDict.get("Length") || 128;

            if (keyLength < 40) {
              keyLength <<= 3;
            }
          }
        }
      }

      if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
        throw new _util.FormatError("invalid key length");
      }

      const ownerPassword = (0, _util.stringToBytes)(dict.get("O")).subarray(0, 32);
      const userPassword = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 32);
      const flags = dict.get("P");
      const revision = dict.get("R");
      const encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
      this.encryptMetadata = encryptMetadata;
      const fileIdBytes = (0, _util.stringToBytes)(fileId);
      let passwordBytes;

      if (password) {
        if (revision === 6) {
          try {
            password = (0, _util.utf8StringToString)(password);
          } catch (ex) {
            (0, _util.warn)("CipherTransformFactory: " + "Unable to convert UTF8 encoded password.");
          }
        }

        passwordBytes = (0, _util.stringToBytes)(password);
      }

      let encryptionKey;

      if (algorithm !== 5) {
        encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
      } else {
        const ownerValidationSalt = (0, _util.stringToBytes)(dict.get("O")).subarray(32, 40);
        const ownerKeySalt = (0, _util.stringToBytes)(dict.get("O")).subarray(40, 48);
        const uBytes = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 48);
        const userValidationSalt = (0, _util.stringToBytes)(dict.get("U")).subarray(32, 40);
        const userKeySalt = (0, _util.stringToBytes)(dict.get("U")).subarray(40, 48);
        const ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
        const userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
        const perms = (0, _util.stringToBytes)(dict.get("Perms"));
        encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
      }

      if (!encryptionKey && !password) {
        throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
      } else if (!encryptionKey && password) {
        const decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
        encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
      }

      if (!encryptionKey) {
        throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
      }

      this.encryptionKey = encryptionKey;

      if (algorithm >= 4) {
        const cf = dict.get("CF");

        if ((0, _primitives.isDict)(cf)) {
          cf.suppressEncryption = true;
        }

        this.cf = cf;
        this.stmf = dict.get("StmF") || identityName;
        this.strf = dict.get("StrF") || identityName;
        this.eff = dict.get("EFF") || this.stmf;
      }
    }

    createCipherTransform(num, gen) {
      if (this.algorithm === 4 || this.algorithm === 5) {
        return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
      }

      const key = buildObjectKey(num, gen, this.encryptionKey, false);

      const cipherConstructor = function buildCipherCipherConstructor() {
        return new ARCFourCipher(key);
      };

      return new CipherTransform(cipherConstructor, cipherConstructor);
    }

  }

  return CipherTransformFactory;
}();

exports.CipherTransformFactory = CipherTransformFactory;

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DecryptStream = void 0;

var _decode_stream = __w_pdfjs_require__(19);

const chunkSize = 512;

class DecryptStream extends _decode_stream.DecodeStream {
  constructor(str, maybeLength, decrypt) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.decrypt = decrypt;
    this.nextChunk = null;
    this.initialized = false;
  }

  readBlock() {
    let chunk;

    if (this.initialized) {
      chunk = this.nextChunk;
    } else {
      chunk = this.str.getBytes(chunkSize);
      this.initialized = true;
    }

    if (!chunk || chunk.length === 0) {
      this.eof = true;
      return;
    }

    this.nextChunk = this.str.getBytes(chunkSize);
    const hasMoreData = this.nextChunk && this.nextChunk.length > 0;
    const decrypt = this.decrypt;
    chunk = decrypt(chunk, !hasMoreData);
    let bufferLength = this.bufferLength;
    const n = chunk.length,
          buffer = this.ensureBuffer(bufferLength + n);

    for (let i = 0; i < n; i++) {
      buffer[bufferLength++] = chunk[i];
    }

    this.bufferLength = bufferLength;
  }

}

exports.DecryptStream = DecryptStream;

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XFAFactory = void 0;

var _xfa_object = __w_pdfjs_require__(68);

var _bind = __w_pdfjs_require__(71);

var _parser = __w_pdfjs_require__(75);

class XFAFactory {
  constructor(data) {
    try {
      this.root = new _parser.XFAParser().parse(XFAFactory._createDocument(data));
      this.form = new _bind.Binder(this.root).bind();
      this.pages = this.form[_xfa_object.$toHTML]();
    } catch (e) {
      console.log(e);
    }
  }

  getPage(pageIndex) {
    return this.pages.children[pageIndex];
  }

  get numberPages() {
    return this.pages.children.length;
  }

  static _createDocument(data) {
    if (!data["/xdp:xdp"]) {
      return data["xdp:xdp"];
    }

    return Object.values(data).join("");
  }

}

exports.XFAFactory = XFAFactory;

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XmlObject = exports.XFAObjectArray = exports.XFAObject = exports.XFAAttribute = exports.StringObject = exports.OptionObject = exports.Option10 = exports.Option01 = exports.IntegerObject = exports.ContentObject = exports.$uid = exports.$toStyle = exports.$toHTML = exports.$text = exports.$setValue = exports.$setSetAttributes = exports.$setId = exports.$resolvePrototypes = exports.$removeChild = exports.$onText = exports.$onChildCheck = exports.$onChild = exports.$nsAttributes = exports.$nodeName = exports.$namespaceId = exports.$isTransparent = exports.$isDescendent = exports.$isDataValue = exports.$insertAt = exports.$indexOf = exports.$hasSettableValue = exports.$hasItem = exports.$global = exports.$getRealChildrenByNameIt = exports.$getParent = exports.$getChildrenByNameIt = exports.$getChildrenByName = exports.$getChildrenByClass = exports.$getChildren = exports.$getAttributeIt = exports.$finalize = exports.$extra = exports.$dump = exports.$data = exports.$content = exports.$consumed = exports.$clone = exports.$cleanup = exports.$clean = exports.$childrenToHTML = exports.$appendChild = exports.$acceptWhitespace = void 0;

var _utils = __w_pdfjs_require__(69);

var _util = __w_pdfjs_require__(2);

var _namespaces = __w_pdfjs_require__(70);

const $acceptWhitespace = Symbol();
exports.$acceptWhitespace = $acceptWhitespace;
const $appendChild = Symbol();
exports.$appendChild = $appendChild;
const $childrenToHTML = Symbol();
exports.$childrenToHTML = $childrenToHTML;
const $clean = Symbol();
exports.$clean = $clean;
const $cleanup = Symbol();
exports.$cleanup = $cleanup;
const $clone = Symbol();
exports.$clone = $clone;
const $consumed = Symbol();
exports.$consumed = $consumed;
const $content = Symbol("content");
exports.$content = $content;
const $data = Symbol("data");
exports.$data = $data;
const $dump = Symbol();
exports.$dump = $dump;
const $extra = Symbol("extra");
exports.$extra = $extra;
const $finalize = Symbol();
exports.$finalize = $finalize;
const $getAttributeIt = Symbol();
exports.$getAttributeIt = $getAttributeIt;
const $getChildrenByClass = Symbol();
exports.$getChildrenByClass = $getChildrenByClass;
const $getChildrenByName = Symbol();
exports.$getChildrenByName = $getChildrenByName;
const $getChildrenByNameIt = Symbol();
exports.$getChildrenByNameIt = $getChildrenByNameIt;
const $getRealChildrenByNameIt = Symbol();
exports.$getRealChildrenByNameIt = $getRealChildrenByNameIt;
const $getChildren = Symbol();
exports.$getChildren = $getChildren;
const $getParent = Symbol();
exports.$getParent = $getParent;
const $global = Symbol();
exports.$global = $global;
const $hasItem = Symbol();
exports.$hasItem = $hasItem;
const $hasSettableValue = Symbol();
exports.$hasSettableValue = $hasSettableValue;
const $indexOf = Symbol();
exports.$indexOf = $indexOf;
const $insertAt = Symbol();
exports.$insertAt = $insertAt;
const $isDataValue = Symbol();
exports.$isDataValue = $isDataValue;
const $isDescendent = Symbol();
exports.$isDescendent = $isDescendent;
const $isTransparent = Symbol();
exports.$isTransparent = $isTransparent;
const $lastAttribute = Symbol();
const $namespaceId = Symbol("namespaceId");
exports.$namespaceId = $namespaceId;
const $nodeName = Symbol("nodeName");
exports.$nodeName = $nodeName;
const $nsAttributes = Symbol();
exports.$nsAttributes = $nsAttributes;
const $onChild = Symbol();
exports.$onChild = $onChild;
const $onChildCheck = Symbol();
exports.$onChildCheck = $onChildCheck;
const $onText = Symbol();
exports.$onText = $onText;
const $removeChild = Symbol();
exports.$removeChild = $removeChild;
const $resolvePrototypes = Symbol();
exports.$resolvePrototypes = $resolvePrototypes;
const $setId = Symbol();
exports.$setId = $setId;
const $setSetAttributes = Symbol();
exports.$setSetAttributes = $setSetAttributes;
const $setValue = Symbol();
exports.$setValue = $setValue;
const $text = Symbol();
exports.$text = $text;
const $toHTML = Symbol();
exports.$toHTML = $toHTML;
const $toStyle = Symbol();
exports.$toStyle = $toStyle;
const $uid = Symbol("uid");
exports.$uid = $uid;

const _applyPrototype = Symbol();

const _attributes = Symbol();

const _attributeNames = Symbol();

const _children = Symbol("_children");

const _cloneAttribute = Symbol();

const _dataValue = Symbol();

const _defaultValue = Symbol();

const _getPrototype = Symbol();

const _getUnsetAttributes = Symbol();

const _hasChildren = Symbol();

const _max = Symbol();

const _options = Symbol();

const _parent = Symbol("parent");

const _setAttributes = Symbol();

const _validator = Symbol();

let uid = 0;

class XFAObject {
  constructor(nsId, name, hasChildren = false) {
    this[$namespaceId] = nsId;
    this[$nodeName] = name;
    this[_hasChildren] = hasChildren;
    this[_parent] = null;
    this[_children] = [];
    this[$uid] = `${name}${uid++}`;
  }

  [$onChild](child) {
    if (!this[_hasChildren] || !this[$onChildCheck](child)) {
      return false;
    }

    const name = child[$nodeName];
    const node = this[name];

    if (node instanceof XFAObjectArray) {
      if (node.push(child)) {
        this[$appendChild](child);
        return true;
      }
    } else {
      if (node !== null) {
        this[$removeChild](node);
      }

      this[name] = child;
      this[$appendChild](child);
      return true;
    }

    let id = "";

    if (this.id) {
      id = ` (id: ${this.id})`;
    } else if (this.name) {
      id = ` (name: ${this.name} ${this.h.value})`;
    }

    (0, _util.warn)(`XFA - node "${this[$nodeName]}"${id} has already enough "${name}"!`);
    return false;
  }

  [$onChildCheck](child) {
    return this.hasOwnProperty(child[$nodeName]) && child[$namespaceId] === this[$namespaceId];
  }

  [$acceptWhitespace]() {
    return false;
  }

  [$setId](ids) {
    if (this.id && this[$namespaceId] === _namespaces.NamespaceIds.template.id) {
      ids.set(this.id, this);
    }
  }

  [$appendChild](child) {
    child[_parent] = this;

    this[_children].push(child);
  }

  [$removeChild](child) {
    const i = this[_children].indexOf(child);

    this[_children].splice(i, 1);
  }

  [$hasSettableValue]() {
    return this.hasOwnProperty("value");
  }

  [$setValue](_) {}

  [$onText](_) {}

  [$finalize]() {}

  [$clean](builder) {
    delete this[_hasChildren];

    if (this[$cleanup]) {
      builder.clean(this[$cleanup]);
      delete this[$cleanup];
    }
  }

  [$hasItem]() {
    return false;
  }

  [$indexOf](child) {
    return this[_children].indexOf(child);
  }

  [$insertAt](i, child) {
    child[_parent] = this;

    this[_children].splice(i, 0, child);
  }

  [$isTransparent]() {
    return this.name === "";
  }

  [$lastAttribute]() {
    return "";
  }

  [$text]() {
    if (this[_children].length === 0) {
      return this[$content];
    }

    return this[_children].map(c => c[$text]()).join("");
  }

  get [_attributeNames]() {
    const proto = Object.getPrototypeOf(this);

    if (!proto._attributes) {
      const attributes = proto._attributes = new Set();

      for (const name of Object.getOwnPropertyNames(this)) {
        if (this[name] === null || this[name] instanceof XFAObject || this[name] instanceof XFAObjectArray) {
          break;
        }

        attributes.add(name);
      }
    }

    return (0, _util.shadow)(this, _attributeNames, proto._attributes);
  }

  [$isDescendent](parent) {
    let node = this;

    while (node) {
      if (node === parent) {
        return true;
      }

      node = node[$getParent]();
    }

    return false;
  }

  [$getParent]() {
    return this[_parent];
  }

  [$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }

    return this[name];
  }

  [$dump]() {
    const dumped = Object.create(null);

    if (this[$content]) {
      dumped.$content = this[$content];
    }

    for (const name of Object.getOwnPropertyNames(this)) {
      const value = this[name];

      if (value === null) {
        continue;
      }

      if (value instanceof XFAObject) {
        dumped[name] = value[$dump]();
      } else if (value instanceof XFAObjectArray) {
        if (!value.isEmpty()) {
          dumped[name] = value.dump();
        }
      } else {
        dumped[name] = value;
      }
    }

    return dumped;
  }

  [$toStyle]() {
    return null;
  }

  [$toHTML]() {
    return null;
  }

  [$childrenToHTML]({
    filter = null,
    include = true
  }) {
    const res = [];
    this[$getChildren]().forEach(node => {
      if (!filter || include === filter.has(node[$nodeName])) {
        const html = node[$toHTML]();

        if (html) {
          res.push(html);
        }
      }
    });
    return res;
  }

  [$setSetAttributes](attributes) {
    if (attributes.use || attributes.id) {
      this[_setAttributes] = new Set(Object.keys(attributes));
    }
  }

  [_getUnsetAttributes](protoAttributes) {
    const allAttr = this[_attributeNames];
    const setAttr = this[_setAttributes];
    return [...protoAttributes].filter(x => allAttr.has(x) && !setAttr.has(x));
  }

  [$resolvePrototypes](ids, ancestors = new Set()) {
    for (const child of this[_children]) {
      const proto = child[_getPrototype](ids, ancestors);

      if (proto) {
        child[_applyPrototype](proto, ids, ancestors);
      } else {
        child[$resolvePrototypes](ids, ancestors);
      }
    }
  }

  [_getPrototype](ids, ancestors) {
    const {
      use
    } = this;

    if (use && use.startsWith("#")) {
      const id = use.slice(1);
      const proto = ids.get(id);
      this.use = "";

      if (!proto) {
        (0, _util.warn)(`XFA - Invalid prototype id: ${id}.`);
        return null;
      }

      if (proto[$nodeName] !== this[$nodeName]) {
        (0, _util.warn)(`XFA - Incompatible prototype: ${proto[$nodeName]} !== ${this[$nodeName]}.`);
        return null;
      }

      if (ancestors.has(proto)) {
        (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
        return null;
      }

      ancestors.add(proto);

      const protoProto = proto[_getPrototype](ids, ancestors);

      if (!protoProto) {
        ancestors.delete(proto);
        return proto;
      }

      proto[_applyPrototype](protoProto, ids, ancestors);

      ancestors.delete(proto);
      return proto;
    }

    return null;
  }

  [_applyPrototype](proto, ids, ancestors) {
    if (ancestors.has(proto)) {
      (0, _util.warn)(`XFA - Cycle detected in prototypes use.`);
      return;
    }

    if (!this[$content] && proto[$content]) {
      this[$content] = proto[$content];
    }

    const newAncestors = new Set(ancestors);
    newAncestors.add(proto);

    for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) {
      this[unsetAttrName] = proto[unsetAttrName];

      if (this[_setAttributes]) {
        this[_setAttributes].add(unsetAttrName);
      }
    }

    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        continue;
      }

      const value = this[name];
      const protoValue = proto[name];

      if (value instanceof XFAObjectArray) {
        for (const child of value[_children]) {
          child[$resolvePrototypes](ids, ancestors);
        }

        for (let i = value[_children].length, ii = protoValue[_children].length; i < ii; i++) {
          const child = proto[_children][i][$clone]();

          if (value.push(child)) {
            child[_parent] = this;

            this[_children].push(child);

            child[$resolvePrototypes](ids, newAncestors);
          } else {
            break;
          }
        }

        continue;
      }

      if (value !== null) {
        value[$resolvePrototypes](ids, ancestors);
        continue;
      }

      if (protoValue !== null) {
        const child = protoValue[$clone]();
        child[_parent] = this;
        this[name] = child;

        this[_children].push(child);

        child[$resolvePrototypes](ids, newAncestors);
      }
    }
  }

  static [_cloneAttribute](obj) {
    if (Array.isArray(obj)) {
      return obj.map(x => XFAObject[_cloneAttribute](x));
    }

    if (obj instanceof Object) {
      return Object.assign({}, obj);
    }

    return obj;
  }

  [$clone]() {
    const clone = Object.create(Object.getPrototypeOf(this));

    for (const $symbol of Object.getOwnPropertySymbols(this)) {
      try {
        clone[$symbol] = this[$symbol];
      } catch (_) {
        (0, _util.shadow)(clone, $symbol, this[$symbol]);
      }
    }

    clone[_children] = [];

    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        clone[name] = XFAObject[_cloneAttribute](this[name]);
        continue;
      }

      const value = this[name];

      if (value instanceof XFAObjectArray) {
        clone[name] = new XFAObjectArray(value[_max]);
      } else {
        clone[name] = null;
      }
    }

    for (const child of this[_children]) {
      const name = child[$nodeName];
      const clonedChild = child[$clone]();

      clone[_children].push(clonedChild);

      clonedChild[_parent] = clone;

      if (clone[name] === null) {
        clone[name] = clonedChild;
      } else {
        clone[name][_children].push(clonedChild);
      }
    }

    return clone;
  }

  [$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }

    return this[_children].filter(c => c[$nodeName] === name);
  }

  [$getChildrenByClass](name) {
    return this[name];
  }

  [$getChildrenByName](name, allTransparent, first = true) {
    return Array.from(this[$getChildrenByNameIt](name, allTransparent, first));
  }

  *[$getChildrenByNameIt](name, allTransparent, first = true) {
    if (name === "parent") {
      yield this[_parent];
      return;
    }

    for (const child of this[_children]) {
      if (child[$nodeName] === name) {
        yield child;
      }

      if (child.name === name) {
        yield child;
      }

      if (allTransparent || child[$isTransparent]()) {
        yield* child[$getChildrenByNameIt](name, allTransparent, false);
      }
    }

    if (first && this[_attributeNames].has(name)) {
      yield new XFAAttribute(this, name, this[name]);
    }
  }

}

exports.XFAObject = XFAObject;

class XFAObjectArray {
  constructor(max = Infinity) {
    this[_max] = max;
    this[_children] = [];
  }

  push(child) {
    const len = this[_children].length;

    if (len <= this[_max]) {
      this[_children].push(child);

      return true;
    }

    (0, _util.warn)(`XFA - node "${child[$nodeName]}" accepts no more than ${this[_max]} children`);
    return false;
  }

  isEmpty() {
    return this[_children].length === 0;
  }

  dump() {
    return this[_children].length === 1 ? this[_children][0][$dump]() : this[_children].map(x => x[$dump]());
  }

  [$clone]() {
    const clone = new XFAObjectArray(this[_max]);
    clone[_children] = this[_children].map(c => c[$clone]());
    return clone;
  }

  get children() {
    return this[_children];
  }

  clear() {
    this[_children].length = 0;
  }

}

exports.XFAObjectArray = XFAObjectArray;

class XFAAttribute {
  constructor(node, name, value) {
    this[_parent] = node;
    this[$nodeName] = name;
    this[$content] = value;
    this[$consumed] = false;
  }

  [$getParent]() {
    return this[_parent];
  }

  [$isDataValue]() {
    return true;
  }

  [$text]() {
    return this[$content];
  }

  [$isDescendent](parent) {
    return this[_parent] === parent || this[_parent][$isDescendent](parent);
  }

}

exports.XFAAttribute = XFAAttribute;

class XmlObject extends XFAObject {
  constructor(nsId, name, attributes = {}) {
    super(nsId, name);
    this[$content] = "";
    this[_dataValue] = null;

    if (name !== "#text") {
      const map = new Map();
      this[_attributes] = map;

      for (const [attrName, value] of Object.entries(attributes)) {
        map.set(attrName, new XFAAttribute(this, attrName, value));
      }

      if (attributes.hasOwnProperty($nsAttributes)) {
        const dataNode = attributes[$nsAttributes].xfa.dataNode;

        if (dataNode !== undefined) {
          if (dataNode === "dataGroup") {
            this[_dataValue] = false;
          } else if (dataNode === "dataValue") {
            this[_dataValue] = true;
          }
        }
      }
    }

    this[$consumed] = false;
  }

  [$onChild](child) {
    if (this[$content]) {
      const node = new XmlObject(this[$namespaceId], "#text");
      this[$appendChild](node);
      node[$content] = this[$content];
      this[$content] = "";
    }

    this[$appendChild](child);
    return true;
  }

  [$onText](str) {
    this[$content] += str;
  }

  [$finalize]() {
    if (this[$content] && this[_children].length > 0) {
      const node = new XmlObject(this[$namespaceId], "#text");
      this[$appendChild](node);
      node[$content] = this[$content];
      delete this[$content];
    }
  }

  [$toHTML]() {
    if (this[$nodeName] === "#text") {
      return {
        name: "#text",
        value: this[$content]
      };
    }

    return null;
  }

  [$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }

    return this[_children].filter(c => c[$nodeName] === name);
  }

  [$getChildrenByClass](name) {
    const value = this[_attributes].get(name);

    if (value !== undefined) {
      return value;
    }

    return this[$getChildren](name);
  }

  *[$getChildrenByNameIt](name, allTransparent) {
    const value = this[_attributes].get(name);

    if (value) {
      yield value;
    }

    for (const child of this[_children]) {
      if (child[$nodeName] === name) {
        yield child;
      }

      if (allTransparent) {
        yield* child[$getChildrenByNameIt](name, allTransparent);
      }
    }
  }

  *[$getAttributeIt](name, skipConsumed) {
    const value = this[_attributes].get(name);

    if (value && (!skipConsumed || !value[$consumed])) {
      yield value;
    }

    for (const child of this[_children]) {
      yield* child[$getAttributeIt](name, skipConsumed);
    }
  }

  *[$getRealChildrenByNameIt](name, allTransparent, skipConsumed) {
    for (const child of this[_children]) {
      if (child[$nodeName] === name && (!skipConsumed || !child[$consumed])) {
        yield child;
      }

      if (allTransparent) {
        yield* child[$getRealChildrenByNameIt](name, allTransparent, skipConsumed);
      }
    }
  }

  [$isDataValue]() {
    if (this[_dataValue] === null) {
      return this[_children].length === 0;
    }

    return this[_dataValue];
  }

  [$dump]() {
    const dumped = Object.create(null);

    if (this[$content]) {
      dumped.$content = this[$content];
    }

    dumped.$name = this[$nodeName];
    dumped.children = [];

    for (const child of this[_children]) {
      dumped.children.push(child[$dump]());
    }

    dumped.attributes = Object.create(null);

    for (const [name, value] of this[_attributes]) {
      dumped.attributes[name] = value[$content];
    }

    return dumped;
  }

}

exports.XmlObject = XmlObject;

class ContentObject extends XFAObject {
  constructor(nsId, name) {
    super(nsId, name);
    this[$content] = "";
  }

  [$onText](text) {
    this[$content] += text;
  }

  [$finalize]() {}

}

exports.ContentObject = ContentObject;

class OptionObject extends ContentObject {
  constructor(nsId, name, options) {
    super(nsId, name);
    this[_options] = options;
  }

  [$finalize]() {
    this[$content] = (0, _utils.getKeyword)({
      data: this[$content],
      defaultValue: this[_options][0],
      validate: k => this[_options].includes(k)
    });
  }

  [$clean](builder) {
    super[$clean](builder);
    delete this[_options];
  }

}

exports.OptionObject = OptionObject;

class StringObject extends ContentObject {
  [$finalize]() {
    this[$content] = this[$content].trim();
  }

}

exports.StringObject = StringObject;

class IntegerObject extends ContentObject {
  constructor(nsId, name, defaultValue, validator) {
    super(nsId, name);
    this[_defaultValue] = defaultValue;
    this[_validator] = validator;
  }

  [$finalize]() {
    this[$content] = (0, _utils.getInteger)({
      data: this[$content],
      defaultValue: this[_defaultValue],
      validate: this[_validator]
    });
  }

  [$clean](builder) {
    super[$clean](builder);
    delete this[_defaultValue];
    delete this[_validator];
  }

}

exports.IntegerObject = IntegerObject;

class Option01 extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 0, n => n === 1);
  }

}

exports.Option01 = Option01;

class Option10 extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 1, n => n === 0);
  }

}

exports.Option10 = Option10;

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getBBox = getBBox;
exports.getColor = getColor;
exports.getFloat = getFloat;
exports.getInteger = getInteger;
exports.getKeyword = getKeyword;
exports.getMeasurement = getMeasurement;
exports.getRatio = getRatio;
exports.getRelevant = getRelevant;
exports.getStringOption = getStringOption;
const dimConverters = {
  pt: x => x,
  cm: x => x / 2.54 * 72,
  mm: x => x / (10 * 2.54) * 72,
  in: x => x * 72
};
const measurementPattern = /([+-]?[0-9]+\.?[0-9]*)(.*)/;

function getInteger({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }

  data = data.trim();
  const n = parseInt(data, 10);

  if (!isNaN(n) && validate(n)) {
    return n;
  }

  return defaultValue;
}

function getFloat({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }

  data = data.trim();
  const n = parseFloat(data);

  if (!isNaN(n) && validate(n)) {
    return n;
  }

  return defaultValue;
}

function getKeyword({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }

  data = data.trim();

  if (validate(data)) {
    return data;
  }

  return defaultValue;
}

function getStringOption(data, options) {
  return getKeyword({
    data,
    defaultValue: options[0],
    validate: k => options.includes(k)
  });
}

function getMeasurement(str, def = "0") {
  def = def || "0";

  if (!str) {
    return getMeasurement(def);
  }

  const match = str.trim().match(measurementPattern);

  if (!match) {
    return getMeasurement(def);
  }

  const [, valueStr, unit] = match;
  const value = parseFloat(valueStr);

  if (isNaN(value)) {
    return getMeasurement(def);
  }

  if (value === 0) {
    return 0;
  }

  const conv = dimConverters[unit];

  if (conv) {
    return conv(value);
  }

  return value;
}

function getRatio(data) {
  if (!data) {
    return {
      num: 1,
      den: 1
    };
  }

  const ratio = data.trim().split(/\s*:\s*/).map(x => parseFloat(x)).filter(x => !isNaN(x));

  if (ratio.length === 1) {
    ratio.push(1);
  }

  if (ratio.length === 0) {
    return {
      num: 1,
      den: 1
    };
  }

  const [num, den] = ratio;
  return {
    num,
    den
  };
}

function getRelevant(data) {
  if (!data) {
    return [];
  }

  return data.trim().split(/\s+/).map(e => {
    return {
      excluded: e[0] === "-",
      viewname: e.substring(1)
    };
  });
}

function getColor(data, def = [0, 0, 0]) {
  let [r, g, b] = def;

  if (!data) {
    return {
      r,
      g,
      b
    };
  }

  const color = data.trim().split(/\s*,\s*/).map(c => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map(c => isNaN(c) ? 0 : c);

  if (color.length < 3) {
    return {
      r,
      g,
      b
    };
  }

  [r, g, b] = color;
  return {
    r,
    g,
    b
  };
}

function getBBox(data) {
  const def = -1;

  if (!data) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }

  const bbox = data.trim().split(/\s*,\s*/).map(m => getMeasurement(m, "-1"));

  if (bbox.length < 4 || bbox[2] < 0 || bbox[3] < 0) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }

  const [x, y, width, height] = bbox;
  return {
    x,
    y,
    width,
    height
  };
}

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NamespaceIds = exports.$buildXFAObject = void 0;
const $buildXFAObject = Symbol();
exports.$buildXFAObject = $buildXFAObject;
const NamespaceIds = {
  config: {
    id: 0,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xci/")
  },
  connectionSet: {
    id: 1,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
  },
  datasets: {
    id: 2,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-data/")
  },
  form: {
    id: 3,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-form/")
  },
  localeSet: {
    id: 4,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
  },
  pdf: {
    id: 5,
    check: ns => ns === "http://ns.adobe.com/xdp/pdf/"
  },
  signature: {
    id: 6,
    check: ns => ns === "http://www.w3.org/2000/09/xmldsig#"
  },
  sourceSet: {
    id: 7,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-source-set/")
  },
  stylesheet: {
    id: 8,
    check: ns => ns === "http://www.w3.org/1999/XSL/Transform"
  },
  template: {
    id: 9,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xfa-template/")
  },
  xdc: {
    id: 10,
    check: ns => ns.startsWith("http://www.xfa.org/schema/xdc/")
  },
  xdp: {
    id: 11,
    check: ns => ns === "http://ns.adobe.com/xdp/"
  },
  xfdf: {
    id: 12,
    check: ns => ns === "http://ns.adobe.com/xfdf/"
  },
  xhtml: {
    id: 13,
    check: ns => ns === "http://www.w3.org/1999/xhtml"
  },
  xmpmeta: {
    id: 14,
    check: ns => ns === "http://ns.adobe.com/xmpmeta/"
  }
};
exports.NamespaceIds = NamespaceIds;

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Binder = void 0;

var _xfa_object = __w_pdfjs_require__(68);

var _template = __w_pdfjs_require__(72);

var _som = __w_pdfjs_require__(74);

var _namespaces = __w_pdfjs_require__(70);

var _util = __w_pdfjs_require__(2);

function createText(content) {
  const node = new _template.Text({});
  node[_xfa_object.$content] = content;
  return node;
}

class Binder {
  constructor(root) {
    this.root = root;
    this.datasets = root.datasets;

    if (root.datasets && root.datasets.data) {
      this.emptyMerge = false;
      this.data = root.datasets.data;
    } else {
      this.emptyMerge = true;
      this.data = new _xfa_object.XmlObject(_namespaces.NamespaceIds.datasets.id, "data");
    }

    this.root.form = this.form = root.template[_xfa_object.$clone]();
  }

  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }

  _isMatchTemplate() {
    return !this._isConsumeData();
  }

  bind() {
    this._bindElement(this.form, this.data);

    return this.form;
  }

  getData() {
    return this.data;
  }

  _bindValue(formNode, data, picture) {
    if (formNode[_xfa_object.$hasSettableValue]()) {
      if (data[_xfa_object.$isDataValue]()) {
        const value = data[_xfa_object.$content].trim();

        formNode[_xfa_object.$setValue](createText(value));

        formNode[_xfa_object.$data] = data;
      } else if (formNode instanceof _template.Field && formNode.ui && formNode.ui.choiceList && formNode.ui.choiceList.open === "multiSelect") {
        const value = data[_xfa_object.$getChildren]().map(child => child[_xfa_object.$content].trim()).join("\n");

        formNode[_xfa_object.$setValue](createText(value));

        formNode[_xfa_object.$data] = data;
      } else if (this._isConsumeData()) {
        (0, _util.warn)(`XFA - Nodes haven't the same type.`);
      }
    } else if (!data[_xfa_object.$isDataValue]() || this._isMatchTemplate()) {
      this._bindElement(formNode, data);

      formNode[_xfa_object.$data] = data;
    } else {
      (0, _util.warn)(`XFA - Nodes haven't the same type.`);
    }
  }

  _findDataByNameToConsume(name, dataNode, global) {
    if (!name) {
      return null;
    }

    let generator, match;

    for (let i = 0; i < 3; i++) {
      generator = dataNode[_xfa_object.$getRealChildrenByNameIt](name, false, true);
      match = generator.next().value;

      if (match) {
        return match;
      }

      if (dataNode[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.datasets.id && dataNode[_xfa_object.$nodeName] === "data") {
        break;
      }

      dataNode = dataNode[_xfa_object.$getParent]();
    }

    if (!global) {
      return null;
    }

    generator = this.datasets[_xfa_object.$getRealChildrenByNameIt](name, false, false);

    while (true) {
      match = generator.next().value;

      if (!match) {
        break;
      }

      if (match[_xfa_object.$global]) {
        return match;
      }
    }

    generator = this.data[_xfa_object.$getAttributeIt](name, true);
    match = generator.next().value;

    if (match && match[_xfa_object.$isDataValue]()) {
      return match;
    }

    return null;
  }

  _setProperties(formNode, dataNode) {
    if (!formNode.hasOwnProperty("setProperty")) {
      return;
    }

    for (const {
      ref,
      target,
      connection
    } of formNode.setProperty.children) {
      if (connection) {
        continue;
      }

      if (!ref) {
        continue;
      }

      const [node] = (0, _som.searchNode)(this.root, dataNode, ref, false, false);

      if (!node) {
        (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
        continue;
      }

      if (!node[_xfa_object.$isDescendent](this.data)) {
        (0, _util.warn)(`XFA - Invalid node: must be a data node.`);
        continue;
      }

      const [targetNode] = (0, _som.searchNode)(this.root, formNode, target, false, false);

      if (!targetNode) {
        (0, _util.warn)(`XFA - Invalid target: ${target}.`);
        continue;
      }

      if (!targetNode[_xfa_object.$isDescendent](formNode)) {
        (0, _util.warn)(`XFA - Invalid target: must be a property or subproperty.`);
        continue;
      }

      const targetParent = targetNode[_xfa_object.$getParent]();

      if (targetNode instanceof _template.SetProperty || targetParent instanceof _template.SetProperty) {
        (0, _util.warn)(`XFA - Invalid target: cannot be a setProperty or one of its properties.`);
        continue;
      }

      if (targetNode instanceof _template.BindItems || targetParent instanceof _template.BindItems) {
        (0, _util.warn)(`XFA - Invalid target: cannot be a bindItems or one of its properties.`);
        continue;
      }

      const content = node[_xfa_object.$text]();

      const name = targetNode[_xfa_object.$nodeName];

      if (targetNode instanceof _xfa_object.XFAAttribute) {
        const attrs = Object.create(null);
        attrs[name] = content;
        const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]);
        targetParent[name] = obj[name];
        continue;
      }

      if (!targetNode.hasOwnProperty(_xfa_object.$content)) {
        (0, _util.warn)(`XFA - Invalid node to use in setProperty`);
        continue;
      }

      targetNode[_xfa_object.$data] = node;
      targetNode[_xfa_object.$content] = content;

      targetNode[_xfa_object.$finalize]();
    }
  }

  _bindItems(formNode, dataNode) {
    if (!formNode.hasOwnProperty("items") || !formNode.hasOwnProperty("bindItems") || formNode.bindItems.isEmpty()) {
      return;
    }

    for (const item of formNode.items.children) {
      formNode[_xfa_object.$removeChild](item);
    }

    formNode.items.clear();
    const labels = new _template.Items({});
    const values = new _template.Items({});

    formNode[_xfa_object.$appendChild](labels);

    formNode.items.push(labels);

    formNode[_xfa_object.$appendChild](values);

    formNode.items.push(values);

    for (const {
      ref,
      labelRef,
      valueRef,
      connection
    } of formNode.bindItems.children) {
      if (connection) {
        continue;
      }

      if (!ref) {
        continue;
      }

      const nodes = (0, _som.searchNode)(this.root, dataNode, ref, false, false);

      if (!nodes) {
        (0, _util.warn)(`XFA - Invalid reference: ${ref}.`);
        continue;
      }

      for (const node of nodes) {
        if (!node[_xfa_object.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid ref (${ref}): must be a datasets child.`);
          continue;
        }

        const [labelNode] = (0, _som.searchNode)(this.root, node, labelRef, true, false);

        if (!labelNode) {
          (0, _util.warn)(`XFA - Invalid label: ${labelRef}.`);
          continue;
        }

        if (!labelNode[_xfa_object.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid label: must be a datasets child.`);
          continue;
        }

        const [valueNode] = (0, _som.searchNode)(this.root, node, valueRef, true, false);

        if (!valueNode) {
          (0, _util.warn)(`XFA - Invalid value: ${valueRef}.`);
          continue;
        }

        if (!valueNode[_xfa_object.$isDescendent](this.datasets)) {
          (0, _util.warn)(`XFA - Invalid value: must be a datasets child.`);
          continue;
        }

        const label = createText(labelNode[_xfa_object.$text]());
        const value = createText(valueNode[_xfa_object.$text]());

        labels[_xfa_object.$appendChild](label);

        labels.text.push(label);

        values[_xfa_object.$appendChild](value);

        values.text.push(value);
      }
    }
  }

  _bindOccurrences(formNode, matches, picture) {
    let baseClone;

    if (matches.length > 1) {
      baseClone = formNode[_xfa_object.$clone]();
    }

    this._bindValue(formNode, matches[0], picture);

    this._setProperties(formNode, matches[0]);

    this._bindItems(formNode, matches[0]);

    if (matches.length === 1) {
      return;
    }

    const parent = formNode[_xfa_object.$getParent]();

    const name = formNode[_xfa_object.$nodeName];

    const pos = parent[_xfa_object.$indexOf](formNode);

    for (let i = 1, ii = matches.length; i < ii; i++) {
      const match = matches[i];

      const clone = baseClone[_xfa_object.$clone]();

      clone.occur.min = 1;
      clone.occur.max = 1;
      clone.occur.initial = 1;
      parent[name].push(clone);

      parent[_xfa_object.$insertAt](pos + i, clone);

      this._bindValue(clone, match, picture);

      this._setProperties(clone, match);

      this._bindItems(clone, match);
    }
  }

  _createOccurrences(formNode) {
    if (!this.emptyMerge) {
      return;
    }

    const {
      occur
    } = formNode;

    if (!occur || occur.initial <= 1) {
      return;
    }

    const parent = formNode[_xfa_object.$getParent]();

    const name = formNode[_xfa_object.$nodeName];

    for (let i = 0, ii = occur.initial; i < ii; i++) {
      const clone = formNode[_xfa_object.$clone]();

      clone.occur.min = 1;
      clone.occur.max = 1;
      clone.occur.initial = 1;
      parent[name].push(clone);

      parent[_xfa_object.$appendChild](clone);
    }
  }

  _getOccurInfo(formNode) {
    const {
      occur
    } = formNode;
    const dataName = formNode.name;

    if (!occur || !dataName) {
      return [1, 1];
    }

    const max = occur.max === -1 ? Infinity : occur.max;
    return [occur.min, max];
  }

  _bindElement(formNode, dataNode) {
    const uselessNodes = [];

    this._createOccurrences(formNode);

    for (const child of formNode[_xfa_object.$getChildren]()) {
      if (child[_xfa_object.$data]) {
        continue;
      }

      if (this._mergeMode === undefined && child[_xfa_object.$nodeName] === "subform") {
        this._mergeMode = child.mergeMode === "consumeData";
      }

      let global = false;
      let picture = null;
      let ref = null;
      let match = null;

      if (child.bind) {
        switch (child.bind.match) {
          case "none":
            continue;

          case "global":
            global = true;
            break;

          case "dataRef":
            if (!child.bind.ref) {
              (0, _util.warn)(`XFA - ref is empty in node ${child[_xfa_object.$nodeName]}.`);
              continue;
            }

            ref = child.bind.ref;
            break;

          default:
            break;
        }

        if (child.bind.picture) {
          picture = child.bind.picture[_xfa_object.$content];
        }
      }

      const [min, max] = this._getOccurInfo(child);

      if (ref) {
        match = (0, _som.searchNode)(this.root, dataNode, ref, true, false);

        if (match === null) {
          match = (0, _som.createDataNode)(this.data, dataNode, ref);

          if (this._isConsumeData()) {
            match[_xfa_object.$consumed] = true;
          }

          match = [match];
        } else {
          if (this._isConsumeData()) {
            match = match.filter(node => !node[_xfa_object.$consumed]);
          }

          if (match.length > max) {
            match = match.slice(0, max);
          } else if (match.length === 0) {
            match = null;
          }

          if (match && this._isConsumeData()) {
            match.forEach(node => {
              node[_xfa_object.$consumed] = true;
            });
          }
        }
      } else {
        if (!child.name) {
          this._bindElement(child, dataNode);

          continue;
        }

        if (this._isConsumeData()) {
          const matches = [];

          while (matches.length < max) {
            const found = this._findDataByNameToConsume(child.name, dataNode, global);

            if (!found) {
              break;
            }

            found[_xfa_object.$consumed] = true;
            matches.push(found);
          }

          match = matches.length > 0 ? matches : null;
        } else {
          match = dataNode[_xfa_object.$getRealChildrenByNameIt](child.name, false, false).next().value;

          if (!match) {
            match = new _xfa_object.XmlObject(dataNode[_xfa_object.$namespaceId], child.name);

            dataNode[_xfa_object.$appendChild](match);
          }

          match = [match];
        }
      }

      if (match) {
        if (match.length < min) {
          (0, _util.warn)(`XFA - Must have at least ${min} occurrences: ${formNode[_xfa_object.$nodeName]}.`);
          continue;
        }

        this._bindOccurrences(child, match, picture);
      } else if (min > 0) {
        this._bindElement(child, dataNode);
      } else {
        uselessNodes.push(child);
      }
    }

    uselessNodes.forEach(node => node[_xfa_object.$getParent]()[_xfa_object.$removeChild](node));
  }

}

exports.Binder = Binder;

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Value = exports.Text = exports.TemplateNamespace = exports.Template = exports.SetProperty = exports.Items = exports.Field = exports.BindItems = void 0;

var _xfa_object = __w_pdfjs_require__(68);

var _namespaces = __w_pdfjs_require__(70);

var _html_utils = __w_pdfjs_require__(73);

var _utils = __w_pdfjs_require__(69);

var _util = __w_pdfjs_require__(2);

const TEMPLATE_NS_ID = _namespaces.NamespaceIds.template.id;

function _setValue(templateNode, value) {
  if (!templateNode.value) {
    const nodeValue = new Value({});

    templateNode[_xfa_object.$appendChild](nodeValue);

    templateNode.value = nodeValue;
  }

  templateNode.value[_xfa_object.$setValue](value);
}

class AppearanceFilter extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "appearanceFilter");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Arc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "arc", true);
    this.circular = (0, _utils.getInteger)({
      data: attributes.circular,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.startAngle = (0, _utils.getFloat)({
      data: attributes.startAngle,
      defaultValue: 0,
      validate: x => true
    });
    this.sweepAngle = (0, _utils.getFloat)({
      data: attributes.sweepAngle,
      defaultValue: 360,
      validate: x => true
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
    this.fill = null;
  }

}

class Area extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "area", true);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: n => n >= 1
    });
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$isTransparent]() {
    return true;
  }

  [_xfa_object.$toHTML]() {
    this[_xfa_object.$extra] = Object.create(null);
    const style = (0, _html_utils.toStyle)(this, "position");
    const attributes = {
      style,
      id: this[_xfa_object.$uid],
      class: "xfaArea"
    };

    if (this.name) {
      attributes.xfaName = this.name;
    }

    const children = this[_xfa_object.$childrenToHTML]({
      filter: new Set(["area", "draw", "field", "subform", "subformSet"]),
      include: true
    });

    const html = {
      name: "div",
      attributes,
      children
    };
    return html;
  }

}

class Assist extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "assist", true);
    this.id = attributes.id || "";
    this.role = attributes.role || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.speak = null;
    this.toolTip = null;
  }

}

class Barcode extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "barcode", true);
    this.charEncoding = (0, _utils.getKeyword)({
      data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: k => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-[0-9]{2}/)
    });
    this.checksum = (0, _utils.getStringOption)(attributes.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
    this.dataColumnCount = (0, _utils.getInteger)({
      data: attributes.dataColumnCount,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.dataLength = (0, _utils.getInteger)({
      data: attributes.dataLength,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.dataPrep = (0, _utils.getStringOption)(attributes.dataPrep, ["none", "flateCompress"]);
    this.dataRowCount = (0, _utils.getInteger)({
      data: attributes.dataRowCount,
      defaultValue: -1,
      validate: x => x >= 0
    });
    this.endChar = attributes.endChar || "";
    this.errorCorrectionLevel = (0, _utils.getInteger)({
      data: attributes.errorCorrectionLevel,
      defaultValue: -1,
      validate: x => x >= 0 && x <= 8
    });
    this.id = attributes.id || "";
    this.moduleHeight = (0, _utils.getMeasurement)(attributes.moduleHeight, "5mm");
    this.moduleWidth = (0, _utils.getMeasurement)(attributes.moduleWidth, "0.25mm");
    this.printCheckDigit = (0, _utils.getInteger)({
      data: attributes.printCheckDigit,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.rowColumnRatio = (0, _utils.getRatio)(attributes.rowColumnRatio);
    this.startChar = attributes.startChar || "";
    this.textLocation = (0, _utils.getStringOption)(attributes.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
    this.truncate = (0, _utils.getInteger)({
      data: attributes.truncate,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.type = (0, _utils.getStringOption)(attributes.type ? attributes.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
    this.upsMode = (0, _utils.getStringOption)(attributes.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wideNarrowRatio = (0, _utils.getRatio)(attributes.wideNarrowRatio);
    this.encrypt = null;
    this.extras = null;
  }

}

class Bind extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bind", true);
    this.match = (0, _utils.getStringOption)(attributes.match, ["once", "dataRef", "global", "none"]);
    this.ref = attributes.ref || "";
    this.picture = null;
  }

}

class BindItems extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bindItems");
    this.connection = attributes.connection || "";
    this.labelRef = attributes.labelRef || "";
    this.ref = attributes.ref || "";
    this.valueRef = attributes.valueRef || "";
  }

}

exports.BindItems = BindItems;

class Bookend extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bookend");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class BooleanElement extends _xfa_object.Option01 {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "boolean");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$toHTML]() {
    return this[_xfa_object.$content] === 1;
  }

}

class Border extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "border", true);
    this.break = (0, _utils.getStringOption)(attributes.break, ["close", "open"]);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new _xfa_object.XFAObjectArray(4);
    this.edge = new _xfa_object.XFAObjectArray(4);
    this.extras = null;
    this.fill = null;
    this.margin = null;
  }

  [_xfa_object.$toStyle](widths, margins) {
    const edges = this.edge.children.slice();

    if (edges.length < 4) {
      const defaultEdge = edges[edges.length - 1] || new Edge({});

      for (let i = edges.length; i < 4; i++) {
        edges.push(defaultEdge);
      }
    }

    if (widths) {
      for (let i = 0; i < 4; i++) {
        widths[i] = edges[i].thickness;
      }
    }

    const edgeStyles = edges.map(node => node[_xfa_object.$toStyle]());
    const cornerStyles = this.corner.children.map(node => node[_xfa_object.$toStyle]());
    let style;

    if (this.margin) {
      style = this.margin[_xfa_object.$toStyle]();

      if (margins) {
        margins[0] = this.margin.topInset;
        margins[1] = this.margin.rightInset;
        margins[2] = this.margin.bottomInset;
        margins[3] = this.margin.leftInset;
      }
    } else {
      style = Object.create(null);
    }

    if (this.fill) {
      Object.assign(style, this.fill[_xfa_object.$toStyle]());
    }

    style.borderWidth = edgeStyles.map(s => s.width).join(" ");
    style.borderColor = edgeStyles.map(s => s.color).join(" ");
    style.borderStyle = edgeStyles.map(s => s.style).join(" ");

    if (cornerStyles.length > 0) {
      if (cornerStyles.length === 2 || cornerStyles.length === 3) {
        const last = cornerStyles[cornerStyles.length - 1];

        for (let i = cornerStyles.length; i < 4; i++) {
          cornerStyles.push(last);
        }
      }

      style.borderRadius = cornerStyles.map(s => s.radius).join(" ");
    }

    switch (this.presence) {
      case "invisible":
      case "hidden":
        style.borderStyle = "";
        break;

      case "inactive":
        style.borderStyle = "none";
        break;
    }

    return style;
  }

}

class Break extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "break", true);
    this.after = (0, _utils.getStringOption)(attributes.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.afterTarget = attributes.afterTarget || "";
    this.before = (0, _utils.getStringOption)(attributes.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.beforeTarget = attributes.beforeTarget || "";
    this.bookendLeader = attributes.bookendLeader || "";
    this.bookendTrailer = attributes.bookendTrailer || "";
    this.id = attributes.id || "";
    this.overflowLeader = attributes.overflowLeader || "";
    this.overflowTarget = attributes.overflowTarget || "";
    this.overflowTrailer = attributes.overflowTrailer || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }

}

class BreakAfter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "breakAfter", true);
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }

}

class BreakBefore extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "breakBefore", true);
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = (0, _utils.getInteger)({
      data: attributes.startNew,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = (0, _utils.getStringOption)(attributes.targetType, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }

}

class Button extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "button", true);
    this.highlight = (0, _utils.getStringOption)(attributes.highlight, ["inverted", "none", "outline", "push"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }

  [_xfa_object.$toHTML]() {
    return {
      name: "button",
      attributes: {
        class: "xfaButton",
        style: {}
      }
    };
  }

}

class Calculate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "calculate", true);
    this.id = attributes.id || "";
    this.override = (0, _utils.getStringOption)(attributes.override, ["disabled", "error", "ignore", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.script = null;
  }

}

class Caption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "caption", true);
    this.id = attributes.id || "";
    this.placement = (0, _utils.getStringOption)(attributes.placement, ["left", "bottom", "inline", "right", "top"]);
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.reserve = (0, _utils.getMeasurement)(attributes.reserve);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.font = null;
    this.margin = null;
    this.para = null;
    this.value = null;
  }

  [_xfa_object.$setValue](value) {
    _setValue(this, value);
  }

  [_xfa_object.$toHTML]() {
    if (!this.value) {
      return null;
    }

    const value = this.value[_xfa_object.$toHTML]();

    if (!value) {
      return null;
    }

    const children = [];

    if (typeof value === "string") {
      children.push({
        name: "#text",
        value
      });
    } else {
      children.push(value);
    }

    const style = (0, _html_utils.toStyle)(this, "font", "margin", "para", "visibility");

    switch (this.placement) {
      case "left":
      case "right":
        style.minWidth = (0, _html_utils.measureToString)(this.reserve);
        break;

      case "top":
      case "bottom":
        style.minHeight = (0, _html_utils.measureToString)(this.reserve);
        break;
    }

    return {
      name: "div",
      attributes: {
        style
      },
      children
    };
  }

}

class Certificate extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "certificate");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Certificates extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "certificates", true);
    this.credentialServerPolicy = (0, _utils.getStringOption)(attributes.credentialServerPolicy, ["optional", "required"]);
    this.id = attributes.id || "";
    this.url = attributes.url || "";
    this.urlPolicy = attributes.urlPolicy || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryption = null;
    this.issuers = null;
    this.keyUsage = null;
    this.oids = null;
    this.signing = null;
    this.subjectDNs = null;
  }

}

class CheckButton extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "checkButton", true);
    this.id = attributes.id || "";
    this.mark = (0, _utils.getStringOption)(attributes.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
    this.shape = (0, _utils.getStringOption)(attributes.shape, ["square", "round"]);
    this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }

  [_xfa_object.$toHTML]() {
    const style = (0, _html_utils.toStyle)(this, "border", "margin");
    const size = (0, _html_utils.measureToString)(this.size);
    style.width = style.height = size;
    let mark, radius;

    if (this.shape === "square") {
      mark = "▪";
      radius = "10%";
    } else {
      mark = "●";
      radius = "50%";
    }

    if (!style.borderRadius) {
      style.borderRadius = radius;
    }

    if (this.mark !== "default") {
      switch (this.mark) {
        case "check":
          mark = "✓";
          break;

        case "circle":
          mark = "●";
          break;

        case "cross":
          mark = "✕";
          break;

        case "diamond":
          mark = "♦";
          break;

        case "square":
          mark = "▪";
          break;

        case "star":
          mark = "★";
          break;
      }
    }

    if (size !== "10px") {
      style.fontSize = size;
      style.lineHeight = size;
      style.width = size;
      style.height = size;
    }

    return {
      name: "label",
      attributes: {
        class: "xfaLabel"
      },
      children: [{
        name: "input",
        attributes: {
          class: "xfaCheckbox",
          type: "checkbox"
        }
      }, {
        name: "span",
        attributes: {
          class: "xfaCheckboxMark",
          mark,
          style
        }
      }]
    };
  }

}

class ChoiceList extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "choiceList", true);
    this.commitOn = (0, _utils.getStringOption)(attributes.commitOn, ["select", "exit"]);
    this.id = attributes.id || "";
    this.open = (0, _utils.getStringOption)(attributes.open, ["userControl", "always", "multiSelect", "onEntry"]);
    this.textEntry = (0, _utils.getInteger)({
      data: attributes.textEntry,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }

  [_xfa_object.$toHTML]() {
    const style = (0, _html_utils.toStyle)(this, "border", "margin");
    return {
      name: "label",
      attributes: {
        class: "xfaLabel"
      },
      children: [{
        name: "select",
        attributes: {
          class: "xfaSelect",
          multiple: this.open === "multiSelect",
          style
        }
      }]
    };
  }

}

class Color extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "color", true);
    this.cSpace = (0, _utils.getStringOption)(attributes.cSpace, ["SRGB"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.value = (0, _utils.getColor)(attributes.value);
    this.extras = null;
  }

  [_xfa_object.$hasSettableValue]() {
    return false;
  }

  [_xfa_object.$toStyle]() {
    return _util.Util.makeHexColor(this.value.r, this.value.g, this.value.b);
  }

}

class Comb extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "comb");
    this.id = attributes.id || "";
    this.numberOfCells = (0, _utils.getInteger)({
      data: attributes.numberOfCells,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Connect extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "connect", true);
    this.connection = attributes.connection || "";
    this.id = attributes.id || "";
    this.ref = attributes.ref || "";
    this.usage = (0, _utils.getStringOption)(attributes.usage, ["exportAndImport", "exportOnly", "importOnly"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.picture = null;
  }

}

class ContentArea extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "contentArea", true);
    this.h = (0, _utils.getMeasurement)(attributes.h);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = (0, _utils.getMeasurement)(attributes.w);
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
  }

  [_xfa_object.$toHTML]() {
    const left = (0, _html_utils.measureToString)(this.x);
    const top = (0, _html_utils.measureToString)(this.y);
    const style = {
      position: "absolute",
      left,
      top,
      width: (0, _html_utils.measureToString)(this.w),
      height: (0, _html_utils.measureToString)(this.h)
    };
    return {
      name: "div",
      children: [],
      attributes: {
        style,
        class: "xfaContentarea",
        id: this[_xfa_object.$uid]
      }
    };
  }

}

class Corner extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "corner", true);
    this.id = attributes.id || "";
    this.inverted = (0, _utils.getInteger)({
      data: attributes.inverted,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.join = (0, _utils.getStringOption)(attributes.join, ["square", "round"]);
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.radius = (0, _utils.getMeasurement)(attributes.radius);
    this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }

  [_xfa_object.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "visibility");
    style.radius = (0, _html_utils.measureToString)(this.radius);
    return style;
  }

}

class DateElement extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "date");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = new Date(this[_xfa_object.$content].trim());
  }

  [_xfa_object.$toHTML]() {
    return this[_xfa_object.$content].toString();
  }

}

class DateTime extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "dateTime");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = new Date(this[_xfa_object.$content].trim());
  }

  [_xfa_object.$toHTML]() {
    return this[_xfa_object.$content].toString();
  }

}

class DateTimeEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "dateTimeEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.picker = (0, _utils.getStringOption)(attributes.picker, ["host", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }

  [_xfa_object.$toHTML]() {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    const html = {
      name: "input",
      attributes: {
        type: "text",
        class: "xfaTextfield",
        style
      }
    };
    return {
      name: "label",
      attributes: {
        class: "xfaLabel"
      },
      children: [html]
    };
  }

}

class Decimal extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "decimal");
    this.fracDigits = (0, _utils.getInteger)({
      data: attributes.fracDigits,
      defaultValue: 2,
      validate: x => true
    });
    this.id = attributes.id || "";
    this.leadDigits = (0, _utils.getInteger)({
      data: attributes.leadDigits,
      defaultValue: -1,
      validate: x => true
    });
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    const number = parseFloat(this[_xfa_object.$content].trim());
    this[_xfa_object.$content] = isNaN(number) ? null : number;
  }

  [_xfa_object.$toHTML]() {
    return this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : "";
  }

}

class DefaultUi extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "defaultUi", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }

}

class Desc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "desc", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }

}

class DigestMethod extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class DigestMethods extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "digestMethods", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.digestMethod = new _xfa_object.XFAObjectArray();
  }

}

class Draw extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "draw", true);
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: x => x >= 1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.rotate = (0, _utils.getInteger)({
      data: attributes.rotate,
      defaultValue: 0,
      validate: x => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.border = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.value = null;
    this.setProperty = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$setValue](value) {
    _setValue(this, value);
  }

  [_xfa_object.$toHTML]() {
    if (!this.value) {
      return null;
    }

    const style = (0, _html_utils.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "borderMarginPadding");
    const clazz = ["xfaDraw"];

    if (this.font) {
      clazz.push("xfaFont");
    }

    const attributes = {
      style,
      id: this[_xfa_object.$uid],
      class: clazz.join(" ")
    };

    if (this.name) {
      attributes.xfaName = this.name;
    }

    let html = {
      name: "div",
      attributes,
      children: []
    };
    const value = this.value ? this.value[_xfa_object.$toHTML]() : null;

    if (value === null) {
      return html;
    }

    html.children.push(value);

    if (this.para && value.attributes.class === "xfaRich") {
      const paraStyle = this.para[_xfa_object.$toStyle]();

      if (!value.attributes.style) {
        value.attributes.style = paraStyle;
      } else {
        for (const [key, val] of Object.entries(paraStyle)) {
          if (!(key in value.attributes.style)) {
            value.attributes.style[key] = val;
          }
        }
      }
    }

    html = (0, _html_utils.addExtraDivForMargin)(html);
    return html;
  }

}

class Edge extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "edge", true);
    this.cap = (0, _utils.getStringOption)(attributes.cap, ["square", "butt", "round"]);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.stroke = (0, _utils.getStringOption)(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = (0, _utils.getMeasurement)(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }

  [_xfa_object.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "visibility");
    Object.assign(style, {
      linecap: this.cap,
      width: (0, _html_utils.measureToString)(this.thickness),
      color: this.color ? this.color[_xfa_object.$toHTML]() : "#000000",
      style: ""
    });

    if (this.presence !== "visible") {
      style.style = "none";
    } else {
      switch (this.stroke) {
        case "solid":
          style.style = "solid";
          break;

        case "dashDot":
          style.style = "dashed";
          break;

        case "dashDotDot":
          style.style = "dashed";
          break;

        case "dashed":
          style.style = "dashed";
          break;

        case "dotted":
          style.style = "dotted";
          break;

        case "embossed":
          style.style = "ridge";
          break;

        case "etched":
          style.style = "groove";
          break;

        case "lowered":
          style.style = "inset";
          break;

        case "raised":
          style.style = "outset";
          break;
      }
    }

    return style;
  }

}

class Encoding extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Encodings extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encodings", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encoding = new _xfa_object.XFAObjectArray();
  }

}

class Encrypt extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encrypt", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = null;
  }

}

class EncryptData extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptData", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["encrypt", "decrypt"]);
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }

}

class Encryption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryption", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }

}

class EncryptionMethod extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class EncryptionMethods extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptionMethods", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryptionMethod = new _xfa_object.XFAObjectArray();
  }

}

class Event extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "event", true);
    this.activity = (0, _utils.getStringOption)(attributes.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
    this.id = attributes.id || "";
    this.listen = (0, _utils.getStringOption)(attributes.listen, ["refOnly", "refAndDescendents"]);
    this.name = attributes.name || "";
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.encryptData = null;
    this.execute = null;
    this.script = null;
    this.signData = null;
    this.submit = null;
  }

}

class ExData extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exData");
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.maxLength = (0, _utils.getInteger)({
      data: attributes.maxLength,
      defaultValue: -1,
      validate: x => x >= -1
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["none", "base64", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$onChild](child) {
    if (this.contentType === "text/html" && child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
      this[_xfa_object.$content] = child;
      return true;
    }

    if (this.contentType === "text/xml") {
      this[_xfa_object.$content] = child;
      return true;
    }

    return false;
  }

  [_xfa_object.$toHTML]() {
    if (this.contentType !== "text/html" || !this[_xfa_object.$content]) {
      return null;
    }

    return this[_xfa_object.$content][_xfa_object.$toHTML]();
  }

}

class ExObject extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exObject", true);
    this.archive = attributes.archive || "";
    this.classId = attributes.classId || "";
    this.codeBase = attributes.codeBase || "";
    this.codeType = attributes.codeType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }

}

class ExclGroup extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exclGroup", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: x => x >= 1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.connect = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$hasSettableValue]() {
    return true;
  }

  [_xfa_object.$setValue](value) {
    for (const field of this.field.children) {
      if (!field.value) {
        const nodeValue = new Value({});

        field[_xfa_object.$appendChild](nodeValue);

        field.value = nodeValue;
      }

      const nodeBoolean = new BooleanElement({});
      nodeBoolean[_xfa_object.$content] = 0;

      for (const item of field.items.children) {
        if (item[_xfa_object.$hasItem](value)) {
          nodeBoolean[_xfa_object.$content] = 1;
          break;
        }
      }

      field.value[_xfa_object.$setValue](nodeBoolean);
    }
  }

  [_xfa_object.$toHTML]() {
    if (!this.value) {
      return null;
    }

    const style = (0, _html_utils.toStyle)(this, "dimensions", "position", "anchorType");
    const attributes = {
      style,
      id: this[_xfa_object.$uid],
      class: "xfaExclgroup"
    };

    const children = this[_xfa_object.$childrenToHTML]({
      filter: new Set(["field"]),
      include: true
    });

    return {
      name: "div",
      attributes,
      children
    };
  }

}

class Execute extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "execute");
    this.connection = attributes.connection || "";
    this.executeType = (0, _utils.getStringOption)(attributes.executeType, ["import", "remerge"]);
    this.id = attributes.id || "";
    this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Extras extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "extras", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.extras = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }

}

class Field extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "field", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: x => x >= 1
    });
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.rotate = (0, _utils.getInteger)({
      data: attributes.rotate,
      defaultValue: 0,
      validate: x => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.format = null;
    this.items = new _xfa_object.XFAObjectArray(2);
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.validate = null;
    this.value = null;
    this.bindItems = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$setValue](value) {
    _setValue(this, value);
  }

  [_xfa_object.$toHTML]() {
    if (!this.ui) {
      return null;
    }

    const style = (0, _html_utils.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "borderMarginPadding");
    const clazz = ["xfaField"];

    if (this.font) {
      clazz.push("xfaFont");
    }

    const attributes = {
      style,
      id: this[_xfa_object.$uid],
      class: clazz.join(" ")
    };

    if (this.name) {
      attributes.xfaName = this.name;
    }

    const children = [];
    let html = {
      name: "div",
      attributes,
      children
    };
    const ui = this.ui ? this.ui[_xfa_object.$toHTML]() : null;

    if (!ui) {
      return html;
    }

    if (!ui.attributes.style) {
      ui.attributes.style = Object.create(null);
    }

    children.push(ui);

    if (this.value && ui.name !== "button") {
      ui.children[0].attributes.value = this.value[_xfa_object.$toHTML]().value;
    }

    const caption = this.caption ? this.caption[_xfa_object.$toHTML]() : null;

    if (!caption) {
      return html;
    }

    if (ui.name === "button") {
      ui.attributes.style.background = style.background;
      delete style.background;

      if (caption.name === "div") {
        caption.name = "span";
      }

      ui.children = [caption];
      return html;
    }

    ui.children.splice(0, 0, caption);

    switch (this.caption.placement) {
      case "left":
        ui.attributes.style.flexDirection = "row";
        break;

      case "right":
        ui.attributes.style.flexDirection = "row-reverse";
        break;

      case "top":
        ui.attributes.style.flexDirection = "column";
        break;

      case "bottom":
        ui.attributes.style.flexDirection = "column-reverse";
        break;

      case "inline":
        delete ui.attributes.class;
        caption.attributes.style.float = "left";
        break;
    }

    html = (0, _html_utils.addExtraDivForMargin)(html);
    return html;
  }

}

exports.Field = Field;

class Fill extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "fill", true);
    this.id = attributes.id || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
    this.linear = null;
    this.pattern = null;
    this.radial = null;
    this.solid = null;
    this.stipple = null;
  }

  [_xfa_object.$toStyle]() {
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "extras" || name === "color") {
        continue;
      }

      const obj = this[name];

      if (!(obj instanceof _xfa_object.XFAObject)) {
        continue;
      }

      return {
        color: obj[_xfa_object.$toStyle](this.color)
      };
    }

    if (this.color) {
      return {
        background: this.color[_xfa_object.$toStyle]()
      };
    }

    return {};
  }

}

class Filter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "filter", true);
    this.addRevocationInfo = (0, _utils.getStringOption)(attributes.addRevocationInfo, ["", "required", "optional", "none"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.version = (0, _utils.getInteger)({
      data: this.version,
      defaultValue: 5,
      validate: x => x >= 1 && x <= 5
    });
    this.appearanceFilter = null;
    this.certificates = null;
    this.digestMethods = null;
    this.encodings = null;
    this.encryptionMethods = null;
    this.handler = null;
    this.lockDocument = null;
    this.mdp = null;
    this.reasons = null;
    this.timeStamp = null;
  }

}

class Float extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "float");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    const number = parseFloat(this[_xfa_object.$content].trim());
    this[_xfa_object.$content] = isNaN(number) ? null : number;
  }

  [_xfa_object.$toHTML]() {
    return this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : "";
  }

}

class Font extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "font", true);
    this.baselineShift = (0, _utils.getMeasurement)(attributes.baselineShift);
    this.fontHorizontalScale = (0, _utils.getFloat)({
      data: attributes.fontHorizontalScale,
      defaultValue: 100,
      validate: x => x >= 0
    });
    this.fontVerticalScale = (0, _utils.getFloat)({
      data: attributes.fontVerticalScale,
      defaultValue: 100,
      validate: x => x >= 0
    });
    this.id = attributes.id || "";
    this.kerningMode = (0, _utils.getStringOption)(attributes.kerningMode, ["none", "pair"]);
    this.letterSpacing = (0, _utils.getMeasurement)(attributes.letterSpacing, "0");
    this.lineThrough = (0, _utils.getInteger)({
      data: attributes.lineThrough,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.lineThroughPeriod = (0, _utils.getStringOption)(attributes.lineThroughPeriod, ["all", "word"]);
    this.overline = (0, _utils.getInteger)({
      data: attributes.overline,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.overlinePeriod = (0, _utils.getStringOption)(attributes.overlinePeriod, ["all", "word"]);
    this.posture = (0, _utils.getStringOption)(attributes.posture, ["normal", "italic"]);
    this.size = (0, _utils.getMeasurement)(attributes.size, "10pt");
    this.typeface = attributes.typeface || "";
    this.underline = (0, _utils.getInteger)({
      data: attributes.underline,
      defaultValue: 0,
      validate: x => x === 1 || x === 2
    });
    this.underlinePeriod = (0, _utils.getStringOption)(attributes.underlinePeriod, ["all", "word"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.weight = (0, _utils.getStringOption)(attributes.weight, ["normal", "bold"]);
    this.extras = null;
    this.fill = null;
  }

  [_xfa_object.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "fill");
    const color = style.background;

    if (color) {
      if (color === "#000000") {
        delete style.background;
      } else if (!color.startsWith("#")) {
        style.backgroundClip = "text";
        style.color = "transparent";
      } else {
        style.color = color;
        delete style.background;
      }
    }

    if (this.baselineShift) {
      style.verticalAlign = (0, _html_utils.measureToString)(this.baselineShift);
    }

    if (this.kerningMode !== "none") {
      style.fontKerning = "normal";
    }

    if (this.letterSpacing) {
      style.letterSpacing = (0, _html_utils.measureToString)(this.letterSpacing);
    }

    if (this.lineThrough !== 0) {
      style.textDecoration = "line-through";

      if (this.lineThrough === 2) {
        style.textDecorationStyle = "double";
      }
    }

    if (this.overline !== 0) {
      style.textDecoration = "overline";

      if (this.overline === 2) {
        style.textDecorationStyle = "double";
      }
    }

    if (this.posture !== "normal") {
      style.fontStyle = this.posture;
    }

    const fontSize = (0, _html_utils.measureToString)(this.size);

    if (fontSize !== "10px") {
      style.fontSize = fontSize;
    }

    style.fontFamily = this.typeface;

    if (this.underline !== 0) {
      style.textDecoration = "underline";

      if (this.underline === 2) {
        style.textDecorationStyle = "double";
      }
    }

    if (this.weight !== "normal") {
      style.fontWeight = this.weight;
    }

    return style;
  }

}

class Format extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "format", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
  }

}

class Handler extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "handler");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Hyphenation extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "hyphenation");
    this.excludeAllCaps = (0, _utils.getInteger)({
      data: attributes.excludeAllCaps,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.excludeInitialCap = (0, _utils.getInteger)({
      data: attributes.excludeInitialCap,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hyphenate = (0, _utils.getInteger)({
      data: attributes.hyphenate,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.id = attributes.id || "";
    this.pushCharacterCount = (0, _utils.getInteger)({
      data: attributes.pushCharacterCount,
      defaultValue: 3,
      validate: x => x >= 0
    });
    this.remainCharacterCount = (0, _utils.getInteger)({
      data: attributes.remainCharacterCount,
      defaultValue: 3,
      validate: x => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wordCharacterCount = (0, _utils.getInteger)({
      data: attributes.wordCharacterCount,
      defaultValue: 7,
      validate: x => x >= 0
    });
  }

}

class Image extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "image");
    this.aspect = (0, _utils.getStringOption)(attributes.aspect, ["fit", "actual", "height", "none", "width"]);
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.transferEncoding = (0, _utils.getStringOption)(attributes.transferEncoding, ["base64", "none", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$toHTML]() {
    if (this.href || !this[_xfa_object.$content]) {
      return null;
    }

    if (this.transferEncoding === "base64") {
      const buffer = (0, _util.stringToBytes)(atob(this[_xfa_object.$content]));
      const blob = new Blob([buffer], {
        type: this.contentType
      });
      return {
        name: "img",
        attributes: {
          class: "xfaImage",
          style: {},
          src: URL.createObjectURL(blob)
        }
      };
    }

    return null;
  }

}

class ImageEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "imageEdit", true);
    this.data = (0, _utils.getStringOption)(attributes.data, ["link", "embed"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }

}

class Integer extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "integer");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    const number = parseInt(this[_xfa_object.$content].trim(), 10);
    this[_xfa_object.$content] = isNaN(number) ? null : number;
  }

  [_xfa_object.$toHTML]() {
    return this[_xfa_object.$content] !== null ? this[_xfa_object.$content].toString() : "";
  }

}

class Issuers extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "issuers", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }

}

class Items extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "items", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.ref = attributes.ref || "";
    this.save = (0, _utils.getInteger)({
      data: attributes.save,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$hasItem](value) {
    return this.hasOwnProperty(value[_xfa_object.$nodeName]) && this[value[_xfa_object.$nodeName]].children.some(node => node[_xfa_object.$content] === value[_xfa_object.$content]);
  }

}

exports.Items = Items;

class Keep extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "keep", true);
    this.id = attributes.id || "";
    const options = ["none", "contentArea", "pageArea"];
    this.intact = (0, _utils.getStringOption)(attributes.intact, options);
    this.next = (0, _utils.getStringOption)(attributes.next, options);
    this.previous = (0, _utils.getStringOption)(attributes.previous, options);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }

}

class KeyUsage extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "keyUsage");
    const options = ["", "yes", "no"];
    this.crlSign = (0, _utils.getStringOption)(attributes.crlSign, options);
    this.dataEncipherment = (0, _utils.getStringOption)(attributes.dataEncipherment, options);
    this.decipherOnly = (0, _utils.getStringOption)(attributes.decipherOnly, options);
    this.digitalSignature = (0, _utils.getStringOption)(attributes.digitalSignature, options);
    this.encipherOnly = (0, _utils.getStringOption)(attributes.encipherOnly, options);
    this.id = attributes.id || "";
    this.keyAgreement = (0, _utils.getStringOption)(attributes.keyAgreement, options);
    this.keyCertSign = (0, _utils.getStringOption)(attributes.keyCertSign, options);
    this.keyEncipherment = (0, _utils.getStringOption)(attributes.keyEncipherment, options);
    this.nonRepudiation = (0, _utils.getStringOption)(attributes.nonRepudiation, options);
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Line extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "line", true);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.slope = (0, _utils.getStringOption)(attributes.slope, ["\\", "/"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
  }

}

class Linear extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "linear", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["toRight", "toBottom", "toLeft", "toTop"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }

  [_xfa_object.$toStyle](startColor) {
    startColor = startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
    const transf = this.type.replace(/([RBLT])/, " $1").toLowerCase();
    const endColor = this.color ? this.color[_xfa_object.$toStyle]() : "#000000";
    return `linear-gradient(${transf}, ${startColor}, ${endColor})`;
  }

}

class LockDocument extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "lockDocument");
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = (0, _utils.getStringOption)(this[_xfa_object.$content], ["auto", "0", "1"]);
  }

}

class Manifest extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "manifest", true);
    this.action = (0, _utils.getStringOption)(attributes.action, ["include", "all", "exclude"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.ref = new _xfa_object.XFAObjectArray();
  }

}

class Margin extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "margin", true);
    this.bottomInset = (0, _utils.getMeasurement)(attributes.bottomInset, "0");
    this.id = attributes.id || "";
    this.leftInset = (0, _utils.getMeasurement)(attributes.leftInset, "0");
    this.rightInset = (0, _utils.getMeasurement)(attributes.rightInset, "0");
    this.topInset = (0, _utils.getMeasurement)(attributes.topInset, "0");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }

  [_xfa_object.$toStyle]() {
    return {
      margin: (0, _html_utils.measureToString)(this.topInset) + " " + (0, _html_utils.measureToString)(this.rightInset) + " " + (0, _html_utils.measureToString)(this.bottomInset) + " " + (0, _html_utils.measureToString)(this.leftInset)
    };
  }

}

class Mdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "mdp");
    this.id = attributes.id || "";
    this.permissions = (0, _utils.getInteger)({
      data: attributes.permissions,
      defaultValue: 2,
      validate: x => x === 1 || x === 3
    });
    this.signatureType = (0, _utils.getStringOption)(attributes.signatureType, ["filler", "author"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Medium extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "medium");
    this.id = attributes.id || "";
    this.imagingBBox = (0, _utils.getBBox)(attributes.imagingBBox);
    this.long = (0, _utils.getMeasurement)(attributes.long);
    this.orientation = (0, _utils.getStringOption)(attributes.orientation, ["portrait", "landscape"]);
    this.short = (0, _utils.getMeasurement)(attributes.short);
    this.stock = attributes.stock || "";
    this.trayIn = (0, _utils.getStringOption)(attributes.trayIn, ["auto", "delegate", "pageFront"]);
    this.trayOut = (0, _utils.getStringOption)(attributes.trayOut, ["auto", "delegate"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Message extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "message", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.text = new _xfa_object.XFAObjectArray();
  }

}

class NumericEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "numericEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }

  [_xfa_object.$toHTML]() {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    const html = {
      name: "input",
      attributes: {
        type: "text",
        class: "xfaTextfield",
        style
      }
    };
    return {
      name: "label",
      attributes: {
        class: "xfaLabel"
      },
      children: [html]
    };
  }

}

class Occur extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "occur", true);
    this.id = attributes.id || "";
    this.initial = (0, _utils.getInteger)({
      data: attributes.initial,
      defaultValue: 1,
      validate: x => true
    });
    this.max = (0, _utils.getInteger)({
      data: attributes.max,
      defaultValue: 1,
      validate: x => true
    });
    this.min = (0, _utils.getInteger)({
      data: attributes.min,
      defaultValue: 1,
      validate: x => true
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }

}

class Oid extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "oid");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Oids extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "oids", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.oid = new _xfa_object.XFAObjectArray();
  }

}

class Overflow extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "overflow");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.target = attributes.target || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class PageArea extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pageArea", true);
    this.blankOrNotBlank = (0, _utils.getStringOption)(attributes.blankOrNotBlank, ["any", "blank", "notBlank"]);
    this.id = attributes.id || "";
    this.initialNumber = (0, _utils.getInteger)({
      data: attributes.initialNumber,
      defaultValue: 1,
      validate: x => true
    });
    this.name = attributes.name || "";
    this.numbered = (0, _utils.getInteger)({
      data: attributes.numbered,
      defaultValue: 1,
      validate: x => true
    });
    this.oddOrEven = (0, _utils.getStringOption)(attributes.oddOrEven, ["any", "even", "odd"]);
    this.pagePosition = (0, _utils.getStringOption)(attributes.pagePosition, ["any", "first", "last", "only", "rest"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.desc = null;
    this.extras = null;
    this.medium = null;
    this.occur = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.contentArea = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$toHTML]() {
    if (this.contentArea.children.length === 0) {
      return null;
    }

    const children = this[_xfa_object.$childrenToHTML]({
      filter: new Set(["area", "draw", "field", "subform", "contentArea"]),
      include: true
    });

    const contentArea = children.find(node => node.attributes.class === "xfaContentarea");
    const style = Object.create(null);

    if (this.medium && this.medium.short && this.medium.long) {
      style.width = (0, _html_utils.measureToString)(this.medium.short);
      style.height = (0, _html_utils.measureToString)(this.medium.long);
    } else {}

    return {
      name: "div",
      children,
      attributes: {
        id: this[_xfa_object.$uid],
        style
      },
      contentArea
    };
  }

}

class PageSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pageSet", true);
    this.duplexImposition = (0, _utils.getStringOption)(attributes.duplexImposition, ["longEdge", "shortEdge"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = (0, _utils.getStringOption)(attributes.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.occur = null;
    this.pageArea = new _xfa_object.XFAObjectArray();
    this.pageSet = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$toHTML]() {
    return {
      name: "div",
      children: this[_xfa_object.$childrenToHTML]({
        filter: new Set(["pageArea", "pageSet"]),
        include: true
      }),
      attributes: {
        id: this[_xfa_object.$uid]
      }
    };
  }

}

class Para extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "para", true);
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.lineHeight = attributes.lineHeight ? (0, _utils.getMeasurement)(attributes.lineHeight, "0pt") : "";
    this.marginLeft = attributes.marginLeft ? (0, _utils.getMeasurement)(attributes.marginLeft, "0pt") : "";
    this.marginRight = attributes.marginRight ? (0, _utils.getMeasurement)(attributes.marginRight, "0pt") : "";
    this.orphans = (0, _utils.getInteger)({
      data: attributes.orphans,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.preserve = attributes.preserve || "";
    this.radixOffset = attributes.radixOffset ? (0, _utils.getMeasurement)(attributes.radixOffset, "0pt") : "";
    this.spaceAbove = attributes.spaceAbove ? (0, _utils.getMeasurement)(attributes.spaceAbove, "0pt") : "";
    this.spaceBelow = attributes.spaceBelow ? (0, _utils.getMeasurement)(attributes.spaceBelow, "0pt") : "";
    this.tabDefault = attributes.tabDefault ? (0, _utils.getMeasurement)(this.tabDefault) : "";
    this.tabStops = (attributes.tabStops || "").trim().split(/\s+/).map((x, i) => i % 2 === 1 ? (0, _utils.getMeasurement)(x) : x);
    this.textIndent = attributes.textIndent ? (0, _utils.getMeasurement)(attributes.textIndent, "0pt") : "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vAlign = (0, _utils.getStringOption)(attributes.vAlign, ["top", "bottom", "middle"]);
    this.widows = (0, _utils.getInteger)({
      data: attributes.widows,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.hyphenation = null;
  }

  [_xfa_object.$toStyle]() {
    const style = (0, _html_utils.toStyle)(this, "hAlign");

    if (this.marginLeft !== "") {
      style.marginLeft = (0, _html_utils.measureToString)(this.marginLeft);
    }

    if (this.marginRight !== "") {
      style.marginRight = (0, _html_utils.measureToString)(this.marginRight);
    }

    if (this.spaceAbove !== "") {
      style.marginTop = (0, _html_utils.measureToString)(this.spaceAbove);
    }

    if (this.spaceBelow !== "") {
      style.marginBottom = (0, _html_utils.measureToString)(this.spaceBelow);
    }

    if (this.textIndent !== "") {
      style.textIndent = (0, _html_utils.measureToString)(this.textIndent);
    }

    if (this.lineHeight !== "") {
      style.lineHeight = (0, _html_utils.measureToString)(this.lineHeight);
    }

    if (this.tabDefault !== "") {
      style.tabSize = (0, _html_utils.measureToString)(this.tabDefault);
    }

    if (this.tabStops.length > 0) {}

    if (this.hyphenatation) {
      Object.assign(style, this.hyphenatation[_xfa_object.$toStyle]());
    }

    return style;
  }

}

class PasswordEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "passwordEdit", true);
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.passwordChar = attributes.passwordChar || "*";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }

}

class Pattern extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "pattern", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }

  [_xfa_object.$toStyle](startColor) {
    startColor = startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[_xfa_object.$toStyle]() : "#000000";
    const width = 5;
    const cmd = "repeating-linear-gradient";
    const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`;

    switch (this.type) {
      case "crossHatch":
        return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;

      case "crossDiagonal":
        return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;

      case "diagonalLeft":
        return `${cmd}(45deg,${colors})`;

      case "diagonalRight":
        return `${cmd}(-45deg,${colors})`;

      case "horizontal":
        return `${cmd}(to top,${colors})`;

      case "vertical":
        return `${cmd}(to right,${colors})`;
    }

    return "";
  }

}

class Picture extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "picture");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Proto extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "proto", true);
    this.appearanceFilter = new _xfa_object.XFAObjectArray();
    this.arc = new _xfa_object.XFAObjectArray();
    this.area = new _xfa_object.XFAObjectArray();
    this.assist = new _xfa_object.XFAObjectArray();
    this.barcode = new _xfa_object.XFAObjectArray();
    this.bindItems = new _xfa_object.XFAObjectArray();
    this.bookend = new _xfa_object.XFAObjectArray();
    this.boolean = new _xfa_object.XFAObjectArray();
    this.border = new _xfa_object.XFAObjectArray();
    this.break = new _xfa_object.XFAObjectArray();
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.button = new _xfa_object.XFAObjectArray();
    this.calculate = new _xfa_object.XFAObjectArray();
    this.caption = new _xfa_object.XFAObjectArray();
    this.certificate = new _xfa_object.XFAObjectArray();
    this.certificates = new _xfa_object.XFAObjectArray();
    this.checkButton = new _xfa_object.XFAObjectArray();
    this.choiceList = new _xfa_object.XFAObjectArray();
    this.color = new _xfa_object.XFAObjectArray();
    this.comb = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.contentArea = new _xfa_object.XFAObjectArray();
    this.corner = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.dateTimeEdit = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.defaultUi = new _xfa_object.XFAObjectArray();
    this.desc = new _xfa_object.XFAObjectArray();
    this.digestMethod = new _xfa_object.XFAObjectArray();
    this.digestMethods = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.edge = new _xfa_object.XFAObjectArray();
    this.encoding = new _xfa_object.XFAObjectArray();
    this.encodings = new _xfa_object.XFAObjectArray();
    this.encrypt = new _xfa_object.XFAObjectArray();
    this.encryptData = new _xfa_object.XFAObjectArray();
    this.encryption = new _xfa_object.XFAObjectArray();
    this.encryptionMethod = new _xfa_object.XFAObjectArray();
    this.encryptionMethods = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.execute = new _xfa_object.XFAObjectArray();
    this.extras = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.fill = new _xfa_object.XFAObjectArray();
    this.filter = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.font = new _xfa_object.XFAObjectArray();
    this.format = new _xfa_object.XFAObjectArray();
    this.handler = new _xfa_object.XFAObjectArray();
    this.hyphenation = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.imageEdit = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.issuers = new _xfa_object.XFAObjectArray();
    this.items = new _xfa_object.XFAObjectArray();
    this.keep = new _xfa_object.XFAObjectArray();
    this.keyUsage = new _xfa_object.XFAObjectArray();
    this.line = new _xfa_object.XFAObjectArray();
    this.linear = new _xfa_object.XFAObjectArray();
    this.lockDocument = new _xfa_object.XFAObjectArray();
    this.manifest = new _xfa_object.XFAObjectArray();
    this.margin = new _xfa_object.XFAObjectArray();
    this.mdp = new _xfa_object.XFAObjectArray();
    this.medium = new _xfa_object.XFAObjectArray();
    this.message = new _xfa_object.XFAObjectArray();
    this.numericEdit = new _xfa_object.XFAObjectArray();
    this.occur = new _xfa_object.XFAObjectArray();
    this.oid = new _xfa_object.XFAObjectArray();
    this.oids = new _xfa_object.XFAObjectArray();
    this.overflow = new _xfa_object.XFAObjectArray();
    this.pageArea = new _xfa_object.XFAObjectArray();
    this.pageSet = new _xfa_object.XFAObjectArray();
    this.para = new _xfa_object.XFAObjectArray();
    this.passwordEdit = new _xfa_object.XFAObjectArray();
    this.pattern = new _xfa_object.XFAObjectArray();
    this.picture = new _xfa_object.XFAObjectArray();
    this.radial = new _xfa_object.XFAObjectArray();
    this.reason = new _xfa_object.XFAObjectArray();
    this.reasons = new _xfa_object.XFAObjectArray();
    this.rectangle = new _xfa_object.XFAObjectArray();
    this.ref = new _xfa_object.XFAObjectArray();
    this.script = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
    this.signData = new _xfa_object.XFAObjectArray();
    this.signature = new _xfa_object.XFAObjectArray();
    this.signing = new _xfa_object.XFAObjectArray();
    this.solid = new _xfa_object.XFAObjectArray();
    this.speak = new _xfa_object.XFAObjectArray();
    this.stipple = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
    this.subjectDN = new _xfa_object.XFAObjectArray();
    this.subjectDNs = new _xfa_object.XFAObjectArray();
    this.submit = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.textEdit = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
    this.timeStamp = new _xfa_object.XFAObjectArray();
    this.toolTip = new _xfa_object.XFAObjectArray();
    this.traversal = new _xfa_object.XFAObjectArray();
    this.traverse = new _xfa_object.XFAObjectArray();
    this.ui = new _xfa_object.XFAObjectArray();
    this.validate = new _xfa_object.XFAObjectArray();
    this.value = new _xfa_object.XFAObjectArray();
    this.variables = new _xfa_object.XFAObjectArray();
  }

}

class Radial extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "radial", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["toEdge", "toCenter"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }

  [_xfa_object.$toStyle](startColor) {
    startColor = startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[_xfa_object.$toStyle]() : "#000000";
    const colors = this.type === "toEdge" ? `${startColor},${endColor}` : `${endColor},${startColor}`;
    return `radial-gradient(circle to center, ${colors})`;
  }

}

class Reason extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "reason");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Reasons extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "reasons", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.reason = new _xfa_object.XFAObjectArray();
  }

}

class Rectangle extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "rectangle", true);
    this.hand = (0, _utils.getStringOption)(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new _xfa_object.XFAObjectArray(4);
    this.edge = new _xfa_object.XFAObjectArray(4);
    this.fill = null;
  }

}

class RefElement extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "ref");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Script extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "script");
    this.binding = attributes.binding || "";
    this.contentType = attributes.contentType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.runAt = (0, _utils.getStringOption)(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class SetProperty extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "setProperty");
    this.connection = attributes.connection || "";
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
  }

}

exports.SetProperty = SetProperty;

class SignData extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signData", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["sign", "clear", "verify"]);
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }

}

class Signature extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signature", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["PDF1.3", "PDF1.6"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.filter = null;
    this.manifest = null;
    this.margin = null;
  }

}

class Signing extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "signing", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new _xfa_object.XFAObjectArray();
  }

}

class Solid extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "solid", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }

  [_xfa_object.$toStyle](startColor) {
    return startColor ? startColor[_xfa_object.$toStyle]() : "#FFFFFF";
  }

}

class Speak extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "speak");
    this.disable = (0, _utils.getInteger)({
      data: attributes.disable,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.id = attributes.id || "";
    this.priority = (0, _utils.getStringOption)(attributes.priority, ["custom", "caption", "name", "toolTip"]);
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Stipple extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "stipple", true);
    this.id = attributes.id || "";
    this.rate = (0, _utils.getInteger)({
      data: attributes.rate,
      defaultValue: 50,
      validate: x => x >= 0 && x <= 100
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }

  [_xfa_object.$toStyle](bgColor) {
    const alpha = this.rate / 100;
    return _util.Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha));
  }

}

class Subform extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subform", true);
    this.access = (0, _utils.getStringOption)(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.allowMacro = (0, _utils.getInteger)({
      data: attributes.allowMacro,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.anchorType = (0, _utils.getStringOption)(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = (0, _utils.getInteger)({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: x => x >= 1
    });
    this.columnWidths = (attributes.columnWidths || "").trim().split(/\s+/).map(x => x === "-1" ? -1 : (0, _utils.getMeasurement)(x));
    this.h = attributes.h ? (0, _utils.getMeasurement)(attributes.h) : "";
    this.hAlign = (0, _utils.getStringOption)(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = (0, _utils.getStringOption)(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.locale = attributes.locale || "";
    this.maxH = (0, _utils.getMeasurement)(attributes.maxH, "0pt");
    this.maxW = (0, _utils.getMeasurement)(attributes.maxW, "0pt");
    this.mergeMode = (0, _utils.getStringOption)(attributes.mergeMode, ["consumeData", "matchTemplate"]);
    this.minH = (0, _utils.getMeasurement)(attributes.minH, "0pt");
    this.minW = (0, _utils.getMeasurement)(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = (0, _utils.getStringOption)(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.restoreState = (0, _utils.getStringOption)(attributes.restoreState, ["manual", "auto"]);
    this.scope = (0, _utils.getStringOption)(attributes.scope, ["name", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? (0, _utils.getMeasurement)(attributes.w) : "";
    this.x = (0, _utils.getMeasurement)(attributes.x, "0pt");
    this.y = (0, _utils.getMeasurement)(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.bookend = null;
    this.border = null;
    this.break = null;
    this.calculate = null;
    this.desc = null;
    this.extras = null;
    this.keep = null;
    this.margin = null;
    this.occur = null;
    this.overflow = null;
    this.pageSet = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.variables = null;
    this.area = new _xfa_object.XFAObjectArray();
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.connect = new _xfa_object.XFAObjectArray();
    this.draw = new _xfa_object.XFAObjectArray();
    this.event = new _xfa_object.XFAObjectArray();
    this.exObject = new _xfa_object.XFAObjectArray();
    this.exclGroup = new _xfa_object.XFAObjectArray();
    this.field = new _xfa_object.XFAObjectArray();
    this.proto = new _xfa_object.XFAObjectArray();
    this.setProperty = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$toHTML]() {
    this[_xfa_object.$extra] = Object.create(null);

    if (this.layout === "row") {
      const columnWidths = this[_xfa_object.$getParent]().columnWidths;

      if (Array.isArray(columnWidths) && columnWidths.length > 0) {
        this[_xfa_object.$extra].columnWidths = columnWidths;
        this[_xfa_object.$extra].currentColumn = 0;
      }
    }

    const parent = this[_xfa_object.$getParent]();

    let page = null;

    if (parent[_xfa_object.$nodeName] === "template") {
      if (this.pageSet !== null) {
        this[_xfa_object.$extra].pageNumber = 0;
      } else {
        (0, _util.warn)("XFA - No pageSet in root subform");
      }
    } else if (parent[_xfa_object.$extra] && parent[_xfa_object.$extra].pageNumber !== undefined) {
      const pageNumber = parent[_xfa_object.$extra].pageNumber;
      const pageAreas = parent.pageSet.pageArea.children;
      parent[_xfa_object.$extra].pageNumber = (parent[_xfa_object.$extra].pageNumber + 1) % pageAreas.length;
      page = pageAreas[pageNumber][_xfa_object.$toHTML]();
    }

    const style = (0, _html_utils.toStyle)(this, "dimensions", "position", "presence");
    const clazz = ["xfaSubform"];
    const cl = (0, _html_utils.layoutClass)(this);

    if (cl) {
      clazz.push(cl);
    }

    const attributes = {
      style,
      id: this[_xfa_object.$uid],
      class: clazz.join(" ")
    };

    if (this.name) {
      attributes.xfaName = this.name;
    }

    const children = this[_xfa_object.$childrenToHTML]({
      filter: new Set(["area", "draw", "field", "subform", "subformSet"]),
      include: true
    });

    const html = {
      name: "div",
      attributes,
      children
    };

    if (page) {
      page.contentArea.children.push(html);
      delete page.contentArea;
      return page;
    }

    return html;
  }

}

class SubformSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subformSet", true);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = (0, _utils.getStringOption)(attributes.relation, ["ordered", "choice", "unordered"]);
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.bookend = null;
    this.break = null;
    this.desc = null;
    this.extras = null;
    this.occur = null;
    this.overflow = null;
    this.breakAfter = new _xfa_object.XFAObjectArray();
    this.breakBefore = new _xfa_object.XFAObjectArray();
    this.subform = new _xfa_object.XFAObjectArray();
    this.subformSet = new _xfa_object.XFAObjectArray();
  }

}

class SubjectDN extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subjectDN");
    this.delimiter = attributes.delimiter || ",";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = new Map(this[_xfa_object.$content].split(this.delimiter).map(kv => {
      kv = kv.split("=", 2);
      kv[0] = kv[0].trim();
      return kv;
    }));
  }

}

class SubjectDNs extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subjectDNs", true);
    this.id = attributes.id || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.subjectDN = new _xfa_object.XFAObjectArray();
  }

}

class Submit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "submit", true);
    this.embedPDF = (0, _utils.getInteger)({
      data: attributes.embedPDF,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.format = (0, _utils.getStringOption)(attributes.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
    this.id = attributes.id || "";
    this.target = attributes.target || "";
    this.textEncoding = (0, _utils.getKeyword)({
      data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: k => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-[0-9]{2}/)
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.xdpContent = attributes.xdpContent || "";
    this.encrypt = null;
    this.encryptData = new _xfa_object.XFAObjectArray();
    this.signData = new _xfa_object.XFAObjectArray();
  }

}

class Template extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "template", true);
    this.baseProfile = (0, _utils.getStringOption)(attributes.baseProfile, ["full", "interactiveForms"]);
    this.extras = null;
    this.subform = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$finalize]() {
    if (this.subform.children.length === 0) {
      (0, _util.warn)("XFA - No subforms in template node.");
    }

    if (this.subform.children.length >= 2) {
      (0, _util.warn)("XFA - Several subforms in template node: please file a bug.");
    }
  }

  [_xfa_object.$toHTML]() {
    if (this.subform.children.length > 0) {
      return this.subform.children[0][_xfa_object.$toHTML]();
    }

    return {
      name: "div",
      children: []
    };
  }

}

exports.Template = Template;

class Text extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "text");
    this.id = attributes.id || "";
    this.maxChars = (0, _utils.getInteger)({
      data: attributes.maxChars,
      defaultValue: 0,
      validate: x => x >= 0
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$onChild](child) {
    if (child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.xhtml.id) {
      this[_xfa_object.$content] = child;
      return true;
    }

    (0, _util.warn)(`XFA - Invalid content in Text: ${child[_xfa_object.$nodeName]}.`);
    return false;
  }

  [_xfa_object.$toHTML]() {
    if (typeof this[_xfa_object.$content] === "string") {
      const html = {
        name: "span",
        attributes: {
          class: "xfaRich",
          style: {}
        },
        value: this[_xfa_object.$content]
      };

      if (this[_xfa_object.$content].includes("\u2029")) {
        html.name = "div";
        html.children = [];

        this[_xfa_object.$content].split("\u2029").map(para => para.split(/[\u2028\n]/).reduce((acc, line) => {
          acc.push({
            name: "span",
            value: line
          }, {
            name: "br"
          });
          return acc;
        }, [])).forEach(lines => {
          html.children.push({
            name: "p",
            children: lines
          });
        });
      } else if (/[\u2028\n]/.test(this[_xfa_object.$content])) {
        html.name = "div";
        html.children = [];

        this[_xfa_object.$content].split(/[\u2028\n]/).forEach(line => {
          html.children.push({
            name: "span",
            value: line
          }, {
            name: "br"
          });
        });
      }

      return html;
    }

    return this[_xfa_object.$content][_xfa_object.$toHTML]();
  }

}

exports.Text = Text;

class TextEdit extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "textEdit", true);
    this.allowRichText = (0, _utils.getInteger)({
      data: attributes.allowRichText,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.hScrollPolicy = (0, _utils.getStringOption)(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.multiLine = (0, _utils.getInteger)({
      data: attributes.multiLine,
      defaultValue: 1,
      validate: x => x === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vScrollPolicy = (0, _utils.getStringOption)(attributes.vScrollPolicy, ["auto", "off", "on"]);
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }

  [_xfa_object.$toHTML]() {
    const style = (0, _html_utils.toStyle)(this, "border", "font", "margin");
    let html;

    if (this.multiLine === 1) {
      html = {
        name: "textarea",
        attributes: {
          class: "xfaTextfield",
          style
        }
      };
    } else {
      html = {
        name: "input",
        attributes: {
          type: "text",
          class: "xfaTextfield",
          style
        }
      };
    }

    return {
      name: "label",
      attributes: {
        class: "xfaLabel"
      },
      children: [html]
    };
  }

}

class Time extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "time");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = new Date(this[_xfa_object.$content]);
  }

  [_xfa_object.$toHTML]() {
    return this[_xfa_object.$content].toString();
  }

}

class TimeStamp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "timeStamp");
    this.id = attributes.id || "";
    this.server = attributes.server || "";
    this.type = (0, _utils.getStringOption)(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class ToolTip extends _xfa_object.StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "toolTip");
    this.id = attributes.id || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Traversal extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "traversal", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.traverse = new _xfa_object.XFAObjectArray();
  }

}

class Traverse extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "traverse", true);
    this.id = attributes.id || "";
    this.operation = (0, _utils.getStringOption)(attributes.operation, ["next", "back", "down", "first", "left", "right", "up"]);
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.script = null;
  }

  get name() {
    return this.operation;
  }

  [_xfa_object.$isTransparent]() {
    return false;
  }

}

class Ui extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "ui", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
    this.barcode = null;
    this.button = null;
    this.checkButton = null;
    this.choiceList = null;
    this.dateTimeEdit = null;
    this.defaultUi = null;
    this.imageEdit = null;
    this.numericEdit = null;
    this.passwordEdit = null;
    this.signature = null;
    this.textEdit = null;
  }

  [_xfa_object.$toHTML]() {
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "extras" || name === "picture") {
        continue;
      }

      const obj = this[name];

      if (!(obj instanceof _xfa_object.XFAObject)) {
        continue;
      }

      return obj[_xfa_object.$toHTML]();
    }

    return null;
  }

}

class Validate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "validate", true);
    this.formatTest = (0, _utils.getStringOption)(attributes.formatTest, ["warning", "disabled", "error"]);
    this.id = attributes.id || "";
    this.nullTest = (0, _utils.getStringOption)(attributes.nullTest, ["disabled", "error", "warning"]);
    this.scriptTest = (0, _utils.getStringOption)(attributes.scriptTest, ["error", "disabled", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.picture = null;
    this.script = null;
  }

}

class Value extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "value", true);
    this.id = attributes.id || "";
    this.override = (0, _utils.getInteger)({
      data: attributes.override,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.relevant = (0, _utils.getRelevant)(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.arc = null;
    this.boolean = null;
    this.date = null;
    this.dateTime = null;
    this.decimal = null;
    this.exData = null;
    this.float = null;
    this.image = null;
    this.integer = null;
    this.line = null;
    this.rectangle = null;
    this.text = null;
    this.time = null;
  }

  [_xfa_object.$setValue](value) {
    const valueName = value[_xfa_object.$nodeName];

    if (this[valueName] !== null) {
      this[valueName][_xfa_object.$content] = value[_xfa_object.$content];
      return;
    }

    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];

      if (obj instanceof _xfa_object.XFAObject) {
        this[name] = null;

        this[_xfa_object.$removeChild](obj);
      }
    }

    this[value[_xfa_object.$nodeName]] = value;

    this[_xfa_object.$appendChild](value);
  }

  [_xfa_object.$toHTML]() {
    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];

      if (!(obj instanceof _xfa_object.XFAObject)) {
        continue;
      }

      return obj[_xfa_object.$toHTML]();
    }

    return null;
  }

}

exports.Value = Value;

class Variables extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "variables", true);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new _xfa_object.XFAObjectArray();
    this.date = new _xfa_object.XFAObjectArray();
    this.dateTime = new _xfa_object.XFAObjectArray();
    this.decimal = new _xfa_object.XFAObjectArray();
    this.exData = new _xfa_object.XFAObjectArray();
    this.float = new _xfa_object.XFAObjectArray();
    this.image = new _xfa_object.XFAObjectArray();
    this.integer = new _xfa_object.XFAObjectArray();
    this.manifest = new _xfa_object.XFAObjectArray();
    this.script = new _xfa_object.XFAObjectArray();
    this.text = new _xfa_object.XFAObjectArray();
    this.time = new _xfa_object.XFAObjectArray();
  }

  [_xfa_object.$isTransparent]() {
    return true;
  }

}

class TemplateNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (TemplateNamespace.hasOwnProperty(name)) {
      const node = TemplateNamespace[name](attributes);

      node[_xfa_object.$setSetAttributes](attributes);

      return node;
    }

    return undefined;
  }

  static appearanceFilter(attrs) {
    return new AppearanceFilter(attrs);
  }

  static arc(attrs) {
    return new Arc(attrs);
  }

  static area(attrs) {
    return new Area(attrs);
  }

  static assist(attrs) {
    return new Assist(attrs);
  }

  static barcode(attrs) {
    return new Barcode(attrs);
  }

  static bind(attrs) {
    return new Bind(attrs);
  }

  static bindItems(attrs) {
    return new BindItems(attrs);
  }

  static bookend(attrs) {
    return new Bookend(attrs);
  }

  static boolean(attrs) {
    return new BooleanElement(attrs);
  }

  static border(attrs) {
    return new Border(attrs);
  }

  static break(attrs) {
    return new Break(attrs);
  }

  static breakAfter(attrs) {
    return new BreakAfter(attrs);
  }

  static breakBefore(attrs) {
    return new BreakBefore(attrs);
  }

  static button(attrs) {
    return new Button(attrs);
  }

  static calculate(attrs) {
    return new Calculate(attrs);
  }

  static caption(attrs) {
    return new Caption(attrs);
  }

  static certificate(attrs) {
    return new Certificate(attrs);
  }

  static certificates(attrs) {
    return new Certificates(attrs);
  }

  static checkButton(attrs) {
    return new CheckButton(attrs);
  }

  static choiceList(attrs) {
    return new ChoiceList(attrs);
  }

  static color(attrs) {
    return new Color(attrs);
  }

  static comb(attrs) {
    return new Comb(attrs);
  }

  static connect(attrs) {
    return new Connect(attrs);
  }

  static contentArea(attrs) {
    return new ContentArea(attrs);
  }

  static corner(attrs) {
    return new Corner(attrs);
  }

  static date(attrs) {
    return new DateElement(attrs);
  }

  static dateTime(attrs) {
    return new DateTime(attrs);
  }

  static dateTimeEdit(attrs) {
    return new DateTimeEdit(attrs);
  }

  static decimal(attrs) {
    return new Decimal(attrs);
  }

  static defaultUi(attrs) {
    return new DefaultUi(attrs);
  }

  static desc(attrs) {
    return new Desc(attrs);
  }

  static digestMethod(attrs) {
    return new DigestMethod(attrs);
  }

  static digestMethods(attrs) {
    return new DigestMethods(attrs);
  }

  static draw(attrs) {
    return new Draw(attrs);
  }

  static edge(attrs) {
    return new Edge(attrs);
  }

  static encoding(attrs) {
    return new Encoding(attrs);
  }

  static encodings(attrs) {
    return new Encodings(attrs);
  }

  static encrypt(attrs) {
    return new Encrypt(attrs);
  }

  static encryptData(attrs) {
    return new EncryptData(attrs);
  }

  static encryption(attrs) {
    return new Encryption(attrs);
  }

  static encryptionMethod(attrs) {
    return new EncryptionMethod(attrs);
  }

  static encryptionMethods(attrs) {
    return new EncryptionMethods(attrs);
  }

  static event(attrs) {
    return new Event(attrs);
  }

  static exData(attrs) {
    return new ExData(attrs);
  }

  static exObject(attrs) {
    return new ExObject(attrs);
  }

  static exclGroup(attrs) {
    return new ExclGroup(attrs);
  }

  static execute(attrs) {
    return new Execute(attrs);
  }

  static extras(attrs) {
    return new Extras(attrs);
  }

  static field(attrs) {
    return new Field(attrs);
  }

  static fill(attrs) {
    return new Fill(attrs);
  }

  static filter(attrs) {
    return new Filter(attrs);
  }

  static float(attrs) {
    return new Float(attrs);
  }

  static font(attrs) {
    return new Font(attrs);
  }

  static format(attrs) {
    return new Format(attrs);
  }

  static handler(attrs) {
    return new Handler(attrs);
  }

  static hyphenation(attrs) {
    return new Hyphenation(attrs);
  }

  static image(attrs) {
    return new Image(attrs);
  }

  static imageEdit(attrs) {
    return new ImageEdit(attrs);
  }

  static integer(attrs) {
    return new Integer(attrs);
  }

  static issuers(attrs) {
    return new Issuers(attrs);
  }

  static items(attrs) {
    return new Items(attrs);
  }

  static keep(attrs) {
    return new Keep(attrs);
  }

  static keyUsage(attrs) {
    return new KeyUsage(attrs);
  }

  static line(attrs) {
    return new Line(attrs);
  }

  static linear(attrs) {
    return new Linear(attrs);
  }

  static lockDocument(attrs) {
    return new LockDocument(attrs);
  }

  static manifest(attrs) {
    return new Manifest(attrs);
  }

  static margin(attrs) {
    return new Margin(attrs);
  }

  static mdp(attrs) {
    return new Mdp(attrs);
  }

  static medium(attrs) {
    return new Medium(attrs);
  }

  static message(attrs) {
    return new Message(attrs);
  }

  static numericEdit(attrs) {
    return new NumericEdit(attrs);
  }

  static occur(attrs) {
    return new Occur(attrs);
  }

  static oid(attrs) {
    return new Oid(attrs);
  }

  static oids(attrs) {
    return new Oids(attrs);
  }

  static overflow(attrs) {
    return new Overflow(attrs);
  }

  static pageArea(attrs) {
    return new PageArea(attrs);
  }

  static pageSet(attrs) {
    return new PageSet(attrs);
  }

  static para(attrs) {
    return new Para(attrs);
  }

  static passwordEdit(attrs) {
    return new PasswordEdit(attrs);
  }

  static pattern(attrs) {
    return new Pattern(attrs);
  }

  static picture(attrs) {
    return new Picture(attrs);
  }

  static proto(attrs) {
    return new Proto(attrs);
  }

  static radial(attrs) {
    return new Radial(attrs);
  }

  static reason(attrs) {
    return new Reason(attrs);
  }

  static reasons(attrs) {
    return new Reasons(attrs);
  }

  static rectangle(attrs) {
    return new Rectangle(attrs);
  }

  static ref(attrs) {
    return new RefElement(attrs);
  }

  static script(attrs) {
    return new Script(attrs);
  }

  static setProperty(attrs) {
    return new SetProperty(attrs);
  }

  static signData(attrs) {
    return new SignData(attrs);
  }

  static signature(attrs) {
    return new Signature(attrs);
  }

  static signing(attrs) {
    return new Signing(attrs);
  }

  static solid(attrs) {
    return new Solid(attrs);
  }

  static speak(attrs) {
    return new Speak(attrs);
  }

  static stipple(attrs) {
    return new Stipple(attrs);
  }

  static subform(attrs) {
    return new Subform(attrs);
  }

  static subformSet(attrs) {
    return new SubformSet(attrs);
  }

  static subjectDN(attrs) {
    return new SubjectDN(attrs);
  }

  static subjectDNs(attrs) {
    return new SubjectDNs(attrs);
  }

  static submit(attrs) {
    return new Submit(attrs);
  }

  static template(attrs) {
    return new Template(attrs);
  }

  static text(attrs) {
    return new Text(attrs);
  }

  static textEdit(attrs) {
    return new TextEdit(attrs);
  }

  static time(attrs) {
    return new Time(attrs);
  }

  static timeStamp(attrs) {
    return new TimeStamp(attrs);
  }

  static toolTip(attrs) {
    return new ToolTip(attrs);
  }

  static traversal(attrs) {
    return new Traversal(attrs);
  }

  static traverse(attrs) {
    return new Traverse(attrs);
  }

  static ui(attrs) {
    return new Ui(attrs);
  }

  static validate(attrs) {
    return new Validate(attrs);
  }

  static value(attrs) {
    return new Value(attrs);
  }

  static variables(attrs) {
    return new Variables(attrs);
  }

}

exports.TemplateNamespace = TemplateNamespace;

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addExtraDivForMargin = addExtraDivForMargin;
exports.layoutClass = layoutClass;
exports.measureToString = measureToString;
exports.toStyle = toStyle;

var _xfa_object = __w_pdfjs_require__(68);

var _util = __w_pdfjs_require__(2);

function measureToString(m) {
  if (typeof m === "string") {
    return "0px";
  }

  return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`;
}

const converters = {
  anchorType(node, style) {
    if (!("transform" in style)) {
      style.transform = "";
    }

    switch (node.anchorType) {
      case "bottomCenter":
        style.transform += "translate(-50%, -100%)";
        break;

      case "bottomLeft":
        style.transform += "translate(0,-100%)";
        break;

      case "bottomRight":
        style.transform += "translate(-100%,-100%)";
        break;

      case "middleCenter":
        style.transform += "translate(-50%,-50%)";
        break;

      case "middleLeft":
        style.transform += "translate(0,-50%)";
        break;

      case "middleRight":
        style.transform += "translate(-100%,-50%)";
        break;

      case "topCenter":
        style.transform += "translate(-50%,0)";
        break;

      case "topRight":
        style.transform += "translate(-100%,0)";
        break;
    }
  },

  dimensions(node, style) {
    const parent = node[_xfa_object.$getParent]();

    const extra = parent[_xfa_object.$extra];
    let width = node.w;

    if (extra && extra.columnWidths) {
      width = extra.columnWidths[extra.currentColumn];
      extra.currentColumn = (extra.currentColumn + 1) % extra.columnWidths.length;
    }

    if (width !== "") {
      style.width = measureToString(width);
    } else {
      style.width = "auto";

      if (node.maxW > 0) {
        style.maxWidth = measureToString(node.maxW);
      }

      style.minWidth = measureToString(node.minW);
    }

    if (node.h !== "") {
      style.height = measureToString(node.h);
    } else {
      style.height = "auto";

      if (node.maxH > 0) {
        style.maxHeight = measureToString(node.maxH);
      }

      style.minHeight = measureToString(node.minH);
    }
  },

  position(node, style) {
    const parent = node[_xfa_object.$getParent]();

    if (parent && parent.layout && parent.layout !== "position") {
      return;
    }

    style.position = "absolute";
    style.left = measureToString(node.x);
    style.top = measureToString(node.y);
  },

  rotate(node, style) {
    if (node.rotate) {
      if (!("transform" in style)) {
        style.transform = "";
      }

      style.transform += `rotate(-${node.rotate}deg)`;
      style.transformOrigin = "top left";
    }
  },

  presence(node, style) {
    switch (node.presence) {
      case "invisible":
        style.visibility = "hidden";
        break;

      case "hidden":
      case "inactive":
        style.display = "none";
        break;
    }
  },

  hAlign(node, style) {
    switch (node.hAlign) {
      case "justifyAll":
        style.textAlign = "justify-all";
        break;

      case "radix":
        style.textAlign = "left";
        break;

      default:
        style.textAlign = node.hAlign;
    }
  },

  borderMarginPadding(node, style) {
    const borderWidths = [0, 0, 0, 0];
    const marginWidths = [0, 0, 0, 0];
    const marginNode = node.margin ? [node.margin.topInset, node.margin.rightInset, node.margin.bottomInset, node.margin.leftInset] : [0, 0, 0, 0];

    if (node.border) {
      Object.assign(style, node.border[_xfa_object.$toStyle](borderWidths, marginWidths));
    }

    if (borderWidths.every(x => x === 0)) {
      if (node.margin) {
        Object.assign(style, node.margin[_xfa_object.$toStyle]());
      }

      style.padding = style.margin;
      delete style.margin;
    } else {
      style.padding = measureToString(marginNode[0] - borderWidths[0] - marginWidths[0]) + " " + measureToString(marginNode[1] - borderWidths[1] - marginWidths[1]) + " " + measureToString(marginNode[2] - borderWidths[2] - marginWidths[2]) + " " + measureToString(marginNode[3] - borderWidths[3] - marginWidths[3]);
    }
  }

};

function layoutClass(node) {
  switch (node.layout) {
    case "position":
      return "xfaPosition";

    case "lr-tb":
      return "xfaLrTb";

    case "rl-row":
      return "xfaRlRow";

    case "rl-tb":
      return "xfaRlTb";

    case "row":
      return "xfaRow";

    case "table":
      return "xfaTable";

    case "tb":
      return "xfaTb";

    default:
      return "xfaPosition";
  }
}

function toStyle(node, ...names) {
  const style = Object.create(null);

  for (const name of names) {
    const value = node[name];

    if (value === null) {
      continue;
    }

    if (value instanceof _xfa_object.XFAObject) {
      const newStyle = value[_xfa_object.$toStyle]();

      if (newStyle) {
        Object.assign(style, newStyle);
      } else {
        (0, _util.warn)(`(DEBUG) - XFA - style for ${name} not implemented yet`);
      }

      continue;
    }

    if (converters.hasOwnProperty(name)) {
      converters[name](node, style);
    }
  }

  return style;
}

function addExtraDivForMargin(html) {
  const style = html.attributes.style;

  if (style.margin) {
    const padding = style.margin;
    delete style.margin;
    const width = style.width || "auto";
    const height = style.height || "auto";
    style.width = "100%";
    style.height = "100%";
    return {
      name: "div",
      attributes: {
        style: {
          padding,
          width,
          height
        }
      },
      children: [html]
    };
  }

  return html;
}

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createDataNode = createDataNode;
exports.searchNode = searchNode;

var _xfa_object = __w_pdfjs_require__(68);

var _util = __w_pdfjs_require__(2);

const namePattern = /^[^.[]+/;
const indexPattern = /^[^\]]+/;
const operators = {
  dot: 0,
  dotDot: 1,
  dotHash: 2,
  dotBracket: 3,
  dotParen: 4
};
const shortcuts = new Map([["$data", (root, current) => root.datasets.data], ["$template", (root, current) => root.template], ["$connectionSet", (root, current) => root.connectionSet], ["$form", (root, current) => root.form], ["$layout", (root, current) => root.layout], ["$host", (root, current) => root.host], ["$dataWindow", (root, current) => root.dataWindow], ["$event", (root, current) => root.event], ["!", (root, current) => root.datasets], ["$xfa", (root, current) => root], ["xfa", (root, current) => root], ["$", (root, current) => current]]);
const somCache = new WeakMap();

function parseIndex(index) {
  index = index.trim();

  if (index === "*") {
    return Infinity;
  }

  return parseInt(index, 10) || 0;
}

function parseExpression(expr, dotDotAllowed) {
  let match = expr.match(namePattern);

  if (!match) {
    return null;
  }

  let [name] = match;
  const parsed = [{
    name,
    cacheName: "." + name,
    index: 0,
    js: null,
    formCalc: null,
    operator: operators.dot
  }];
  let pos = name.length;

  while (pos < expr.length) {
    const spos = pos;
    const char = expr.charAt(pos++);

    if (char === "[") {
      match = expr.slice(pos).match(indexPattern);

      if (!match) {
        (0, _util.warn)("XFA - Invalid index in SOM expression");
        return null;
      }

      parsed[parsed.length - 1].index = parseIndex(match[0]);
      pos += match[0].length + 1;
      continue;
    }

    let operator;

    switch (expr.charAt(pos)) {
      case ".":
        if (!dotDotAllowed) {
          return null;
        }

        pos++;
        operator = operators.dotDot;
        break;

      case "#":
        pos++;
        operator = operators.dotHash;
        break;

      case "[":
        operator = operators.dotBracket;
        break;

      case "(":
        operator = operators.dotParen;
        break;

      default:
        operator = operators.dot;
        break;
    }

    match = expr.slice(pos).match(namePattern);

    if (!match) {
      break;
    }

    [name] = match;
    pos += name.length;
    parsed.push({
      name,
      cacheName: expr.slice(spos, pos),
      operator,
      index: 0,
      js: null,
      formCalc: null
    });
  }

  return parsed;
}

function searchNode(root, container, expr, dotDotAllowed = true, useCache = true) {
  const parsed = parseExpression(expr, dotDotAllowed);

  if (!parsed) {
    return null;
  }

  const fn = shortcuts.get(parsed[0].name);
  let i = 0;
  let isQualified;

  if (fn) {
    isQualified = true;
    root = [fn(root, container)];
    i = 1;
  } else {
    isQualified = container === null;
    root = [container || root];
  }

  for (let ii = parsed.length; i < ii; i++) {
    const {
      name,
      cacheName,
      operator,
      index
    } = parsed[i];
    const nodes = [];

    for (const node of root) {
      if (!(node instanceof _xfa_object.XFAObject)) {
        continue;
      }

      let children, cached;

      if (useCache) {
        cached = somCache.get(node);

        if (!cached) {
          cached = new Map();
          somCache.set(node, cached);
        }

        children = cached.get(cacheName);
      }

      if (!children) {
        switch (operator) {
          case operators.dot:
            children = node[_xfa_object.$getChildrenByName](name, false);
            break;

          case operators.dotDot:
            children = node[_xfa_object.$getChildrenByName](name, true);
            break;

          case operators.dotHash:
            children = node[_xfa_object.$getChildrenByClass](name);

            if (children instanceof _xfa_object.XFAObjectArray) {
              children = children.children;
            } else {
              children = [children];
            }

            break;

          default:
            break;
        }

        if (useCache) {
          cached.set(cacheName, children);
        }
      }

      if (children.length > 0) {
        nodes.push(children);
      }
    }

    if (nodes.length === 0 && !isQualified && i === 0) {
      const parent = container[_xfa_object.$getParent]();

      container = parent;

      if (!container) {
        return null;
      }

      i = -1;
      root = [container];
      continue;
    }

    if (isFinite(index)) {
      root = nodes.filter(node => index < node.length).map(node => node[index]);
    } else {
      root = nodes.reduce((acc, node) => acc.concat(node), []);
    }
  }

  if (root.length === 0) {
    return null;
  }

  return root;
}

function createNodes(root, path) {
  let node = null;

  for (const {
    name,
    index
  } of path) {
    for (let i = 0; i <= index; i++) {
      node = new _xfa_object.XmlObject(root[_xfa_object.$namespaceId], name);

      root[_xfa_object.$appendChild](node);
    }

    root = node;
  }

  return node;
}

function createDataNode(root, container, expr) {
  const parsed = parseExpression(expr);

  if (!parsed) {
    return null;
  }

  if (parsed.some(x => x.operator === operators.dotDot)) {
    return null;
  }

  const fn = shortcuts.get(parsed[0].name);
  let i = 0;

  if (fn) {
    root = fn(root, container);
    i = 1;
  } else {
    root = container || root;
  }

  for (let ii = parsed.length; i < ii; i++) {
    const {
      cacheName,
      index
    } = parsed[i];

    if (!isFinite(index)) {
      parsed[i].index = 0;
      return createNodes(root, parsed.slice(i));
    }

    const cached = somCache.get(root);

    if (!cached) {
      (0, _util.warn)(`XFA - createDataNode must be called after searchNode.`);
      return null;
    }

    const children = cached.get(cacheName);

    if (children.length === 0) {
      return createNodes(root, parsed.slice(i));
    }

    if (index < children.length) {
      const child = children[index];

      if (!(child instanceof _xfa_object.XFAObject)) {
        (0, _util.warn)(`XFA - Cannot create a node.`);
        return null;
      }

      root = child;
    } else {
      parsed[i].index = children.length - index;
      return createNodes(root, parsed.slice(i));
    }
  }

  return null;
}

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XFAParser = void 0;

var _xfa_object = __w_pdfjs_require__(68);

var _xml_parser = __w_pdfjs_require__(61);

var _builder = __w_pdfjs_require__(76);

var _util = __w_pdfjs_require__(2);

class XFAParser extends _xml_parser.XMLParserBase {
  constructor() {
    super();
    this._builder = new _builder.Builder();
    this._stack = [];
    this._ids = new Map();
    this._current = this._builder.buildRoot(this._ids);
    this._errorCode = _xml_parser.XMLParserErrorCode.NoError;
    this._whiteRegex = /^\s+$/;
  }

  parse(data) {
    this.parseXml(data);

    if (this._errorCode !== _xml_parser.XMLParserErrorCode.NoError) {
      return undefined;
    }

    this._current[_xfa_object.$finalize]();

    return this._current.element;
  }

  onText(text) {
    if (this._current[_xfa_object.$acceptWhitespace]()) {
      this._current[_xfa_object.$onText](text);

      return;
    }

    if (this._whiteRegex.test(text)) {
      return;
    }

    this._current[_xfa_object.$onText](text.trim());
  }

  onCdata(text) {
    this._current[_xfa_object.$onText](text);
  }

  _mkAttributes(attributes, tagName) {
    let namespace = null;
    let prefixes = null;
    const attributeObj = Object.create({});

    for (const {
      name,
      value
    } of attributes) {
      if (name === "xmlns") {
        if (!namespace) {
          namespace = value;
        } else {
          (0, _util.warn)(`XFA - multiple namespace definition in <${tagName}>`);
        }
      } else if (name.startsWith("xmlns:")) {
        const prefix = name.substring("xmlns:".length);

        if (!prefixes) {
          prefixes = [];
        }

        prefixes.push({
          prefix,
          value
        });
      } else {
        const i = name.indexOf(":");

        if (i === -1) {
          attributeObj[name] = value;
        } else {
          let nsAttrs = attributeObj[_xfa_object.$nsAttributes];

          if (!nsAttrs) {
            nsAttrs = attributeObj[_xfa_object.$nsAttributes] = Object.create(null);
          }

          const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)];
          let attrs = nsAttrs[ns];

          if (!attrs) {
            attrs = nsAttrs[ns] = Object.create(null);
          }

          attrs[attrName] = value;
        }
      }
    }

    return [namespace, prefixes, attributeObj];
  }

  _getNameAndPrefix(name) {
    const i = name.indexOf(":");

    if (i === -1) {
      return [name, null];
    }

    return [name.substring(i + 1), name.substring(0, i)];
  }

  onBeginElement(tagName, attributes, isEmpty) {
    const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName);

    const [name, nsPrefix] = this._getNameAndPrefix(tagName);

    const node = this._builder.build({
      nsPrefix,
      name,
      attributes: attributesObj,
      namespace,
      prefixes
    });

    if (isEmpty) {
      node[_xfa_object.$finalize]();

      if (this._current[_xfa_object.$onChild](node)) {
        node[_xfa_object.$setId](this._ids);
      }

      node[_xfa_object.$clean](this._builder);

      return;
    }

    this._stack.push(this._current);

    this._current = node;
  }

  onEndElement(name) {
    const node = this._current;

    node[_xfa_object.$finalize]();

    this._current = this._stack.pop();

    if (this._current[_xfa_object.$onChild](node)) {
      node[_xfa_object.$setId](this._ids);
    }

    node[_xfa_object.$clean](this._builder);
  }

  onError(code) {
    this._errorCode = code;
  }

}

exports.XFAParser = XFAParser;

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Builder = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

var _setup = __w_pdfjs_require__(77);

var _template = __w_pdfjs_require__(72);

var _unknown = __w_pdfjs_require__(86);

var _util = __w_pdfjs_require__(2);

const _ids = Symbol();

class Root extends _xfa_object.XFAObject {
  constructor(ids) {
    super(-1, "root", Object.create(null));
    this.element = null;
    this[_ids] = ids;
  }

  [_xfa_object.$onChild](child) {
    this.element = child;
    return true;
  }

  [_xfa_object.$finalize]() {
    super[_xfa_object.$finalize]();

    if (this.element.template instanceof _template.Template) {
      this.element.template[_xfa_object.$resolvePrototypes](this[_ids]);
    }
  }

}

class Empty extends _xfa_object.XFAObject {
  constructor() {
    super(-1, "", Object.create(null));
  }

  [_xfa_object.$onChild](_) {
    return false;
  }

}

class Builder {
  constructor() {
    this._namespaceStack = [];
    this._namespacePrefixes = new Map();
    this._namespaces = new Map();
    this._nextNsId = Math.max(...Object.values(_namespaces.NamespaceIds).map(({
      id
    }) => id));
    this._currentNamespace = new _unknown.UnknownNamespace(++this._nextNsId);
  }

  buildRoot(ids) {
    return new Root(ids);
  }

  build({
    nsPrefix,
    name,
    attributes,
    namespace,
    prefixes
  }) {
    const hasNamespaceDef = namespace !== null;

    if (hasNamespaceDef) {
      this._namespaceStack.push(this._currentNamespace);

      this._currentNamespace = this._searchNamespace(namespace);
    }

    if (prefixes) {
      this._addNamespacePrefix(prefixes);
    }

    if (attributes.hasOwnProperty(_xfa_object.$nsAttributes)) {
      const dataTemplate = _setup.NamespaceSetUp.datasets;
      const nsAttrs = attributes[_xfa_object.$nsAttributes];
      let xfaAttrs = null;

      for (const [ns, attrs] of Object.entries(nsAttrs)) {
        const nsToUse = this._getNamespaceToUse(ns);

        if (nsToUse === dataTemplate) {
          xfaAttrs = {
            xfa: attrs
          };
          break;
        }
      }

      if (xfaAttrs) {
        attributes[_xfa_object.$nsAttributes] = xfaAttrs;
      } else {
        delete attributes[_xfa_object.$nsAttributes];
      }
    }

    const namespaceToUse = this._getNamespaceToUse(nsPrefix);

    const node = namespaceToUse && namespaceToUse[_namespaces.$buildXFAObject](name, attributes) || new Empty();

    if (hasNamespaceDef || prefixes) {
      node[_xfa_object.$cleanup] = {
        hasNamespace: hasNamespaceDef,
        prefixes
      };
    }

    return node;
  }

  _searchNamespace(nsName) {
    let ns = this._namespaces.get(nsName);

    if (ns) {
      return ns;
    }

    for (const [name, {
      check
    }] of Object.entries(_namespaces.NamespaceIds)) {
      if (check(nsName)) {
        ns = _setup.NamespaceSetUp[name];

        if (ns) {
          this._namespaces.set(nsName, ns);

          return ns;
        }

        break;
      }
    }

    ns = new _unknown.UnknownNamespace(++this._nextNsId);

    this._namespaces.set(nsName, ns);

    return ns;
  }

  _addNamespacePrefix(prefixes) {
    for (const {
      prefix,
      value
    } of prefixes) {
      const namespace = this._searchNamespace(value);

      let prefixStack = this._namespacePrefixes.get(prefix);

      if (!prefixStack) {
        prefixStack = [];

        this._namespacePrefixes.set(prefix, prefixStack);
      }

      prefixStack.push(namespace);
    }
  }

  _getNamespaceToUse(prefix) {
    if (!prefix) {
      return this._currentNamespace;
    }

    const prefixStack = this._namespacePrefixes.get(prefix);

    if (prefixStack && prefixStack.length > 0) {
      return prefixStack[prefixStack.length - 1];
    }

    (0, _util.warn)(`Unknown namespace prefix: ${prefix}.`);
    return null;
  }

  clean(data) {
    const {
      hasNamespace,
      prefixes
    } = data;

    if (hasNamespace) {
      this._currentNamespace = this._namespaceStack.pop();
    }

    if (prefixes) {
      prefixes.forEach(({
        prefix
      }) => {
        this._namespacePrefixes.get(prefix).pop();
      });
    }
  }

}

exports.Builder = Builder;

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NamespaceSetUp = void 0;

var _config = __w_pdfjs_require__(78);

var _connection_set = __w_pdfjs_require__(79);

var _datasets = __w_pdfjs_require__(80);

var _locale_set = __w_pdfjs_require__(81);

var _signature = __w_pdfjs_require__(82);

var _stylesheet = __w_pdfjs_require__(83);

var _template = __w_pdfjs_require__(72);

var _xdp = __w_pdfjs_require__(84);

var _xhtml = __w_pdfjs_require__(85);

const NamespaceSetUp = {
  config: _config.ConfigNamespace,
  connection: _connection_set.ConnectionSetNamespace,
  datasets: _datasets.DatasetsNamespace,
  localeSet: _locale_set.LocaleSetNamespace,
  signature: _signature.SignatureNamespace,
  stylesheet: _stylesheet.StylesheetNamespace,
  template: _template.TemplateNamespace,
  xdp: _xdp.XdpNamespace,
  xhtml: _xhtml.XhtmlNamespace
};
exports.NamespaceSetUp = NamespaceSetUp;

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConfigNamespace = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

var _utils = __w_pdfjs_require__(69);

var _util = __w_pdfjs_require__(2);

const CONFIG_NS_ID = _namespaces.NamespaceIds.config.id;

class Acrobat extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "acrobat", true);
    this.acrobat7 = null;
    this.autoSave = null;
    this.common = null;
    this.validate = null;
    this.validateApprovalSignatures = null;
    this.submitUrl = new _xfa_object.XFAObjectArray();
  }

}

class Acrobat7 extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "acrobat7", true);
    this.dynamicRender = null;
  }

}

class ADBE_JSConsole extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }

}

class ADBE_JSDebugger extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }

}

class AddSilentPrint extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addSilentPrint");
  }

}

class AddViewerPreferences extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addViewerPreferences");
  }

}

class AdjustData extends _xfa_object.Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adjustData");
  }

}

class AdobeExtensionLevel extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adobeExtensionLevel", 0, n => n >= 1 && n <= 8);
  }

}

class Agent extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "agent", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.common = new _xfa_object.XFAObjectArray();
  }

}

class AlwaysEmbed extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "alwaysEmbed");
  }

}

class Amd extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "amd");
  }

}

class Area extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "area");
    this.level = (0, _utils.getInteger)({
      data: attributes.level,
      defaultValue: 0,
      validate: n => n >= 1 && n <= 3
    });
    this.name = (0, _utils.getStringOption)(attributes.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }

}

class Attributes extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "attributes", ["preserve", "delegate", "ignore"]);
  }

}

class AutoSave extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "autoSave", ["disabled", "enabled"]);
  }

}

class Base extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "base");
  }

}

class BatchOutput extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "batchOutput");
    this.format = (0, _utils.getStringOption)(attributes.format, ["none", "concat", "zip", "zipCompress"]);
  }

}

class BehaviorOverride extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "behaviorOverride");
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = new Map(this[_xfa_object.$content].trim().split(/\s+/).filter(x => !!x && x.include(":")).map(x => x.split(":", 2)));
  }

}

class Cache extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "cache", true);
    this.templateCache = null;
  }

}

class Change extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "change");
  }

}

class Common extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "common", true);
    this.data = null;
    this.locale = null;
    this.localeSet = null;
    this.messaging = null;
    this.suppressBanner = null;
    this.template = null;
    this.validationMessaging = null;
    this.versionControl = null;
    this.log = new _xfa_object.XFAObjectArray();
  }

}

class Compress extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compress");
    this.scope = (0, _utils.getStringOption)(attributes.scope, ["imageOnly", "document"]);
  }

}

class CompressLogicalStructure extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressLogicalStructure");
  }

}

class CompressObjectStream extends _xfa_object.Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressObjectStream");
  }

}

class Compression extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compression", true);
    this.compressLogicalStructure = null;
    this.compressObjectStream = null;
    this.level = null;
    this.type = null;
  }

}

class Config extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "config", true);
    this.acrobat = null;
    this.present = null;
    this.trace = null;
    this.agent = new _xfa_object.XFAObjectArray();
  }

}

class Conformance extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "conformance", ["A", "B"]);
  }

}

class ContentCopy extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "contentCopy");
  }

}

class Copies extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "copies", 1, n => n >= 1);
  }

}

class Creator extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "creator");
  }

}

class CurrentPage extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "currentPage", 0, n => n >= 0);
  }

}

class Data extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "data", true);
    this.adjustData = null;
    this.attributes = null;
    this.incrementalLoad = null;
    this.outputXSL = null;
    this.range = null;
    this.record = null;
    this.startNode = null;
    this.uri = null;
    this.window = null;
    this.xsl = null;
    this.excludeNS = new _xfa_object.XFAObjectArray();
    this.transform = new _xfa_object.XFAObjectArray();
  }

}

class Debug extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "debug", true);
    this.uri = null;
  }

}

class DefaultTypeface extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "defaultTypeface");
    this.writingScript = (0, _utils.getStringOption)(attributes.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }

}

class Destination extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }

}

class DocumentAssembly extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "documentAssembly");
  }

}

class Driver extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "driver", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }

}

class DuplexOption extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }

}

class DynamicRender extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "dynamicRender", ["forbidden", "required"]);
  }

}

class Embed extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "embed");
  }

}

class Encrypt extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encrypt");
  }

}

class Encryption extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encryption", true);
    this.encrypt = null;
    this.encryptionLevel = null;
    this.permissions = null;
  }

}

class EncryptionLevel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encryptionLevel", ["40bit", "128bit"]);
  }

}

class Enforce extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "enforce");
  }

}

class Equate extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equate");
    this.force = (0, _utils.getInteger)({
      data: attributes.force,
      defaultValue: 1,
      validate: n => n === 0
    });
    this.from = attributes.from || "";
    this.to = attributes.to || "";
  }

}

class EquateRange extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equateRange");
    this.from = attributes.from || "";
    this.to = attributes.to || "";
    this._unicodeRange = attributes.unicodeRange || "";
  }

  get unicodeRange() {
    const ranges = [];
    const unicodeRegex = /U\+([0-9a-fA-F]+)/;
    const unicodeRange = this._unicodeRange;

    for (let range of unicodeRange.split(",").map(x => x.trim()).filter(x => !!x)) {
      range = range.split("-", 2).map(x => {
        const found = x.match(unicodeRegex);

        if (!found) {
          return 0;
        }

        return parseInt(found[1], 16);
      });

      if (range.length === 1) {
        range.push(range[0]);
      }

      ranges.push(range);
    }

    return (0, _util.shadow)(this, "unicodeRange", ranges);
  }

}

class Exclude extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "exclude");
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/).filter(x => x && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(x));
  }

}

class ExcludeNS extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "excludeNS");
  }

}

class FlipLabel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }

}

class FontInfo extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "fontInfo", true);
    this.embed = null;
    this.map = null;
    this.subsetBelow = null;
    this.alwaysEmbed = new _xfa_object.XFAObjectArray();
    this.defaultTypeface = new _xfa_object.XFAObjectArray();
    this.neverEmbed = new _xfa_object.XFAObjectArray();
  }

}

class FormFieldFilling extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "formFieldFilling");
  }

}

class GroupParent extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "groupParent");
  }

}

class IfEmpty extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }

}

class IncludeXDPContent extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "includeXDPContent");
  }

}

class IncrementalLoad extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalLoad", ["none", "forwardOnly"]);
  }

}

class IncrementalMerge extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalMerge");
  }

}

class Interactive extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "interactive");
  }

}

class Jog extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }

}

class LabelPrinter extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "labelPrinter", true);
    this.name = (0, _utils.getStringOption)(attributes.name, ["zpl", "dpl", "ipl", "tcpl"]);
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }

}

class Layout extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "layout", ["paginate", "panel"]);
  }

}

class Level extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "level", 0, n => n > 0);
  }

}

class Linearized extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "linearized");
  }

}

class Locale extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "locale");
  }

}

class LocaleSet extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "localeSet");
  }

}

class Log extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "log", true);
    this.mode = null;
    this.threshold = null;
    this.to = null;
    this.uri = null;
  }

}

class MapElement extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "map", true);
    this.equate = new _xfa_object.XFAObjectArray();
    this.equateRange = new _xfa_object.XFAObjectArray();
  }

}

class MediumInfo extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "mediumInfo", true);
    this.map = null;
  }

}

class Message extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "message", true);
    this.msgId = null;
    this.severity = null;
  }

}

class Messaging extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "messaging", true);
    this.message = new _xfa_object.XFAObjectArray();
  }

}

class Mode extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "mode", ["append", "overwrite"]);
  }

}

class ModifyAnnots extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "modifyAnnots");
  }

}

class MsgId extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "msgId", 1, n => n >= 1);
  }

}

class NameAttr extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "nameAttr");
  }

}

class NeverEmbed extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "neverEmbed");
  }

}

class NumberOfCopies extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "numberOfCopies", null, n => n >= 2 && n <= 5);
  }

}

class OpenAction extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "openAction", true);
    this.destination = null;
  }

}

class Output extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "output", true);
    this.to = null;
    this.type = null;
    this.uri = null;
  }

}

class OutputBin extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "outputBin");
  }

}

class OutputXSL extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "outputXSL", true);
    this.uri = null;
  }

}

class Overprint extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "overprint", ["none", "both", "draw", "field"]);
  }

}

class Packets extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "packets");
  }

  [_xfa_object.$finalize]() {
    if (this[_xfa_object.$content] === "*") {
      return;
    }

    this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/).filter(x => ["config", "datasets", "template", "xfdf", "xslt"].includes(x));
  }

}

class PageOffset extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageOffset");
    this.x = (0, _utils.getInteger)({
      data: attributes.x,
      defaultValue: "useXDCSetting",
      validate: n => true
    });
    this.y = (0, _utils.getInteger)({
      data: attributes.y,
      defaultValue: "useXDCSetting",
      validate: n => true
    });
  }

}

class PageRange extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageRange");
  }

  [_xfa_object.$finalize]() {
    const numbers = this[_xfa_object.$content].trim().split(/\s+/).map(x => parseInt(x, 10));

    const ranges = [];

    for (let i = 0, ii = numbers.length; i < ii; i += 2) {
      ranges.push(numbers.slice(i, i + 2));
    }

    this[_xfa_object.$content] = ranges;
  }

}

class Pagination extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }

}

class PaginationOverride extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }

}

class Part extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "part", 1, n => false);
  }

}

class Pcl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pcl", true);
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.pageOffset = null;
    this.staple = null;
    this.xdc = null;
  }

}

class Pdf extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pdf", true);
    this.name = attributes.name || "";
    this.adobeExtensionLevel = null;
    this.batchOutput = null;
    this.compression = null;
    this.creator = null;
    this.encryption = null;
    this.fontInfo = null;
    this.interactive = null;
    this.linearized = null;
    this.openAction = null;
    this.pdfa = null;
    this.producer = null;
    this.renderPolicy = null;
    this.scriptModel = null;
    this.silentPrint = null;
    this.submitFormat = null;
    this.tagged = null;
    this.version = null;
    this.viewerPreferences = null;
    this.xdc = null;
  }

}

class Pdfa extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pdfa", true);
    this.amd = null;
    this.conformance = null;
    this.includeXDPContent = null;
    this.part = null;
  }

}

class Permissions extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "permissions", true);
    this.accessibleContent = null;
    this.change = null;
    this.contentCopy = null;
    this.documentAssembly = null;
    this.formFieldFilling = null;
    this.modifyAnnots = null;
    this.plaintextMetadata = null;
    this.print = null;
    this.printHighQuality = null;
  }

}

class PickTrayByPDFSize extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pickTrayByPDFSize");
  }

}

class Picture extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "picture");
  }

}

class PlaintextMetadata extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "plaintextMetadata");
  }

}

class Presence extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }

}

class Present extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "present", true);
    this.behaviorOverride = null;
    this.cache = null;
    this.common = null;
    this.copies = null;
    this.destination = null;
    this.incrementalMerge = null;
    this.layout = null;
    this.output = null;
    this.overprint = null;
    this.pagination = null;
    this.paginationOverride = null;
    this.script = null;
    this.validate = null;
    this.xdp = null;
    this.driver = new _xfa_object.XFAObjectArray();
    this.labelPrinter = new _xfa_object.XFAObjectArray();
    this.pcl = new _xfa_object.XFAObjectArray();
    this.pdf = new _xfa_object.XFAObjectArray();
    this.ps = new _xfa_object.XFAObjectArray();
    this.submitUrl = new _xfa_object.XFAObjectArray();
    this.webClient = new _xfa_object.XFAObjectArray();
    this.zpl = new _xfa_object.XFAObjectArray();
  }

}

class Print extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "print");
  }

}

class PrintHighQuality extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printHighQuality");
  }

}

class PrintScaling extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printScaling", ["appdefault", "noScaling"]);
  }

}

class PrinterName extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printerName");
  }

}

class Producer extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "producer");
  }

}

class Ps extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ps", true);
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.staple = null;
    this.xdc = null;
  }

}

class Range extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "range");
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s*,\s*/, 2).map(range => range.split("-").map(x => parseInt(x.trim(), 10))).filter(range => range.every(x => !isNaN(x))).map(range => {
      if (range.length === 1) {
        range.push(range[0]);
      }

      return range;
    });
  }

}

class Record extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "record");
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = this[_xfa_object.$content].trim();
    const n = parseInt(this[_xfa_object.$content], 10);

    if (!isNaN(n) && n >= 0) {
      this[_xfa_object.$content] = n;
    }
  }

}

class Relevant extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "relevant");
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/);
  }

}

class Rename extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "rename");
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = this[_xfa_object.$content].trim();

    if (this[_xfa_object.$content].toLowerCase().startsWith("xml") || this[_xfa_object.$content].match(new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u"))) {
      (0, _util.warn)("XFA - Rename: invalid XFA name");
    }
  }

}

class RenderPolicy extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "renderPolicy", ["server", "client"]);
  }

}

class RunScripts extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "runScripts", ["both", "client", "none", "server"]);
  }

}

class Script extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "script", true);
    this.currentPage = null;
    this.exclude = null;
    this.runScripts = null;
  }

}

class ScriptModel extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "scriptModel", ["XFA", "none"]);
  }

}

class Severity extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }

}

class SilentPrint extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "silentPrint", true);
    this.addSilentPrint = null;
    this.printerName = null;
  }

}

class Staple extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "staple");
    this.mode = (0, _utils.getStringOption)(attributes.mode, ["usePrinterSetting", "on", "off"]);
  }

}

class StartNode extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startNode");
  }

}

class StartPage extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startPage", 0, n => true);
  }

}

class SubmitFormat extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }

}

class SubmitUrl extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitUrl");
  }

}

class SubsetBelow extends _xfa_object.IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "subsetBelow", 100, n => n >= 0 && n <= 100);
  }

}

class SuppressBanner extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "suppressBanner");
  }

}

class Tagged extends _xfa_object.Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "tagged");
  }

}

class Template extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "template", true);
    this.base = null;
    this.relevant = null;
    this.startPage = null;
    this.uri = null;
    this.xsl = null;
  }

}

class Threshold extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "threshold", ["trace", "error", "information", "warning"]);
  }

}

class To extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }

}

class TemplateCache extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "templateCache");
    this.maxEntries = (0, _utils.getInteger)({
      data: attributes.maxEntries,
      defaultValue: 5,
      validate: n => n >= 0
    });
  }

}

class Trace extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "trace", true);
    this.area = new _xfa_object.XFAObjectArray();
  }

}

class Transform extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "transform", true);
    this.groupParent = null;
    this.ifEmpty = null;
    this.nameAttr = null;
    this.picture = null;
    this.presence = null;
    this.rename = null;
    this.whitespace = null;
  }

}

class Type extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }

}

class Uri extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "uri");
  }

}

class Validate extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }

}

class ValidateApprovalSignatures extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validateApprovalSignatures");
  }

  [_xfa_object.$finalize]() {
    this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\s+/).filter(x => ["docReady", "postSign"].includes(x));
  }

}

class ValidationMessaging extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }

}

class Version extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }

}

class VersionControl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "VersionControl");
    this.outputBelow = (0, _utils.getStringOption)(attributes.outputBelow, ["warn", "error", "update"]);
    this.sourceAbove = (0, _utils.getStringOption)(attributes.sourceAbove, ["warn", "error"]);
    this.sourceBelow = (0, _utils.getStringOption)(attributes.sourceBelow, ["update", "maintain"]);
  }

}

class ViewerPreferences extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "viewerPreferences", true);
    this.ADBE_JSConsole = null;
    this.ADBE_JSDebugger = null;
    this.addViewerPreferences = null;
    this.duplexOption = null;
    this.enforce = null;
    this.numberOfCopies = null;
    this.pageRange = null;
    this.pickTrayByPDFSize = null;
    this.printScaling = null;
  }

}

class WebClient extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "webClient", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }

}

class Whitespace extends _xfa_object.OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }

}

class Window extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "window");
  }

  [_xfa_object.$finalize]() {
    const pair = this[_xfa_object.$content].trim().split(/\s*,\s*/, 2).map(x => parseInt(x, 10));

    if (pair.some(x => isNaN(x))) {
      this[_xfa_object.$content] = [0, 0];
      return;
    }

    if (pair.length === 1) {
      pair.push(pair[0]);
    }

    this[_xfa_object.$content] = pair;
  }

}

class Xdc extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xdc", true);
    this.uri = new _xfa_object.XFAObjectArray();
    this.xsl = new _xfa_object.XFAObjectArray();
  }

}

class Xdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xdp", true);
    this.packets = null;
  }

}

class Xsl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "xsl", true);
    this.debug = null;
    this.uri = null;
  }

}

class Zpl extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "zpl", true);
    this.name = attributes.name ? attributes.name.trim() : "";
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }

}

class ConfigNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (ConfigNamespace.hasOwnProperty(name)) {
      return ConfigNamespace[name](attributes);
    }

    return undefined;
  }

  static acrobat(attrs) {
    return new Acrobat(attrs);
  }

  static acrobat7(attrs) {
    return new Acrobat7(attrs);
  }

  static ADBE_JSConsole(attrs) {
    return new ADBE_JSConsole(attrs);
  }

  static ADBE_JSDebugger(attrs) {
    return new ADBE_JSDebugger(attrs);
  }

  static addSilentPrint(attrs) {
    return new AddSilentPrint(attrs);
  }

  static addViewerPreferences(attrs) {
    return new AddViewerPreferences(attrs);
  }

  static adjustData(attrs) {
    return new AdjustData(attrs);
  }

  static adobeExtensionLevel(attrs) {
    return new AdobeExtensionLevel(attrs);
  }

  static agent(attrs) {
    return new Agent(attrs);
  }

  static alwaysEmbed(attrs) {
    return new AlwaysEmbed(attrs);
  }

  static amd(attrs) {
    return new Amd(attrs);
  }

  static area(attrs) {
    return new Area(attrs);
  }

  static attributes(attrs) {
    return new Attributes(attrs);
  }

  static autoSave(attrs) {
    return new AutoSave(attrs);
  }

  static base(attrs) {
    return new Base(attrs);
  }

  static batchOutput(attrs) {
    return new BatchOutput(attrs);
  }

  static behaviorOverride(attrs) {
    return new BehaviorOverride(attrs);
  }

  static cache(attrs) {
    return new Cache(attrs);
  }

  static change(attrs) {
    return new Change(attrs);
  }

  static common(attrs) {
    return new Common(attrs);
  }

  static compress(attrs) {
    return new Compress(attrs);
  }

  static compressLogicalStructure(attrs) {
    return new CompressLogicalStructure(attrs);
  }

  static compressObjectStream(attrs) {
    return new CompressObjectStream(attrs);
  }

  static compression(attrs) {
    return new Compression(attrs);
  }

  static config(attrs) {
    return new Config(attrs);
  }

  static conformance(attrs) {
    return new Conformance(attrs);
  }

  static contentCopy(attrs) {
    return new ContentCopy(attrs);
  }

  static copies(attrs) {
    return new Copies(attrs);
  }

  static creator(attrs) {
    return new Creator(attrs);
  }

  static currentPage(attrs) {
    return new CurrentPage(attrs);
  }

  static data(attrs) {
    return new Data(attrs);
  }

  static debug(attrs) {
    return new Debug(attrs);
  }

  static defaultTypeface(attrs) {
    return new DefaultTypeface(attrs);
  }

  static destination(attrs) {
    return new Destination(attrs);
  }

  static documentAssembly(attrs) {
    return new DocumentAssembly(attrs);
  }

  static driver(attrs) {
    return new Driver(attrs);
  }

  static duplexOption(attrs) {
    return new DuplexOption(attrs);
  }

  static dynamicRender(attrs) {
    return new DynamicRender(attrs);
  }

  static embed(attrs) {
    return new Embed(attrs);
  }

  static encrypt(attrs) {
    return new Encrypt(attrs);
  }

  static encryption(attrs) {
    return new Encryption(attrs);
  }

  static encryptionLevel(attrs) {
    return new EncryptionLevel(attrs);
  }

  static enforce(attrs) {
    return new Enforce(attrs);
  }

  static equate(attrs) {
    return new Equate(attrs);
  }

  static equateRange(attrs) {
    return new EquateRange(attrs);
  }

  static exclude(attrs) {
    return new Exclude(attrs);
  }

  static excludeNS(attrs) {
    return new ExcludeNS(attrs);
  }

  static flipLabel(attrs) {
    return new FlipLabel(attrs);
  }

  static fontInfo(attrs) {
    return new FontInfo(attrs);
  }

  static formFieldFilling(attrs) {
    return new FormFieldFilling(attrs);
  }

  static groupParent(attrs) {
    return new GroupParent(attrs);
  }

  static ifEmpty(attrs) {
    return new IfEmpty(attrs);
  }

  static includeXDPContent(attrs) {
    return new IncludeXDPContent(attrs);
  }

  static incrementalLoad(attrs) {
    return new IncrementalLoad(attrs);
  }

  static incrementalMerge(attrs) {
    return new IncrementalMerge(attrs);
  }

  static interactive(attrs) {
    return new Interactive(attrs);
  }

  static jog(attrs) {
    return new Jog(attrs);
  }

  static labelPrinter(attrs) {
    return new LabelPrinter(attrs);
  }

  static layout(attrs) {
    return new Layout(attrs);
  }

  static level(attrs) {
    return new Level(attrs);
  }

  static linearized(attrs) {
    return new Linearized(attrs);
  }

  static locale(attrs) {
    return new Locale(attrs);
  }

  static localeSet(attrs) {
    return new LocaleSet(attrs);
  }

  static log(attrs) {
    return new Log(attrs);
  }

  static map(attrs) {
    return new MapElement(attrs);
  }

  static mediumInfo(attrs) {
    return new MediumInfo(attrs);
  }

  static message(attrs) {
    return new Message(attrs);
  }

  static messaging(attrs) {
    return new Messaging(attrs);
  }

  static mode(attrs) {
    return new Mode(attrs);
  }

  static modifyAnnots(attrs) {
    return new ModifyAnnots(attrs);
  }

  static msgId(attrs) {
    return new MsgId(attrs);
  }

  static nameAttr(attrs) {
    return new NameAttr(attrs);
  }

  static neverEmbed(attrs) {
    return new NeverEmbed(attrs);
  }

  static numberOfCopies(attrs) {
    return new NumberOfCopies(attrs);
  }

  static openAction(attrs) {
    return new OpenAction(attrs);
  }

  static output(attrs) {
    return new Output(attrs);
  }

  static outputBin(attrs) {
    return new OutputBin(attrs);
  }

  static outputXSL(attrs) {
    return new OutputXSL(attrs);
  }

  static overprint(attrs) {
    return new Overprint(attrs);
  }

  static packets(attrs) {
    return new Packets(attrs);
  }

  static pageOffset(attrs) {
    return new PageOffset(attrs);
  }

  static pageRange(attrs) {
    return new PageRange(attrs);
  }

  static pagination(attrs) {
    return new Pagination(attrs);
  }

  static paginationOverride(attrs) {
    return new PaginationOverride(attrs);
  }

  static part(attrs) {
    return new Part(attrs);
  }

  static pcl(attrs) {
    return new Pcl(attrs);
  }

  static pdf(attrs) {
    return new Pdf(attrs);
  }

  static pdfa(attrs) {
    return new Pdfa(attrs);
  }

  static permissions(attrs) {
    return new Permissions(attrs);
  }

  static pickTrayByPDFSize(attrs) {
    return new PickTrayByPDFSize(attrs);
  }

  static picture(attrs) {
    return new Picture(attrs);
  }

  static plaintextMetadata(attrs) {
    return new PlaintextMetadata(attrs);
  }

  static presence(attrs) {
    return new Presence(attrs);
  }

  static present(attrs) {
    return new Present(attrs);
  }

  static print(attrs) {
    return new Print(attrs);
  }

  static printHighQuality(attrs) {
    return new PrintHighQuality(attrs);
  }

  static printScaling(attrs) {
    return new PrintScaling(attrs);
  }

  static printerName(attrs) {
    return new PrinterName(attrs);
  }

  static producer(attrs) {
    return new Producer(attrs);
  }

  static ps(attrs) {
    return new Ps(attrs);
  }

  static range(attrs) {
    return new Range(attrs);
  }

  static record(attrs) {
    return new Record(attrs);
  }

  static relevant(attrs) {
    return new Relevant(attrs);
  }

  static rename(attrs) {
    return new Rename(attrs);
  }

  static renderPolicy(attrs) {
    return new RenderPolicy(attrs);
  }

  static runScripts(attrs) {
    return new RunScripts(attrs);
  }

  static script(attrs) {
    return new Script(attrs);
  }

  static scriptModel(attrs) {
    return new ScriptModel(attrs);
  }

  static severity(attrs) {
    return new Severity(attrs);
  }

  static silentPrint(attrs) {
    return new SilentPrint(attrs);
  }

  static staple(attrs) {
    return new Staple(attrs);
  }

  static startNode(attrs) {
    return new StartNode(attrs);
  }

  static startPage(attrs) {
    return new StartPage(attrs);
  }

  static submitFormat(attrs) {
    return new SubmitFormat(attrs);
  }

  static submitUrl(attrs) {
    return new SubmitUrl(attrs);
  }

  static subsetBelow(attrs) {
    return new SubsetBelow(attrs);
  }

  static suppressBanner(attrs) {
    return new SuppressBanner(attrs);
  }

  static tagged(attrs) {
    return new Tagged(attrs);
  }

  static template(attrs) {
    return new Template(attrs);
  }

  static templateCache(attrs) {
    return new TemplateCache(attrs);
  }

  static threshold(attrs) {
    return new Threshold(attrs);
  }

  static to(attrs) {
    return new To(attrs);
  }

  static trace(attrs) {
    return new Trace(attrs);
  }

  static transform(attrs) {
    return new Transform(attrs);
  }

  static type(attrs) {
    return new Type(attrs);
  }

  static uri(attrs) {
    return new Uri(attrs);
  }

  static validate(attrs) {
    return new Validate(attrs);
  }

  static validateApprovalSignatures(attrs) {
    return new ValidateApprovalSignatures(attrs);
  }

  static validationMessaging(attrs) {
    return new ValidationMessaging(attrs);
  }

  static version(attrs) {
    return new Version(attrs);
  }

  static versionControl(attrs) {
    return new VersionControl(attrs);
  }

  static viewerPreferences(attrs) {
    return new ViewerPreferences(attrs);
  }

  static webClient(attrs) {
    return new WebClient(attrs);
  }

  static whitespace(attrs) {
    return new Whitespace(attrs);
  }

  static window(attrs) {
    return new Window(attrs);
  }

  static xdc(attrs) {
    return new Xdc(attrs);
  }

  static xdp(attrs) {
    return new Xdp(attrs);
  }

  static xsl(attrs) {
    return new Xsl(attrs);
  }

  static zpl(attrs) {
    return new Zpl(attrs);
  }

}

exports.ConfigNamespace = ConfigNamespace;

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionSetNamespace = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

const CONNECTION_SET_NS_ID = _namespaces.NamespaceIds.connectionSet.id;

class ConnectionSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "connectionSet", true);
    this.wsdlConnection = new _xfa_object.XFAObjectArray();
    this.xmlConnection = new _xfa_object.XFAObjectArray();
    this.xsdConnection = new _xfa_object.XFAObjectArray();
  }

}

class EffectiveInputPolicy extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveInputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class EffectiveOutputPolicy extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveOutputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Operation extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "operation");
    this.id = attributes.id || "";
    this.input = attributes.input || "";
    this.name = attributes.name || "";
    this.output = attributes.output || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class RootElement extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "rootElement");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class SoapAction extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAction");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class SoapAddress extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class Uri extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "uri");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class WsdlAddress extends _xfa_object.StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "wsdlAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }

}

class WsdlConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "wsdlConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.effectiveInputPolicy = null;
    this.effectiveOutputPolicy = null;
    this.operation = null;
    this.soapAction = null;
    this.soapAddress = null;
    this.wsdlAddress = null;
  }

}

class XmlConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "xmlConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.uri = null;
  }

}

class XsdConnection extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "xsdConnection", true);
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.rootElement = null;
    this.uri = null;
  }

}

class ConnectionSetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (ConnectionSetNamespace.hasOwnProperty(name)) {
      return ConnectionSetNamespace[name](attributes);
    }

    return undefined;
  }

  static connectionSet(attrs) {
    return new ConnectionSet(attrs);
  }

  static effectiveInputPolicy(attrs) {
    return new EffectiveInputPolicy(attrs);
  }

  static effectiveOutputPolicy(attrs) {
    return new EffectiveOutputPolicy(attrs);
  }

  static operation(attrs) {
    return new Operation(attrs);
  }

  static rootElement(attrs) {
    return new RootElement(attrs);
  }

  static soapAction(attrs) {
    return new SoapAction(attrs);
  }

  static soapAddress(attrs) {
    return new SoapAddress(attrs);
  }

  static uri(attrs) {
    return new Uri(attrs);
  }

  static wsdlAddress(attrs) {
    return new WsdlAddress(attrs);
  }

  static wsdlConnection(attrs) {
    return new WsdlConnection(attrs);
  }

  static xmlConnection(attrs) {
    return new XmlConnection(attrs);
  }

  static xsdConnection(attrs) {
    return new XsdConnection(attrs);
  }

}

exports.ConnectionSetNamespace = ConnectionSetNamespace;

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DatasetsNamespace = void 0;

var _xfa_object = __w_pdfjs_require__(68);

var _namespaces = __w_pdfjs_require__(70);

const DATASETS_NS_ID = _namespaces.NamespaceIds.datasets.id;

class Data extends _xfa_object.XmlObject {
  constructor(attributes) {
    super(DATASETS_NS_ID, "data", attributes);
  }

}

class Datasets extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(DATASETS_NS_ID, "datasets", true);
    this.data = null;
    this.Signature = null;
  }

  [_xfa_object.$onChild](child) {
    const name = child[_xfa_object.$nodeName];

    if (name === "data" && child[_xfa_object.$namespaceId] === DATASETS_NS_ID || name === "Signature" && child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.signature.id) {
      this[name] = child;
    } else {
      child[_xfa_object.$global] = true;
    }

    this[_xfa_object.$appendChild](child);
  }

}

class DatasetsNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (DatasetsNamespace.hasOwnProperty(name)) {
      return DatasetsNamespace[name](attributes);
    }

    return undefined;
  }

  static datasets(attributes) {
    return new Datasets(attributes);
  }

  static data(attributes) {
    return new Data(attributes);
  }

}

exports.DatasetsNamespace = DatasetsNamespace;

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocaleSetNamespace = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

var _utils = __w_pdfjs_require__(69);

const LOCALE_SET_NS_ID = _namespaces.NamespaceIds.localeSet.id;

class CalendarSymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "calendarSymbols", true);
    this.name = "gregorian";
    this.dayNames = new _xfa_object.XFAObjectArray(2);
    this.eraNames = null;
    this.meridiemNames = null;
    this.monthNames = new _xfa_object.XFAObjectArray(2);
  }

}

class CurrencySymbol extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "currencySymbol");
    this.name = (0, _utils.getStringOption)(attributes.name, ["symbol", "isoname", "decimal"]);
  }

}

class CurrencySymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "currencySymbols", true);
    this.currencySymbol = new _xfa_object.XFAObjectArray(3);
  }

}

class DatePattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "datePattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }

}

class DatePatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "datePatterns", true);
    this.datePattern = new _xfa_object.XFAObjectArray(4);
  }

}

class DateTimeSymbols extends _xfa_object.ContentObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "dateTimeSymbols");
  }

}

class Day extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "day");
  }

}

class DayNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "dayNames", true);
    this.abbr = (0, _utils.getInteger)({
      data: attributes.abbr,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.day = new _xfa_object.XFAObjectArray(7);
  }

}

class Era extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "era");
  }

}

class EraNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "eraNames", true);
    this.era = new _xfa_object.XFAObjectArray(2);
  }

}

class Locale extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "locale", true);
    this.desc = attributes.desc || "";
    this.name = "isoname";
    this.calendarSymbols = null;
    this.currencySymbols = null;
    this.datePatterns = null;
    this.dateTimeSymbols = null;
    this.numberPatterns = null;
    this.numberSymbols = null;
    this.timePatterns = null;
    this.typeFaces = null;
  }

}

class LocaleSet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "localeSet", true);
    this.locale = new _xfa_object.XFAObjectArray();
  }

}

class Meridiem extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "meridiem");
  }

}

class MeridiemNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "meridiemNames", true);
    this.meridiem = new _xfa_object.XFAObjectArray(2);
  }

}

class Month extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "month");
  }

}

class MonthNames extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "monthNames", true);
    this.abbr = (0, _utils.getInteger)({
      data: attributes.abbr,
      defaultValue: 0,
      validate: x => x === 1
    });
    this.month = new _xfa_object.XFAObjectArray(12);
  }

}

class NumberPattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberPattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }

}

class NumberPatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberPatterns", true);
    this.numberPattern = new _xfa_object.XFAObjectArray(4);
  }

}

class NumberSymbol extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberSymbol");
    this.name = (0, _utils.getStringOption)(attributes.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }

}

class NumberSymbols extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberSymbols", true);
    this.numberSymbol = new _xfa_object.XFAObjectArray(5);
  }

}

class TimePattern extends _xfa_object.StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "timePattern");
    this.name = (0, _utils.getStringOption)(attributes.name, ["full", "long", "med", "short"]);
  }

}

class TimePatterns extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "timePatterns", true);
    this.timePattern = new _xfa_object.XFAObjectArray(4);
  }

}

class TypeFace extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "typeFace", true);
    this.name = attributes.name | "";
  }

}

class TypeFaces extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "typeFaces", true);
    this.typeFace = new _xfa_object.XFAObjectArray();
  }

}

class LocaleSetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (LocaleSetNamespace.hasOwnProperty(name)) {
      return LocaleSetNamespace[name](attributes);
    }

    return undefined;
  }

  static calendarSymbols(attrs) {
    return new CalendarSymbols(attrs);
  }

  static currencySymbol(attrs) {
    return new CurrencySymbol(attrs);
  }

  static currencySymbols(attrs) {
    return new CurrencySymbols(attrs);
  }

  static datePattern(attrs) {
    return new DatePattern(attrs);
  }

  static datePatterns(attrs) {
    return new DatePatterns(attrs);
  }

  static dateTimeSymbols(attrs) {
    return new DateTimeSymbols(attrs);
  }

  static day(attrs) {
    return new Day(attrs);
  }

  static dayNames(attrs) {
    return new DayNames(attrs);
  }

  static era(attrs) {
    return new Era(attrs);
  }

  static eraNames(attrs) {
    return new EraNames(attrs);
  }

  static locale(attrs) {
    return new Locale(attrs);
  }

  static localeSet(attrs) {
    return new LocaleSet(attrs);
  }

  static meridiem(attrs) {
    return new Meridiem(attrs);
  }

  static meridiemNames(attrs) {
    return new MeridiemNames(attrs);
  }

  static month(attrs) {
    return new Month(attrs);
  }

  static monthNames(attrs) {
    return new MonthNames(attrs);
  }

  static numberPattern(attrs) {
    return new NumberPattern(attrs);
  }

  static numberPatterns(attrs) {
    return new NumberPatterns(attrs);
  }

  static numberSymbol(attrs) {
    return new NumberSymbol(attrs);
  }

  static numberSymbols(attrs) {
    return new NumberSymbols(attrs);
  }

  static timePattern(attrs) {
    return new TimePattern(attrs);
  }

  static timePatterns(attrs) {
    return new TimePatterns(attrs);
  }

  static typeFace(attrs) {
    return new TypeFace(attrs);
  }

  static typeFaces(attrs) {
    return new TypeFaces(attrs);
  }

}

exports.LocaleSetNamespace = LocaleSetNamespace;

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SignatureNamespace = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

const SIGNATURE_NS_ID = _namespaces.NamespaceIds.signature.id;

class Signature extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(SIGNATURE_NS_ID, "signature", true);
  }

}

class SignatureNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (SignatureNamespace.hasOwnProperty(name)) {
      return SignatureNamespace[name](attributes);
    }

    return undefined;
  }

  static signature(attributes) {
    return new Signature(attributes);
  }

}

exports.SignatureNamespace = SignatureNamespace;

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StylesheetNamespace = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

const STYLESHEET_NS_ID = _namespaces.NamespaceIds.stylesheet.id;

class Stylesheet extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(STYLESHEET_NS_ID, "stylesheet", true);
  }

}

class StylesheetNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (StylesheetNamespace.hasOwnProperty(name)) {
      return StylesheetNamespace[name](attributes);
    }

    return undefined;
  }

  static stylesheet(attributes) {
    return new Stylesheet(attributes);
  }

}

exports.StylesheetNamespace = StylesheetNamespace;

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XdpNamespace = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

const XDP_NS_ID = _namespaces.NamespaceIds.xdp.id;

class Xdp extends _xfa_object.XFAObject {
  constructor(attributes) {
    super(XDP_NS_ID, "xdp", true);
    this.uuid = attributes.uuid || "";
    this.timeStamp = attributes.timeStamp || "";
    this.config = null;
    this.connectionSet = null;
    this.datasets = null;
    this.localeSet = null;
    this.stylesheet = new _xfa_object.XFAObjectArray();
    this.template = null;
  }

  [_xfa_object.$onChildCheck](child) {
    const ns = _namespaces.NamespaceIds[child[_xfa_object.$nodeName]];
    return ns && child[_xfa_object.$namespaceId] === ns.id;
  }

}

class XdpNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (XdpNamespace.hasOwnProperty(name)) {
      return XdpNamespace[name](attributes);
    }

    return undefined;
  }

  static xdp(attributes) {
    return new Xdp(attributes);
  }

}

exports.XdpNamespace = XdpNamespace;

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XhtmlNamespace = void 0;

var _xfa_object = __w_pdfjs_require__(68);

var _namespaces = __w_pdfjs_require__(70);

var _utils = __w_pdfjs_require__(69);

var _html_utils = __w_pdfjs_require__(73);

const XHTML_NS_ID = _namespaces.NamespaceIds.xhtml.id;
const VALID_STYLES = new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
const StyleMapping = new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", value => value === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", value => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", value => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["letter-spacing", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["line-height", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-bottom", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-left", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-right", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], ["margin-top", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))]]);
const spacesRegExp = /\s+/g;
const crlfRegExp = /[\r\n]+/g;

function mapStyle(styleStr) {
  const style = Object.create(null);

  if (!styleStr) {
    return style;
  }

  for (const [key, value] of styleStr.split(";").map(s => s.split(":", 2))) {
    const mapping = StyleMapping.get(key);

    if (mapping === "") {
      continue;
    }

    let newValue = value;

    if (mapping) {
      if (typeof mapping === "string") {
        newValue = mapping;
      } else {
        newValue = mapping(value);
      }
    }

    if (key.endsWith("scale")) {
      if (style.transform) {
        style.transform = `${style[key]} ${newValue}`;
      } else {
        style.transform = newValue;
      }
    } else {
      style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue;
    }
  }

  return style;
}

function checkStyle(style) {
  if (!style) {
    return "";
  }

  return style.trim().split(/\s*;\s*/).filter(s => !!s).map(s => s.split(/\s*:\s*/, 2)).filter(([key]) => VALID_STYLES.has(key)).map(kv => kv.join(":")).join(";");
}

const NoWhites = new Set(["body", "html"]);

class XhtmlObject extends _xfa_object.XmlObject {
  constructor(attributes, name) {
    super(XHTML_NS_ID, name);
    this.style = checkStyle(attributes.style);
  }

  [_xfa_object.$acceptWhitespace]() {
    return !NoWhites.has(this[_xfa_object.$nodeName]);
  }

  [_xfa_object.$onText](str) {
    str = str.replace(crlfRegExp, "");

    if (!this.style.includes("xfa-spacerun:yes")) {
      str = str.replace(spacesRegExp, " ");
    }

    if (str) {
      this[_xfa_object.$content] += str;
    }
  }

  [_xfa_object.$toHTML]() {
    return {
      name: this[_xfa_object.$nodeName],
      attributes: {
        href: this.href,
        style: mapStyle(this.style)
      },
      children: this[_xfa_object.$childrenToHTML]({}),
      value: this[_xfa_object.$content] || ""
    };
  }

}

class A extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "a");
    this.href = attributes.href || "";
  }

}

class B extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "b");
  }

}

class Body extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "body");
  }

  [_xfa_object.$toHTML]() {
    const html = super[_xfa_object.$toHTML]();

    html.attributes.class = "xfaRich";
    return html;
  }

}

class Br extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "br");
  }

  [_xfa_object.$text]() {
    return "\n";
  }

  [_xfa_object.$toHTML]() {
    return {
      name: "br"
    };
  }

}

class Html extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "html");
  }

  [_xfa_object.$toHTML]() {
    const children = this[_xfa_object.$childrenToHTML]({});

    if (children.length === 0) {
      return {
        name: "div",
        attributes: {
          class: "xfaRich",
          style: {}
        },
        value: this[_xfa_object.$content] || ""
      };
    }

    if (children.length === 1) {
      const child = children[0];

      if (child.attributes && child.attributes.class === "xfaRich") {
        return child;
      }
    }

    return {
      name: "div",
      attributes: {
        class: "xfaRich",
        style: {}
      },
      children
    };
  }

}

class I extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "i");
  }

}

class Li extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "li");
  }

}

class Ol extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ol");
  }

}

class P extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "p");
  }

}

class Span extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "span");
  }

}

class Sub extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sub");
  }

}

class Sup extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sup");
  }

}

class Ul extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ul");
  }

}

class XhtmlNamespace {
  static [_namespaces.$buildXFAObject](name, attributes) {
    if (XhtmlNamespace.hasOwnProperty(name)) {
      return XhtmlNamespace[name](attributes);
    }

    return undefined;
  }

  static a(attributes) {
    return new A(attributes);
  }

  static b(attributes) {
    return new B(attributes);
  }

  static body(attributes) {
    return new Body(attributes);
  }

  static br(attributes) {
    return new Br(attributes);
  }

  static html(attributes) {
    return new Html(attributes);
  }

  static i(attributes) {
    return new I(attributes);
  }

  static li(attributes) {
    return new Li(attributes);
  }

  static ol(attributes) {
    return new Ol(attributes);
  }

  static p(attributes) {
    return new P(attributes);
  }

  static span(attributes) {
    return new Span(attributes);
  }

  static sub(attributes) {
    return new Sub(attributes);
  }

  static sup(attributes) {
    return new Sup(attributes);
  }

  static ul(attributes) {
    return new Ul(attributes);
  }

}

exports.XhtmlNamespace = XhtmlNamespace;

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UnknownNamespace = void 0;

var _namespaces = __w_pdfjs_require__(70);

var _xfa_object = __w_pdfjs_require__(68);

class UnknownNamespace {
  constructor(nsId) {
    this.namespaceId = nsId;
  }

  [_namespaces.$buildXFAObject](name, attributes) {
    return new _xfa_object.XmlObject(this.namespaceId, name, attributes);
  }

}

exports.UnknownNamespace = UnknownNamespace;

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XRef = void 0;

var _util = __w_pdfjs_require__(2);

var _primitives = __w_pdfjs_require__(5);

var _parser = __w_pdfjs_require__(17);

var _core_utils = __w_pdfjs_require__(9);

var _crypto = __w_pdfjs_require__(65);

class XRef {
  constructor(stream, pdfManager) {
    this.stream = stream;
    this.pdfManager = pdfManager;
    this.entries = [];
    this.xrefstms = Object.create(null);
    this._cacheMap = new Map();
    this.stats = {
      streamTypes: Object.create(null),
      fontTypes: Object.create(null)
    };
    this._newRefNum = null;
  }

  getNewRef() {
    if (this._newRefNum === null) {
      this._newRefNum = this.entries.length;
    }

    return _primitives.Ref.get(this._newRefNum++, 0);
  }

  resetNewRef() {
    this._newRefNum = null;
  }

  setStartXRef(startXRef) {
    this.startXRefQueue = [startXRef];
  }

  parse(recoveryMode = false) {
    let trailerDict;

    if (!recoveryMode) {
      trailerDict = this.readXRef();
    } else {
      (0, _util.warn)("Indexing all PDF objects");
      trailerDict = this.indexObjects();
    }

    trailerDict.assignXref(this);
    this.trailer = trailerDict;
    let encrypt;

    try {
      encrypt = trailerDict.get("Encrypt");
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
    }

    if ((0, _primitives.isDict)(encrypt)) {
      const ids = trailerDict.get("ID");
      const fileId = ids && ids.length ? ids[0] : "";
      encrypt.suppressEncryption = true;
      this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
    }

    let root;

    try {
      root = trailerDict.get("Root");
    } catch (ex) {
      if (ex instanceof _core_utils.MissingDataException) {
        throw ex;
      }

      (0, _util.warn)(`XRef.parse - Invalid "Root" reference: "${ex}".`);
    }

    if ((0, _primitives.isDict)(root) && root.has("Pages")) {
      this.root = root;
    } else {
      if (!recoveryMode) {
        throw new _core_utils.XRefParseException();
      }

      throw new _util.FormatError("Invalid root reference");
    }
  }

  processXRefTable(parser) {
    if (!("tableState" in this)) {
      this.tableState = {
        entryNum: 0,
        streamPos: parser.lexer.stream.pos,
        parserBuf1: parser.buf1,
        parserBuf2: parser.buf2
      };
    }

    const obj = this.readXRefTable(parser);

    if (!(0, _primitives.isCmd)(obj, "trailer")) {
      throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
    }

    let dict = parser.getObj();

    if (!(0, _primitives.isDict)(dict) && dict.dict) {
      dict = dict.dict;
    }

    if (!(0, _primitives.isDict)(dict)) {
      throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
    }

    delete this.tableState;
    return dict;
  }

  readXRefTable(parser) {
    const stream = parser.lexer.stream;
    const tableState = this.tableState;
    stream.pos = tableState.streamPos;
    parser.buf1 = tableState.parserBuf1;
    parser.buf2 = tableState.parserBuf2;
    let obj;

    while (true) {
      if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
        if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
          break;
        }

        tableState.firstEntryNum = obj;
        tableState.entryCount = parser.getObj();
      }

      let first = tableState.firstEntryNum;
      const count = tableState.entryCount;

      if (!Number.isInteger(first) || !Number.isInteger(count)) {
        throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
      }

      for (let i = tableState.entryNum; i < count; i++) {
        tableState.streamPos = stream.pos;
        tableState.entryNum = i;
        tableState.parserBuf1 = parser.buf1;
        tableState.parserBuf2 = parser.buf2;
        const entry = {};
        entry.offset = parser.getObj();
        entry.gen = parser.getObj();
        const type = parser.getObj();

        if (type instanceof _primitives.Cmd) {
          switch (type.cmd) {
            case "f":
              entry.free = true;
              break;

            case "n":
              entry.uncompressed = true;
              break;
          }
        }

        if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
          throw new _util.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
        }

        if (i === 0 && entry.free && first === 1) {
          first = 0;
        }

        if (!this.entries[i + first]) {
          this.entries[i + first] = entry;
        }
      }

      tableState.entryNum = 0;
      tableState.streamPos = stream.pos;
      tableState.parserBuf1 = parser.buf1;
      tableState.parserBuf2 = parser.buf2;
      delete tableState.firstEntryNum;
      delete tableState.entryCount;
    }

    if (this.entries[0] && !this.entries[0].free) {
      throw new _util.FormatError("Invalid XRef table: unexpected first object");
    }

    return obj;
  }

  processXRefStream(stream) {
    if (!("streamState" in this)) {
      const streamParameters = stream.dict;
      const byteWidths = streamParameters.get("W");
      let range = streamParameters.get("Index");

      if (!range) {
        range = [0, streamParameters.get("Size")];
      }

      this.streamState = {
        entryRanges: range,
        byteWidths,
        entryNum: 0,
        streamPos: stream.pos
      };
    }

    this.readXRefStream(stream);
    delete this.streamState;
    return stream.dict;
  }

  readXRefStream(stream) {
    let i, j;
    const streamState = this.streamState;
    stream.pos = streamState.streamPos;
    const byteWidths = streamState.byteWidths;
    const typeFieldWidth = byteWidths[0];
    const offsetFieldWidth = byteWidths[1];
    const generationFieldWidth = byteWidths[2];
    const entryRanges = streamState.entryRanges;

    while (entryRanges.length > 0) {
      const first = entryRanges[0];
      const n = entryRanges[1];

      if (!Number.isInteger(first) || !Number.isInteger(n)) {
        throw new _util.FormatError(`Invalid XRef range fields: ${first}, ${n}`);
      }

      if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
        throw new _util.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
      }

      for (i = streamState.entryNum; i < n; ++i) {
        streamState.entryNum = i;
        streamState.streamPos = stream.pos;
        let type = 0,
            offset = 0,
            generation = 0;

        for (j = 0; j < typeFieldWidth; ++j) {
          type = type << 8 | stream.getByte();
        }

        if (typeFieldWidth === 0) {
          type = 1;
        }

        for (j = 0; j < offsetFieldWidth; ++j) {
          offset = offset << 8 | stream.getByte();
        }

        for (j = 0; j < generationFieldWidth; ++j) {
          generation = generation << 8 | stream.getByte();
        }

        const entry = {};
        entry.offset = offset;
        entry.gen = generation;

        switch (type) {
          case 0:
            entry.free = true;
            break;

          case 1:
            entry.uncompressed = true;
            break;

          case 2:
            break;

          default:
            throw new _util.FormatError(`Invalid XRef entry type: ${type}`);
        }

        if (!this.entries[first + i]) {
          this.entries[first + i] = entry;
        }
      }

      streamState.entryNum = 0;
      streamState.streamPos = stream.pos;
      entryRanges.splice(0, 2);
    }
  }

  indexObjects() {
    const TAB = 0x9,
          LF = 0xa,
          CR = 0xd,
          SPACE = 0x20;
    const PERCENT = 0x25,
          LT = 0x3c;

    function readToken(data, offset) {
      let token = "",
          ch = data[offset];

      while (ch !== LF && ch !== CR && ch !== LT) {
        if (++offset >= data.length) {
          break;
        }

        token += String.fromCharCode(ch);
        ch = data[offset];
      }

      return token;
    }

    function skipUntil(data, offset, what) {
      const length = what.length,
            dataLength = data.length;
      let skipped = 0;

      while (offset < dataLength) {
        let i = 0;

        while (i < length && data[offset + i] === what[i]) {
          ++i;
        }

        if (i >= length) {
          break;
        }

        offset++;
        skipped++;
      }

      return skipped;
    }

    const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
    const endobjRegExp = /\bendobj[\b\s]$/;
    const nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
    const CHECK_CONTENT_LENGTH = 25;
    const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
    const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
    const objBytes = new Uint8Array([111, 98, 106]);
    const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0;
    const stream = this.stream;
    stream.pos = 0;
    const buffer = stream.getBytes(),
          length = buffer.length;
    let position = stream.start;
    const trailers = [],
          xrefStms = [];

    while (position < length) {
      let ch = buffer[position];

      if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
        ++position;
        continue;
      }

      if (ch === PERCENT) {
        do {
          ++position;

          if (position >= length) {
            break;
          }

          ch = buffer[position];
        } while (ch !== LF && ch !== CR);

        continue;
      }

      const token = readToken(buffer, position);
      let m;

      if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
        position += skipUntil(buffer, position, trailerBytes);
        trailers.push(position);
        position += skipUntil(buffer, position, startxrefBytes);
      } else if (m = objRegExp.exec(token)) {
        const num = m[1] | 0,
              gen = m[2] | 0;

        if (!this.entries[num] || this.entries[num].gen === gen) {
          this.entries[num] = {
            offset: position - stream.start,
            gen,
            uncompressed: true
          };
        }

        let contentLength,
            startPos = position + token.length;

        while (startPos < buffer.length) {
          const endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4;
          contentLength = endPos - position;
          const checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos);
          const tokenStr = (0, _util.bytesToString)(buffer.subarray(checkPos, endPos));

          if (endobjRegExp.test(tokenStr)) {
            break;
          } else {
            const objToken = nestedObjRegExp.exec(tokenStr);

            if (objToken && objToken[1]) {
              (0, _util.warn)('indexObjects: Found new "obj" inside of another "obj", ' + 'caused by missing "endobj" -- trying to recover.');
              contentLength -= objToken[1].length;
              break;
            }
          }

          startPos = endPos;
        }

        const content = buffer.subarray(position, position + contentLength);
        const xrefTagOffset = skipUntil(content, 0, xrefBytes);

        if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
          xrefStms.push(position - stream.start);
          this.xrefstms[position - stream.start] = 1;
        }

        position += contentLength;
      } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
        trailers.push(position);
        position += skipUntil(buffer, position, startxrefBytes);
      } else {
        position += token.length + 1;
      }
    }

    for (let i = 0, ii = xrefStms.length; i < ii; ++i) {
      this.startXRefQueue.push(xrefStms[i]);
      this.readXRef(true);
    }

    let trailerDict;

    for (let i = 0, ii = trailers.length; i < ii; ++i) {
      stream.pos = trailers[i];
      const parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream),
        xref: this,
        allowStreams: true,
        recoveryMode: true
      });
      const obj = parser.getObj();

      if (!(0, _primitives.isCmd)(obj, "trailer")) {
        continue;
      }

      const dict = parser.getObj();

      if (!(0, _primitives.isDict)(dict)) {
        continue;
      }

      try {
        const rootDict = dict.get("Root");

        if (!(rootDict instanceof _primitives.Dict)) {
          continue;
        }

        const pagesDict = rootDict.get("Pages");

        if (!(pagesDict instanceof _primitives.Dict)) {
          continue;
        }

        const pagesCount = pagesDict.get("Count");

        if (!Number.isInteger(pagesCount)) {
          continue;
        }
      } catch (ex) {
        continue;
      }

      if (dict.has("ID")) {
        return dict;
      }

      trailerDict = dict;
    }

    if (trailerDict) {
      return trailerDict;
    }

    throw new _util.InvalidPDFException("Invalid PDF structure.");
  }

  readXRef(recoveryMode = false) {
    const stream = this.stream;
    const startXRefParsedCache = new Set();

    try {
      while (this.startXRefQueue.length) {
        const startXRef = this.startXRefQueue[0];

        if (startXRefParsedCache.has(startXRef)) {
          (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
          this.startXRefQueue.shift();
          continue;
        }

        startXRefParsedCache.add(startXRef);
        stream.pos = startXRef + stream.start;
        const parser = new _parser.Parser({
          lexer: new _parser.Lexer(stream),
          xref: this,
          allowStreams: true
        });
        let obj = parser.getObj();
        let dict;

        if ((0, _primitives.isCmd)(obj, "xref")) {
          dict = this.processXRefTable(parser);

          if (!this.topDict) {
            this.topDict = dict;
          }

          obj = dict.get("XRefStm");

          if (Number.isInteger(obj)) {
            const pos = obj;

            if (!(pos in this.xrefstms)) {
              this.xrefstms[pos] = 1;
              this.startXRefQueue.push(pos);
            }
          }
        } else if (Number.isInteger(obj)) {
          if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !(0, _primitives.isStream)(obj = parser.getObj())) {
            throw new _util.FormatError("Invalid XRef stream");
          }

          dict = this.processXRefStream(obj);

          if (!this.topDict) {
            this.topDict = dict;
          }

          if (!dict) {
            throw new _util.FormatError("Failed to read XRef stream");
          }
        } else {
          throw new _util.FormatError("Invalid XRef stream header");
        }

        obj = dict.get("Prev");

        if (Number.isInteger(obj)) {
          this.startXRefQueue.push(obj);
        } else if ((0, _primitives.isRef)(obj)) {
          this.startXRefQueue.push(obj.num);
        }

        this.startXRefQueue.shift();
      }

      return this.topDict;
    } catch (e) {
      if (e instanceof _core_utils.MissingDataException) {
        throw e;
      }

      (0, _util.info)("(while reading XRef): " + e);
    }

    if (recoveryMode) {
      return undefined;
    }

    throw new _core_utils.XRefParseException();
  }

  getEntry(i) {
    const xrefEntry = this.entries[i];

    if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
      return xrefEntry;
    }

    return null;
  }

  fetchIfRef(obj, suppressEncryption = false) {
    if (obj instanceof _primitives.Ref) {
      return this.fetch(obj, suppressEncryption);
    }

    return obj;
  }

  fetch(ref, suppressEncryption = false) {
    if (!(ref instanceof _primitives.Ref)) {
      throw new Error("ref object is not a reference");
    }

    const num = ref.num;

    const cacheEntry = this._cacheMap.get(num);

    if (cacheEntry !== undefined) {
      if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
        cacheEntry.objId = ref.toString();
      }

      return cacheEntry;
    }

    let xrefEntry = this.getEntry(num);

    if (xrefEntry === null) {
      this._cacheMap.set(num, xrefEntry);

      return xrefEntry;
    }

    if (xrefEntry.uncompressed) {
      xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
    } else {
      xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption);
    }

    if ((0, _primitives.isDict)(xrefEntry)) {
      xrefEntry.objId = ref.toString();
    } else if ((0, _primitives.isStream)(xrefEntry)) {
      xrefEntry.dict.objId = ref.toString();
    }

    return xrefEntry;
  }

  fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
    const gen = ref.gen;
    let num = ref.num;

    if (xrefEntry.gen !== gen) {
      throw new _core_utils.XRefEntryException(`Inconsistent generation in XRef: ${ref}`);
    }

    const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
    const parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();

    if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }

    if (obj3.cmd !== "obj") {
      if (obj3.cmd.startsWith("obj")) {
        num = parseInt(obj3.cmd.substring(3), 10);

        if (!Number.isNaN(num)) {
          return num;
        }
      }

      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }

    if (this.encrypt && !suppressEncryption) {
      xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
    } else {
      xrefEntry = parser.getObj();
    }

    if (!(0, _primitives.isStream)(xrefEntry)) {
      this._cacheMap.set(num, xrefEntry);
    }

    return xrefEntry;
  }

  fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
    const tableOffset = xrefEntry.offset;
    const stream = this.fetch(_primitives.Ref.get(tableOffset, 0));

    if (!(0, _primitives.isStream)(stream)) {
      throw new _util.FormatError("bad ObjStm stream");
    }

    const first = stream.dict.get("First");
    const n = stream.dict.get("N");

    if (!Number.isInteger(first) || !Number.isInteger(n)) {
      throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
    }

    let parser = new _parser.Parser({
      lexer: new _parser.Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const nums = new Array(n);
    const offsets = new Array(n);

    for (let i = 0; i < n; ++i) {
      const num = parser.getObj();

      if (!Number.isInteger(num)) {
        throw new _util.FormatError(`invalid object number in the ObjStm stream: ${num}`);
      }

      const offset = parser.getObj();

      if (!Number.isInteger(offset)) {
        throw new _util.FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
      }

      nums[i] = num;
      offsets[i] = offset;
    }

    const start = (stream.start || 0) + first;
    const entries = new Array(n);

    for (let i = 0; i < n; ++i) {
      const length = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined;

      if (length < 0) {
        throw new _util.FormatError("Invalid offset in the ObjStm stream.");
      }

      parser = new _parser.Parser({
        lexer: new _parser.Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)),
        xref: this,
        allowStreams: true
      });
      const obj = parser.getObj();
      entries[i] = obj;

      if ((0, _primitives.isStream)(obj)) {
        continue;
      }

      const num = nums[i],
            entry = this.entries[num];

      if (entry && entry.offset === tableOffset && entry.gen === i) {
        this._cacheMap.set(num, obj);
      }
    }

    xrefEntry = entries[xrefEntry.gen];

    if (xrefEntry === undefined) {
      throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
    }

    return xrefEntry;
  }

  async fetchIfRefAsync(obj, suppressEncryption) {
    if (obj instanceof _primitives.Ref) {
      return this.fetchAsync(obj, suppressEncryption);
    }

    return obj;
  }

  async fetchAsync(ref, suppressEncryption) {
    try {
      return this.fetch(ref, suppressEncryption);
    } catch (ex) {
      if (!(ex instanceof _core_utils.MissingDataException)) {
        throw ex;
      }

      await this.pdfManager.requestRange(ex.begin, ex.end);
      return this.fetchAsync(ref, suppressEncryption);
    }
  }

  getCatalogObj() {
    return this.root;
  }

}

exports.XRef = XRef;

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;

var _util = __w_pdfjs_require__(2);

const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};

function wrapReason(reason) {
  if (typeof reason !== "object" || reason === null) {
    return reason;
  }

  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);

    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);

    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);

    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);

    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}

class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.postMessageTransfers = true;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);

    this._onComObjOnMessage = event => {
      const data = event.data;

      if (data.targetName !== this.sourceName) {
        return;
      }

      if (data.stream) {
        this._processStreamMessage(data);

        return;
      }

      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];

        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }

        delete this.callbackCapabilities[callbackId];

        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }

        return;
      }

      const action = this.actionHandler[data.action];

      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }

      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }

      if (data.streamId) {
        this._createStreamSink(data);

        return;
      }

      action(data.data);
    };

    comObj.addEventListener("message", this._onComObjOnMessage);
  }

  on(actionName, handler) {
    const ah = this.actionHandler;

    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }

    ah[actionName] = handler;
  }

  send(actionName, data, transfers) {
    this._postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }

  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = (0, _util.createPromiseCapability)();
    this.callbackCapabilities[callbackId] = capability;

    try {
      this._postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }

    return capability.promise;
  }

  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++;
    const sourceName = this.sourceName;
    const targetName = this.targetName;
    const comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };

        this._postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);

        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }

  _createStreamSink(data) {
    const self = this;
    const action = this.actionHandler[data.action];
    const streamId = data.streamId;
    const sourceName = this.sourceName;
    const targetName = data.sourceName;
    const comObj = this.comObj;
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }

        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;

        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = (0, _util.createPromiseCapability)();
          this.ready = this.sinkCapability.promise;
        }

        self._postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },

      close() {
        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },

      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },

      sinkCapability: (0, _util.createPromiseCapability)(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }

  _processStreamMessage(data) {
    const streamId = data.streamId;
    const sourceName = this.sourceName;
    const targetName = data.sourceName;
    const comObj = this.comObj;

    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].startCall.resolve();
        } else {
          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].pullCall.resolve();
        } else {
          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL:
        if (!this.streamSinks[streamId]) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }

        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
          this.streamSinks[streamId].sinkCapability.resolve();
        }

        this.streamSinks[streamId].desiredSize = data.desiredSize;
        const {
          onPull
        } = this.streamSinks[data.streamId];
        new Promise(function (resolve) {
          resolve(onPull && onPull());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;

      case StreamKind.ENQUEUE:
        (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller");

        if (this.streamControllers[streamId].isClosed) {
          break;
        }

        this.streamControllers[streamId].controller.enqueue(data.chunk);
        break;

      case StreamKind.CLOSE:
        (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller");

        if (this.streamControllers[streamId].isClosed) {
          break;
        }

        this.streamControllers[streamId].isClosed = true;
        this.streamControllers[streamId].controller.close();

        this._deleteStreamController(streamId);

        break;

      case StreamKind.ERROR:
        (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller");
        this.streamControllers[streamId].controller.error(wrapReason(data.reason));

        this._deleteStreamController(streamId);

        break;

      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].cancelCall.resolve();
        } else {
          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
        }

        this._deleteStreamController(streamId);

        break;

      case StreamKind.CANCEL:
        if (!this.streamSinks[streamId]) {
          break;
        }

        const {
          onCancel
        } = this.streamSinks[data.streamId];
        new Promise(function (resolve) {
          resolve(onCancel && onCancel(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
        this.streamSinks[streamId].isCancelled = true;
        delete this.streamSinks[streamId];
        break;

      default:
        throw new Error("Unexpected stream case");
    }
  }

  async _deleteStreamController(streamId) {
    await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {
      return capability && capability.promise;
    }));
    delete this.streamControllers[streamId];
  }

  _postMessage(message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }

  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }

}

exports.MessageHandler = MessageHandler;

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFWorkerStream = void 0;

var _util = __w_pdfjs_require__(2);

class PDFWorkerStream {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this._contentLength = null;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFWorkerStream = PDFWorkerStream;

class PDFWorkerStreamReader {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;
    this._contentLength = null;
    this._isRangeSupported = false;
    this._isStreamingSupported = false;

    const readableStream = this._msgHandler.sendWithStream("GetReader");

    this._reader = readableStream.getReader();
    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(data => {
      this._isStreamingSupported = data.isStreamingSupported;
      this._isRangeSupported = data.isRangeSupported;
      this._contentLength = data.contentLength;
    });
  }

  get headersReady() {
    return this._headersReady;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  async read() {
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value: undefined,
        done: true
      };
    }

    return {
      value: value.buffer,
      done: false
    };
  }

  cancel(reason) {
    this._reader.cancel(reason);
  }

}

class PDFWorkerStreamRangeReader {
  constructor(begin, end, msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;

    const readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
      begin,
      end
    });

    this._reader = readableStream.getReader();
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value: undefined,
        done: true
      };
    }

    return {
      value: value.buffer,
      done: false
    };
  }

  cancel(reason) {
    this._reader.cancel(reason);
  }

}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__w_pdfjs_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__w_pdfjs_require__.o(definition, key) && !__w_pdfjs_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__w_pdfjs_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__w_pdfjs_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "WorkerMessageHandler", ({
  enumerable: true,
  get: function () {
    return _worker.WorkerMessageHandler;
  }
}));

var _worker = __w_pdfjs_require__(1);

const pdfjsVersion = '2.9.0';
const pdfjsBuild = '3538ef0';
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.worker.js.map]]></content>
  </entry>
</search>
